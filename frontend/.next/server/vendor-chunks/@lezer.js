"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lezer";
exports.ids = ["vendor-chunks/@lezer"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lezer/common/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@lezer/common/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBufferLength: () => (/* binding */ DefaultBufferLength),\n/* harmony export */   IterMode: () => (/* binding */ IterMode),\n/* harmony export */   MountedTree: () => (/* binding */ MountedTree),\n/* harmony export */   NodeProp: () => (/* binding */ NodeProp),\n/* harmony export */   NodeSet: () => (/* binding */ NodeSet),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   NodeWeakMap: () => (/* binding */ NodeWeakMap),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Tree: () => (/* binding */ Tree),\n/* harmony export */   TreeBuffer: () => (/* binding */ TreeBuffer),\n/* harmony export */   TreeCursor: () => (/* binding */ TreeCursor),\n/* harmony export */   TreeFragment: () => (/* binding */ TreeFragment),\n/* harmony export */   parseMixed: () => (/* binding */ parseMixed)\n/* harmony export */ });\n/**\nThe default maximum length of a `TreeBuffer` node.\n*/ const DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to){\n        this.from = from;\n        this.to = to;\n    }\n}\n/**\nEach [node type](#common.NodeType) or [individual tree](#common.Tree)\ncan have metadata associated with it in props. Instances of this\nclass represent prop names.\n*/ class NodeProp {\n    /**\n    Create a new node prop type.\n    */ constructor(config = {}){\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (()=>{\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /**\n    This is meant to be used with\n    [`NodeSet.extend`](#common.NodeSet.extend) or\n    [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    prop values for each node type in the set. Takes a [match\n    object](#common.NodeType^match) or function that returns undefined\n    if the node type doesn't get this prop, and the prop's value if\n    it does.\n    */ add(match) {\n        if (this.perNode) throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\") match = NodeType.match(match);\n        return (type)=>{\n            let result = match(type);\n            return result === undefined ? null : [\n                this,\n                result\n            ];\n        };\n    }\n}\n/**\nProp that is used to describe matching delimiters. For opening\ndelimiters, this holds an array of node names (written as a\nspace-separated string when declaring this prop in a grammar)\nfor the node types of closing delimiters that match it.\n*/ NodeProp.closedBy = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nThe inverse of [`closedBy`](#common.NodeProp^closedBy). This is\nattached to closing delimiters, holding an array of node names\nof types of matching opening delimiters.\n*/ NodeProp.openedBy = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nUsed to assign node types to groups (for example, all node\ntypes that represent an expression could be tagged with an\n`\"Expression\"` group).\n*/ NodeProp.group = new NodeProp({\n    deserialize: (str)=>str.split(\" \")\n});\n/**\nAttached to nodes to indicate these should be\n[displayed](https://codemirror.net/docs/ref/#language.syntaxTree)\nin a bidirectional text isolate, so that direction-neutral\ncharacters on their sides don't incorrectly get associated with\nsurrounding text. You'll generally want to set this for nodes\nthat contain arbitrary text, like strings and comments, and for\nnodes that appear _inside_ arbitrary text, like HTML tags. When\nnot given a value, in a grammar declaration, defaults to\n`\"auto\"`.\n*/ NodeProp.isolate = new NodeProp({\n    deserialize: (value)=>{\n        if (value && value != \"rtl\" && value != \"ltr\" && value != \"auto\") throw new RangeError(\"Invalid value for isolate: \" + value);\n        return value || \"auto\";\n    }\n});\n/**\nThe hash of the [context](#lr.ContextTracker.constructor)\nthat the node was parsed in, if any. Used to limit reuse of\ncontextual nodes.\n*/ NodeProp.contextHash = new NodeProp({\n    perNode: true\n});\n/**\nThe distance beyond the end of the node that the tokenizer\nlooked ahead for any of the tokens inside the node. (The LR\nparser only stores this when it is larger than 25, for\nefficiency reasons.)\n*/ NodeProp.lookAhead = new NodeProp({\n    perNode: true\n});\n/**\nThis per-node prop is used to replace a given node, or part of a\nnode, with another tree. This is useful to include trees from\ndifferent languages in mixed-language parsers.\n*/ NodeProp.mounted = new NodeProp({\n    perNode: true\n});\n/**\nA mounted tree, which can be [stored](#common.NodeProp^mounted) on\na tree node to indicate that parts of its content are\nrepresented by another tree.\n*/ class MountedTree {\n    constructor(/**\n    The inner tree.\n    */ tree, /**\n    If this is null, this tree replaces the entire node (it will\n    be included in the regular iteration instead of its host\n    node). If not, only the given ranges are considered to be\n    covered by this tree. This is used for trees that are mixed in\n    a way that isn't strictly hierarchical. Such mounted trees are\n    only entered by [`resolveInner`](#common.Tree.resolveInner)\n    and [`enter`](#common.SyntaxNode.enter).\n    */ overlay, /**\n    The parser used to create this subtree.\n    */ parser){\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n    /**\n    @internal\n    */ static get(tree) {\n        return tree && tree.props && tree.props[NodeProp.mounted.id];\n    }\n}\nconst noProps = Object.create(null);\n/**\nEach node in a syntax tree has a node type associated with it.\n*/ class NodeType {\n    /**\n    @internal\n    */ constructor(/**\n    The name of the node type. Not necessarily unique, but if the\n    grammar was written properly, different node types with the\n    same name within a node set should play the same semantic\n    role.\n    */ name, /**\n    @internal\n    */ props, /**\n    The id of this node in its set. Corresponds to the term ids\n    used in the parser.\n    */ id, /**\n    @internal\n    */ flags = 0){\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    /**\n    Define a node type.\n    */ static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* NodeFlag.Top */  : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */  : 0) | (spec.error ? 4 /* NodeFlag.Error */  : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */  : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props) for (let src of spec.props){\n            if (!Array.isArray(src)) src = src(type);\n            if (src) {\n                if (src[0].perNode) throw new RangeError(\"Can't store a per-node prop on a node type\");\n                props[src[0].id] = src[1];\n            }\n        }\n        return type;\n    }\n    /**\n    Retrieves a node prop for this type. Will return `undefined` if\n    the prop isn't present on this node.\n    */ prop(prop) {\n        return this.props[prop.id];\n    }\n    /**\n    True when this is the top node of a grammar.\n    */ get isTop() {\n        return (this.flags & 1 /* NodeFlag.Top */ ) > 0;\n    }\n    /**\n    True when this node is produced by a skip rule.\n    */ get isSkipped() {\n        return (this.flags & 2 /* NodeFlag.Skipped */ ) > 0;\n    }\n    /**\n    Indicates whether this is an error node.\n    */ get isError() {\n        return (this.flags & 4 /* NodeFlag.Error */ ) > 0;\n    }\n    /**\n    When true, this node type doesn't correspond to a user-declared\n    named node, for example because it is used to cache repetition.\n    */ get isAnonymous() {\n        return (this.flags & 8 /* NodeFlag.Anonymous */ ) > 0;\n    }\n    /**\n    Returns true when this node's name or one of its\n    [groups](#common.NodeProp^group) matches the given string.\n    */ is(name) {\n        if (typeof name == \"string\") {\n            if (this.name == name) return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /**\n    Create a function from node types to arbitrary values by\n    specifying an object whose property names are node or\n    [group](#common.NodeProp^group) names. Often useful with\n    [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    names, separated by spaces, in a single property name to map\n    multiple node names to a single value.\n    */ static match(map) {\n        let direct = Object.create(null);\n        for(let prop in map)for (let name of prop.split(\" \"))direct[name] = map[prop];\n        return (node)=>{\n            for(let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++){\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found) return found;\n            }\n        };\n    }\n}\n/**\nAn empty dummy node type to use when no actual type is available.\n*/ NodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */ );\n/**\nA node set holds a collection of node types. It is used to\ncompactly represent trees by storing their type ids, rather than a\nfull pointer to the type object, in a numeric array. Each parser\n[has](#lr.LRParser.nodeSet) a node set, and [tree\nbuffers](#common.TreeBuffer) can only store collections of nodes\nfrom the same set. A set can have a maximum of 2**16 (65536) node\ntypes in it, so that the ids fit into 16-bit typed array slots.\n*/ class NodeSet {\n    /**\n    Create a set with the given types. The `id` property of each\n    type should correspond to its position within the array.\n    */ constructor(/**\n    The node types in this set, by id.\n    */ types){\n        this.types = types;\n        for(let i = 0; i < types.length; i++)if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /**\n    Create a copy of this set with some node properties added. The\n    arguments to this method can be created with\n    [`NodeProp.add`](#common.NodeProp.add).\n    */ extend(...props) {\n        let newTypes = [];\n        for (let type of this.types){\n            let newProps = null;\n            for (let source of props){\n                let add = source(type);\n                if (add) {\n                    if (!newProps) newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/**\nOptions that control iteration. Can be combined with the `|`\noperator to enable multiple ones.\n*/ var IterMode;\n(function(IterMode) {\n    /**\n    When enabled, iteration will only visit [`Tree`](#common.Tree)\n    objects, not nodes packed into\n    [`TreeBuffer`](#common.TreeBuffer)s.\n    */ IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n    /**\n    Enable this to make iteration include anonymous nodes (such as\n    the nodes that wrap repeated grammar constructs into a balanced\n    tree).\n    */ IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n    /**\n    By default, regular [mounted](#common.NodeProp^mounted) nodes\n    replace their base node in iteration. Enable this to ignore them\n    instead.\n    */ IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n    /**\n    This option only applies in\n    [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n    library to not enter mounted overlays if one covers the given\n    position.\n    */ IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/**\nA piece of syntax tree. There are two ways to approach these\ntrees: the way they are actually stored in memory, and the\nconvenient way.\n\nSyntax trees are stored as a tree of `Tree` and `TreeBuffer`\nobjects. By packing detail information into `TreeBuffer` leaf\nnodes, the representation is made a lot more memory-efficient.\n\nHowever, when you want to actually work with tree nodes, this\nrepresentation is very awkward, so most client code will want to\nuse the [`TreeCursor`](#common.TreeCursor) or\n[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\na view on some part of this data structure, and can be used to\nmove around to adjacent nodes.\n*/ class Tree {\n    /**\n    Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    */ constructor(/**\n    The type of the top node.\n    */ type, /**\n    This node's child nodes.\n    */ children, /**\n    The positions (offsets relative to the start of this tree) of\n    the children.\n    */ positions, /**\n    The total length of this tree\n    */ length, /**\n    Per-node [node props](#common.NodeProp) to associate with this node.\n    */ props){\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /**\n        @internal\n        */ this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /**\n    @internal\n    */ toString() {\n        let mounted = MountedTree.get(this);\n        if (mounted && !mounted.overlay) return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children){\n            let str = ch.toString();\n            if (str) {\n                if (children) children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children : (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) positioned at the top of\n    the tree. Mode can be used to [control](#common.IterMode) which\n    nodes the cursor visits.\n    */ cursor(mode = 0) {\n        return new TreeCursor(this.topNode, mode);\n    }\n    /**\n    Get a [tree cursor](#common.TreeCursor) pointing into this tree\n    at the given position and side (see\n    [`moveTo`](#common.TreeCursor.moveTo).\n    */ cursorAt(pos, side = 0, mode = 0) {\n        let scope = CachedNode.get(this) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        cursor.moveTo(pos, side);\n        CachedNode.set(this, cursor._tree);\n        return cursor;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) object for the top of the\n    tree.\n    */ get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /**\n    Get the [syntax node](#common.SyntaxNode) at the given position.\n    If `side` is -1, this will move into nodes that end at the\n    position. If 1, it'll move into nodes that start at the\n    position. With 0, it'll only enter nodes that cover the position\n    from both sides.\n    \n    Note that this will not enter\n    [overlays](#common.MountedTree.overlay), and you often want\n    [`resolveInner`](#common.Tree.resolveInner) instead.\n    */ resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /**\n    Like [`resolve`](#common.Tree.resolve), but will enter\n    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    pointing into the innermost overlaid tree at the given position\n    (with parent links going through all parent structure, including\n    the host trees).\n    */ resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /**\n    In some situations, it can be useful to iterate through all\n    nodes around a position, including those in overlays that don't\n    directly cover the position. This method gives you an iterator\n    that will produce all nodes, from small to big, around the given\n    position.\n    */ resolveStack(pos, side = 0) {\n        return stackIterator(this, pos, side);\n    }\n    /**\n    Iterate over the tree and its children, calling `enter` for any\n    node that touches the `from`/`to` region (if given) before\n    running over such a node's children, and `leave` (if given) when\n    leaving the node. When `enter` returns `false`, that node will\n    not have its children iterated over (or `leave` called).\n    */ iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;\n        for(let c = this.cursor(mode | IterMode.IncludeAnonymous);;){\n            let entered = false;\n            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {\n                if (c.firstChild()) continue;\n                entered = true;\n            }\n            for(;;){\n                if (entered && leave && (anon || !c.type.isAnonymous)) leave(c);\n                if (c.nextSibling()) break;\n                if (!c.parent()) return;\n                entered = true;\n            }\n        }\n    }\n    /**\n    Get the value of the given [node prop](#common.NodeProp) for this\n    node. Works with both per-node and per-type props.\n    */ prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /**\n    Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    format that can be passed to the [`Tree`](#common.Tree)\n    constructor.\n    */ get propValues() {\n        let result = [];\n        if (this.props) for(let id in this.props)result.push([\n            +id,\n            this.props[id]\n        ]);\n        return result;\n    }\n    /**\n    Balance the direct children of this tree, producing a copy of\n    which may have children grouped into subtrees with type\n    [`NodeType.none`](#common.NodeType^none).\n    */ balance(config = {}) {\n        return this.children.length <= 8 /* Balance.BranchFactor */  ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length)=>new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length)=>new Tree(NodeType.none, children, positions, length)));\n    }\n    /**\n    Build a tree from a postfix-ordered buffer of node information,\n    or a cursor over such a buffer.\n    */ static build(data) {\n        return buildTree(data);\n    }\n}\n/**\nThe empty tree\n*/ Tree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index){\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() {\n        return this.buffer[this.index - 4];\n    }\n    get start() {\n        return this.buffer[this.index - 3];\n    }\n    get end() {\n        return this.buffer[this.index - 2];\n    }\n    get size() {\n        return this.buffer[this.index - 1];\n    }\n    get pos() {\n        return this.index;\n    }\n    next() {\n        this.index -= 4;\n    }\n    fork() {\n        return new FlatBufferCursor(this.buffer, this.index);\n    }\n}\n/**\nTree buffers contain (type, start, end, endIndex) quads for each\nnode. In such a buffer, nodes are stored in prefix order (parents\nbefore children, with the endIndex of the parent indicating which\nchildren belong to it).\n*/ class TreeBuffer {\n    /**\n    Create a tree buffer.\n    */ constructor(/**\n    The buffer's content.\n    */ buffer, /**\n    The total length of the group of nodes in the buffer.\n    */ length, /**\n    The node set used in this buffer.\n    */ set){\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /**\n    @internal\n    */ get type() {\n        return NodeType.none;\n    }\n    /**\n    @internal\n    */ toString() {\n        let result = [];\n        for(let index = 0; index < this.buffer.length;){\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /**\n    @internal\n    */ childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index) return result;\n        let children = [];\n        while(index < endIndex){\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /**\n    @internal\n    */ findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for(let i = startIndex; i != endIndex; i = buffer[i + 3]){\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0) break;\n            }\n        }\n        return pick;\n    }\n    /**\n    @internal\n    */ slice(startI, endI, from) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI), len = 0;\n        for(let i = startI, j = 0; i < endI;){\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            let to = copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n            len = Math.max(len, to);\n        }\n        return new TreeBuffer(copy, len, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch(side){\n        case -2 /* Side.Before */ :\n            return from < pos;\n        case -1 /* Side.AtOrBefore */ :\n            return to >= pos && from < pos;\n        case 0 /* Side.Around */ :\n            return from < pos && to > pos;\n        case 1 /* Side.AtOrAfter */ :\n            return from <= pos && to > pos;\n        case 2 /* Side.After */ :\n            return to > pos;\n        case 4 /* Side.DontCare */ :\n            return true;\n    }\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while(node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)){\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent) return node;\n        node = parent;\n    }\n    let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays) for(let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent){\n        if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from) node = parent;\n    }\n    for(;;){\n        let inner = node.enter(pos, side, mode);\n        if (!inner) return node;\n        node = inner;\n    }\n}\nclass BaseNode {\n    cursor(mode = 0) {\n        return new TreeCursor(this, mode);\n    }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    matchContext(context) {\n        return matchNodeContext(this.parent, context);\n    }\n    enterUnfinishedNodesBefore(pos) {\n        let scan = this.childBefore(pos), node = this;\n        while(scan){\n            let last = scan.lastChild;\n            if (!last || last.to != scan.to) break;\n            if (last.type.isError && last.from == last.to) {\n                node = scan;\n                scan = last.prevSibling;\n            } else {\n                scan = last;\n            }\n        }\n        return node;\n    }\n    get node() {\n        return this;\n    }\n    get next() {\n        return this.parent;\n    }\n}\nclass TreeNode extends BaseNode {\n    constructor(_tree, from, // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent){\n        super();\n        this._tree = _tree;\n        this.from = from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() {\n        return this._tree.type;\n    }\n    get name() {\n        return this._tree.type.name;\n    }\n    get to() {\n        return this.from + this._tree.length;\n    }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for(let parent = this;;){\n            for(let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir){\n                let next = children[i], start = positions[i] + parent.from;\n                if (!checkSide(side, pos, start, start + next.length)) continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & IterMode.ExcludeBuffers) continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {\n                    let mounted;\n                    if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null;\n            if (parent.index >= 0) i = parent.index + dir;\n            else i = dir < 0 ? -1 : parent._parent._tree.children.length;\n            parent = parent._parent;\n            if (!parent) return null;\n        }\n    }\n    get firstChild() {\n        return this.nextChild(0, 1, 0, 4 /* Side.DontCare */ );\n    }\n    get lastChild() {\n        return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */ );\n    }\n    childAfter(pos) {\n        return this.nextChild(0, 1, pos, 2 /* Side.After */ );\n    }\n    childBefore(pos) {\n        return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */ );\n    }\n    enter(pos, side, mode = 0) {\n        let mounted;\n        if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay){\n                if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, mode);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while(val.type.isAnonymous && val._parent)val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */ ) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */ ) : null;\n    }\n    get tree() {\n        return this._tree;\n    }\n    toTree() {\n        return this._tree;\n    }\n    /**\n    @internal\n    */ toString() {\n        return this._tree.toString();\n    }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor(), result = [];\n    if (!cur.firstChild()) return result;\n    if (before != null) for(let found = false; !found;){\n        found = cur.type.is(before);\n        if (!cur.nextSibling()) return result;\n    }\n    for(;;){\n        if (after != null && cur.type.is(after)) return result;\n        if (cur.type.is(type)) result.push(cur.node);\n        if (!cur.nextSibling()) return after == null ? result : [];\n    }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n    for(let p = node; i >= 0; p = p.parent){\n        if (!p) return false;\n        if (!p.type.isAnonymous) {\n            if (context[i] && context[i] != p.name) return false;\n            i--;\n        }\n    }\n    return true;\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start){\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode extends BaseNode {\n    get name() {\n        return this.type.name;\n    }\n    get from() {\n        return this.context.start + this.context.buffer.buffer[this.index + 1];\n    }\n    get to() {\n        return this.context.start + this.context.buffer.buffer[this.index + 2];\n    }\n    constructor(context, _parent, index){\n        super();\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() {\n        return this.child(1, 0, 4 /* Side.DontCare */ );\n    }\n    get lastChild() {\n        return this.child(-1, 0, 4 /* Side.DontCare */ );\n    }\n    childAfter(pos) {\n        return this.child(1, pos, 2 /* Side.After */ );\n    }\n    childBefore(pos) {\n        return this.child(-1, pos, -2 /* Side.Before */ );\n    }\n    enter(pos, side, mode = 0) {\n        if (mode & IterMode.ExcludeBuffers) return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */ );\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart) return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */ ));\n    }\n    get tree() {\n        return null;\n    }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1];\n            children.push(buffer.slice(startI, endI, from));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.context.buffer.childString(this.index);\n    }\n}\nfunction iterStack(heads) {\n    if (!heads.length) return null;\n    let pick = 0, picked = heads[0];\n    for(let i = 1; i < heads.length; i++){\n        let node = heads[i];\n        if (node.from > picked.from || node.to < picked.to) {\n            picked = node;\n            pick = i;\n        }\n    }\n    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;\n    let newHeads = heads.slice();\n    if (next) newHeads[pick] = next;\n    else newHeads.splice(pick, 1);\n    return new StackIterator(newHeads, picked);\n}\nclass StackIterator {\n    constructor(heads, node){\n        this.heads = heads;\n        this.node = node;\n    }\n    get next() {\n        return iterStack(this.heads);\n    }\n}\nfunction stackIterator(tree, pos, side) {\n    let inner = tree.resolveInner(pos, side), layers = null;\n    for(let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent){\n        if (scan.index < 0) {\n            let parent = scan.parent;\n            (layers || (layers = [\n                inner\n            ])).push(parent.resolve(pos, side));\n            scan = parent;\n        } else {\n            let mount = MountedTree.get(scan.tree);\n            // Relevant overlay branching off\n            if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {\n                let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);\n                (layers || (layers = [\n                    inner\n                ])).push(resolveNode(root, pos, side, false));\n            }\n        }\n    }\n    return layers ? iterStack(layers) : inner;\n}\n/**\nA tree cursor object focuses on a given node in a syntax tree, and\nallows you to move to adjacent nodes.\n*/ class TreeCursor {\n    /**\n    Shorthand for `.type.name`.\n    */ get name() {\n        return this.type.name;\n    }\n    /**\n    @internal\n    */ constructor(node, /**\n    @internal\n    */ mode = 0){\n        this.mode = mode;\n        /**\n        @internal\n        */ this.buffer = null;\n        this.stack = [];\n        /**\n        @internal\n        */ this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        } else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for(let n = node._parent; n; n = n._parent)this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    yieldNode(node) {\n        if (!node) return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    /**\n    @internal\n    */ yield(node) {\n        if (!node) return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /**\n    @internal\n    */ enterChild(dir, pos, side) {\n        if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0) return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /**\n    Move the cursor to this node's first child. When this returns\n    false, the node has no child, and the cursor has not been moved.\n    */ firstChild() {\n        return this.enterChild(1, 0, 4 /* Side.DontCare */ );\n    }\n    /**\n    Move the cursor to this node's last child.\n    */ lastChild() {\n        return this.enterChild(-1, 0, 4 /* Side.DontCare */ );\n    }\n    /**\n    Move the cursor to the first child that ends after `pos`.\n    */ childAfter(pos) {\n        return this.enterChild(1, pos, 2 /* Side.After */ );\n    }\n    /**\n    Move to the last child that starts before `pos`.\n    */ childBefore(pos) {\n        return this.enterChild(-1, pos, -2 /* Side.Before */ );\n    }\n    /**\n    Move the cursor to the child around `pos`. If side is -1 the\n    child may end at that position, when 1 it may start there. This\n    will also enter [overlaid](#common.MountedTree.overlay)\n    [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    set to false.\n    */ enter(pos, side, mode = this.mode) {\n        if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));\n        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n    }\n    /**\n    Move to the node's parent node, if this isn't the top node.\n    */ parent() {\n        if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);\n        if (this.stack.length) return this.yieldBuf(this.stack.pop());\n        let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /**\n    @internal\n    */ sibling(dir) {\n        if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */ , this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */ ));\n        } else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */ , this.mode)) : false;\n    }\n    /**\n    Move to this node's next sibling, if any.\n    */ nextSibling() {\n        return this.sibling(1);\n    }\n    /**\n    Move to this node's previous sibling, if any.\n    */ prevSibling() {\n        return this.sibling(-1);\n    }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length) return false;\n            } else {\n                for(let i = 0; i < this.index; i++)if (buffer.buffer.buffer[i + 3] < this.index) return false;\n            }\n            ({ index, parent } = buffer);\n        } else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for(; parent; { index, _parent: parent } = parent){\n            if (index > -1) for(let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir){\n                let child = parent._tree.children[i];\n                if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;\n            }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */ )) return true;\n        for(;;){\n            if (this.sibling(dir)) return true;\n            if (this.atLastNode(dir) || !this.parent()) return false;\n        }\n    }\n    /**\n    Move to the next node in a\n    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n    traversal, going from a node to its first child or, if the\n    current node is empty or `enter` is false, its next sibling or\n    the next sibling of the first parent node that has one.\n    */ next(enter = true) {\n        return this.move(1, enter);\n    }\n    /**\n    Move to the next node in a last-to-first pre-order traversal. A\n    node is followed by its last child or, if it has none, its\n    previous sibling or the previous sibling of the first parent\n    node that has one.\n    */ prev(enter = true) {\n        return this.move(-1, enter);\n    }\n    /**\n    Move the cursor to the innermost node that covers `pos`. If\n    `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    it will enter nodes that start at `pos`.\n    */ moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while(this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))if (!this.parent()) break;\n        // Then scan down into child nodes as far as possible\n        while(this.enterChild(1, pos, side)){}\n        return this;\n    }\n    /**\n    Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    position.\n    */ get node() {\n        if (!this.buffer) return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for(let index = this.index, d = this.stack.length; d >= 0;){\n                for(let c = cache; c; c = c._parent)if (c.index == index) {\n                    if (index == this.index) return c;\n                    result = c;\n                    depth = d + 1;\n                    break scan;\n                }\n                index = this.stack[--d];\n            }\n        }\n        for(let i = depth; i < this.stack.length; i++)result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /**\n    Get the [tree](#common.Tree) that represents the current node, if\n    any. Will return null when the node is in a [tree\n    buffer](#common.TreeBuffer).\n    */ get tree() {\n        return this.buffer ? null : this._tree._tree;\n    }\n    /**\n    Iterate over the current node and all its descendants, calling\n    `enter` when entering a node and `leave`, if given, when leaving\n    one. When `enter` returns `false`, any children of that node are\n    skipped, and `leave` isn't called for it.\n    */ iterate(enter, leave) {\n        for(let depth = 0;;){\n            let mustLeave = false;\n            if (this.type.isAnonymous || enter(this) !== false) {\n                if (this.firstChild()) {\n                    depth++;\n                    continue;\n                }\n                if (!this.type.isAnonymous) mustLeave = true;\n            }\n            for(;;){\n                if (mustLeave && leave) leave(this);\n                mustLeave = this.type.isAnonymous;\n                if (!depth) return;\n                if (this.nextSibling()) break;\n                this.parent();\n                depth--;\n                mustLeave = true;\n            }\n        }\n    }\n    /**\n    Test whether the current node matches a given contextâ€”a sequence\n    of direct parent node names. Empty strings in the context array\n    are treated as wildcards.\n    */ matchContext(context) {\n        if (!this.buffer) return matchNodeContext(this.node.parent, context);\n        let { buffer } = this.buffer, { types } = buffer.set;\n        for(let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--){\n            if (d < 0) return matchNodeContext(this._tree, context, i);\n            let type = types[buffer.buffer[this.stack[d]]];\n            if (!type.isAnonymous) {\n                if (context[i] && context[i] != type.name) return false;\n                i--;\n            }\n        }\n        return true;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some((ch)=>ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead, contextAtStart = contextHash;\n        while(size < 0){\n            cursor.next();\n            if (size == -1 /* SpecialRecord.Reuse */ ) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            } else if (size == -3 /* SpecialRecord.ContextChange */ ) {\n                contextHash = id;\n                return;\n            } else if (size == -4 /* SpecialRecord.LookAhead */ ) {\n                lookAhead = id;\n                return;\n            } else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while(cursor.pos > endPos)index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        } else {\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while(cursor.pos > endPos){\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                } else if (depth > 2500 /* CutOff.Depth */ ) {\n                    takeFlatNode(start, endPos, localChildren, localPositions);\n                } else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type, contextAtStart);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            } else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function takeFlatNode(parentStart, minPos, children, positions) {\n        let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions\n        let nodeCount = 0, stopAt = -1;\n        while(cursor.pos > minPos){\n            let { id, start, end, size } = cursor;\n            if (size > 4) {\n                cursor.next();\n            } else if (stopAt > -1 && start < stopAt) {\n                break;\n            } else {\n                if (stopAt < 0) stopAt = end - maxBufferLength;\n                nodes.push(id, start, end);\n                nodeCount++;\n                cursor.next();\n            }\n        }\n        if (nodeCount) {\n            let buffer = new Uint16Array(nodeCount * 4);\n            let start = nodes[nodes.length - 2];\n            for(let i = nodes.length - 3, j = 0; i >= 0; i -= 3){\n                buffer[j++] = nodes[i];\n                buffer[j++] = nodes[i + 1] - start;\n                buffer[j++] = nodes[i + 2] - start;\n                buffer[j++] = j;\n            }\n            children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));\n            positions.push(start - parentStart);\n        }\n    }\n    function makeBalanced(type, contextHash) {\n        return (children, positions, length)=>{\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length) return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead, contextHash);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead, contextHash) {\n        let localChildren = [], localPositions = [];\n        while(children.length > i){\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to, contextHash));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead, contextHash, props) {\n        if (contextHash) {\n            let pair = [\n                NodeProp.contextHash,\n                contextHash\n            ];\n            props = props ? [\n                pair\n            ].concat(props) : [\n                pair\n            ];\n        }\n        if (lookAhead > 25) {\n            let pair = [\n                NodeProp.lookAhead,\n                lookAhead\n            ];\n            props = props ? [\n                pair\n            ].concat(props) : [\n                pair\n            ];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = {\n            size: 0,\n            start: 0,\n            skip: 0\n        };\n        scan: for(let minPos = fork.pos - maxSize; fork.pos > minPos;){\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while(fork.pos > startPos){\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* SpecialRecord.ContextChange */ ) localSkipped += 4;\n                    else break scan;\n                } else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while(cursor.pos > endPos)index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        } else if (size == -3 /* SpecialRecord.ContextChange */ ) {\n            contextHash = id;\n        } else if (size == -4 /* SpecialRecord.LookAhead */ ) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while(cursor.pos > 0)takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children){\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(// The type the balanced tree's inner nodes.\nbalanceType, // The direct children and their positions\nchildren, positions, // The index range in children/positions to use\nfrom, to, // The start position of the nodes, relative to their parent.\nstart, // Length of the outer node\nlength, // Function to build the top node of the balanced tree\nmkTop, // Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for(let i = from; i < to; i++)total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil(total * 1.5 / 8 /* Balance.BranchFactor */ );\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for(let i = from; i < to;){\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for(; i < to; i++){\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild) break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            } else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/**\nProvides a way to associate values with pieces of trees. As long\nas that part of the tree is reused, the associated values can be\nretrieved from an updated tree.\n*/ class NodeWeakMap {\n    constructor(){\n        this.map = new WeakMap();\n    }\n    setBuffer(buffer, index, value) {\n        let inner = this.map.get(buffer);\n        if (!inner) this.map.set(buffer, inner = new Map);\n        inner.set(index, value);\n    }\n    getBuffer(buffer, index) {\n        let inner = this.map.get(buffer);\n        return inner && inner.get(index);\n    }\n    /**\n    Set the value for this syntax node.\n    */ set(node, value) {\n        if (node instanceof BufferNode) this.setBuffer(node.context.buffer, node.index, value);\n        else if (node instanceof TreeNode) this.map.set(node.tree, value);\n    }\n    /**\n    Retrieve value for this syntax node, if it exists in the map.\n    */ get(node) {\n        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n    }\n    /**\n    Set the value for the node that a cursor currently points to.\n    */ cursorSet(cursor, value) {\n        if (cursor.buffer) this.setBuffer(cursor.buffer.buffer, cursor.index, value);\n        else this.map.set(cursor.tree, value);\n    }\n    /**\n    Retrieve the value for the node that a cursor currently points\n    to.\n    */ cursorGet(cursor) {\n        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n    }\n}\n/**\nTree fragments are used during [incremental\nparsing](#common.Parser.startParse) to track parts of old trees\nthat can be reused in a new parse. An array of fragments is used\nto track regions of an old tree whose nodes might be reused in new\nparses. Use the static\n[`applyChanges`](#common.TreeFragment^applyChanges) method to\nupdate fragments for document changes.\n*/ class TreeFragment {\n    /**\n    Construct a tree fragment. You'll usually want to use\n    [`addTree`](#common.TreeFragment^addTree) and\n    [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n    calling this directly.\n    */ constructor(/**\n    The start of the unchanged range pointed to by this fragment.\n    This refers to an offset in the _updated_ document (as opposed\n    to the original tree).\n    */ from, /**\n    The end of the unchanged range.\n    */ to, /**\n    The tree that this fragment is based on.\n    */ tree, /**\n    The offset between the fragment's tree and the document that\n    this fragment can be used against. Add this when going from\n    document to tree positions, subtract it to go from tree to\n    document positions.\n    */ offset, openStart = false, openEnd = false){\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Open.Start */  : 0) | (openEnd ? 2 /* Open.End */  : 0);\n    }\n    /**\n    Whether the start of the fragment represents the start of a\n    parse, or the end of a change. (In the second case, it may not\n    be safe to reuse some nodes at the start, depending on the\n    parsing algorithm.)\n    */ get openStart() {\n        return (this.open & 1 /* Open.Start */ ) > 0;\n    }\n    /**\n    Whether the end of the fragment represents the end of a\n    full-document parse, or the start of a change.\n    */ get openEnd() {\n        return (this.open & 2 /* Open.End */ ) > 0;\n    }\n    /**\n    Create a set of fragments from a freshly parsed tree, or update\n    an existing set of fragments by replacing the ones that overlap\n    with a tree with content from the new tree. When `partial` is\n    true, the parse is treated as incomplete, and the resulting\n    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    true.\n    */ static addTree(tree, fragments = [], partial = false) {\n        let result = [\n            new TreeFragment(0, tree.length, tree, 0, false, partial)\n        ];\n        for (let f of fragments)if (f.to > tree.length) result.push(f);\n        return result;\n    }\n    /**\n    Apply a set of edits to an array of fragments, removing or\n    splitting fragments as necessary to remove edited ranges, and\n    adjusting offsets for fragments that moved.\n    */ static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length) return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for(let cI = 0, pos = 0, off = 0;; cI++){\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap) while(nextF && nextF.from < nextPos){\n                let cut = nextF;\n                if (pos >= cut.from || nextPos <= cut.to || off) {\n                    let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                    cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                }\n                if (cut) result.push(cut);\n                if (nextF.to > nextPos) break;\n                nextF = fI < fragments.length ? fragments[fI++] : null;\n            }\n            if (!nextC) break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/**\nA superclass that parsers should extend.\n*/ class Parser {\n    /**\n    Start a parse, returning a [partial parse](#common.PartialParse)\n    object. [`fragments`](#common.TreeFragment) can be passed in to\n    make the parse incremental.\n    \n    By default, the entire input is parsed. You can pass `ranges`,\n    which should be a sorted array of non-empty, non-overlapping\n    ranges, to parse only those ranges. The tree returned in that\n    case will start at `ranges[0].from`.\n    */ startParse(input, fragments, ranges) {\n        if (typeof input == \"string\") input = new StringInput(input);\n        ranges = !ranges ? [\n            new Range(0, input.length)\n        ] : ranges.length ? ranges.map((r)=>new Range(r.from, r.to)) : [\n            new Range(0, 0)\n        ];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /**\n    Run a full parse, returning the resulting tree.\n    */ parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for(;;){\n            let done = parse.advance();\n            if (done) return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string){\n        this.string = string;\n    }\n    get length() {\n        return this.string.length;\n    }\n    chunk(from) {\n        return this.string.slice(from);\n    }\n    get lineChunks() {\n        return false;\n    }\n    read(from, to) {\n        return this.string.slice(from, to);\n    }\n}\n/**\nCreate a parse wrapper that, after the inner parse completes,\nscans its tree for mixed language regions with the `nest`\nfunction, runs the resulting [inner parses](#common.NestedParse),\nand then [mounts](#common.NodeProp^mounted) their results onto the\ntree.\n*/ function parseMixed(nest) {\n    return (parse, input, fragments, ranges)=>new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, from){\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.from = from;\n    }\n}\nfunction checkRanges(ranges) {\n    if (!ranges.length || ranges.some((r)=>r.from >= r.to)) throw new RangeError(\"Invalid inner parse ranges given: \" + JSON.stringify(ranges));\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev){\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({\n    perNode: true\n});\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges){\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done) return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null) for (let inner of this.inner)inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null) result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([\n                [\n                    stoppedInner,\n                    this.stoppedAt\n                ]\n            ]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse) return 0;\n        let pos = this.input.length;\n        for(let i = this.innerDone; i < this.inner.length; i++){\n            if (this.inner[i].from < pos) pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse) this.baseParse.stopAt(pos);\n        else for(let i = this.innerDone; i < this.inner.length; i++)this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n        scan: for(let nest, isCovered;;){\n            let enter = true, range;\n            if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {\n                enter = false;\n            } else if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find((m)=>m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match) for (let r of match.mount.overlay){\n                        let from = r.from + match.pos, to = r.to + match.pos;\n                        if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some((r)=>r.from < to && r.to > from)) overlay.ranges.push({\n                            from,\n                            to\n                        });\n                    }\n                }\n                enter = false;\n            } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Cover.Full */ ;\n            } else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) && (cursor.from < cursor.to || !nest.overlay)) {\n                if (!cursor.tree) materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                } else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || (cursor.from < cursor.to ? [\n                        new Range(cursor.from, cursor.to)\n                    ] : []));\n                    if (ranges.length) checkRanges(ranges);\n                    if (ranges.length || !nest.overlay) this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(\"\"), nest.overlay ? nest.overlay.map((r)=>new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));\n                    if (!nest.overlay) enter = false;\n                    else if (ranges.length) covered = {\n                        ranges,\n                        depth: 0,\n                        prev: covered\n                    };\n                }\n            } else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true) range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to) {\n                    let last = overlay.ranges.length - 1;\n                    if (last >= 0 && overlay.ranges[last].to == range.from) overlay.ranges[last] = {\n                        from: overlay.ranges[last].from,\n                        to: range.to\n                    };\n                    else overlay.ranges.push(range);\n                }\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay) overlay.depth++;\n                if (covered) covered.depth++;\n            } else {\n                for(;;){\n                    if (cursor.nextSibling()) break;\n                    if (!cursor.parent()) break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length) {\n                            checkRanges(ranges);\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map((r)=>new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));\n                        }\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth) covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered){\n        if (range.from >= to) break;\n        if (range.to > from) return range.from <= from && range.to >= to ? 2 /* Cover.Full */  : 1 /* Cover.Partial */ ;\n    }\n    return 0 /* Cover.None */ ;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1];\n        nodes.push(buf.slice(startI, endI, from));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, stack = [];\n    let buffer = node.context.buffer;\n    // Scan up to the nearest tree\n    do {\n        stack.push(cursor.index);\n        cursor.parent();\n    }while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let base = cursor.tree, i = base.children.indexOf(buffer);\n    let buf = base.children[i], b = buf.buffer, newStack = [\n        i\n    ];\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length, stackPos) {\n        let targetI = stack[stackPos];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, targetI, children, positions, innerOffset);\n        let from = b[targetI + 1], to = b[targetI + 2];\n        newStack.push(children.length);\n        let child = stackPos ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1) : node.toTree();\n        children.push(child);\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);\n    // Move the cursor back to the target node\n    for (let index of newStack){\n        let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];\n        cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));\n    }\n}\nclass StructureCursor {\n    constructor(root, offset){\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while(!this.done && cursor.from < p){\n            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;\n            else if (!cursor.next(false)) this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for(let tree = this.cursor.tree;;){\n                if (tree == cursor.tree) return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree) tree = tree.children[0];\n                else break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments){\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        } else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while(this.curFrag && node.from >= this.curTo)this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        } else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for(let pos = this.inner.cursor.node; pos; pos = pos.parent){\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for(let i = this.fragI; i < this.fragments.length; i++){\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to) break;\n                        if (frag.tree == this.curFrag.tree) result.push({\n                            frag,\n                            pos: pos.from - frag.offset,\n                            mount\n                        });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for(let i = 1, j = 0; i < outer.length; i++){\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for(; j < current.length; j++){\n            let r = current[j];\n            if (r.from >= gapTo) break;\n            if (r.to <= gapFrom) continue;\n            if (!copy) current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            } else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            } else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for(;;){\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end) result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9) break;\n        if (nextA == pos) {\n            if (!inA) inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB) inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts){\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map((r)=>new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for(let i = 0, pos = from;; i++){\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos) result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n                if (last) break;\n                pos = changes[i].to;\n            }\n        } else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n        }\n    }\n    return result;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2NvbW1vbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQSxHQUNBLE1BQU1BLHNCQUFzQjtBQUM1QixJQUFJQyxhQUFhO0FBQ2pCLE1BQU1DO0lBQ0ZDLFlBQVlDLElBQUksRUFBRUMsRUFBRSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsRUFBRSxHQUFHQTtJQUNkO0FBQ0o7QUFDQTs7OztBQUlBLEdBQ0EsTUFBTUM7SUFDRjs7SUFFQSxHQUNBSCxZQUFZSSxTQUFTLENBQUMsQ0FBQyxDQUFFO1FBQ3JCLElBQUksQ0FBQ0MsRUFBRSxHQUFHUDtRQUNWLElBQUksQ0FBQ1EsT0FBTyxHQUFHLENBQUMsQ0FBQ0YsT0FBT0UsT0FBTztRQUMvQixJQUFJLENBQUNDLFdBQVcsR0FBR0gsT0FBT0csV0FBVyxJQUFLO1lBQ3RDLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtJQUNKO0lBQ0E7Ozs7Ozs7O0lBUUEsR0FDQUMsSUFBSUMsS0FBSyxFQUFFO1FBQ1AsSUFBSSxJQUFJLENBQUNKLE9BQU8sRUFDWixNQUFNLElBQUlLLFdBQVc7UUFDekIsSUFBSSxPQUFPRCxTQUFTLFlBQ2hCQSxRQUFRRSxTQUFTRixLQUFLLENBQUNBO1FBQzNCLE9BQU8sQ0FBQ0c7WUFDSixJQUFJQyxTQUFTSixNQUFNRztZQUNuQixPQUFPQyxXQUFXQyxZQUFZLE9BQU87Z0JBQUMsSUFBSTtnQkFBRUQ7YUFBTztRQUN2RDtJQUNKO0FBQ0o7QUFDQTs7Ozs7QUFLQSxHQUNBWCxTQUFTYSxRQUFRLEdBQUcsSUFBSWIsU0FBUztJQUFFSSxhQUFhVSxDQUFBQSxNQUFPQSxJQUFJQyxLQUFLLENBQUM7QUFBSztBQUN0RTs7OztBQUlBLEdBQ0FmLFNBQVNnQixRQUFRLEdBQUcsSUFBSWhCLFNBQVM7SUFBRUksYUFBYVUsQ0FBQUEsTUFBT0EsSUFBSUMsS0FBSyxDQUFD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QUFDWDtBQUVnSyIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2tuaWNoZS8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanM/YzE5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcblRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUuXG4qL1xuY29uc3QgRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IDEwMjQ7XG5sZXQgbmV4dFByb3BJRCA9IDA7XG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbi8qKlxuRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG5jYW4gaGF2ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbiovXG5jbGFzcyBOb2RlUHJvcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gICAgW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgcHJvcCB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgaXQgZG9lcy5cbiAgICAqL1xuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5wZXJOb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBhZGQgcGVyLW5vZGUgcHJvcHMgdG8gbm9kZSB0eXBlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBtYXRjaCA9IE5vZGVUeXBlLm1hdGNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogW3RoaXMsIHJlc3VsdF07XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG5Qcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcbnNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbmZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbiovXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVGhlIGludmVyc2Ugb2YgW2BjbG9zZWRCeWBdKCNjb21tb24uTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG5hdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xub2YgdHlwZXMgb2YgbWF0Y2hpbmcgb3BlbmluZyBkZWxpbWl0ZXJzLlxuKi9cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLyoqXG5Vc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG50eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG5gXCJFeHByZXNzaW9uXCJgIGdyb3VwKS5cbiovXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuQXR0YWNoZWQgdG8gbm9kZXMgdG8gaW5kaWNhdGUgdGhlc2Ugc2hvdWxkIGJlXG5bZGlzcGxheWVkXShodHRwczovL2NvZGVtaXJyb3IubmV0L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhUcmVlKVxuaW4gYSBiaWRpcmVjdGlvbmFsIHRleHQgaXNvbGF0ZSwgc28gdGhhdCBkaXJlY3Rpb24tbmV1dHJhbFxuY2hhcmFjdGVycyBvbiB0aGVpciBzaWRlcyBkb24ndCBpbmNvcnJlY3RseSBnZXQgYXNzb2NpYXRlZCB3aXRoXG5zdXJyb3VuZGluZyB0ZXh0LiBZb3UnbGwgZ2VuZXJhbGx5IHdhbnQgdG8gc2V0IHRoaXMgZm9yIG5vZGVzXG50aGF0IGNvbnRhaW4gYXJiaXRyYXJ5IHRleHQsIGxpa2Ugc3RyaW5ncyBhbmQgY29tbWVudHMsIGFuZCBmb3Jcbm5vZGVzIHRoYXQgYXBwZWFyIF9pbnNpZGVfIGFyYml0cmFyeSB0ZXh0LCBsaWtlIEhUTUwgdGFncy4gV2hlblxubm90IGdpdmVuIGEgdmFsdWUsIGluIGEgZ3JhbW1hciBkZWNsYXJhdGlvbiwgZGVmYXVsdHMgdG9cbmBcImF1dG9cImAuXG4qL1xuTm9kZVByb3AuaXNvbGF0ZSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPSBcInJ0bFwiICYmIHZhbHVlICE9IFwibHRyXCIgJiYgdmFsdWUgIT0gXCJhdXRvXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIGlzb2xhdGU6IFwiICsgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgXCJhdXRvXCI7XG4gICAgfSB9KTtcbi8qKlxuVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXG50aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuY29udGV4dHVhbCBub2Rlcy5cbiovXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vKipcblRoZSBkaXN0YW5jZSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbm9kZSB0aGF0IHRoZSB0b2tlbml6ZXJcbmxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG5wYXJzZXIgb25seSBzdG9yZXMgdGhpcyB3aGVuIGl0IGlzIGxhcmdlciB0aGFuIDI1LCBmb3JcbmVmZmljaWVuY3kgcmVhc29ucy4pXG4qL1xuTm9kZVByb3AubG9va0FoZWFkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8qKlxuVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxubm9kZSwgd2l0aCBhbm90aGVyIHRyZWUuIFRoaXMgaXMgdXNlZnVsIHRvIGluY2x1ZGUgdHJlZXMgZnJvbVxuZGlmZmVyZW50IGxhbmd1YWdlcyBpbiBtaXhlZC1sYW5ndWFnZSBwYXJzZXJzLlxuKi9cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLyoqXG5BIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbmEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG5yZXByZXNlbnRlZCBieSBhbm90aGVyIHRyZWUuXG4qL1xuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBpbm5lciB0cmVlLlxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgYmUgaW5jbHVkZWQgaW4gdGhlIHJlZ3VsYXIgaXRlcmF0aW9uIGluc3RlYWQgb2YgaXRzIGhvc3RcbiAgICBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIGEgd2F5IHRoYXQgaXNuJ3Qgc3RyaWN0bHkgaGllcmFyY2hpY2FsLiBTdWNoIG1vdW50ZWQgdHJlZXMgYXJlXG4gICAgb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgKi9cbiAgICBvdmVybGF5LCBcbiAgICAvKipcbiAgICBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICAqL1xuICAgIHBhcnNlcikge1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWUgJiYgdHJlZS5wcm9wcyAmJiB0cmVlLnByb3BzW05vZGVQcm9wLm1vdW50ZWQuaWRdO1xuICAgIH1cbn1cbmNvbnN0IG5vUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5FYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuKi9cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xuICAgIHJvbGUuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHByb3BzLCBcbiAgICAvKipcbiAgICBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIHVzZWQgaW4gdGhlIHBhcnNlci5cbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIE5vZGVGbGFnLlRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBOb2RlRmxhZy5FcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1swXS5wZXJOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBzdG9yZSBhIHBlci1ub2RlIHByb3Agb24gYSBub2RlIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3NyY1swXS5pZF0gPSBzcmNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gICAgdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxuICAgICovXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIE5vZGVGbGFnLlRvcCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICAqL1xuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogTm9kZUZsYWcuRXJyb3IgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxuICAgIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgICovXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXG4gICAgW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmdW5jdGlvbiBmcm9tIG5vZGUgdHlwZXMgdG8gYXJiaXRyYXJ5IHZhbHVlcyBieVxuICAgIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgW2dyb3VwXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBuYW1lcy4gT2Z0ZW4gdXNlZnVsIHdpdGhcbiAgICBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS4gWW91IGNhbiBwdXQgbXVsdGlwbGVcbiAgICBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoKG1hcCkge1xuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcbiAgICAgICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cHMgPSBub2RlLnByb3AoTm9kZVByb3AuZ3JvdXApLCBpID0gLTE7IGkgPCAoZ3JvdXBzID8gZ3JvdXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbiovXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovKTtcbi8qKlxuQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xuY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG5mdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWVyaWMgYXJyYXkuIEVhY2ggcGFyc2VyXG5baGFzXSgjbHIuTFJQYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXG5idWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG5mcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNikgbm9kZVxudHlwZXMgaW4gaXQsIHNvIHRoYXQgdGhlIGlkcyBmaXQgaW50byAxNi1iaXQgdHlwZWQgYXJyYXkgc2xvdHMuXG4qL1xuY2xhc3MgTm9kZVNldCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IHdpdGggdGhlIGdpdmVuIHR5cGVzLiBUaGUgYGlkYCBwcm9wZXJ0eSBvZiBlYWNoXG4gICAgdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHR5cGVzIGluIHRoaXMgc2V0LCBieSBpZC5cbiAgICAqL1xuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCBjYW4gYmUgY3JlYXRlZCB3aXRoXG4gICAgW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgKi9cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNbYWRkWzBdLmlkXSA9IGFkZFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUeXBlcy5wdXNoKG5ld1Byb3BzID8gbmV3IE5vZGVUeXBlKHR5cGUubmFtZSwgbmV3UHJvcHMsIHR5cGUuaWQsIHR5cGUuZmxhZ3MpIDogdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2V0KG5ld1R5cGVzKTtcbiAgICB9XG59XG5jb25zdCBDYWNoZWROb2RlID0gbmV3IFdlYWtNYXAoKSwgQ2FjaGVkSW5uZXJOb2RlID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuT3B0aW9ucyB0aGF0IGNvbnRyb2wgaXRlcmF0aW9uLiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgYHxgXG5vcGVyYXRvciB0byBlbmFibGUgbXVsdGlwbGUgb25lcy5cbiovXG52YXIgSXRlck1vZGU7XG4oZnVuY3Rpb24gKEl0ZXJNb2RlKSB7XG4gICAgLyoqXG4gICAgV2hlbiBlbmFibGVkLCBpdGVyYXRpb24gd2lsbCBvbmx5IHZpc2l0IFtgVHJlZWBdKCNjb21tb24uVHJlZSlcbiAgICBvYmplY3RzLCBub3Qgbm9kZXMgcGFja2VkIGludG9cbiAgICBbYFRyZWVCdWZmZXJgXSgjY29tbW9uLlRyZWVCdWZmZXIpcy5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiRXhjbHVkZUJ1ZmZlcnNcIl0gPSAxXSA9IFwiRXhjbHVkZUJ1ZmZlcnNcIjtcbiAgICAvKipcbiAgICBFbmFibGUgdGhpcyB0byBtYWtlIGl0ZXJhdGlvbiBpbmNsdWRlIGFub255bW91cyBub2RlcyAoc3VjaCBhc1xuICAgIHRoZSBub2RlcyB0aGF0IHdyYXAgcmVwZWF0ZWQgZ3JhbW1hciBjb25zdHJ1Y3RzIGludG8gYSBiYWxhbmNlZFxuICAgIHRyZWUpLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJbmNsdWRlQW5vbnltb3VzXCJdID0gMl0gPSBcIkluY2x1ZGVBbm9ueW1vdXNcIjtcbiAgICAvKipcbiAgICBCeSBkZWZhdWx0LCByZWd1bGFyIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIG5vZGVzXG4gICAgcmVwbGFjZSB0aGVpciBiYXNlIG5vZGUgaW4gaXRlcmF0aW9uLiBFbmFibGUgdGhpcyB0byBpZ25vcmUgdGhlbVxuICAgIGluc3RlYWQuXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIklnbm9yZU1vdW50c1wiXSA9IDRdID0gXCJJZ25vcmVNb3VudHNcIjtcbiAgICAvKipcbiAgICBUaGlzIG9wdGlvbiBvbmx5IGFwcGxpZXMgaW5cbiAgICBbYGVudGVyYF0oI2NvbW1vbi5TeW50YXhOb2RlLmVudGVyKS1zdHlsZSBtZXRob2RzLiBJdCB0ZWxscyB0aGVcbiAgICBsaWJyYXJ5IHRvIG5vdCBlbnRlciBtb3VudGVkIG92ZXJsYXlzIGlmIG9uZSBjb3ZlcnMgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIklnbm9yZU92ZXJsYXlzXCJdID0gOF0gPSBcIklnbm9yZU92ZXJsYXlzXCI7XG59KShJdGVyTW9kZSB8fCAoSXRlck1vZGUgPSB7fSkpO1xuLyoqXG5BIHBpZWNlIG9mIHN5bnRheCB0cmVlLiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gYXBwcm9hY2ggdGhlc2VcbnRyZWVzOiB0aGUgd2F5IHRoZXkgYXJlIGFjdHVhbGx5IHN0b3JlZCBpbiBtZW1vcnksIGFuZCB0aGVcbmNvbnZlbmllbnQgd2F5LlxuXG5TeW50YXggdHJlZXMgYXJlIHN0b3JlZCBhcyBhIHRyZWUgb2YgYFRyZWVgIGFuZCBgVHJlZUJ1ZmZlcmBcbm9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcbm5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG5cbkhvd2V2ZXIsIHdoZW4geW91IHdhbnQgdG8gYWN0dWFsbHkgd29yayB3aXRoIHRyZWUgbm9kZXMsIHRoaXNcbnJlcHJlc2VudGF0aW9uIGlzIHZlcnkgYXdrd2FyZCwgc28gbW9zdCBjbGllbnQgY29kZSB3aWxsIHdhbnQgdG9cbnVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuW2BTeW50YXhOb2RlYF0oI2NvbW1vbi5TeW50YXhOb2RlKSBpbnRlcmZhY2UgaW5zdGVhZCwgd2hpY2ggcHJvdmlkZXNcbmEgdmlldyBvbiBzb21lIHBhcnQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSwgYW5kIGNhbiBiZSB1c2VkIHRvXG5tb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbiovXG5jbGFzcyBUcmVlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIHRoZSB0b3Agbm9kZS5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoaXMgbm9kZSdzIGNoaWxkIG5vZGVzLlxuICAgICovXG4gICAgY2hpbGRyZW4sIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICB0aGUgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBwb3NpdGlvbnMsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFBlci1ub2RlIFtub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wKSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgcmV0dXJuIG1vdW50ZWQudHJlZS50b1N0cmluZygpO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gY2gudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IFwiLFwiO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMudHlwZS5uYW1lID8gY2hpbGRyZW4gOlxuICAgICAgICAgICAgKC9cXFcvLnRlc3QodGhpcy50eXBlLm5hbWUpICYmICF0aGlzLnR5cGUuaXNFcnJvciA/IEpTT04uc3RyaW5naWZ5KHRoaXMudHlwZS5uYW1lKSA6IHRoaXMudHlwZS5uYW1lKSArXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mXG4gICAgdGhlIHRyZWUuIE1vZGUgY2FuIGJlIHVzZWQgdG8gW2NvbnRyb2xdKCNjb21tb24uSXRlck1vZGUpIHdoaWNoXG4gICAgbm9kZXMgdGhlIGN1cnNvciB2aXNpdHMuXG4gICAgKi9cbiAgICBjdXJzb3IobW9kZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgbW9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb2ludGluZyBpbnRvIHRoaXMgdHJlZVxuICAgIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZSAoc2VlXG4gICAgW2Btb3ZlVG9gXSgjY29tbW9uLlRyZWVDdXJzb3IubW92ZVRvKS5cbiAgICAqL1xuICAgIGN1cnNvckF0KHBvcywgc2lkZSA9IDAsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBzY29wZSA9IENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpO1xuICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICByZXR1cm4gY3Vyc29yO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIHRyZWUuXG4gICAgKi9cbiAgICBnZXQgdG9wTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSh0aGlzLCAwLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICBwb3NpdGlvbi4gSWYgMSwgaXQnbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgc3RhcnQgYXQgdGhlXG4gICAgcG9zaXRpb24uIFdpdGggMCwgaXQnbGwgb25seSBlbnRlciBub2RlcyB0aGF0IGNvdmVyIHRoZSBwb3NpdGlvblxuICAgIGZyb20gYm90aCBzaWRlcy5cbiAgICBcbiAgICBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBlbnRlclxuICAgIFtvdmVybGF5c10oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSwgYW5kIHlvdSBvZnRlbiB3YW50XG4gICAgW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKSBpbnN0ZWFkLlxuICAgICovXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgcmVzb2x2ZWBdKCNjb21tb24uVHJlZS5yZXNvbHZlKSwgYnV0IHdpbGwgZW50ZXJcbiAgICBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSkgbm9kZXMsIHByb2R1Y2luZyBhIHN5bnRheCBub2RlXG4gICAgcG9pbnRpbmcgaW50byB0aGUgaW5uZXJtb3N0IG92ZXJsYWlkIHRyZWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgKHdpdGggcGFyZW50IGxpbmtzIGdvaW5nIHRocm91Z2ggYWxsIHBhcmVudCBzdHJ1Y3R1cmUsIGluY2x1ZGluZ1xuICAgIHRoZSBob3N0IHRyZWVzKS5cbiAgICAqL1xuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkSW5uZXJOb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgICAgIENhY2hlZElubmVyTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbiBzb21lIHNpdHVhdGlvbnMsIGl0IGNhbiBiZSB1c2VmdWwgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbFxuICAgIG5vZGVzIGFyb3VuZCBhIHBvc2l0aW9uLCBpbmNsdWRpbmcgdGhvc2UgaW4gb3ZlcmxheXMgdGhhdCBkb24ndFxuICAgIGRpcmVjdGx5IGNvdmVyIHRoZSBwb3NpdGlvbi4gVGhpcyBtZXRob2QgZ2l2ZXMgeW91IGFuIGl0ZXJhdG9yXG4gICAgdGhhdCB3aWxsIHByb2R1Y2UgYWxsIG5vZGVzLCBmcm9tIHNtYWxsIHRvIGJpZywgYXJvdW5kIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgcmVzb2x2ZVN0YWNrKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrSXRlcmF0b3IodGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgbm9kZSB0aGF0IHRvdWNoZXMgdGhlIGBmcm9tYC9gdG9gIHJlZ2lvbiAoaWYgZ2l2ZW4pIGJlZm9yZVxuICAgIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIG5vdCBoYXZlIGl0cyBjaGlsZHJlbiBpdGVyYXRlZCBvdmVyIChvciBgbGVhdmVgIGNhbGxlZCkuXG4gICAgKi9cbiAgICBpdGVyYXRlKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgZW50ZXIsIGxlYXZlLCBmcm9tID0gMCwgdG8gPSB0aGlzLmxlbmd0aCB9ID0gc3BlYztcbiAgICAgICAgbGV0IG1vZGUgPSBzcGVjLm1vZGUgfHwgMCwgYW5vbiA9IChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPiAwO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IobW9kZSB8IEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoIWFub24gJiYgYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMpICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChlbnRlcmVkICYmIGxlYXZlICYmIChhbm9uIHx8ICFjLnR5cGUuaXNBbm9ueW1vdXMpKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBbbm9kZSBwcm9wXSgjY29tbW9uLk5vZGVQcm9wKSBmb3IgdGhpc1xuICAgIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLnBlck5vZGUgPyB0aGlzLnR5cGUucHJvcChwcm9wKSA6IHRoaXMucHJvcHMgPyB0aGlzLnByb3BzW3Byb3AuaWRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBub2RlJ3MgW3Blci1ub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wLnBlck5vZGUpIGluIGFcbiAgICBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgY29uc3RydWN0b3IuXG4gICAgKi9cbiAgICBnZXQgcHJvcFZhbHVlcygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucHJvcHMpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goWytpZCwgdGhpcy5wcm9wc1tpZF1dKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgICBbYE5vZGVUeXBlLm5vbmVgXSgjY29tbW9uLk5vZGVUeXBlXm5vbmUpLlxuICAgICovXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyA/IHRoaXMgOlxuICAgICAgICAgICAgYmFsYW5jZVJhbmdlKE5vZGVUeXBlLm5vbmUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgdGhpcy5sZW5ndGgsIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCB0aGlzLnByb3BWYWx1ZXMpLCBjb25maWcubWFrZVRyZWUgfHwgKChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgICovXG4gICAgc3RhdGljIGJ1aWxkKGRhdGEpIHsgcmV0dXJuIGJ1aWxkVHJlZShkYXRhKTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgdHJlZVxuKi9cblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbi8qKlxuVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxubm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbmJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG5jaGlsZHJlbiBiZWxvbmcgdG8gaXQpLlxuKi9cbmNsYXNzIFRyZWVCdWZmZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGJ1ZmZlcidzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBidWZmZXIsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgICovXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoOykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIixcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzbGljZShzdGFydEksIGVuZEksIGZyb20pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSksIGxlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBsZXQgdG8gPSBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICAgICAgbGVuID0gTWF0aC5tYXgobGVuLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQnVmZmVyKGNvcHksIGxlbiwgdGhpcy5zZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2lkZShzaWRlLCBwb3MsIGZyb20sIHRvKSB7XG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgLTIgLyogU2lkZS5CZWZvcmUgKi86IHJldHVybiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIC0xIC8qIFNpZGUuQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogU2lkZS5Bcm91bmQgKi86IHJldHVybiBmcm9tIDwgcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDEgLyogU2lkZS5BdE9yQWZ0ZXIgKi86IHJldHVybiBmcm9tIDw9IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAyIC8qIFNpZGUuQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIFNpZGUuRG9udENhcmUgKi86IHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVOb2RlKG5vZGUsIHBvcywgc2lkZSwgb3ZlcmxheXMpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgd2hpbGUgKG5vZGUuZnJvbSA9PSBub2RlLnRvIHx8XG4gICAgICAgIChzaWRlIDwgMSA/IG5vZGUuZnJvbSA+PSBwb3MgOiBub2RlLmZyb20gPiBwb3MpIHx8XG4gICAgICAgIChzaWRlID4gLTEgPyBub2RlLnRvIDw9IHBvcyA6IG5vZGUudG8gPCBwb3MpKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAhb3ZlcmxheXMgJiYgbm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIG5vZGUuaW5kZXggPCAwID8gbnVsbCA6IG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICBsZXQgbW9kZSA9IG92ZXJsYXlzID8gMCA6IEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzO1xuICAgIC8vIE11c3QgZ28gdXAgb3V0IG9mIG92ZXJsYXlzIHdoZW4gdGhvc2UgZG8gbm90IG92ZXJsYXAgd2l0aCBwb3NcbiAgICBpZiAob3ZlcmxheXMpXG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBwYXJlbnQgPSBzY2FuLnBhcmVudDsgcGFyZW50OyBzY2FuID0gcGFyZW50LCBwYXJlbnQgPSBzY2FuLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHNjYW4gaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBzY2FuLmluZGV4IDwgMCAmJiAoKF9hID0gcGFyZW50LmVudGVyKHBvcywgc2lkZSwgbW9kZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcm9tKSAhPSBzY2FuLmZyb20pXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGlubmVyID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIG1vZGUpO1xuICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBCYXNlTm9kZSB7XG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLCBtb2RlKTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMucGFyZW50LCBjb250ZXh0KTtcbiAgICB9XG4gICAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUocG9zKSB7XG4gICAgICAgIGxldCBzY2FuID0gdGhpcy5jaGlsZEJlZm9yZShwb3MpLCBub2RlID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHNjYW4pIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gc2Nhbi5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoIWxhc3QgfHwgbGFzdC50byAhPSBzY2FuLnRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGxhc3QudHlwZS5pc0Vycm9yICYmIGxhc3QuZnJvbSA9PSBsYXN0LnRvKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHNjYW47XG4gICAgICAgICAgICAgICAgc2NhbiA9IGxhc3QucHJldlNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2FuID0gbGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5vZGUoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiB0aGlzLnBhcmVudDsgfVxufVxuY2xhc3MgVHJlZU5vZGUgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gICAgY29uc3RydWN0b3IoX3RyZWUsIGZyb20sIFxuICAgIC8vIEluZGV4IGluIHBhcmVudCBub2RlLCBzZXQgdG8gLTEgaWYgdGhlIG5vZGUgaXMgbm90IGEgZGlyZWN0IGNoaWxkIG9mIF9wYXJlbnQubm9kZSAob3ZlcmxheSlcbiAgICBpbmRleCwgX3BhcmVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90cmVlID0gX3RyZWU7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLl90cmVlLnR5cGU7IH1cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZS5uYW1lOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy5fdHJlZS5sZW5ndGg7IH1cbiAgICBuZXh0Q2hpbGQoaSwgZGlyLCBwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IHRoaXM7Oykge1xuICAgICAgICAgICAgZm9yIChsZXQgeyBjaGlsZHJlbiwgcG9zaXRpb25zIH0gPSBwYXJlbnQuX3RyZWUsIGUgPSBkaXIgPiAwID8gY2hpbGRyZW4ubGVuZ3RoIDogLTE7IGkgIT0gZTsgaSArPSBkaXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGNoaWxkcmVuW2ldLCBzdGFydCA9IHBvc2l0aW9uc1tpXSArIHBhcmVudC5mcm9tO1xuICAgICAgICAgICAgICAgIGlmICghY2hlY2tTaWRlKHNpZGUsIHBvcywgc3RhcnQsIHN0YXJ0ICsgbmV4dC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgJiBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBuZXh0LmZpbmRDaGlsZCgwLCBuZXh0LmJ1ZmZlci5sZW5ndGgsIGRpciwgcG9zIC0gc3RhcnQsIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyTm9kZShuZXcgQnVmZmVyQ29udGV4dChwYXJlbnQsIG5leHQsIGksIHN0YXJ0KSwgbnVsbCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICghbmV4dC50eXBlLmlzQW5vbnltb3VzIHx8IGhhc0NoaWxkKG5leHQpKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobW9kZSAmIEl0ZXJNb2RlLklnbm9yZU1vdW50cykgJiYgKG1vdW50ZWQgPSBNb3VudGVkVHJlZS5nZXQobmV4dCkpICYmICFtb3VudGVkLm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgc3RhcnQsIGksIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IG5ldyBUcmVlTm9kZShuZXh0LCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgIWlubmVyLnR5cGUuaXNBbm9ueW1vdXMgPyBpbm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbm5lci5uZXh0Q2hpbGQoZGlyIDwgMCA/IG5leHQuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIGRpciwgcG9zLCBzaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhcGFyZW50LnR5cGUuaXNBbm9ueW1vdXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAocGFyZW50LmluZGV4ID49IDApXG4gICAgICAgICAgICAgICAgaSA9IHBhcmVudC5pbmRleCArIGRpcjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Ll9wYXJlbnQuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGNoaWxkQWZ0ZXIocG9zKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIDIgLyogU2lkZS5BZnRlciAqLyk7IH1cbiAgICBjaGlsZEJlZm9yZShwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKHRoaXMuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIHBvcywgLTIgLyogU2lkZS5CZWZvcmUgKi8pOyB9XG4gICAgZW50ZXIocG9zLCBzaWRlLCBtb2RlID0gMCkge1xuICAgICAgICBsZXQgbW91bnRlZDtcbiAgICAgICAgaWYgKCEobW9kZSAmIEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzKSAmJiAobW91bnRlZCA9IE1vdW50ZWRUcmVlLmdldCh0aGlzLl90cmVlKSkgJiYgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgclBvcyA9IHBvcyAtIHRoaXMuZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHNpZGUgPiAwID8gZnJvbSA8PSByUG9zIDogZnJvbSA8IHJQb3MpICYmXG4gICAgICAgICAgICAgICAgICAgIChzaWRlIDwgMCA/IHRvID49IHJQb3MgOiB0byA+IHJQb3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVOb2RlKG1vdW50ZWQudHJlZSwgbW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyB0aGlzLmZyb20sIC0xLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgcG9zLCBzaWRlLCBtb2RlKTtcbiAgICB9XG4gICAgbmV4dFNpZ25pZmljYW50UGFyZW50KCkge1xuICAgICAgICBsZXQgdmFsID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHZhbC50eXBlLmlzQW5vbnltb3VzICYmIHZhbC5fcGFyZW50KVxuICAgICAgICAgICAgdmFsID0gdmFsLl9wYXJlbnQ7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbmV4dFNpYmxpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLmluZGV4ICsgMSwgMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBwcmV2U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggLSAxLCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIHRvVHJlZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50b1N0cmluZygpOyB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihub2RlLCB0eXBlLCBiZWZvcmUsIGFmdGVyKSB7XG4gICAgbGV0IGN1ciA9IG5vZGUuY3Vyc29yKCksIHJlc3VsdCA9IFtdO1xuICAgIGlmICghY3VyLmZpcnN0Q2hpbGQoKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoYmVmb3JlICE9IG51bGwpXG4gICAgICAgIGZvciAobGV0IGZvdW5kID0gZmFsc2U7ICFmb3VuZDspIHtcbiAgICAgICAgICAgIGZvdW5kID0gY3VyLnR5cGUuaXMoYmVmb3JlKTtcbiAgICAgICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKGFmdGVyICE9IG51bGwgJiYgY3VyLnR5cGUuaXMoYWZ0ZXIpKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgaWYgKGN1ci50eXBlLmlzKHR5cGUpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VyLm5vZGUpO1xuICAgICAgICBpZiAoIWN1ci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgcmV0dXJuIGFmdGVyID09IG51bGwgPyByZXN1bHQgOiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXRjaE5vZGVDb250ZXh0KG5vZGUsIGNvbnRleHQsIGkgPSBjb250ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICBmb3IgKGxldCBwID0gbm9kZTsgaSA+PSAwOyBwID0gcC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKCFwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXAudHlwZS5pc0Fub255bW91cykge1xuICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSBwLm5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0ICsgdGhpcy5jb250ZXh0LmJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDFdOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0ICsgdGhpcy5jb250ZXh0LmJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDJdOyB9XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgX3BhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSBjb250ZXh0LmJ1ZmZlci5zZXQudHlwZXNbY29udGV4dC5idWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgfVxuICAgIGNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmNvbnRleHQuc3RhcnQsIHNpZGUpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCBwb3MsIC0yIC8qIFNpZGUuQmVmb3JlICovKTsgfVxuICAgIGVudGVyKHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgaWYgKG1vZGUgJiBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIHNpZGUgPiAwID8gMSA6IC0xLCBwb3MgLSB0aGlzLmNvbnRleHQuc3RhcnQsIHNpZGUpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50IHx8IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgfVxuICAgIGV4dGVybmFsU2libGluZyhkaXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IG51bGwgOiB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRDaGlsZCh0aGlzLmNvbnRleHQuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChhZnRlciA8ICh0aGlzLl9wYXJlbnQgPyBidWZmZXIuYnVmZmVyW3RoaXMuX3BhcmVudC5pbmRleCArIDNdIDogYnVmZmVyLmJ1ZmZlci5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBhZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmluZGV4ICsgNCA6IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSk7XG4gICAgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHRvVHJlZSgpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHN0YXJ0SSA9IHRoaXMuaW5kZXggKyA0LCBlbmRJID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChlbmRJID4gc3RhcnRJKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDFdO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChidWZmZXIuc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tKSk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodGhpcy50eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCB0aGlzLnRvIC0gdGhpcy5mcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCk7IH1cbn1cbmZ1bmN0aW9uIGl0ZXJTdGFjayhoZWFkcykge1xuICAgIGlmICghaGVhZHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcGljayA9IDAsIHBpY2tlZCA9IGhlYWRzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVhZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBoZWFkc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuZnJvbSA+IHBpY2tlZC5mcm9tIHx8IG5vZGUudG8gPCBwaWNrZWQudG8pIHtcbiAgICAgICAgICAgIHBpY2tlZCA9IG5vZGU7XG4gICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbmV4dCA9IHBpY2tlZCBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIHBpY2tlZC5pbmRleCA8IDAgPyBudWxsIDogcGlja2VkLnBhcmVudDtcbiAgICBsZXQgbmV3SGVhZHMgPSBoZWFkcy5zbGljZSgpO1xuICAgIGlmIChuZXh0KVxuICAgICAgICBuZXdIZWFkc1twaWNrXSA9IG5leHQ7XG4gICAgZWxzZVxuICAgICAgICBuZXdIZWFkcy5zcGxpY2UocGljaywgMSk7XG4gICAgcmV0dXJuIG5ldyBTdGFja0l0ZXJhdG9yKG5ld0hlYWRzLCBwaWNrZWQpO1xufVxuY2xhc3MgU3RhY2tJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoaGVhZHMsIG5vZGUpIHtcbiAgICAgICAgdGhpcy5oZWFkcyA9IGhlYWRzO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIGl0ZXJTdGFjayh0aGlzLmhlYWRzKTsgfVxufVxuZnVuY3Rpb24gc3RhY2tJdGVyYXRvcih0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgaW5uZXIgPSB0cmVlLnJlc29sdmVJbm5lcihwb3MsIHNpZGUpLCBsYXllcnMgPSBudWxsO1xuICAgIGZvciAobGV0IHNjYW4gPSBpbm5lciBpbnN0YW5jZW9mIFRyZWVOb2RlID8gaW5uZXIgOiBpbm5lci5jb250ZXh0LnBhcmVudDsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50KSB7XG4gICAgICAgIGlmIChzY2FuLmluZGV4IDwgMCkgeyAvLyBUaGlzIGlzIGFuIG92ZXJsYXkgcm9vdFxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHNjYW4ucGFyZW50O1xuICAgICAgICAgICAgKGxheWVycyB8fCAobGF5ZXJzID0gW2lubmVyXSkpLnB1c2gocGFyZW50LnJlc29sdmUocG9zLCBzaWRlKSk7XG4gICAgICAgICAgICBzY2FuID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1vdW50ID0gTW91bnRlZFRyZWUuZ2V0KHNjYW4udHJlZSk7XG4gICAgICAgICAgICAvLyBSZWxldmFudCBvdmVybGF5IGJyYW5jaGluZyBvZmZcbiAgICAgICAgICAgIGlmIChtb3VudCAmJiBtb3VudC5vdmVybGF5ICYmIG1vdW50Lm92ZXJsYXlbMF0uZnJvbSA8PSBwb3MgJiYgbW91bnQub3ZlcmxheVttb3VudC5vdmVybGF5Lmxlbmd0aCAtIDFdLnRvID49IHBvcykge1xuICAgICAgICAgICAgICAgIGxldCByb290ID0gbmV3IFRyZWVOb2RlKG1vdW50LnRyZWUsIG1vdW50Lm92ZXJsYXlbMF0uZnJvbSArIHNjYW4uZnJvbSwgLTEsIHNjYW4pO1xuICAgICAgICAgICAgICAgIChsYXllcnMgfHwgKGxheWVycyA9IFtpbm5lcl0pKS5wdXNoKHJlc29sdmVOb2RlKHJvb3QsIHBvcywgc2lkZSwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJzID8gaXRlclN0YWNrKGxheWVycykgOiBpbm5lcjtcbn1cbi8qKlxuQSB0cmVlIGN1cnNvciBvYmplY3QgZm9jdXNlcyBvbiBhIGdpdmVuIG5vZGUgaW4gYSBzeW50YXggdHJlZSwgYW5kXG5hbGxvd3MgeW91IHRvIG1vdmUgdG8gYWRqYWNlbnQgbm9kZXMuXG4qL1xuY2xhc3MgVHJlZUN1cnNvciB7XG4gICAgLyoqXG4gICAgU2hvcnRoYW5kIGZvciBgLnR5cGUubmFtZWAuXG4gICAgKi9cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1vZGUgPSAwKSB7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGUuY29udGV4dC5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSBub2RlLl9wYXJlbnQ7IG47IG4gPSBuLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay51bnNoaWZ0KG4uaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgeWllbGROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLl90cmVlID0gbm9kZTtcbiAgICAgICAgdGhpcy50eXBlID0gbm9kZS50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSBub2RlLmZyb207XG4gICAgICAgIHRoaXMudG8gPSBub2RlLnRvO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGRCdWYoaW5kZXgsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBsZXQgeyBzdGFydCwgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCBidWZmZXIuc2V0LnR5cGVzW2J1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICAgICAgdGhpcy5mcm9tID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMV07XG4gICAgICAgIHRoaXMudG8gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAyXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgeWllbGQobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCwgbm9kZS50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gdGhpcy5idWZmZXIuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpIDogdGhpcy5fdHJlZS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVudGVyQ2hpbGQoZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUubmV4dENoaWxkKGRpciA8IDAgPyB0aGlzLl90cmVlLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSwgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIHBvcyAtIHRoaXMuYnVmZmVyLnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuaW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBmaXJzdCBjaGlsZC4gV2hlbiB0aGlzIHJldHVybnNcbiAgICBmYWxzZSwgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBhbmQgdGhlIGN1cnNvciBoYXMgbm90IGJlZW4gbW92ZWQuXG4gICAgKi9cbiAgICBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgbGFzdCBjaGlsZC5cbiAgICAqL1xuICAgIGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgZmlyc3QgY2hpbGQgdGhhdCBlbmRzIGFmdGVyIGBwb3NgLlxuICAgICovXG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIDIgLyogU2lkZS5BZnRlciAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBsYXN0IGNoaWxkIHRoYXQgc3RhcnRzIGJlZm9yZSBgcG9zYC5cbiAgICAqL1xuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKC0xLCBwb3MsIC0yIC8qIFNpZGUuQmVmb3JlICovKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgY2hpbGQgYXJvdW5kIGBwb3NgLiBJZiBzaWRlIGlzIC0xIHRoZVxuICAgIGNoaWxkIG1heSBlbmQgYXQgdGhhdCBwb3NpdGlvbiwgd2hlbiAxIGl0IG1heSBzdGFydCB0aGVyZS4gVGhpc1xuICAgIHdpbGwgYWxzbyBlbnRlciBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSlcbiAgICBbbW91bnRlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0cmVlcyB1bmxlc3MgYG92ZXJsYXlzYCBpc1xuICAgIHNldCB0byBmYWxzZS5cbiAgICAqL1xuICAgIGVudGVyKHBvcywgc2lkZSwgbW9kZSA9IHRoaXMubW9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5lbnRlcihwb3MsIHNpZGUsIG1vZGUpKTtcbiAgICAgICAgcmV0dXJuIG1vZGUgJiBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycyA/IGZhbHNlIDogdGhpcy5lbnRlckNoaWxkKDEsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5vZGUncyBwYXJlbnQgbm9kZSwgaWYgdGhpcyBpc24ndCB0aGUgdG9wIG5vZGUuXG4gICAgKi9cbiAgICBwYXJlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpID8gdGhpcy5fdHJlZS5fcGFyZW50IDogdGhpcy5fdHJlZS5wYXJlbnQpO1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1Zih0aGlzLnN0YWNrLnBvcCgpKTtcbiAgICAgICAgbGV0IHBhcmVudCA9ICh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuYnVmZmVyLnBhcmVudCA6IHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUocGFyZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzaWJsaW5nKGRpcikge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl90cmVlLl9wYXJlbnQgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpcy55aWVsZCh0aGlzLl90cmVlLmluZGV4IDwgMCA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl90cmVlLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuX3RyZWUuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovLCB0aGlzLm1vZGUpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlciwgZCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGRpciA8IDApIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRTdGFydCA9IGQgPCAwID8gMCA6IHRoaXMuc3RhY2tbZF0gKyA0O1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggIT0gcGFyZW50U3RhcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPCAoZCA8IDAgPyBidWZmZXIuYnVmZmVyLmxlbmd0aCA6IGJ1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXSArIDNdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihhZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQgPCAwID8gdGhpcy55aWVsZCh0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dENoaWxkKHRoaXMuYnVmZmVyLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLywgdGhpcy5tb2RlKSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGlzIG5vZGUncyBuZXh0IHNpYmxpbmcsIGlmIGFueS5cbiAgICAqL1xuICAgIG5leHRTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKDEpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGlzIG5vZGUncyBwcmV2aW91cyBzaWJsaW5nLCBpZiBhbnkuXG4gICAgKi9cbiAgICBwcmV2U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygtMSk7IH1cbiAgICBhdExhc3ROb2RlKGRpcikge1xuICAgICAgICBsZXQgaW5kZXgsIHBhcmVudCwgeyBidWZmZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPCBidWZmZXIuYnVmZmVyLmJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmRleDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLmJ1ZmZlci5idWZmZXJbaSArIDNdIDwgdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh7IGluZGV4LCBwYXJlbnQgfSA9IGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSB0aGlzLl90cmVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgcGFyZW50OyB7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgZGlyLCBlID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Ll90cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQuX3RyZWUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWNoaWxkLnR5cGUuaXNBbm9ueW1vdXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkKGNoaWxkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG1vdmUoZGlyLCBlbnRlcikge1xuICAgICAgICBpZiAoZW50ZXIgJiYgdGhpcy5lbnRlckNoaWxkKGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWJsaW5nKGRpcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5hdExhc3ROb2RlKGRpcikgfHwgIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhXG4gICAgW3ByZS1vcmRlcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJlZV90cmF2ZXJzYWwjUHJlLW9yZGVyLF9OTFIpXG4gICAgdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIGN1cnJlbnQgbm9kZSBpcyBlbXB0eSBvciBgZW50ZXJgIGlzIGZhbHNlLCBpdHMgbmV4dCBzaWJsaW5nIG9yXG4gICAgdGhlIG5leHQgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50IG5vZGUgdGhhdCBoYXMgb25lLlxuICAgICovXG4gICAgbmV4dChlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgxLCBlbnRlcik7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYSBsYXN0LXRvLWZpcnN0IHByZS1vcmRlciB0cmF2ZXJzYWwuIEFcbiAgICBub2RlIGlzIGZvbGxvd2VkIGJ5IGl0cyBsYXN0IGNoaWxkIG9yLCBpZiBpdCBoYXMgbm9uZSwgaXRzXG4gICAgcHJldmlvdXMgc2libGluZyBvciB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50XG4gICAgbm9kZSB0aGF0IGhhcyBvbmUuXG4gICAgKi9cbiAgICBwcmV2KGVudGVyID0gdHJ1ZSkgeyByZXR1cm4gdGhpcy5tb3ZlKC0xLCBlbnRlcik7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGlubmVybW9zdCBub2RlIHRoYXQgY292ZXJzIGBwb3NgLiBJZlxuICAgIGBzaWRlYCBpcyAtMSwgaXQgd2lsbCBlbnRlciBub2RlcyB0aGF0IGVuZCBhdCBgcG9zYC4gSWYgaXQgaXMgMSxcbiAgICBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgc3RhcnQgYXQgYHBvc2AuXG4gICAgKi9cbiAgICBtb3ZlVG8ocG9zLCBzaWRlID0gMCkge1xuICAgICAgICAvLyBNb3ZlIHVwIHRvIGEgbm9kZSB0aGF0IGFjdHVhbGx5IGhvbGRzIHRoZSBwb3NpdGlvbiwgaWYgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZnJvbSA9PSB0aGlzLnRvIHx8XG4gICAgICAgICAgICAoc2lkZSA8IDEgPyB0aGlzLmZyb20gPj0gcG9zIDogdGhpcy5mcm9tID4gcG9zKSB8fFxuICAgICAgICAgICAgKHNpZGUgPiAtMSA/IHRoaXMudG8gPD0gcG9zIDogdGhpcy50byA8IHBvcykpXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRoZW4gc2NhbiBkb3duIGludG8gY2hpbGQgbm9kZXMgYXMgZmFyIGFzIHBvc3NpYmxlXG4gICAgICAgIHdoaWxlICh0aGlzLmVudGVyQ2hpbGQoMSwgcG9zLCBzaWRlKSkgeyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGN1cnNvcidzIGN1cnJlbnRcbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBub2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyZWU7XG4gICAgICAgIGxldCBjYWNoZSA9IHRoaXMuYnVmZmVyTm9kZSwgcmVzdWx0ID0gbnVsbCwgZGVwdGggPSAwO1xuICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUuY29udGV4dCA9PSB0aGlzLmJ1ZmZlcikge1xuICAgICAgICAgICAgc2NhbjogZm9yIChsZXQgaW5kZXggPSB0aGlzLmluZGV4LCBkID0gdGhpcy5zdGFjay5sZW5ndGg7IGQgPj0gMDspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0gY2FjaGU7IGM7IGMgPSBjLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXB0aCA9IGQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5zdGFja1stLWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSBkZXB0aDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQnVmZmVyTm9kZSh0aGlzLmJ1ZmZlciwgcmVzdWx0LCB0aGlzLnN0YWNrW2ldKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyTm9kZSA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIFt0cmVlXSgjY29tbW9uLlRyZWUpIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBub2RlLCBpZlxuICAgIGFueS4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIHRoZSBub2RlIGlzIGluIGEgW3RyZWVcbiAgICBidWZmZXJdKCNjb21tb24uVHJlZUJ1ZmZlcikuXG4gICAgKi9cbiAgICBnZXQgdHJlZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gbnVsbCA6IHRoaXMuX3RyZWUuX3RyZWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgY3VycmVudCBub2RlIGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzLCBjYWxsaW5nXG4gICAgYGVudGVyYCB3aGVuIGVudGVyaW5nIGEgbm9kZSBhbmQgYGxlYXZlYCwgaWYgZ2l2ZW4sIHdoZW4gbGVhdmluZ1xuICAgIG9uZS4gV2hlbiBgZW50ZXJgIHJldHVybnMgYGZhbHNlYCwgYW55IGNoaWxkcmVuIG9mIHRoYXQgbm9kZSBhcmVcbiAgICBza2lwcGVkLCBhbmQgYGxlYXZlYCBpc24ndCBjYWxsZWQgZm9yIGl0LlxuICAgICovXG4gICAgaXRlcmF0ZShlbnRlciwgbGVhdmUpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBtdXN0TGVhdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuaXNBbm9ueW1vdXMgfHwgZW50ZXIodGhpcykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICAgICAgbXVzdExlYXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAobXVzdExlYXZlICYmIGxlYXZlKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0aGlzLnR5cGUuaXNBbm9ueW1vdXM7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgY3VycmVudCBub2RlIG1hdGNoZXMgYSBnaXZlbiBjb250ZXh04oCUYSBzZXF1ZW5jZVxuICAgIG9mIGRpcmVjdCBwYXJlbnQgbm9kZSBuYW1lcy4gRW1wdHkgc3RyaW5ncyBpbiB0aGUgY29udGV4dCBhcnJheVxuICAgIGFyZSB0cmVhdGVkIGFzIHdpbGRjYXJkcy5cbiAgICAqL1xuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLm5vZGUucGFyZW50LCBjb250ZXh0KTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlciwgeyB0eXBlcyB9ID0gYnVmZmVyLnNldDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSwgZCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGlmIChkIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hOb2RlQ29udGV4dCh0aGlzLl90cmVlLCBjb250ZXh0LCBpKTtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdHlwZXNbYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdXV07XG4gICAgICAgICAgICBpZiAoIXR5cGUuaXNBbm9ueW1vdXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dFtpXSAmJiBjb250ZXh0W2ldICE9IHR5cGUubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDaGlsZCh0cmVlKSB7XG4gICAgcmV0dXJuIHRyZWUuY2hpbGRyZW4uc29tZShjaCA9PiBjaCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgIWNoLnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQoY2gpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVHJlZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IGJ1ZmZlciwgbm9kZVNldCwgbWF4QnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aCwgcmV1c2VkID0gW10sIG1pblJlcGVhdFR5cGUgPSBub2RlU2V0LnR5cGVzLmxlbmd0aCB9ID0gZGF0YTtcbiAgICBsZXQgY3Vyc29yID0gQXJyYXkuaXNBcnJheShidWZmZXIpID8gbmV3IEZsYXRCdWZmZXJDdXJzb3IoYnVmZmVyLCBidWZmZXIubGVuZ3RoKSA6IGJ1ZmZlcjtcbiAgICBsZXQgdHlwZXMgPSBub2RlU2V0LnR5cGVzO1xuICAgIGxldCBjb250ZXh0SGFzaCA9IDAsIGxvb2tBaGVhZCA9IDA7XG4gICAgZnVuY3Rpb24gdGFrZU5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5SZXBlYXQsIGRlcHRoKSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGxldCBsb29rQWhlYWRBdFN0YXJ0ID0gbG9va0FoZWFkLCBjb250ZXh0QXRTdGFydCA9IGNvbnRleHRIYXNoO1xuICAgICAgICB3aGlsZSAoc2l6ZSA8IDApIHtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PSAtMSAvKiBTcGVjaWFsUmVjb3JkLlJldXNlICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSByZXVzZWRbaWRdO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pIHsgLy8gQ29udGV4dCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5yZWNvZ25pemVkIHJlY29yZCBzaXplOiAke3NpemV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpZF0sIG5vZGUsIGJ1ZmZlcjtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgaWYgKGVuZCAtIHN0YXJ0IDw9IG1heEJ1ZmZlckxlbmd0aCAmJiAoYnVmZmVyID0gZmluZEJ1ZmZlclNpemUoY3Vyc29yLnBvcyAtIG1pblBvcywgaW5SZXBlYXQpKSkge1xuICAgICAgICAgICAgLy8gU21hbGwgZW5vdWdoIGZvciBhIGJ1ZmZlciwgYW5kIG5vIHJldXNlZCBub2RlcyBpbnNpZGVcbiAgICAgICAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlci5zaXplIC0gYnVmZmVyLnNraXApO1xuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBidWZmZXIuc2l6ZSwgaW5kZXggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlci5zdGFydCwgZGF0YSwgaW5kZXgpO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBUcmVlQnVmZmVyKGRhdGEsIGVuZCAtIGJ1ZmZlci5zdGFydCwgbm9kZVNldCk7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJ1ZmZlci5zdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNYWtlIGl0IGEgbm9kZVxuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBzaXplO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgICAgICBsZXQgbG9jYWxJblJlcGVhdCA9IGlkID49IG1pblJlcGVhdFR5cGUgPyBpZCA6IC0xO1xuICAgICAgICAgICAgbGV0IGxhc3RHcm91cCA9IDAsIGxhc3RFbmQgPSBlbmQ7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgY3Vyc29yLmlkID09IGxvY2FsSW5SZXBlYXQgJiYgY3Vyc29yLnNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmVuZCA8PSBsYXN0RW5kIC0gbWF4QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgY3Vyc29yLmVuZCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCwgY29udGV4dEF0U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdyb3VwID0gbG9jYWxDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RW5kID0gY3Vyc29yLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkZXB0aCA+IDI1MDAgLyogQ3V0T2ZmLkRlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHRha2VGbGF0Tm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YWtlTm9kZShzdGFydCwgZW5kUG9zLCBsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgbG9jYWxJblJlcGVhdCwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+PSAwICYmIGxhc3RHcm91cCA+IDAgJiYgbGFzdEdyb3VwIDwgbG9jYWxDaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbWFrZVJlcGVhdExlYWYobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHN0YXJ0LCBsYXN0R3JvdXAsIHN0YXJ0LCBsYXN0RW5kLCBsb2NhbEluUmVwZWF0LCBsb29rQWhlYWRBdFN0YXJ0LCBjb250ZXh0QXRTdGFydCk7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnJldmVyc2UoKTtcbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID4gLTEgJiYgbGFzdEdyb3VwID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBtYWtlID0gbWFrZUJhbGFuY2VkKHR5cGUsIGNvbnRleHRBdFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBub2RlID0gYmFsYW5jZVJhbmdlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCAwLCBsb2NhbENoaWxkcmVuLmxlbmd0aCwgMCwgZW5kIC0gc3RhcnQsIG1ha2UsIG1ha2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG1ha2VUcmVlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBlbmQgLSBzdGFydCwgbG9va0FoZWFkQXRTdGFydCAtIGVuZCwgY29udGV4dEF0U3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0UG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGFrZUZsYXROb2RlKHBhcmVudFN0YXJ0LCBtaW5Qb3MsIGNoaWxkcmVuLCBwb3NpdGlvbnMpIHtcbiAgICAgICAgbGV0IG5vZGVzID0gW107IC8vIFRlbXBvcmFyeSwgaW52ZXJ0ZWQgYXJyYXkgb2YgbGVhZiBub2RlcyBmb3VuZCwgd2l0aCBhYnNvbHV0ZSBwb3NpdGlvbnNcbiAgICAgICAgbGV0IG5vZGVDb3VudCA9IDAsIHN0b3BBdCA9IC0xO1xuICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IG1pblBvcykge1xuICAgICAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgICAgIGlmIChzaXplID4gNCkgeyAvLyBOb3QgYSBsZWFmXG4gICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0b3BBdCA+IC0xICYmIHN0YXJ0IDwgc3RvcEF0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcEF0IDwgMClcbiAgICAgICAgICAgICAgICAgICAgc3RvcEF0ID0gZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goaWQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIG5vZGVDb3VudCsrO1xuICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVDb3VudCkge1xuICAgICAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50MTZBcnJheShub2RlQ291bnQgKiA0KTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmxlbmd0aCAtIDMsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBub2Rlc1tpICsgMV0gLSBzdGFydDtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IG5vZGVzW2kgKyAyXSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IFRyZWVCdWZmZXIoYnVmZmVyLCBub2Rlc1syXSAtIHN0YXJ0LCBub2RlU2V0KSk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaChzdGFydCAtIHBhcmVudFN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlQmFsYW5jZWQodHlwZSwgY29udGV4dEhhc2gpIHtcbiAgICAgICAgcmV0dXJuIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSAwLCBsYXN0SSA9IGNoaWxkcmVuLmxlbmd0aCAtIDEsIGxhc3QsIGxvb2tBaGVhZFByb3A7XG4gICAgICAgICAgICBpZiAobGFzdEkgPj0gMCAmJiAobGFzdCA9IGNoaWxkcmVuW2xhc3RJXSkgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0SSAmJiBsYXN0LnR5cGUgPT0gdHlwZSAmJiBsYXN0Lmxlbmd0aCA9PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgICAgICAgICAgIGlmIChsb29rQWhlYWRQcm9wID0gbGFzdC5wcm9wKE5vZGVQcm9wLmxvb2tBaGVhZCkpXG4gICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZCA9IHBvc2l0aW9uc1tsYXN0SV0gKyBsYXN0Lmxlbmd0aCArIGxvb2tBaGVhZFByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZVRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBsb29rQWhlYWQsIGNvbnRleHRIYXNoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVJlcGVhdExlYWYoY2hpbGRyZW4sIHBvc2l0aW9ucywgYmFzZSwgaSwgZnJvbSwgdG8sIHR5cGUsIGxvb2tBaGVhZCwgY29udGV4dEhhc2gpIHtcbiAgICAgICAgbGV0IGxvY2FsQ2hpbGRyZW4gPSBbXSwgbG9jYWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCA+IGkpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbi5wb3AoKSk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9ucy5wb3AoKSArIGJhc2UgLSBmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5wdXNoKG1ha2VUcmVlKG5vZGVTZXQudHlwZXNbdHlwZV0sIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCB0byAtIGZyb20sIGxvb2tBaGVhZCAtIHRvLCBjb250ZXh0SGFzaCkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gYmFzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkLCBjb250ZXh0SGFzaCwgcHJvcHMpIHtcbiAgICAgICAgaWYgKGNvbnRleHRIYXNoKSB7XG4gICAgICAgICAgICBsZXQgcGFpciA9IFtOb2RlUHJvcC5jb250ZXh0SGFzaCwgY29udGV4dEhhc2hdO1xuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb29rQWhlYWQgPiAyNSkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AubG9va0FoZWFkLCBsb29rQWhlYWRdO1xuICAgICAgICAgICAgcHJvcHMgPSBwcm9wcyA/IFtwYWlyXS5jb25jYXQocHJvcHMpIDogW3BhaXJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIHByb3BzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEJ1ZmZlclNpemUobWF4U2l6ZSwgaW5SZXBlYXQpIHtcbiAgICAgICAgLy8gU2NhbiB0aHJvdWdoIHRoZSBidWZmZXIgdG8gZmluZCBwcmV2aW91cyBzaWJsaW5ncyB0aGF0IGZpdFxuICAgICAgICAvLyB0b2dldGhlciBpbiBhIFRyZWVCdWZmZXIsIGFuZCBkb24ndCBjb250YWluIGFueSByZXVzZWQgbm9kZXNcbiAgICAgICAgLy8gKHdoaWNoIGNhbid0IGJlIHN0b3JlZCBpbiBhIGJ1ZmZlcikuXG4gICAgICAgIC8vIElmIGBpblJlcGVhdGAgaXMgPiAtMSwgaWdub3JlIG5vZGUgYm91bmRhcmllcyBvZiB0aGF0IHR5cGUgZm9yXG4gICAgICAgIC8vIG5lc3RpbmcsIGJ1dCBtYWtlIHN1cmUgdGhlIGVuZCBmYWxscyBlaXRoZXIgYXQgdGhlIHN0YXJ0XG4gICAgICAgIC8vIChgbWF4U2l6ZWApIG9yIGJlZm9yZSBzdWNoIGEgbm9kZS5cbiAgICAgICAgbGV0IGZvcmsgPSBjdXJzb3IuZm9yaygpO1xuICAgICAgICBsZXQgc2l6ZSA9IDAsIHN0YXJ0ID0gMCwgc2tpcCA9IDAsIG1pblN0YXJ0ID0gZm9yay5lbmQgLSBtYXhCdWZmZXJMZW5ndGg7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHNpemU6IDAsIHN0YXJ0OiAwLCBza2lwOiAwIH07XG4gICAgICAgIHNjYW46IGZvciAobGV0IG1pblBvcyA9IGZvcmsucG9zIC0gbWF4U2l6ZTsgZm9yay5wb3MgPiBtaW5Qb3M7KSB7XG4gICAgICAgICAgICBsZXQgbm9kZVNpemUgPSBmb3JrLnNpemU7XG4gICAgICAgICAgICAvLyBQcmV0ZW5kIG5lc3RlZCByZXBlYXQgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZSBkb24ndCBleGlzdFxuICAgICAgICAgICAgaWYgKGZvcmsuaWQgPT0gaW5SZXBlYXQgJiYgbm9kZVNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdCB0aGF0IHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIGFzIGEgdmFsaWQgcmV0dXJuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgICAgICAgICBza2lwICs9IDQ7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSA0O1xuICAgICAgICAgICAgICAgIGZvcmsubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0UG9zID0gZm9yay5wb3MgLSBub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChub2RlU2l6ZSA8IDAgfHwgc3RhcnRQb3MgPCBtaW5Qb3MgfHwgZm9yay5zdGFydCA8IG1pblN0YXJ0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IGxvY2FsU2tpcHBlZCA9IGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSA/IDQgOiAwO1xuICAgICAgICAgICAgbGV0IG5vZGVTdGFydCA9IGZvcmsuc3RhcnQ7XG4gICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlIChmb3JrLnBvcyA+IHN0YXJ0UG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmsuc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9yay5pZCA+PSBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2tpcHBlZCArPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gbm9kZVN0YXJ0O1xuICAgICAgICAgICAgc2l6ZSArPSBub2RlU2l6ZTtcbiAgICAgICAgICAgIHNraXAgKz0gbG9jYWxTa2lwcGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpblJlcGVhdCA8IDAgfHwgc2l6ZSA9PSBtYXhTaXplKSB7XG4gICAgICAgICAgICByZXN1bHQuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHJlc3VsdC5za2lwID0gc2tpcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnNpemUgPiA0ID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3B5VG9CdWZmZXIoYnVmZmVyU3RhcnQsIGJ1ZmZlciwgaW5kZXgpIHtcbiAgICAgICAgbGV0IHsgaWQsIHN0YXJ0LCBlbmQsIHNpemUgfSA9IGN1cnNvcjtcbiAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgaWYgKHNpemUgPj0gMCAmJiBpZCA8IG1pblJlcGVhdFR5cGUpIHtcbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBpZiAoc2l6ZSA+IDQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kUG9zID0gY3Vyc29yLnBvcyAtIChzaXplIC0gNCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5wb3MgPiBlbmRQb3MpXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0SW5kZXg7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBlbmQgLSBidWZmZXJTdGFydDtcbiAgICAgICAgICAgIGJ1ZmZlclstLWluZGV4XSA9IHN0YXJ0IC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplID09IC0zIC8qIFNwZWNpYWxSZWNvcmQuQ29udGV4dENoYW5nZSAqLykge1xuICAgICAgICAgICAgY29udGV4dEhhc2ggPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaXplID09IC00IC8qIFNwZWNpYWxSZWNvcmQuTG9va0FoZWFkICovKSB7XG4gICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGxldCBjaGlsZHJlbiA9IFtdLCBwb3NpdGlvbnMgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IDApXG4gICAgICAgIHRha2VOb2RlKGRhdGEuc3RhcnQgfHwgMCwgZGF0YS5idWZmZXJTdGFydCB8fCAwLCBjaGlsZHJlbiwgcG9zaXRpb25zLCAtMSwgMCk7XG4gICAgbGV0IGxlbmd0aCA9IChfYSA9IGRhdGEubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoY2hpbGRyZW4ubGVuZ3RoID8gcG9zaXRpb25zWzBdICsgY2hpbGRyZW5bMF0ubGVuZ3RoIDogMCk7XG4gICAgcmV0dXJuIG5ldyBUcmVlKHR5cGVzW2RhdGEudG9wSURdLCBjaGlsZHJlbi5yZXZlcnNlKCksIHBvc2l0aW9ucy5yZXZlcnNlKCksIGxlbmd0aCk7XG59XG5jb25zdCBub2RlU2l6ZUNhY2hlID0gbmV3IFdlYWtNYXA7XG5mdW5jdGlvbiBub2RlU2l6ZShiYWxhbmNlVHlwZSwgbm9kZSkge1xuICAgIGlmICghYmFsYW5jZVR5cGUuaXNBbm9ueW1vdXMgfHwgbm9kZSBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgbm9kZS50eXBlICE9IGJhbGFuY2VUeXBlKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBsZXQgc2l6ZSA9IG5vZGVTaXplQ2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChzaXplID09IG51bGwpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9IGJhbGFuY2VUeXBlIHx8ICEoY2hpbGQgaW5zdGFuY2VvZiBUcmVlKSkge1xuICAgICAgICAgICAgICAgIHNpemUgPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZSArPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVTaXplQ2FjaGUuc2V0KG5vZGUsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbmZ1bmN0aW9uIGJhbGFuY2VSYW5nZShcbi8vIFRoZSB0eXBlIHRoZSBiYWxhbmNlZCB0cmVlJ3MgaW5uZXIgbm9kZXMuXG5iYWxhbmNlVHlwZSwgXG4vLyBUaGUgZGlyZWN0IGNoaWxkcmVuIGFuZCB0aGVpciBwb3NpdGlvbnNcbmNoaWxkcmVuLCBwb3NpdGlvbnMsIFxuLy8gVGhlIGluZGV4IHJhbmdlIGluIGNoaWxkcmVuL3Bvc2l0aW9ucyB0byB1c2VcbmZyb20sIHRvLCBcbi8vIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgbm9kZXMsIHJlbGF0aXZlIHRvIHRoZWlyIHBhcmVudC5cbnN0YXJ0LCBcbi8vIExlbmd0aCBvZiB0aGUgb3V0ZXIgbm9kZVxubGVuZ3RoLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIHRoZSB0b3Agbm9kZSBvZiB0aGUgYmFsYW5jZWQgdHJlZVxubWtUb3AsIFxuLy8gRnVuY3Rpb24gdG8gYnVpbGQgaW50ZXJuYWwgbm9kZXMgZm9yIHRoZSBiYWxhbmNlZCB0cmVlXG5ta1RyZWUpIHtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKylcbiAgICAgICAgdG90YWwgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICBsZXQgbWF4Q2hpbGQgPSBNYXRoLmNlaWwoKHRvdGFsICogMS41KSAvIDggLyogQmFsYW5jZS5CcmFuY2hGYWN0b3IgKi8pO1xuICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgZnVuY3Rpb24gZGl2aWRlKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGZyb20sIHRvLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCBncm91cEZyb20gPSBpLCBncm91cFN0YXJ0ID0gcG9zaXRpb25zW2ldLCBncm91cFNpemUgPSBub2RlU2l6ZShiYWxhbmNlVHlwZSwgY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgZm9yICg7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTaXplICsgbmV4dFNpemUgPj0gbWF4Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGdyb3VwU2l6ZSArPSBuZXh0U2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09IGdyb3VwRnJvbSArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBTaXplID4gbWF4Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9ubHkgPSBjaGlsZHJlbltncm91cEZyb21dOyAvLyBPbmx5IHRyZWVzIGNhbiBoYXZlIGEgc2l6ZSA+IDFcbiAgICAgICAgICAgICAgICAgICAgZGl2aWRlKG9ubHkuY2hpbGRyZW4sIG9ubHkucG9zaXRpb25zLCAwLCBvbmx5LmNoaWxkcmVuLmxlbmd0aCwgcG9zaXRpb25zW2dyb3VwRnJvbV0gKyBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuW2dyb3VwRnJvbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IHBvc2l0aW9uc1tpIC0gMV0gKyBjaGlsZHJlbltpIC0gMV0ubGVuZ3RoIC0gZ3JvdXBTdGFydDtcbiAgICAgICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goYmFsYW5jZVJhbmdlKGJhbGFuY2VUeXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBncm91cEZyb20sIGksIGdyb3VwU3RhcnQsIGxlbmd0aCwgbnVsbCwgbWtUcmVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5wdXNoKGdyb3VwU3RhcnQgKyBvZmZzZXQgLSBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGl2aWRlKGNoaWxkcmVuLCBwb3NpdGlvbnMsIGZyb20sIHRvLCAwKTtcbiAgICByZXR1cm4gKG1rVG9wIHx8IG1rVHJlZSkobG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIGxlbmd0aCk7XG59XG4vKipcblByb3ZpZGVzIGEgd2F5IHRvIGFzc29jaWF0ZSB2YWx1ZXMgd2l0aCBwaWVjZXMgb2YgdHJlZXMuIEFzIGxvbmdcbmFzIHRoYXQgcGFydCBvZiB0aGUgdHJlZSBpcyByZXVzZWQsIHRoZSBhc3NvY2lhdGVkIHZhbHVlcyBjYW4gYmVcbnJldHJpZXZlZCBmcm9tIGFuIHVwZGF0ZWQgdHJlZS5cbiovXG5jbGFzcyBOb2RlV2Vha01hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgc2V0QnVmZmVyKGJ1ZmZlciwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMubWFwLmdldChidWZmZXIpO1xuICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGJ1ZmZlciwgaW5uZXIgPSBuZXcgTWFwKTtcbiAgICAgICAgaW5uZXIuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldEJ1ZmZlcihidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMubWFwLmdldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gaW5uZXIgJiYgaW5uZXIuZ2V0KGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZS5cbiAgICAqL1xuICAgIHNldChub2RlLCB2YWx1ZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEJ1ZmZlck5vZGUpXG4gICAgICAgICAgICB0aGlzLnNldEJ1ZmZlcihub2RlLmNvbnRleHQuYnVmZmVyLCBub2RlLmluZGV4LCB2YWx1ZSk7XG4gICAgICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSlcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChub2RlLnRyZWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgdmFsdWUgZm9yIHRoaXMgc3ludGF4IG5vZGUsIGlmIGl0IGV4aXN0cyBpbiB0aGUgbWFwLlxuICAgICovXG4gICAgZ2V0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBCdWZmZXJOb2RlID8gdGhpcy5nZXRCdWZmZXIobm9kZS5jb250ZXh0LmJ1ZmZlciwgbm9kZS5pbmRleClcbiAgICAgICAgICAgIDogbm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlID8gdGhpcy5tYXAuZ2V0KG5vZGUudHJlZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50cyB0by5cbiAgICAqL1xuICAgIGN1cnNvclNldChjdXJzb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChjdXJzb3IuYnVmZmVyKVxuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXIoY3Vyc29yLmJ1ZmZlci5idWZmZXIsIGN1cnNvci5pbmRleCwgdmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoY3Vyc29yLnRyZWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgdGhlIHZhbHVlIGZvciB0aGUgbm9kZSB0aGF0IGEgY3Vyc29yIGN1cnJlbnRseSBwb2ludHNcbiAgICB0by5cbiAgICAqL1xuICAgIGN1cnNvckdldChjdXJzb3IpIHtcbiAgICAgICAgcmV0dXJuIGN1cnNvci5idWZmZXIgPyB0aGlzLmdldEJ1ZmZlcihjdXJzb3IuYnVmZmVyLmJ1ZmZlciwgY3Vyc29yLmluZGV4KSA6IHRoaXMubWFwLmdldChjdXJzb3IudHJlZSk7XG4gICAgfVxufVxuXG4vKipcblRyZWUgZnJhZ21lbnRzIGFyZSB1c2VkIGR1cmluZyBbaW5jcmVtZW50YWxcbnBhcnNpbmddKCNjb21tb24uUGFyc2VyLnN0YXJ0UGFyc2UpIHRvIHRyYWNrIHBhcnRzIG9mIG9sZCB0cmVlc1xudGhhdCBjYW4gYmUgcmV1c2VkIGluIGEgbmV3IHBhcnNlLiBBbiBhcnJheSBvZiBmcmFnbWVudHMgaXMgdXNlZFxudG8gdHJhY2sgcmVnaW9ucyBvZiBhbiBvbGQgdHJlZSB3aG9zZSBub2RlcyBtaWdodCBiZSByZXVzZWQgaW4gbmV3XG5wYXJzZXMuIFVzZSB0aGUgc3RhdGljXG5bYGFwcGx5Q2hhbmdlc2BdKCNjb21tb24uVHJlZUZyYWdtZW50XmFwcGx5Q2hhbmdlcykgbWV0aG9kIHRvXG51cGRhdGUgZnJhZ21lbnRzIGZvciBkb2N1bWVudCBjaGFuZ2VzLlxuKi9cbmNsYXNzIFRyZWVGcmFnbWVudCB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgdHJlZSBmcmFnbWVudC4gWW91J2xsIHVzdWFsbHkgd2FudCB0byB1c2VcbiAgICBbYGFkZFRyZWVgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hZGRUcmVlKSBhbmRcbiAgICBbYGFwcGx5Q2hhbmdlc2BdKCNjb21tb24uVHJlZUZyYWdtZW50XmFwcGx5Q2hhbmdlcykgaW5zdGVhZCBvZlxuICAgIGNhbGxpbmcgdGhpcyBkaXJlY3RseS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgdW5jaGFuZ2VkIHJhbmdlIHBvaW50ZWQgdG8gYnkgdGhpcyBmcmFnbWVudC5cbiAgICBUaGlzIHJlZmVycyB0byBhbiBvZmZzZXQgaW4gdGhlIF91cGRhdGVkXyBkb2N1bWVudCAoYXMgb3Bwb3NlZFxuICAgIHRvIHRoZSBvcmlnaW5hbCB0cmVlKS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgdHJlZSB0aGF0IHRoaXMgZnJhZ21lbnQgaXMgYmFzZWQgb24uXG4gICAgKi9cbiAgICB0cmVlLCBcbiAgICAvKipcbiAgICBUaGUgb2Zmc2V0IGJldHdlZW4gdGhlIGZyYWdtZW50J3MgdHJlZSBhbmQgdGhlIGRvY3VtZW50IHRoYXRcbiAgICB0aGlzIGZyYWdtZW50IGNhbiBiZSB1c2VkIGFnYWluc3QuIEFkZCB0aGlzIHdoZW4gZ29pbmcgZnJvbVxuICAgIGRvY3VtZW50IHRvIHRyZWUgcG9zaXRpb25zLCBzdWJ0cmFjdCBpdCB0byBnbyBmcm9tIHRyZWUgdG9cbiAgICBkb2N1bWVudCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBvZmZzZXQsIG9wZW5TdGFydCA9IGZhbHNlLCBvcGVuRW5kID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5vcGVuID0gKG9wZW5TdGFydCA/IDEgLyogT3Blbi5TdGFydCAqLyA6IDApIHwgKG9wZW5FbmQgPyAyIC8qIE9wZW4uRW5kICovIDogMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiBhXG4gICAgcGFyc2UsIG9yIHRoZSBlbmQgb2YgYSBjaGFuZ2UuIChJbiB0aGUgc2Vjb25kIGNhc2UsIGl0IG1heSBub3RcbiAgICBiZSBzYWZlIHRvIHJldXNlIHNvbWUgbm9kZXMgYXQgdGhlIHN0YXJ0LCBkZXBlbmRpbmcgb24gdGhlXG4gICAgcGFyc2luZyBhbGdvcml0aG0uKVxuICAgICovXG4gICAgZ2V0IG9wZW5TdGFydCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAxIC8qIE9wZW4uU3RhcnQgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIGVuZCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIGFcbiAgICBmdWxsLWRvY3VtZW50IHBhcnNlLCBvciB0aGUgc3RhcnQgb2YgYSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgb3BlbkVuZCgpIHsgcmV0dXJuICh0aGlzLm9wZW4gJiAyIC8qIE9wZW4uRW5kICovKSA+IDA7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgZnJhZ21lbnRzIGZyb20gYSBmcmVzaGx5IHBhcnNlZCB0cmVlLCBvciB1cGRhdGVcbiAgICBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcbiAgICB3aXRoIGEgdHJlZSB3aXRoIGNvbnRlbnQgZnJvbSB0aGUgbmV3IHRyZWUuIFdoZW4gYHBhcnRpYWxgIGlzXG4gICAgdHJ1ZSwgdGhlIHBhcnNlIGlzIHRyZWF0ZWQgYXMgaW5jb21wbGV0ZSwgYW5kIHRoZSByZXN1bHRpbmdcbiAgICBmcmFnbWVudCBoYXMgW2BvcGVuRW5kYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQub3BlbkVuZCkgc2V0IHRvXG4gICAgdHJ1ZS5cbiAgICAqL1xuICAgIHN0YXRpYyBhZGRUcmVlKHRyZWUsIGZyYWdtZW50cyA9IFtdLCBwYXJ0aWFsID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtuZXcgVHJlZUZyYWdtZW50KDAsIHRyZWUubGVuZ3RoLCB0cmVlLCAwLCBmYWxzZSwgcGFydGlhbCldO1xuICAgICAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cylcbiAgICAgICAgICAgIGlmIChmLnRvID4gdHJlZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgICBzcGxpdHRpbmcgZnJhZ21lbnRzIGFzIG5lY2Vzc2FyeSB0byByZW1vdmUgZWRpdGVkIHJhbmdlcywgYW5kXG4gICAgYWRqdXN0aW5nIG9mZnNldHMgZm9yIGZyYWdtZW50cyB0aGF0IG1vdmVkLlxuICAgICovXG4gICAgc3RhdGljIGFwcGx5Q2hhbmdlcyhmcmFnbWVudHMsIGNoYW5nZXMsIG1pbkdhcCA9IDEyOCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZkkgPSAxLCBuZXh0RiA9IGZyYWdtZW50cy5sZW5ndGggPyBmcmFnbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBjSSA9IDAsIHBvcyA9IDAsIG9mZiA9IDA7OyBjSSsrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dEMgPSBjSSA8IGNoYW5nZXMubGVuZ3RoID8gY2hhbmdlc1tjSV0gOiBudWxsO1xuICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0QyA/IG5leHRDLmZyb21BIDogMWU5O1xuICAgICAgICAgICAgaWYgKG5leHRQb3MgLSBwb3MgPj0gbWluR2FwKVxuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0RiAmJiBuZXh0Ri5mcm9tIDwgbmV4dFBvcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3V0ID0gbmV4dEY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gY3V0LmZyb20gfHwgbmV4dFBvcyA8PSBjdXQudG8gfHwgb2ZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZkZyb20gPSBNYXRoLm1heChjdXQuZnJvbSwgcG9zKSAtIG9mZiwgZlRvID0gTWF0aC5taW4oY3V0LnRvLCBuZXh0UG9zKSAtIG9mZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1dCA9IGZGcm9tID49IGZUbyA/IG51bGwgOiBuZXcgVHJlZUZyYWdtZW50KGZGcm9tLCBmVG8sIGN1dC50cmVlLCBjdXQub2Zmc2V0ICsgb2ZmLCBjSSA+IDAsICEhbmV4dEMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dEYudG8gPiBuZXh0UG9zKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGID0gZkkgPCBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzW2ZJKytdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHRDKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gbmV4dEMudG9BO1xuICAgICAgICAgICAgb2ZmID0gbmV4dEMudG9BIC0gbmV4dEMudG9CO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5BIHN1cGVyY2xhc3MgdGhhdCBwYXJzZXJzIHNob3VsZCBleHRlbmQuXG4qL1xuY2xhc3MgUGFyc2VyIHtcbiAgICAvKipcbiAgICBTdGFydCBhIHBhcnNlLCByZXR1cm5pbmcgYSBbcGFydGlhbCBwYXJzZV0oI2NvbW1vbi5QYXJ0aWFsUGFyc2UpXG4gICAgb2JqZWN0LiBbYGZyYWdtZW50c2BdKCNjb21tb24uVHJlZUZyYWdtZW50KSBjYW4gYmUgcGFzc2VkIGluIHRvXG4gICAgbWFrZSB0aGUgcGFyc2UgaW5jcmVtZW50YWwuXG4gICAgXG4gICAgQnkgZGVmYXVsdCwgdGhlIGVudGlyZSBpbnB1dCBpcyBwYXJzZWQuIFlvdSBjYW4gcGFzcyBgcmFuZ2VzYCxcbiAgICB3aGljaCBzaG91bGQgYmUgYSBzb3J0ZWQgYXJyYXkgb2Ygbm9uLWVtcHR5LCBub24tb3ZlcmxhcHBpbmdcbiAgICByYW5nZXMsIHRvIHBhcnNlIG9ubHkgdGhvc2UgcmFuZ2VzLiBUaGUgdHJlZSByZXR1cm5lZCBpbiB0aGF0XG4gICAgY2FzZSB3aWxsIHN0YXJ0IGF0IGByYW5nZXNbMF0uZnJvbWAuXG4gICAgKi9cbiAgICBzdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBpbnB1dCA9IG5ldyBTdHJpbmdJbnB1dChpbnB1dCk7XG4gICAgICAgIHJhbmdlcyA9ICFyYW5nZXMgPyBbbmV3IFJhbmdlKDAsIGlucHV0Lmxlbmd0aCldIDogcmFuZ2VzLmxlbmd0aCA/IHJhbmdlcy5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tLCByLnRvKSkgOiBbbmV3IFJhbmdlKDAsIDApXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cyB8fCBbXSwgcmFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUnVuIGEgZnVsbCBwYXJzZSwgcmV0dXJuaW5nIHRoZSByZXN1bHRpbmcgdHJlZS5cbiAgICAqL1xuICAgIHBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICBsZXQgcGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBwYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFN0cmluZ0lucHV0IHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICBjaHVuayhmcm9tKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tKTsgfVxuICAgIGdldCBsaW5lQ2h1bmtzKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICByZWFkKGZyb20sIHRvKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tLCB0byk7IH1cbn1cblxuLyoqXG5DcmVhdGUgYSBwYXJzZSB3cmFwcGVyIHRoYXQsIGFmdGVyIHRoZSBpbm5lciBwYXJzZSBjb21wbGV0ZXMsXG5zY2FucyBpdHMgdHJlZSBmb3IgbWl4ZWQgbGFuZ3VhZ2UgcmVnaW9ucyB3aXRoIHRoZSBgbmVzdGBcbmZ1bmN0aW9uLCBydW5zIHRoZSByZXN1bHRpbmcgW2lubmVyIHBhcnNlc10oI2NvbW1vbi5OZXN0ZWRQYXJzZSksXG5hbmQgdGhlbiBbbW91bnRzXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRoZWlyIHJlc3VsdHMgb250byB0aGVcbnRyZWUuXG4qL1xuZnVuY3Rpb24gcGFyc2VNaXhlZChuZXN0KSB7XG4gICAgcmV0dXJuIChwYXJzZSwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSA9PiBuZXcgTWl4ZWRQYXJzZShwYXJzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKTtcbn1cbmNsYXNzIElubmVyUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgcGFyc2UsIG92ZXJsYXksIHRhcmdldCwgZnJvbSkge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHBhcnNlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1JhbmdlcyhyYW5nZXMpIHtcbiAgICBpZiAoIXJhbmdlcy5sZW5ndGggfHwgcmFuZ2VzLnNvbWUociA9PiByLmZyb20gPj0gci50bykpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbm5lciBwYXJzZSByYW5nZXMgZ2l2ZW46IFwiICsgSlNPTi5zdHJpbmdpZnkocmFuZ2VzKSk7XG59XG5jbGFzcyBBY3RpdmVPdmVybGF5IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHByZWRpY2F0ZSwgbW91bnRzLCBpbmRleCwgc3RhcnQsIHRhcmdldCwgcHJldikge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMubW91bnRzID0gbW91bnRzO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgIH1cbn1cbmNvbnN0IHN0b3BwZWRJbm5lciA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG5jbGFzcyBNaXhlZFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBuZXN0LCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5uZXN0ID0gbmVzdDtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBbXTtcbiAgICAgICAgdGhpcy5pbm5lckRvbmUgPSAwO1xuICAgICAgICB0aGlzLmJhc2VUcmVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmJhc2VQYXJzZSA9IGJhc2U7XG4gICAgfVxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSkge1xuICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmJhc2VQYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB0aGlzLmJhc2VQYXJzZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmJhc2VUcmVlID0gZG9uZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRJbm5lcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5uZXIgb2YgdGhpcy5pbm5lcilcbiAgICAgICAgICAgICAgICAgICAgaW5uZXIucGFyc2Uuc3RvcEF0KHRoaXMuc3RvcHBlZEF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbm5lckRvbmUgPT0gdGhpcy5pbm5lci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmJhc2VUcmVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRyZWUocmVzdWx0LnR5cGUsIHJlc3VsdC5jaGlsZHJlbiwgcmVzdWx0LnBvc2l0aW9ucywgcmVzdWx0Lmxlbmd0aCwgcmVzdWx0LnByb3BWYWx1ZXMuY29uY2F0KFtbc3RvcHBlZElubmVyLCB0aGlzLnN0b3BwZWRBdF1dKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbm5lciA9IHRoaXMuaW5uZXJbdGhpcy5pbm5lckRvbmVdLCBkb25lID0gaW5uZXIucGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgdGhpcy5pbm5lckRvbmUrKztcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzb21ld2hhdCBkb2RneSBidXQgc3VwZXIgaGVscGZ1bCBoYWNrIHdoZXJlIHdlXG4gICAgICAgICAgICAvLyBwYXRjaCB1cCBub2RlcyBjcmVhdGVkIGJ5IHRoZSBpbm5lciBwYXJzZSAoYW5kIHRodXNcbiAgICAgICAgICAgIC8vIHByZXN1bWFibHkgbm90IGFsaWFzZWQgYW55d2hlcmUgZWxzZSkgdG8gaG9sZCB0aGUgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIC8vIGFib3V0IHRoZSBpbm5lciBwYXJzZS5cbiAgICAgICAgICAgIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgaW5uZXIudGFyZ2V0LnByb3BzKTtcbiAgICAgICAgICAgIHByb3BzW05vZGVQcm9wLm1vdW50ZWQuaWRdID0gbmV3IE1vdW50ZWRUcmVlKGRvbmUsIGlubmVyLm92ZXJsYXksIGlubmVyLnBhcnNlcik7XG4gICAgICAgICAgICBpbm5lci50YXJnZXQucHJvcHMgPSBwcm9wcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBhcnNlZFBvcygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLmlucHV0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5uZXJEb25lOyBpIDwgdGhpcy5pbm5lci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5uZXJbaV0uZnJvbSA8IHBvcylcbiAgICAgICAgICAgICAgICBwb3MgPSBNYXRoLm1pbihwb3MsIHRoaXMuaW5uZXJbaV0ucGFyc2UucGFyc2VkUG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gcG9zO1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpXG4gICAgICAgICAgICB0aGlzLmJhc2VQYXJzZS5zdG9wQXQocG9zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5uZXJEb25lOyBpIDwgdGhpcy5pbm5lci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyW2ldLnBhcnNlLnN0b3BBdChwb3MpO1xuICAgIH1cbiAgICBzdGFydElubmVyKCkge1xuICAgICAgICBsZXQgZnJhZ21lbnRDdXJzb3IgPSBuZXcgRnJhZ21lbnRDdXJzb3IodGhpcy5mcmFnbWVudHMpO1xuICAgICAgICBsZXQgb3ZlcmxheSA9IG51bGw7XG4gICAgICAgIGxldCBjb3ZlcmVkID0gbnVsbDtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKG5ldyBUcmVlTm9kZSh0aGlzLmJhc2VUcmVlLCB0aGlzLnJhbmdlc1swXS5mcm9tLCAwLCBudWxsKSwgSXRlck1vZGUuSW5jbHVkZUFub255bW91cyB8IEl0ZXJNb2RlLklnbm9yZU1vdW50cyk7XG4gICAgICAgIHNjYW46IGZvciAobGV0IG5lc3QsIGlzQ292ZXJlZDs7KSB7XG4gICAgICAgICAgICBsZXQgZW50ZXIgPSB0cnVlLCByYW5nZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIGN1cnNvci5mcm9tID49IHRoaXMuc3RvcHBlZEF0KSB7XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyYWdtZW50Q3Vyc29yLmhhc05vZGUoY3Vyc29yKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IG92ZXJsYXkubW91bnRzLmZpbmQobSA9PiBtLmZyYWcuZnJvbSA8PSBjdXJzb3IuZnJvbSAmJiBtLmZyYWcudG8gPj0gY3Vyc29yLnRvICYmIG0ubW91bnQub3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgbWF0Y2gubW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gci5mcm9tICsgbWF0Y2gucG9zLCB0byA9IHIudG8gKyBtYXRjaC5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPj0gY3Vyc29yLmZyb20gJiYgdG8gPD0gY3Vyc29yLnRvICYmICFvdmVybGF5LnJhbmdlcy5zb21lKHIgPT4gci5mcm9tIDwgdG8gJiYgci50byA+IGZyb20pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3ZlcmVkICYmIChpc0NvdmVyZWQgPSBjaGVja0NvdmVyKGNvdmVyZWQucmFuZ2VzLCBjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKSkpIHtcbiAgICAgICAgICAgICAgICBlbnRlciA9IGlzQ292ZXJlZCAhPSAyIC8qIENvdmVyLkZ1bGwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLnR5cGUuaXNBbm9ueW1vdXMgJiYgKG5lc3QgPSB0aGlzLm5lc3QoY3Vyc29yLCB0aGlzLmlucHV0KSkgJiZcbiAgICAgICAgICAgICAgICAoY3Vyc29yLmZyb20gPCBjdXJzb3IudG8gfHwgIW5lc3Qub3ZlcmxheSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbGl6ZShjdXJzb3IpO1xuICAgICAgICAgICAgICAgIGxldCBvbGRNb3VudHMgPSBmcmFnbWVudEN1cnNvci5maW5kTW91bnRzKGN1cnNvci5mcm9tLCBuZXN0LnBhcnNlcik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXN0Lm92ZXJsYXkgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBuZXcgQWN0aXZlT3ZlcmxheShuZXN0LnBhcnNlciwgbmVzdC5vdmVybGF5LCBvbGRNb3VudHMsIHRoaXMuaW5uZXIubGVuZ3RoLCBjdXJzb3IuZnJvbSwgY3Vyc29yLnRyZWUsIG92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBuZXN0Lm92ZXJsYXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjdXJzb3IuZnJvbSA8IGN1cnNvci50byA/IFtuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byldIDogW10pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja1JhbmdlcyhyYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCB8fCAhbmVzdC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5wdXNoKG5ldyBJbm5lclBhcnNlKG5lc3QucGFyc2VyLCByYW5nZXMubGVuZ3RoID8gbmVzdC5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBlbnRlckZyYWdtZW50cyhvbGRNb3VudHMsIHJhbmdlcyksIHJhbmdlcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5lc3QucGFyc2VyLnN0YXJ0UGFyc2UoXCJcIiksIG5lc3Qub3ZlcmxheSA/IG5lc3Qub3ZlcmxheS5tYXAociA9PiBuZXcgUmFuZ2Uoci5mcm9tIC0gY3Vyc29yLmZyb20sIHIudG8gLSBjdXJzb3IuZnJvbSkpIDogbnVsbCwgY3Vyc29yLnRyZWUsIHJhbmdlcy5sZW5ndGggPyByYW5nZXNbMF0uZnJvbSA6IGN1cnNvci5mcm9tKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmVzdC5vdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSB7IHJhbmdlcywgZGVwdGg6IDAsIHByZXY6IGNvdmVyZWQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdmVybGF5ICYmIChyYW5nZSA9IG92ZXJsYXkucHJlZGljYXRlKGN1cnNvcikpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlID09PSB0cnVlKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShjdXJzb3IuZnJvbSwgY3Vyc29yLnRvKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZnJvbSA8IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gb3ZlcmxheS5yYW5nZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QgPj0gMCAmJiBvdmVybGF5LnJhbmdlc1tsYXN0XS50byA9PSByYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXNbbGFzdF0gPSB7IGZyb206IG92ZXJsYXkucmFuZ2VzW2xhc3RdLmZyb20sIHRvOiByYW5nZS50byB9O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGF5LnJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50ZXIgJiYgY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LmRlcHRoKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvdmVyZWQuZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkgJiYgIS0tb3ZlcmxheS5kZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBvdmVybGF5LnJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUmFuZ2VzKHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5zcGxpY2Uob3ZlcmxheS5pbmRleCwgMCwgbmV3IElubmVyUGFyc2Uob3ZlcmxheS5wYXJzZXIsIG92ZXJsYXkucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob3ZlcmxheS5tb3VudHMsIHJhbmdlcyksIHJhbmdlcyksIG92ZXJsYXkucmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBvdmVybGF5LnN0YXJ0LCByLnRvIC0gb3ZlcmxheS5zdGFydCkpLCBvdmVybGF5LnRhcmdldCwgcmFuZ2VzWzBdLmZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBvdmVybGF5LnByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQgJiYgIS0tY292ZXJlZC5kZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSBjb3ZlcmVkLnByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tDb3Zlcihjb3ZlcmVkLCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIGNvdmVyZWQpIHtcbiAgICAgICAgaWYgKHJhbmdlLmZyb20gPj0gdG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZnJvbSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8gPyAyIC8qIENvdmVyLkZ1bGwgKi8gOiAxIC8qIENvdmVyLlBhcnRpYWwgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIENvdmVyLk5vbmUgKi87XG59XG4vLyBUYWtlIGEgcGllY2Ugb2YgYnVmZmVyIGFuZCBjb252ZXJ0IGl0IGludG8gYSBzdGFuZC1hbG9uZVxuLy8gVHJlZUJ1ZmZlci5cbmZ1bmN0aW9uIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCBlbmRJLCBub2RlcywgcG9zaXRpb25zLCBvZmYpIHtcbiAgICBpZiAoc3RhcnRJIDwgZW5kSSkge1xuICAgICAgICBsZXQgZnJvbSA9IGJ1Zi5idWZmZXJbc3RhcnRJICsgMV07XG4gICAgICAgIG5vZGVzLnB1c2goYnVmLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gb2ZmKTtcbiAgICB9XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgbm9kZSB0aGF0J3MgaW4gYSBidWZmZXIsIGFuZCBjb252ZXJ0cyBpdCwgYW5kXG4vLyBpdHMgcGFyZW50IGJ1ZmZlciBub2RlcywgaW50byBhIFRyZWUuIFRoaXMgaXMgYWdhaW4gYWN0aW5nIG9uIHRoZVxuLy8gYXNzdW1wdGlvbiB0aGF0IHRoZSB0cmVlcyBhbmQgYnVmZmVycyBoYXZlIGJlZW4gY29uc3RydWN0ZWQgYnkgdGhlXG4vLyBwYXJzZSB0aGF0IHdhcyByYW4gdmlhIHRoZSBtaXggcGFyc2VyLCBhbmQgdGh1cyBhcmVuJ3Qgc2hhcmVkIHdpdGhcbi8vIGFueSBvdGhlciBjb2RlLCBtYWtpbmcgdmlvbGF0aW9ucyBvZiB0aGUgaW1tdXRhYmlsaXR5IHNhZmUuXG5mdW5jdGlvbiBtYXRlcmlhbGl6ZShjdXJzb3IpIHtcbiAgICBsZXQgeyBub2RlIH0gPSBjdXJzb3IsIHN0YWNrID0gW107XG4gICAgbGV0IGJ1ZmZlciA9IG5vZGUuY29udGV4dC5idWZmZXI7XG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXG4gICAgZG8ge1xuICAgICAgICBzdGFjay5wdXNoKGN1cnNvci5pbmRleCk7XG4gICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICB9IHdoaWxlICghY3Vyc29yLnRyZWUpO1xuICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBidWZmZXIgaW4gdGhhdCB0cmVlXG4gICAgbGV0IGJhc2UgPSBjdXJzb3IudHJlZSwgaSA9IGJhc2UuY2hpbGRyZW4uaW5kZXhPZihidWZmZXIpO1xuICAgIGxldCBidWYgPSBiYXNlLmNoaWxkcmVuW2ldLCBiID0gYnVmLmJ1ZmZlciwgbmV3U3RhY2sgPSBbaV07XG4gICAgLy8gU3BsaXQgYSBsZXZlbCBpbiB0aGUgYnVmZmVyLCBwdXR0aW5nIHRoZSBub2RlcyBiZWZvcmUgYW5kIGFmdGVyXG4gICAgLy8gdGhlIGNoaWxkIHRoYXQgY29udGFpbnMgYG5vZGVgIGludG8gbmV3IGJ1ZmZlcnMuXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RhcnRJLCBlbmRJLCB0eXBlLCBpbm5lck9mZnNldCwgbGVuZ3RoLCBzdGFja1Bvcykge1xuICAgICAgICBsZXQgdGFyZ2V0SSA9IHN0YWNrW3N0YWNrUG9zXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgdGFyZ2V0SSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICBsZXQgZnJvbSA9IGJbdGFyZ2V0SSArIDFdLCB0byA9IGJbdGFyZ2V0SSArIDJdO1xuICAgICAgICBuZXdTdGFjay5wdXNoKGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgICAgIGxldCBjaGlsZCA9IHN0YWNrUG9zXG4gICAgICAgICAgICA/IHNwbGl0KHRhcmdldEkgKyA0LCBiW3RhcmdldEkgKyAzXSwgYnVmLnNldC50eXBlc1tiW3RhcmdldEldXSwgZnJvbSwgdG8gLSBmcm9tLCBzdGFja1BvcyAtIDEpXG4gICAgICAgICAgICA6IG5vZGUudG9UcmVlKCk7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gaW5uZXJPZmZzZXQpO1xuICAgICAgICBzbGljZUJ1ZihidWYsIGJbdGFyZ2V0SSArIDNdLCBlbmRJLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpbm5lck9mZnNldCk7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpO1xuICAgIH1cbiAgICBiYXNlLmNoaWxkcmVuW2ldID0gc3BsaXQoMCwgYi5sZW5ndGgsIE5vZGVUeXBlLm5vbmUsIDAsIGJ1Zi5sZW5ndGgsIHN0YWNrLmxlbmd0aCAtIDEpO1xuICAgIC8vIE1vdmUgdGhlIGN1cnNvciBiYWNrIHRvIHRoZSB0YXJnZXQgbm9kZVxuICAgIGZvciAobGV0IGluZGV4IG9mIG5ld1N0YWNrKSB7XG4gICAgICAgIGxldCB0cmVlID0gY3Vyc29yLnRyZWUuY2hpbGRyZW5baW5kZXhdLCBwb3MgPSBjdXJzb3IudHJlZS5wb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICBjdXJzb3IueWllbGQobmV3IFRyZWVOb2RlKHRyZWUsIHBvcyArIGN1cnNvci5mcm9tLCBpbmRleCwgY3Vyc29yLl90cmVlKSk7XG4gICAgfVxufVxuY2xhc3MgU3RydWN0dXJlQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcihyb290LCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IHJvb3QuY3Vyc29yKEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMgfCBJdGVyTW9kZS5JZ25vcmVNb3VudHMpO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRvIHRoZSBmaXJzdCBub2RlIChpbiBwcmUtb3JkZXIpIHRoYXQgc3RhcnRzIGF0IG9yIGFmdGVyIGBwb3NgLlxuICAgIG1vdmVUbyhwb3MpIHtcbiAgICAgICAgbGV0IHsgY3Vyc29yIH0gPSB0aGlzLCBwID0gcG9zIC0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHdoaWxlICghdGhpcy5kb25lICYmIGN1cnNvci5mcm9tIDwgcCkge1xuICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBwb3MgJiYgY3Vyc29yLmVudGVyKHAsIDEsIEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzIHwgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpKSA7XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLm5leHQoZmFsc2UpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShjdXJzb3IpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oY3Vyc29yLmZyb20pO1xuICAgICAgICBpZiAoIXRoaXMuZG9uZSAmJiB0aGlzLmN1cnNvci5mcm9tICsgdGhpcy5vZmZzZXQgPT0gY3Vyc29yLmZyb20gJiYgdGhpcy5jdXJzb3IudHJlZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSA9IHRoaXMuY3Vyc29yLnRyZWU7Oykge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlID09IGN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHJlZS5jaGlsZHJlbi5sZW5ndGggJiYgdHJlZS5wb3NpdGlvbnNbMF0gPT0gMCAmJiB0cmVlLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgdHJlZSA9IHRyZWUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmN1clRvID0gMDtcbiAgICAgICAgdGhpcy5mcmFnSSA9IDA7XG4gICAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0aGlzLmN1ckZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZmlyc3QudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpcnN0LnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZmlyc3QudHJlZSwgLWZpcnN0Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VyRnJhZyAmJiBub2RlLmZyb20gPj0gdGhpcy5jdXJUbylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyRnJhZyAmJiB0aGlzLmN1ckZyYWcuZnJvbSA8PSBub2RlLmZyb20gJiYgdGhpcy5jdXJUbyA+PSBub2RlLnRvICYmIHRoaXMuaW5uZXIuaGFzTm9kZShub2RlKTtcbiAgICB9XG4gICAgbmV4dEZyYWcoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnSSsrO1xuICAgICAgICBpZiAodGhpcy5mcmFnSSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmN1ckZyYWcgPSB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdJXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmcmFnLnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmcmFnLnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZnJhZy50cmVlLCAtZnJhZy5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRNb3VudHMocG9zLCBwYXJzZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmlubmVyKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyLmN1cnNvci5tb3ZlVG8ocG9zLCAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuaW5uZXIuY3Vyc29yLm5vZGU7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBtb3VudCA9IChfYSA9IHBvcy50cmVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQucGFyc2VyID09IHBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcmFnSTsgaSA8IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcuZnJvbSA+PSBwb3MudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy50cmVlID09IHRoaXMuY3VyRnJhZy50cmVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBwb3MuZnJvbSAtIGZyYWcub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVuY2hSYW5nZXMob3V0ZXIsIHJhbmdlcykge1xuICAgIGxldCBjb3B5ID0gbnVsbCwgY3VycmVudCA9IHJhbmdlcztcbiAgICBmb3IgKGxldCBpID0gMSwgaiA9IDA7IGkgPCBvdXRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IG91dGVyW2kgLSAxXS50bywgZ2FwVG8gPSBvdXRlcltpXS5mcm9tO1xuICAgICAgICBmb3IgKDsgaiA8IGN1cnJlbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByID0gY3VycmVudFtqXTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gZ2FwVG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA8PSBnYXBGcm9tKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjb3B5ID0gcmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoci5mcm9tIDwgZ2FwRnJvbSkge1xuICAgICAgICAgICAgICAgIGNvcHlbal0gPSBuZXcgUmFuZ2Uoci5mcm9tLCBnYXBGcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoci50byA+IGdhcFRvKVxuICAgICAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqICsgMSwgMCwgbmV3IFJhbmdlKGdhcFRvLCByLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyLnRvID4gZ2FwVG8pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2otLV0gPSBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weS5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIGZpbmRDb3ZlckNoYW5nZXMoYSwgYiwgZnJvbSwgdG8pIHtcbiAgICBsZXQgaUEgPSAwLCBpQiA9IDAsIGluQSA9IGZhbHNlLCBpbkIgPSBmYWxzZSwgcG9zID0gLTFlOTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbmV4dEEgPSBpQSA9PSBhLmxlbmd0aCA/IDFlOSA6IGluQSA/IGFbaUFdLnRvIDogYVtpQV0uZnJvbTtcbiAgICAgICAgbGV0IG5leHRCID0gaUIgPT0gYi5sZW5ndGggPyAxZTkgOiBpbkIgPyBiW2lCXS50byA6IGJbaUJdLmZyb207XG4gICAgICAgIGlmIChpbkEgIT0gaW5CKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIsIHRvKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IGVuZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IE1hdGgubWluKG5leHRBLCBuZXh0Qik7XG4gICAgICAgIGlmIChwb3MgPT0gMWU5KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0QSA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5BKVxuICAgICAgICAgICAgICAgIGluQSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0QiA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5CKVxuICAgICAgICAgICAgICAgIGluQiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBHaXZlbiBhIG51bWJlciBvZiBmcmFnbWVudHMgZm9yIHRoZSBvdXRlciB0cmVlLCBhbmQgYSBzZXQgb2YgcmFuZ2VzXG4vLyB0byBwYXJzZSwgZmluZCBmcmFnbWVudHMgZm9yIGlubmVyIHRyZWVzIG1vdW50ZWQgYXJvdW5kIHRob3NlXG4vLyByYW5nZXMsIGlmIGFueS5cbmZ1bmN0aW9uIGVudGVyRnJhZ21lbnRzKG1vdW50cywgcmFuZ2VzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHsgcG9zLCBtb3VudCwgZnJhZyB9IG9mIG1vdW50cykge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBwb3MgKyAobW91bnQub3ZlcmxheSA/IG1vdW50Lm92ZXJsYXlbMF0uZnJvbSA6IDApLCBlbmRQb3MgPSBzdGFydFBvcyArIG1vdW50LnRyZWUubGVuZ3RoO1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KGZyYWcuZnJvbSwgc3RhcnRQb3MpLCB0byA9IE1hdGgubWluKGZyYWcudG8sIGVuZFBvcyk7XG4gICAgICAgIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmxheSA9IG1vdW50Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSArIHBvcywgci50byArIHBvcykpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBmaW5kQ292ZXJDaGFuZ2VzKHJhbmdlcywgb3ZlcmxheSwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IGZyb207OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gY2hhbmdlcy5sZW5ndGgsIGVuZCA9IGxhc3QgPyB0byA6IGNoYW5nZXNbaV0uZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KHBvcywgZW5kLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBwb3MgfHwgZnJhZy5vcGVuU3RhcnQsIGZyYWcudG8gPD0gZW5kIHx8IGZyYWcub3BlbkVuZCkpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBjaGFuZ2VzW2ldLnRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChmcm9tLCB0bywgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gc3RhcnRQb3MgfHwgZnJhZy5vcGVuU3RhcnQsIGZyYWcudG8gPD0gZW5kUG9zIHx8IGZyYWcub3BlbkVuZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IERlZmF1bHRCdWZmZXJMZW5ndGgsIEl0ZXJNb2RlLCBNb3VudGVkVHJlZSwgTm9kZVByb3AsIE5vZGVTZXQsIE5vZGVUeXBlLCBOb2RlV2Vha01hcCwgUGFyc2VyLCBUcmVlLCBUcmVlQnVmZmVyLCBUcmVlQ3Vyc29yLCBUcmVlRnJhZ21lbnQsIHBhcnNlTWl4ZWQgfTtcbiJdLCJuYW1lcyI6WyJEZWZhdWx0QnVmZmVyTGVuZ3RoIiwibmV4dFByb3BJRCIsIlJhbmdlIiwiY29uc3RydWN0b3IiLCJmcm9tIiwidG8iLCJOb2RlUHJvcCIsImNvbmZpZyIsImlkIiwicGVyTm9kZSIsImRlc2VyaWFsaXplIiwiRXJyb3IiLCJhZGQiLCJtYXRjaCIsIlJhbmdlRXJyb3IiLCJOb2RlVHlwZSIsInR5cGUiLCJyZXN1bHQiLCJ1bmRlZmluZWQiLCJjbG9zZWRCeSIsInN0ciIsInNwbGl0Iiwib3BlbmVkQnkiLCJncm91cCIsImlzb2xhdGUiLCJ2YWx1ZSIsImNvbnRleHRIYXNoIiwibG9va0FoZWFkIiwibW91bnRlZCIsIk1vdW50ZWRUcmVlIiwidHJlZSIsIm92ZXJsYXkiLCJwYXJzZXIiLCJnZXQiLCJwcm9wcyIsIm5vUHJvcHMiLCJPYmplY3QiLCJjcmVhdGUiLCJuYW1lIiwiZmxhZ3MiLCJkZWZpbmUiLCJzcGVjIiwibGVuZ3RoIiwidG9wIiwic2tpcHBlZCIsImVycm9yIiwic3JjIiwiQXJyYXkiLCJpc0FycmF5IiwicHJvcCIsImlzVG9wIiwiaXNTa2lwcGVkIiwiaXNFcnJvciIsImlzQW5vbnltb3VzIiwiaXMiLCJpbmRleE9mIiwibWFwIiwiZGlyZWN0Iiwibm9kZSIsImdyb3VwcyIsImkiLCJmb3VuZCIsIm5vbmUiLCJOb2RlU2V0IiwidHlwZXMiLCJleHRlbmQiLCJuZXdUeXBlcyIsIm5ld1Byb3BzIiwic291cmNlIiwiYXNzaWduIiwicHVzaCIsIkNhY2hlZE5vZGUiLCJXZWFrTWFwIiwiQ2FjaGVkSW5uZXJOb2RlIiwiSXRlck1vZGUiLCJUcmVlIiwiY2hpbGRyZW4iLCJwb3NpdGlvbnMiLCJ0b1N0cmluZyIsImNoIiwidGVzdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJjdXJzb3IiLCJtb2RlIiwiVHJlZUN1cnNvciIsInRvcE5vZGUiLCJjdXJzb3JBdCIsInBvcyIsInNpZGUiLCJzY29wZSIsIm1vdmVUbyIsInNldCIsIl90cmVlIiwiVHJlZU5vZGUiLCJyZXNvbHZlIiwicmVzb2x2ZU5vZGUiLCJyZXNvbHZlSW5uZXIiLCJyZXNvbHZlU3RhY2siLCJzdGFja0l0ZXJhdG9yIiwiaXRlcmF0ZSIsImVudGVyIiwibGVhdmUiLCJhbm9uIiwiSW5jbHVkZUFub255bW91cyIsImMiLCJlbnRlcmVkIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwicGFyZW50IiwicHJvcFZhbHVlcyIsImJhbGFuY2UiLCJiYWxhbmNlUmFuZ2UiLCJtYWtlVHJlZSIsImJ1aWxkIiwiZGF0YSIsImJ1aWxkVHJlZSIsImVtcHR5IiwiRmxhdEJ1ZmZlckN1cnNvciIsImJ1ZmZlciIsImluZGV4Iiwic3RhcnQiLCJlbmQiLCJzaXplIiwibmV4dCIsImZvcmsiLCJUcmVlQnVmZmVyIiwiY2hpbGRTdHJpbmciLCJqb2luIiwiZW5kSW5kZXgiLCJmaW5kQ2hpbGQiLCJzdGFydEluZGV4IiwiZGlyIiwicGljayIsImNoZWNrU2lkZSIsInNsaWNlIiwic3RhcnRJIiwiZW5kSSIsImIiLCJjb3B5IiwiVWludDE2QXJyYXkiLCJsZW4iLCJqIiwiTWF0aCIsIm1heCIsIm92ZXJsYXlzIiwiX2EiLCJJZ25vcmVPdmVybGF5cyIsInNjYW4iLCJpbm5lciIsIkJhc2VOb2RlIiwiZ2V0Q2hpbGQiLCJiZWZvcmUiLCJhZnRlciIsInIiLCJnZXRDaGlsZHJlbiIsIm1hdGNoQ29udGV4dCIsImNvbnRleHQiLCJtYXRjaE5vZGVDb250ZXh0IiwiZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUiLCJjaGlsZEJlZm9yZSIsImxhc3QiLCJsYXN0Q2hpbGQiLCJwcmV2U2libGluZyIsIl9wYXJlbnQiLCJuZXh0Q2hpbGQiLCJlIiwiRXhjbHVkZUJ1ZmZlcnMiLCJCdWZmZXJOb2RlIiwiQnVmZmVyQ29udGV4dCIsImhhc0NoaWxkIiwiSWdub3JlTW91bnRzIiwiY2hpbGRBZnRlciIsInJQb3MiLCJuZXh0U2lnbmlmaWNhbnRQYXJlbnQiLCJ2YWwiLCJ0b1RyZWUiLCJjdXIiLCJwIiwiY2hpbGQiLCJleHRlcm5hbFNpYmxpbmciLCJwYXJlbnRTdGFydCIsIml0ZXJTdGFjayIsImhlYWRzIiwicGlja2VkIiwibmV3SGVhZHMiLCJzcGxpY2UiLCJTdGFja0l0ZXJhdG9yIiwibGF5ZXJzIiwibW91bnQiLCJyb290Iiwic3RhY2siLCJidWZmZXJOb2RlIiwieWllbGROb2RlIiwibiIsInVuc2hpZnQiLCJ5aWVsZEJ1ZiIsInlpZWxkIiwiZW50ZXJDaGlsZCIsInBvcCIsInNpYmxpbmciLCJkIiwiYXRMYXN0Tm9kZSIsIm1vdmUiLCJwcmV2IiwiY2FjaGUiLCJkZXB0aCIsIm11c3RMZWF2ZSIsInNvbWUiLCJub2RlU2V0IiwibWF4QnVmZmVyTGVuZ3RoIiwicmV1c2VkIiwibWluUmVwZWF0VHlwZSIsInRha2VOb2RlIiwibWluUG9zIiwiaW5SZXBlYXQiLCJsb29rQWhlYWRBdFN0YXJ0IiwiY29udGV4dEF0U3RhcnQiLCJzdGFydFBvcyIsImZpbmRCdWZmZXJTaXplIiwic2tpcCIsImVuZFBvcyIsImNvcHlUb0J1ZmZlciIsImxvY2FsQ2hpbGRyZW4iLCJsb2NhbFBvc2l0aW9ucyIsImxvY2FsSW5SZXBlYXQiLCJsYXN0R3JvdXAiLCJsYXN0RW5kIiwibWFrZVJlcGVhdExlYWYiLCJ0YWtlRmxhdE5vZGUiLCJyZXZlcnNlIiwibWFrZSIsIm1ha2VCYWxhbmNlZCIsIm5vZGVzIiwibm9kZUNvdW50Iiwic3RvcEF0IiwibGFzdEkiLCJsb29rQWhlYWRQcm9wIiwiYmFzZSIsInBhaXIiLCJjb25jYXQiLCJtYXhTaXplIiwibWluU3RhcnQiLCJub2RlU2l6ZSIsImxvY2FsU2tpcHBlZCIsIm5vZGVTdGFydCIsImJ1ZmZlclN0YXJ0IiwidG9wSUQiLCJub2RlU2l6ZUNhY2hlIiwiYmFsYW5jZVR5cGUiLCJta1RvcCIsIm1rVHJlZSIsInRvdGFsIiwibWF4Q2hpbGQiLCJjZWlsIiwiZGl2aWRlIiwib2Zmc2V0IiwiZ3JvdXBGcm9tIiwiZ3JvdXBTdGFydCIsImdyb3VwU2l6ZSIsIm5leHRTaXplIiwib25seSIsIk5vZGVXZWFrTWFwIiwic2V0QnVmZmVyIiwiTWFwIiwiZ2V0QnVmZmVyIiwiY3Vyc29yU2V0IiwiY3Vyc29yR2V0IiwiVHJlZUZyYWdtZW50Iiwib3BlblN0YXJ0Iiwib3BlbkVuZCIsIm9wZW4iLCJhZGRUcmVlIiwiZnJhZ21lbnRzIiwicGFydGlhbCIsImYiLCJhcHBseUNoYW5nZXMiLCJjaGFuZ2VzIiwibWluR2FwIiwiZkkiLCJuZXh0RiIsImNJIiwib2ZmIiwibmV4dEMiLCJuZXh0UG9zIiwiZnJvbUEiLCJjdXQiLCJmRnJvbSIsImZUbyIsIm1pbiIsInRvQSIsInRvQiIsIlBhcnNlciIsInN0YXJ0UGFyc2UiLCJpbnB1dCIsInJhbmdlcyIsIlN0cmluZ0lucHV0IiwiY3JlYXRlUGFyc2UiLCJwYXJzZSIsImRvbmUiLCJhZHZhbmNlIiwic3RyaW5nIiwiY2h1bmsiLCJsaW5lQ2h1bmtzIiwicmVhZCIsInBhcnNlTWl4ZWQiLCJuZXN0IiwiTWl4ZWRQYXJzZSIsIklubmVyUGFyc2UiLCJ0YXJnZXQiLCJjaGVja1JhbmdlcyIsIkFjdGl2ZU92ZXJsYXkiLCJwcmVkaWNhdGUiLCJtb3VudHMiLCJzdG9wcGVkSW5uZXIiLCJpbm5lckRvbmUiLCJiYXNlVHJlZSIsInN0b3BwZWRBdCIsImJhc2VQYXJzZSIsInN0YXJ0SW5uZXIiLCJwYXJzZWRQb3MiLCJmcmFnbWVudEN1cnNvciIsIkZyYWdtZW50Q3Vyc29yIiwiY292ZXJlZCIsImlzQ292ZXJlZCIsInJhbmdlIiwiaGFzTm9kZSIsImZpbmQiLCJtIiwiZnJhZyIsImNoZWNrQ292ZXIiLCJtYXRlcmlhbGl6ZSIsIm9sZE1vdW50cyIsImZpbmRNb3VudHMiLCJwdW5jaFJhbmdlcyIsImVudGVyRnJhZ21lbnRzIiwic2xpY2VCdWYiLCJidWYiLCJuZXdTdGFjayIsImlubmVyT2Zmc2V0Iiwic3RhY2tQb3MiLCJ0YXJnZXRJIiwiU3RydWN0dXJlQ3Vyc29yIiwiY3VyVG8iLCJmcmFnSSIsImZpcnN0IiwiY3VyRnJhZyIsIm5leHRGcmFnIiwib3V0ZXIiLCJjdXJyZW50IiwiZ2FwRnJvbSIsImdhcFRvIiwiZmluZENvdmVyQ2hhbmdlcyIsImEiLCJpQSIsImlCIiwiaW5BIiwiaW5CIiwibmV4dEEiLCJuZXh0QiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/common/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lezer/highlight/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lezer/highlight/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   classHighlighter: () => (/* binding */ classHighlighter),\n/* harmony export */   getStyleTags: () => (/* binding */ getStyleTags),\n/* harmony export */   highlightCode: () => (/* binding */ highlightCode),\n/* harmony export */   highlightTree: () => (/* binding */ highlightTree),\n/* harmony export */   styleTags: () => (/* binding */ styleTags),\n/* harmony export */   tagHighlighter: () => (/* binding */ tagHighlighter),\n/* harmony export */   tags: () => (/* binding */ tags)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlighter](#highlight.Highlighter).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/ class Tag {\n    /**\n    @internal\n    */ constructor(/**\n    The optional name of the base tag @internal\n    */ name, /**\n    The set of this tag and all its parent tags, starting with\n    this one itself and sorted in order of decreasing specificity.\n    */ set, /**\n    The base unmodified tag that this one is based on, if it's\n    modified @internal\n    */ base, /**\n    The modifiers applied to this.base @internal\n    */ modified){\n        this.name = name;\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /**\n        @internal\n        */ this.id = nextTagID++;\n    }\n    toString() {\n        let { name } = this;\n        for (let mod of this.modified)if (mod.name) name = `${mod.name}(${name})`;\n        return name;\n    }\n    static define(nameOrParent, parent) {\n        let name = typeof nameOrParent == \"string\" ? nameOrParent : \"?\";\n        if (nameOrParent instanceof Tag) parent = nameOrParent;\n        if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag(name, [], null, []);\n        tag.set.push(tag);\n        if (parent) for (let t of parent.set)tag.set.push(t);\n        return tag;\n    }\n    /**\n    Define a tag _modifier_, which is a function that, given a tag,\n    will return a tag that is a subtag of the original. Applying the\n    same modifier to a twice tag will return the same value (`m1(t1)\n    == m1(t1)`) and applying multiple modifiers will, regardless or\n    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    \n    When multiple modifiers are applied to a given base tag, each\n    smaller set of modifiers is registered as a parent, so that for\n    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    `m1(m3(t1)`, and so on.\n    */ static defineModifier(name) {\n        let mod = new Modifier(name);\n        return (tag)=>{\n            if (tag.modified.indexOf(mod) > -1) return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b)=>a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor(name){\n        this.name = name;\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length) return base;\n        let exists = mods[0].instances.find((t)=>t.base == base && sameArray(mods, t.modified));\n        if (exists) return exists;\n        let set = [], tag = new Tag(base.name, set, base, mods);\n        for (let m of mods)m.instances.push(tag);\n        let configs = powerSet(mods);\n        for (let parent of base.set)if (!parent.modified.length) for (let config of configs)set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i)=>x == b[i]);\n}\nfunction powerSet(array) {\n    let sets = [\n        []\n    ];\n    for(let i = 0; i < array.length; i++){\n        for(let j = 0, e = sets.length; j < e; j++){\n            sets.push(sets[j].concat(array[i]));\n        }\n    }\n    return sets.sort((a, b)=>b.length - a.length);\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia [`NodeSet.extend`](#common.NodeSet.extend) or\n[`LRParser.configure`](#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node name](#common.NodeType.name), or\nmultiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single levelâ€”wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.withProps(\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n)\n```\n*/ function styleTags(spec) {\n    let byName = Object.create(null);\n    for(let prop in spec){\n        let tags = spec[prop];\n        if (!Array.isArray(tags)) tags = [\n            tags\n        ];\n        for (let part of prop.split(\" \"))if (part) {\n            let pieces = [], mode = 2 /* Mode.Normal */ , rest = part;\n            for(let pos = 0;;){\n                if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                    mode = 1 /* Mode.Inherit */ ;\n                    break;\n                }\n                let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                if (!m) throw new RangeError(\"Invalid path: \" + part);\n                pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                pos += m[0].length;\n                if (pos == part.length) break;\n                let next = part[pos++];\n                if (pos == part.length && next == \"!\") {\n                    mode = 0 /* Mode.Opaque */ ;\n                    break;\n                }\n                if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n                rest = part.slice(pos);\n            }\n            let last = pieces.length - 1, inner = pieces[last];\n            if (!inner) throw new RangeError(\"Invalid path: \" + part);\n            let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n            byName[inner] = rule.sort(byName[inner]);\n        }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nclass Rule {\n    constructor(tags, mode, context, next){\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    get opaque() {\n        return this.mode == 0 /* Mode.Opaque */ ;\n    }\n    get inherit() {\n        return this.mode == 1 /* Mode.Inherit */ ;\n    }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() {\n        return this.context ? this.context.length : 0;\n    }\n}\nRule.empty = new Rule([], 2 /* Mode.Normal */ , null);\n/**\nDefine a [highlighter](#highlight.Highlighter) from an array of\ntag/class pairs. Classes associated with more specific tags will\ntake precedence.\n*/ function tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags){\n        if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;\n        else for (let tag of style.tag)map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags)=>{\n            let cls = all;\n            for (let tag of tags){\n                for (let sub of tag.set){\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters){\n        let value = highlighter.style(tags);\n        if (value) result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/**\nHighlight the given [tree](#common.Tree) with the given\n[highlighter](#highlight.Highlighter). Often, the higher-level\n[`highlightCode`](#highlight.highlightCode) function is easier to\nuse.\n*/ function highlightTree(tree, highlighter, /**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/ putStyle, /**\nThe start of the range to highlight.\n*/ from = 0, /**\nThe end of the range.\n*/ to = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [\n        highlighter\n    ], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\n/**\nHighlight the given tree with the given highlighter, calling\n`putText` for every piece of text, either with a set of classes or\nwith the empty string when unstyled, and `putBreak` for every line\nbreak.\n*/ function highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {\n    let pos = from;\n    function writeTo(p, classes) {\n        if (p <= pos) return;\n        for(let text = code.slice(pos, p), i = 0;;){\n            let nextBreak = text.indexOf(\"\\n\", i);\n            let upto = nextBreak < 0 ? text.length : nextBreak;\n            if (upto > i) putText(text.slice(i, upto), classes);\n            if (nextBreak < 0) break;\n            putBreak();\n            i = nextBreak + 1;\n        }\n        pos = p;\n    }\n    highlightTree(tree, highlighter, (from, to, classes)=>{\n        writeTo(from, \"\");\n        writeTo(to, classes);\n    }, from, to);\n    writeTo(to, \"\");\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span){\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at) this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class) this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from) return;\n        if (type.isTop) highlighters = this.highlighters.filter((h)=>!h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = getStyleTags(cursor) || Rule.empty;\n        let tagCls = highlightTags(highlighters, rule.tags);\n        if (tagCls) {\n            if (cls) cls += \" \";\n            cls += tagCls;\n            if (rule.mode == 1 /* Mode.Inherit */ ) inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n        }\n        this.startSpan(Math.max(from, start), cls);\n        if (rule.opaque) return;\n        let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter((h)=>!h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for(let i = 0, pos = start;; i++){\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while(cursor.from < rangeTo){\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(rangeTo, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n                    }\n                }\n                if (!next || nextPos > to) break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), \"\", innerHighlighters);\n                    this.startSpan(Math.min(to, pos), cls);\n                }\n            }\n            if (hasChild) cursor.parent();\n        } else if (cursor.firstChild()) {\n            if (mounted) inheritedClass = \"\";\n            do {\n                if (cursor.to <= from) continue;\n                if (cursor.from >= to) break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            }while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\n/**\nMatch a syntax node's [highlight rules](#highlight.styleTags). If\nthere's a match, return its set of tags, and whether it is\nopaque (uses a `!`) or applies to all child nodes (`/...`).\n*/ function getStyleTags(node) {\n    let rule = node.type.prop(ruleNodeProp);\n    while(rule && rule.context && !node.matchContext(rule.context))rule = rule.next;\n    return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/**\nThe default set of highlighting [tags](#highlight.Tag).\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an elementâ€”if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/ const tags = {\n    /**\n    A comment.\n    */ comment,\n    /**\n    A line [comment](#highlight.tags.comment).\n    */ lineComment: t(comment),\n    /**\n    A block [comment](#highlight.tags.comment).\n    */ blockComment: t(comment),\n    /**\n    A documentation [comment](#highlight.tags.comment).\n    */ docComment: t(comment),\n    /**\n    Any kind of identifier.\n    */ name,\n    /**\n    The [name](#highlight.tags.name) of a variable.\n    */ variableName: t(name),\n    /**\n    A type [name](#highlight.tags.name).\n    */ typeName: typeName,\n    /**\n    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    */ tagName: t(typeName),\n    /**\n    A property or field [name](#highlight.tags.name).\n    */ propertyName: propertyName,\n    /**\n    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    */ attributeName: t(propertyName),\n    /**\n    The [name](#highlight.tags.name) of a class.\n    */ className: t(name),\n    /**\n    A label [name](#highlight.tags.name).\n    */ labelName: t(name),\n    /**\n    A namespace [name](#highlight.tags.name).\n    */ namespace: t(name),\n    /**\n    The [name](#highlight.tags.name) of a macro.\n    */ macroName: t(name),\n    /**\n    A literal value.\n    */ literal,\n    /**\n    A string [literal](#highlight.tags.literal).\n    */ string,\n    /**\n    A documentation [string](#highlight.tags.string).\n    */ docString: t(string),\n    /**\n    A character literal (subtag of [string](#highlight.tags.string)).\n    */ character: t(string),\n    /**\n    An attribute value (subtag of [string](#highlight.tags.string)).\n    */ attributeValue: t(string),\n    /**\n    A number [literal](#highlight.tags.literal).\n    */ number,\n    /**\n    An integer [number](#highlight.tags.number) literal.\n    */ integer: t(number),\n    /**\n    A floating-point [number](#highlight.tags.number) literal.\n    */ float: t(number),\n    /**\n    A boolean [literal](#highlight.tags.literal).\n    */ bool: t(literal),\n    /**\n    Regular expression [literal](#highlight.tags.literal).\n    */ regexp: t(literal),\n    /**\n    An escape [literal](#highlight.tags.literal), for example a\n    backslash escape in a string.\n    */ escape: t(literal),\n    /**\n    A color [literal](#highlight.tags.literal).\n    */ color: t(literal),\n    /**\n    A URL [literal](#highlight.tags.literal).\n    */ url: t(literal),\n    /**\n    A language keyword.\n    */ keyword,\n    /**\n    The [keyword](#highlight.tags.keyword) for the self or this\n    object.\n    */ self: t(keyword),\n    /**\n    The [keyword](#highlight.tags.keyword) for null.\n    */ null: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    */ atom: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that represents a unit.\n    */ unit: t(keyword),\n    /**\n    A modifier [keyword](#highlight.tags.keyword).\n    */ modifier: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that acts as an operator.\n    */ operatorKeyword: t(keyword),\n    /**\n    A control-flow related [keyword](#highlight.tags.keyword).\n    */ controlKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) that defines something.\n    */ definitionKeyword: t(keyword),\n    /**\n    A [keyword](#highlight.tags.keyword) related to defining or\n    interfacing with modules.\n    */ moduleKeyword: t(keyword),\n    /**\n    An operator.\n    */ operator,\n    /**\n    An [operator](#highlight.tags.operator) that dereferences something.\n    */ derefOperator: t(operator),\n    /**\n    Arithmetic-related [operator](#highlight.tags.operator).\n    */ arithmeticOperator: t(operator),\n    /**\n    Logical [operator](#highlight.tags.operator).\n    */ logicOperator: t(operator),\n    /**\n    Bit [operator](#highlight.tags.operator).\n    */ bitwiseOperator: t(operator),\n    /**\n    Comparison [operator](#highlight.tags.operator).\n    */ compareOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that updates its operand.\n    */ updateOperator: t(operator),\n    /**\n    [Operator](#highlight.tags.operator) that defines something.\n    */ definitionOperator: t(operator),\n    /**\n    Type-related [operator](#highlight.tags.operator).\n    */ typeOperator: t(operator),\n    /**\n    Control-flow [operator](#highlight.tags.operator).\n    */ controlOperator: t(operator),\n    /**\n    Program or markup punctuation.\n    */ punctuation,\n    /**\n    [Punctuation](#highlight.tags.punctuation) that separates\n    things.\n    */ separator: t(punctuation),\n    /**\n    Bracket-style [punctuation](#highlight.tags.punctuation).\n    */ bracket,\n    /**\n    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    tokens).\n    */ angleBracket: t(bracket),\n    /**\n    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    tokens).\n    */ squareBracket: t(bracket),\n    /**\n    Parentheses (usually `(` and `)` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */ paren: t(bracket),\n    /**\n    Braces (usually `{` and `}` tokens). Subtag of\n    [bracket](#highlight.tags.bracket).\n    */ brace: t(bracket),\n    /**\n    Content, for example plain text in XML or markup documents.\n    */ content,\n    /**\n    [Content](#highlight.tags.content) that represents a heading.\n    */ heading,\n    /**\n    A level 1 [heading](#highlight.tags.heading).\n    */ heading1: t(heading),\n    /**\n    A level 2 [heading](#highlight.tags.heading).\n    */ heading2: t(heading),\n    /**\n    A level 3 [heading](#highlight.tags.heading).\n    */ heading3: t(heading),\n    /**\n    A level 4 [heading](#highlight.tags.heading).\n    */ heading4: t(heading),\n    /**\n    A level 5 [heading](#highlight.tags.heading).\n    */ heading5: t(heading),\n    /**\n    A level 6 [heading](#highlight.tags.heading).\n    */ heading6: t(heading),\n    /**\n    A prose [content](#highlight.tags.content) separator (such as a horizontal rule).\n    */ contentSeparator: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a list.\n    */ list: t(content),\n    /**\n    [Content](#highlight.tags.content) that represents a quote.\n    */ quote: t(content),\n    /**\n    [Content](#highlight.tags.content) that is emphasized.\n    */ emphasis: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled strong.\n    */ strong: t(content),\n    /**\n    [Content](#highlight.tags.content) that is part of a link.\n    */ link: t(content),\n    /**\n    [Content](#highlight.tags.content) that is styled as code or\n    monospace.\n    */ monospace: t(content),\n    /**\n    [Content](#highlight.tags.content) that has a strike-through\n    style.\n    */ strikethrough: t(content),\n    /**\n    Inserted text in a change-tracking format.\n    */ inserted: t(),\n    /**\n    Deleted text.\n    */ deleted: t(),\n    /**\n    Changed text.\n    */ changed: t(),\n    /**\n    An invalid or unsyntactic element.\n    */ invalid: t(),\n    /**\n    Metadata or meta-instruction.\n    */ meta,\n    /**\n    [Metadata](#highlight.tags.meta) that applies to the entire\n    document.\n    */ documentMeta: t(meta),\n    /**\n    [Metadata](#highlight.tags.meta) that annotates or adds\n    attributes to a given syntactic element.\n    */ annotation: t(meta),\n    /**\n    Processing instruction or preprocessor directive. Subtag of\n    [meta](#highlight.tags.meta).\n    */ processingInstruction: t(meta),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    given element is being defined. Expected to be used with the\n    various [name](#highlight.tags.name) tags.\n    */ definition: Tag.defineModifier(\"definition\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates that\n    something is constant. Mostly expected to be used with\n    [variable names](#highlight.tags.variableName).\n    */ constant: Tag.defineModifier(\"constant\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    a [variable](#highlight.tags.variableName) or [property\n    name](#highlight.tags.propertyName) is being called or defined\n    as a function.\n    */ function: Tag.defineModifier(\"function\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    [names](#highlight.tags.name) to indicate that they belong to\n    the language's standard environment.\n    */ standard: Tag.defineModifier(\"standard\"),\n    /**\n    [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    [names](#highlight.tags.name) is local to some scope.\n    */ local: Tag.defineModifier(\"local\"),\n    /**\n    A generic variant [modifier](#highlight.Tag^defineModifier) that\n    can be used to tag language-specific alternative variants of\n    some common tag. It is recommended for themes to define special\n    forms of at least the [string](#highlight.tags.string) and\n    [variable name](#highlight.tags.variableName) tags, since those\n    come up a lot.\n    */ special: Tag.defineModifier(\"special\")\n};\nfor(let name in tags){\n    let val = tags[name];\n    if (val instanceof Tag) val.name = name;\n}\n/**\nThis is a highlighter that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThe following tags are mapped to their name prefixed with `\"tok-\"`\n(for example `\"tok-comment\"`):\n\n* [`link`](#highlight.tags.link)\n* [`heading`](#highlight.tags.heading)\n* [`emphasis`](#highlight.tags.emphasis)\n* [`strong`](#highlight.tags.strong)\n* [`keyword`](#highlight.tags.keyword)\n* [`atom`](#highlight.tags.atom)\n* [`bool`](#highlight.tags.bool)\n* [`url`](#highlight.tags.url)\n* [`labelName`](#highlight.tags.labelName)\n* [`inserted`](#highlight.tags.inserted)\n* [`deleted`](#highlight.tags.deleted)\n* [`literal`](#highlight.tags.literal)\n* [`string`](#highlight.tags.string)\n* [`number`](#highlight.tags.number)\n* [`variableName`](#highlight.tags.variableName)\n* [`typeName`](#highlight.tags.typeName)\n* [`namespace`](#highlight.tags.namespace)\n* [`className`](#highlight.tags.className)\n* [`macroName`](#highlight.tags.macroName)\n* [`propertyName`](#highlight.tags.propertyName)\n* [`operator`](#highlight.tags.operator)\n* [`comment`](#highlight.tags.comment)\n* [`meta`](#highlight.tags.meta)\n* [`punctuation`](#highlight.tags.punctuation)\n* [`invalid`](#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](#highlight.tags.regexp),\n  [`escape`](#highlight.tags.escape), and\n  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n  are mapped to `\"tok-string2\"`\n* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName2\"`\n* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-local\"`\n* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-definition\"`\n* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n  to `\"tok-propertyName tok-definition\"`\n*/ const classHighlighter = tagHighlighter([\n    {\n        tag: tags.link,\n        class: \"tok-link\"\n    },\n    {\n        tag: tags.heading,\n        class: \"tok-heading\"\n    },\n    {\n        tag: tags.emphasis,\n        class: \"tok-emphasis\"\n    },\n    {\n        tag: tags.strong,\n        class: \"tok-strong\"\n    },\n    {\n        tag: tags.keyword,\n        class: \"tok-keyword\"\n    },\n    {\n        tag: tags.atom,\n        class: \"tok-atom\"\n    },\n    {\n        tag: tags.bool,\n        class: \"tok-bool\"\n    },\n    {\n        tag: tags.url,\n        class: \"tok-url\"\n    },\n    {\n        tag: tags.labelName,\n        class: \"tok-labelName\"\n    },\n    {\n        tag: tags.inserted,\n        class: \"tok-inserted\"\n    },\n    {\n        tag: tags.deleted,\n        class: \"tok-deleted\"\n    },\n    {\n        tag: tags.literal,\n        class: \"tok-literal\"\n    },\n    {\n        tag: tags.string,\n        class: \"tok-string\"\n    },\n    {\n        tag: tags.number,\n        class: \"tok-number\"\n    },\n    {\n        tag: [\n            tags.regexp,\n            tags.escape,\n            tags.special(tags.string)\n        ],\n        class: \"tok-string2\"\n    },\n    {\n        tag: tags.variableName,\n        class: \"tok-variableName\"\n    },\n    {\n        tag: tags.local(tags.variableName),\n        class: \"tok-variableName tok-local\"\n    },\n    {\n        tag: tags.definition(tags.variableName),\n        class: \"tok-variableName tok-definition\"\n    },\n    {\n        tag: tags.special(tags.variableName),\n        class: \"tok-variableName2\"\n    },\n    {\n        tag: tags.definition(tags.propertyName),\n        class: \"tok-propertyName tok-definition\"\n    },\n    {\n        tag: tags.typeName,\n        class: \"tok-typeName\"\n    },\n    {\n        tag: tags.namespace,\n        class: \"tok-namespace\"\n    },\n    {\n        tag: tags.className,\n        class: \"tok-className\"\n    },\n    {\n        tag: tags.macroName,\n        class: \"tok-macroName\"\n    },\n    {\n        tag: tags.propertyName,\n        class: \"tok-propertyName\"\n    },\n    {\n        tag: tags.operator,\n        class: \"tok-operator\"\n    },\n    {\n        tag: tags.comment,\n        class: \"tok-comment\"\n    },\n    {\n        tag: tags.meta,\n        class: \"tok-meta\"\n    },\n    {\n        tag: tags.invalid,\n        class: \"tok-invalid\"\n    },\n    {\n        tag: tags.punctuation,\n        class: \"tok-punctuation\"\n    }\n]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF5QztBQUV6QyxJQUFJQyxZQUFZO0FBQ2hCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsR0FDQSxNQUFNQztJQUNGOztJQUVBLEdBQ0FDLFlBQ0E7O0lBRUEsR0FDQUMsSUFBSSxFQUNKOzs7SUFHQSxHQUNBQyxHQUFHLEVBQ0g7OztJQUdBLEdBQ0FDLElBQUksRUFDSjs7SUFFQSxHQUNBQyxRQUFRLENBQUU7UUFDTixJQUFJLENBQUNILElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFDaEI7O1FBRUEsR0FDQSxJQUFJLENBQUNDLEVBQUUsR0FBR1A7SUFDZDtJQUNBUSxXQUFXO1FBQ1AsSUFBSSxFQUFFTCxJQUFJLEVBQUUsR0FBRyxJQUFJO1FBQ25CLEtBQUssSUFBSU0sT0FBTyxJQUFJLENBQUNILFFBQVEsQ0FDekIsSUFBSUcsSUFBSU4sSUFBSSxFQUNSQSxPQUFPLENBQUMsRUFBRU0sSUFBSU4sSUFBSSxDQUFDLENBQUMsRUFBRUEsS0FBSyxDQUFDLENBQUM7UUFDckMsT0FBT0E7SUFDWDtJQUNBLE9BQU9PLE9BQU9DLFlBQVksRUFBRUMsTUFBTSxFQUFFO1FBQ2hDLElBQUlULE9BQU8sT0FBT1EsZ0JBQWdCLFdBQVdBLGVBQWU7UUFDNUQsSUFBSUEsd0JBQXdCVixLQUN4QlcsU0FBU0Q7UUFDYixJQUFJQyxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT1AsSUFBSSxFQUMzRCxNQUFNLElBQUlRLE1BQU07UUFDcEIsSUFBSUMsTUFBTSxJQUFJYixJQUFJRSxNQUFNLEVBQUUsRUFBRSxNQUFNLEVBQUU7UUFDcENXLElBQUlWLEdBQUcsQ0FBQ1csSUFBSSxDQUFDRDtRQUNi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QUUzRCxPQUFPO0lBQWU7SUFDNUM7UUFBRWxFLEtBQUttQyxLQUFLOEcsU0FBUztRQUFFL0UsT0FBTztJQUFnQjtJQUM5QztRQUFFbEUsS0FBS21DLEtBQUs0RyxTQUFTO1FBQUU3RSxPQUFPO0lBQWdCO0lBQzlDO1FBQUVsRSxLQUFLbUMsS0FBSytHLFNBQVM7UUFBRWhGLE9BQU87SUFBZ0I7SUFDOUM7UUFBRWxFLEtBQUttQyxLQUFLMkYsWUFBWTtRQUFFNUQsT0FBTztJQUFtQjtJQUNwRDtRQUFFbEUsS0FBS21DLEtBQUtrRyxRQUFRO1FBQUVuRSxPQUFPO0lBQWU7SUFDNUM7UUFBRWxFLEtBQUttQyxLQUFLeUYsT0FBTztRQUFFMUQsT0FBTztJQUFjO0lBQzFDO1FBQUVsRSxLQUFLbUMsS0FBS3FHLElBQUk7UUFBRXRFLE9BQU87SUFBVztJQUNwQztRQUFFbEUsS0FBS21DLEtBQUtrSyxPQUFPO1FBQUVuSSxPQUFPO0lBQWM7SUFDMUM7UUFBRWxFLEtBQUttQyxLQUFLbUcsV0FBVztRQUFFcEUsT0FBTztJQUFrQjtDQUNyRDtBQUU2RyIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2tuaWNoZS8uL25vZGVfbW9kdWxlcy9AbGV6ZXIvaGlnaGxpZ2h0L2Rpc3QvaW5kZXguanM/ZjI5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlUHJvcCB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG5sZXQgbmV4dFRhZ0lEID0gMDtcbi8qKlxuSGlnaGxpZ2h0aW5nIHRhZ3MgYXJlIG1hcmtlcnMgdGhhdCBkZW5vdGUgYSBoaWdobGlnaHRpbmcgY2F0ZWdvcnkuXG5UaGV5IGFyZSBbYXNzb2NpYXRlZF0oI2hpZ2hsaWdodC5zdHlsZVRhZ3MpIHdpdGggcGFydHMgb2YgYSBzeW50YXhcbnRyZWUgYnkgYSBsYW5ndWFnZSBtb2RlLCBhbmQgdGhlbiBtYXBwZWQgdG8gYW4gYWN0dWFsIENTUyBzdHlsZSBieVxuYSBbaGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLlxuXG5CZWNhdXNlIHN5bnRheCB0cmVlIG5vZGUgdHlwZXMgYW5kIGhpZ2hsaWdodCBzdHlsZXMgaGF2ZSB0byBiZVxuYWJsZSB0byB0YWxrIHRoZSBzYW1lIGxhbmd1YWdlLCBDb2RlTWlycm9yIHVzZXMgYSBtb3N0bHkgX2Nsb3NlZF9cblt2b2NhYnVsYXJ5XSgjaGlnaGxpZ2h0LnRhZ3MpIG9mIHN5bnRheCB0YWdzIChhcyBvcHBvc2VkIHRvXG50cmFkaXRpb25hbCBvcGVuIHN0cmluZy1iYXNlZCBzeXN0ZW1zLCB3aGljaCBtYWtlIGl0IGhhcmQgZm9yXG5oaWdobGlnaHRpbmcgdGhlbWVzIHRvIGNvdmVyIGFsbCB0aGUgdG9rZW5zIHByb2R1Y2VkIGJ5IHRoZVxudmFyaW91cyBsYW5ndWFnZXMpLlxuXG5JdCBfaXNfIHBvc3NpYmxlIHRvIFtkZWZpbmVdKCNoaWdobGlnaHQuVGFnXmRlZmluZSkgeW91ciBvd25cbmhpZ2hsaWdodGluZyB0YWdzIGZvciBzeXN0ZW0taW50ZXJuYWwgdXNlICh3aGVyZSB5b3UgY29udHJvbCBib3RoXG50aGUgbGFuZ3VhZ2UgcGFja2FnZSBhbmQgdGhlIGhpZ2hsaWdodGVyKSwgYnV0IHN1Y2ggdGFncyB3aWxsIG5vdFxuYmUgcGlja2VkIHVwIGJ5IHJlZ3VsYXIgaGlnaGxpZ2h0ZXJzICh0aG91Z2ggeW91IGNhbiBkZXJpdmUgdGhlbVxuZnJvbSBzdGFuZGFyZCB0YWdzIHRvIGFsbG93IGhpZ2hsaWdodGVycyB0byBmYWxsIGJhY2sgdG8gdGhvc2UpLlxuKi9cbmNsYXNzIFRhZyB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgb3B0aW9uYWwgbmFtZSBvZiB0aGUgYmFzZSB0YWcgQGludGVybmFsXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBUaGUgc2V0IG9mIHRoaXMgdGFnIGFuZCBhbGwgaXRzIHBhcmVudCB0YWdzLCBzdGFydGluZyB3aXRoXG4gICAgdGhpcyBvbmUgaXRzZWxmIGFuZCBzb3J0ZWQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZyBzcGVjaWZpY2l0eS5cbiAgICAqL1xuICAgIHNldCwgXG4gICAgLyoqXG4gICAgVGhlIGJhc2UgdW5tb2RpZmllZCB0YWcgdGhhdCB0aGlzIG9uZSBpcyBiYXNlZCBvbiwgaWYgaXQnc1xuICAgIG1vZGlmaWVkIEBpbnRlcm5hbFxuICAgICovXG4gICAgYmFzZSwgXG4gICAgLyoqXG4gICAgVGhlIG1vZGlmaWVycyBhcHBsaWVkIHRvIHRoaXMuYmFzZSBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1vZGlmaWVkKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLm1vZGlmaWVkID0gbW9kaWZpZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG5leHRUYWdJRCsrO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHsgbmFtZSB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgbW9kIG9mIHRoaXMubW9kaWZpZWQpXG4gICAgICAgICAgICBpZiAobW9kLm5hbWUpXG4gICAgICAgICAgICAgICAgbmFtZSA9IGAke21vZC5uYW1lfSgke25hbWV9KWA7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmaW5lKG5hbWVPclBhcmVudCwgcGFyZW50KSB7XG4gICAgICAgIGxldCBuYW1lID0gdHlwZW9mIG5hbWVPclBhcmVudCA9PSBcInN0cmluZ1wiID8gbmFtZU9yUGFyZW50IDogXCI/XCI7XG4gICAgICAgIGlmIChuYW1lT3JQYXJlbnQgaW5zdGFuY2VvZiBUYWcpXG4gICAgICAgICAgICBwYXJlbnQgPSBuYW1lT3JQYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuYmFzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGVyaXZlIGZyb20gYSBtb2RpZmllZCB0YWdcIik7XG4gICAgICAgIGxldCB0YWcgPSBuZXcgVGFnKG5hbWUsIFtdLCBudWxsLCBbXSk7XG4gICAgICAgIHRhZy5zZXQucHVzaCh0YWcpO1xuICAgICAgICBpZiAocGFyZW50KVxuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiBwYXJlbnQuc2V0KVxuICAgICAgICAgICAgICAgIHRhZy5zZXQucHVzaCh0KTtcbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgdGFnIF9tb2RpZmllcl8sIHdoaWNoIGlzIGEgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYSB0YWcsXG4gICAgd2lsbCByZXR1cm4gYSB0YWcgdGhhdCBpcyBhIHN1YnRhZyBvZiB0aGUgb3JpZ2luYWwuIEFwcGx5aW5nIHRoZVxuICAgIHNhbWUgbW9kaWZpZXIgdG8gYSB0d2ljZSB0YWcgd2lsbCByZXR1cm4gdGhlIHNhbWUgdmFsdWUgKGBtMSh0MSlcbiAgICA9PSBtMSh0MSlgKSBhbmQgYXBwbHlpbmcgbXVsdGlwbGUgbW9kaWZpZXJzIHdpbGwsIHJlZ2FyZGxlc3Mgb3JcbiAgICBvcmRlciwgcHJvZHVjZSB0aGUgc2FtZSB0YWcgKGBtMShtMih0MSkpID09IG0yKG0xKHQxKSlgKS5cbiAgICBcbiAgICBXaGVuIG11bHRpcGxlIG1vZGlmaWVycyBhcmUgYXBwbGllZCB0byBhIGdpdmVuIGJhc2UgdGFnLCBlYWNoXG4gICAgc21hbGxlciBzZXQgb2YgbW9kaWZpZXJzIGlzIHJlZ2lzdGVyZWQgYXMgYSBwYXJlbnQsIHNvIHRoYXQgZm9yXG4gICAgZXhhbXBsZSBgbTEobTIobTModDEpKSlgIGlzIGEgc3VidHlwZSBvZiBgbTEobTIodDEpKWAsXG4gICAgYG0xKG0zKHQxKWAsIGFuZCBzbyBvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmVNb2RpZmllcihuYW1lKSB7XG4gICAgICAgIGxldCBtb2QgPSBuZXcgTW9kaWZpZXIobmFtZSk7XG4gICAgICAgIHJldHVybiAodGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFnLm1vZGlmaWVkLmluZGV4T2YobW9kKSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgICAgICByZXR1cm4gTW9kaWZpZXIuZ2V0KHRhZy5iYXNlIHx8IHRhZywgdGFnLm1vZGlmaWVkLmNvbmNhdChtb2QpLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKSk7XG4gICAgICAgIH07XG4gICAgfVxufVxubGV0IG5leHRNb2RpZmllcklEID0gMDtcbmNsYXNzIE1vZGlmaWVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gW107XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0TW9kaWZpZXJJRCsrO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KGJhc2UsIG1vZHMpIHtcbiAgICAgICAgaWYgKCFtb2RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICBsZXQgZXhpc3RzID0gbW9kc1swXS5pbnN0YW5jZXMuZmluZCh0ID0+IHQuYmFzZSA9PSBiYXNlICYmIHNhbWVBcnJheShtb2RzLCB0Lm1vZGlmaWVkKSk7XG4gICAgICAgIGlmIChleGlzdHMpXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RzO1xuICAgICAgICBsZXQgc2V0ID0gW10sIHRhZyA9IG5ldyBUYWcoYmFzZS5uYW1lLCBzZXQsIGJhc2UsIG1vZHMpO1xuICAgICAgICBmb3IgKGxldCBtIG9mIG1vZHMpXG4gICAgICAgICAgICBtLmluc3RhbmNlcy5wdXNoKHRhZyk7XG4gICAgICAgIGxldCBjb25maWdzID0gcG93ZXJTZXQobW9kcyk7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCBvZiBiYXNlLnNldClcbiAgICAgICAgICAgIGlmICghcGFyZW50Lm1vZGlmaWVkLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncylcbiAgICAgICAgICAgICAgICAgICAgc2V0LnB1c2goTW9kaWZpZXIuZ2V0KHBhcmVudCwgY29uZmlnKSk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoeCwgaSkgPT4geCA9PSBiW2ldKTtcbn1cbmZ1bmN0aW9uIHBvd2VyU2V0KGFycmF5KSB7XG4gICAgbGV0IHNldHMgPSBbW11dO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGUgPSBzZXRzLmxlbmd0aDsgaiA8IGU7IGorKykge1xuICAgICAgICAgICAgc2V0cy5wdXNoKHNldHNbal0uY29uY2F0KGFycmF5W2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNldHMuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7XG59XG4vKipcblRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhZGQgYSBzZXQgb2YgdGFncyB0byBhIGxhbmd1YWdlIHN5bnRheFxudmlhIFtgTm9kZVNldC5leHRlbmRgXSgjY29tbW9uLk5vZGVTZXQuZXh0ZW5kKSBvclxuW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuTFJQYXJzZXIuY29uZmlndXJlKS5cblxuVGhlIGFyZ3VtZW50IG9iamVjdCBtYXBzIG5vZGUgc2VsZWN0b3JzIHRvIFtoaWdobGlnaHRpbmdcbnRhZ3NdKCNoaWdobGlnaHQuVGFnKSBvciBhcnJheXMgb2YgdGFncy5cblxuTm9kZSBzZWxlY3RvcnMgbWF5IGhvbGQgb25lIG9yIG1vcmUgKHNwYWNlLXNlcGFyYXRlZCkgbm9kZSBwYXRocy5cblN1Y2ggYSBwYXRoIGNhbiBiZSBhIFtub2RlIG5hbWVdKCNjb21tb24uTm9kZVR5cGUubmFtZSksIG9yXG5tdWx0aXBsZSBub2RlIG5hbWVzIChvciBgKmAgd2lsZGNhcmRzKSBzZXBhcmF0ZWQgYnkgc2xhc2hcbmNoYXJhY3RlcnMsIGFzIGluIGBcIkJsb2NrL0RlY2xhcmF0aW9uL1ZhcmlhYmxlTmFtZVwiYC4gU3VjaCBhIHBhdGhcbm1hdGNoZXMgdGhlIGZpbmFsIG5vZGUgYnV0IG9ubHkgaWYgaXRzIGRpcmVjdCBwYXJlbnQgbm9kZXMgYXJlIHRoZVxub3RoZXIgbm9kZXMgbWVudGlvbmVkLiBBIGAqYCBpbiBzdWNoIGEgcGF0aCBtYXRjaGVzIGFueSBwYXJlbnQsXG5idXQgb25seSBhIHNpbmdsZSBsZXZlbOKAlHdpbGRjYXJkcyB0aGF0IG1hdGNoIG11bHRpcGxlIHBhcmVudHNcbmFyZW4ndCBzdXBwb3J0ZWQsIGJvdGggZm9yIGVmZmljaWVuY3kgcmVhc29ucyBhbmQgYmVjYXVzZSBMZXplclxudHJlZXMgbWFrZSBpdCByYXRoZXIgaGFyZCB0byByZWFzb24gYWJvdXQgd2hhdCB0aGV5IHdvdWxkIG1hdGNoLilcblxuQSBwYXRoIGNhbiBiZSBlbmRlZCB3aXRoIGAvLi4uYCB0byBpbmRpY2F0ZSB0aGF0IHRoZSB0YWcgYXNzaWduZWRcbnRvIHRoZSBub2RlIHNob3VsZCBhbHNvIGFwcGx5IHRvIGFsbCBjaGlsZCBub2RlcywgZXZlbiBpZiB0aGV5XG5tYXRjaCB0aGVpciBvd24gc3R5bGUgKGJ5IGRlZmF1bHQsIG9ubHkgdGhlIGlubmVybW9zdCBzdHlsZSBpc1xudXNlZCkuXG5cbldoZW4gYSBwYXRoIGVuZHMgaW4gYCFgLCBhcyBpbiBgQXR0cmlidXRlIWAsIG5vIGZ1cnRoZXIgbWF0Y2hpbmdcbmhhcHBlbnMgZm9yIHRoZSBub2RlJ3MgY2hpbGQgbm9kZXMsIGFuZCB0aGUgZW50aXJlIG5vZGUgZ2V0cyB0aGVcbmdpdmVuIHN0eWxlLlxuXG5JbiB0aGlzIG5vdGF0aW9uLCBub2RlIG5hbWVzIHRoYXQgY29udGFpbiBgL2AsIGAhYCwgYCpgLCBvciBgLi4uYFxubXVzdCBiZSBxdW90ZWQgYXMgSlNPTiBzdHJpbmdzLlxuXG5Gb3IgZXhhbXBsZTpcblxuYGBgamF2YXNjcmlwdFxucGFyc2VyLndpdGhQcm9wcyhcbiAgc3R5bGVUYWdzKHtcbiAgICAvLyBTdHlsZSBOdW1iZXIgYW5kIEJpZ051bWJlciBub2Rlc1xuICAgIFwiTnVtYmVyIEJpZ051bWJlclwiOiB0YWdzLm51bWJlcixcbiAgICAvLyBTdHlsZSBFc2NhcGUgbm9kZXMgd2hvc2UgcGFyZW50IGlzIFN0cmluZ1xuICAgIFwiU3RyaW5nL0VzY2FwZVwiOiB0YWdzLmVzY2FwZSxcbiAgICAvLyBTdHlsZSBhbnl0aGluZyBpbnNpZGUgQXR0cmlidXRlcyBub2Rlc1xuICAgIFwiQXR0cmlidXRlcyFcIjogdGFncy5tZXRhLFxuICAgIC8vIEFkZCBhIHN0eWxlIHRvIGFsbCBjb250ZW50IGluc2lkZSBJdGFsaWMgbm9kZXNcbiAgICBcIkl0YWxpYy8uLi5cIjogdGFncy5lbXBoYXNpcyxcbiAgICAvLyBTdHlsZSBJbnZhbGlkU3RyaW5nIG5vZGVzIGFzIGJvdGggYHN0cmluZ2AgYW5kIGBpbnZhbGlkYFxuICAgIFwiSW52YWxpZFN0cmluZ1wiOiBbdGFncy5zdHJpbmcsIHRhZ3MuaW52YWxpZF0sXG4gICAgLy8gU3R5bGUgdGhlIG5vZGUgbmFtZWQgXCIvXCIgYXMgcHVuY3R1YXRpb25cbiAgICAnXCIvXCInOiB0YWdzLnB1bmN0dWF0aW9uXG4gIH0pXG4pXG5gYGBcbiovXG5mdW5jdGlvbiBzdHlsZVRhZ3Moc3BlYykge1xuICAgIGxldCBieU5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHByb3AgaW4gc3BlYykge1xuICAgICAgICBsZXQgdGFncyA9IHNwZWNbcHJvcF07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWdzKSlcbiAgICAgICAgICAgIHRhZ3MgPSBbdGFnc107XG4gICAgICAgIGZvciAobGV0IHBhcnQgb2YgcHJvcC5zcGxpdChcIiBcIikpXG4gICAgICAgICAgICBpZiAocGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBwaWVjZXMgPSBbXSwgbW9kZSA9IDIgLyogTW9kZS5Ob3JtYWwgKi8sIHJlc3QgPSBwYXJ0O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdCA9PSBcIi4uLlwiICYmIHBvcyA+IDAgJiYgcG9zICsgMyA9PSBwYXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDEgLyogTW9kZS5Jbmhlcml0ICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSAvXlwiKD86W15cIlxcXFxdfFxcXFwuKSo/XCJ8W15cXC8hXSsvLmV4ZWMocmVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICBwaWVjZXMucHVzaChtWzBdID09IFwiKlwiID8gXCJcIiA6IG1bMF1bMF0gPT0gJ1wiJyA/IEpTT04ucGFyc2UobVswXSkgOiBtWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHBhcnQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcGFydFtwb3MrK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gcGFydC5sZW5ndGggJiYgbmV4dCA9PSBcIiFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZSA9IDAgLyogTW9kZS5PcGFxdWUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBcIi9cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gcGFydC5zbGljZShwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IHBpZWNlcy5sZW5ndGggLSAxLCBpbm5lciA9IHBpZWNlc1tsYXN0XTtcbiAgICAgICAgICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBwYXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgcnVsZSA9IG5ldyBSdWxlKHRhZ3MsIG1vZGUsIGxhc3QgPiAwID8gcGllY2VzLnNsaWNlKDAsIGxhc3QpIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgYnlOYW1lW2lubmVyXSA9IHJ1bGUuc29ydChieU5hbWVbaW5uZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ1bGVOb2RlUHJvcC5hZGQoYnlOYW1lKTtcbn1cbmNvbnN0IHJ1bGVOb2RlUHJvcCA9IG5ldyBOb2RlUHJvcCgpO1xuY2xhc3MgUnVsZSB7XG4gICAgY29uc3RydWN0b3IodGFncywgbW9kZSwgY29udGV4dCwgbmV4dCkge1xuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIH1cbiAgICBnZXQgb3BhcXVlKCkgeyByZXR1cm4gdGhpcy5tb2RlID09IDAgLyogTW9kZS5PcGFxdWUgKi87IH1cbiAgICBnZXQgaW5oZXJpdCgpIHsgcmV0dXJuIHRoaXMubW9kZSA9PSAxIC8qIE1vZGUuSW5oZXJpdCAqLzsgfVxuICAgIHNvcnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlciB8fCBvdGhlci5kZXB0aCA8IHRoaXMuZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG90aGVyO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgb3RoZXIubmV4dCA9IHRoaXMuc29ydChvdGhlci5uZXh0KTtcbiAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7IHJldHVybiB0aGlzLmNvbnRleHQgPyB0aGlzLmNvbnRleHQubGVuZ3RoIDogMDsgfVxufVxuUnVsZS5lbXB0eSA9IG5ldyBSdWxlKFtdLCAyIC8qIE1vZGUuTm9ybWFsICovLCBudWxsKTtcbi8qKlxuRGVmaW5lIGEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKSBmcm9tIGFuIGFycmF5IG9mXG50YWcvY2xhc3MgcGFpcnMuIENsYXNzZXMgYXNzb2NpYXRlZCB3aXRoIG1vcmUgc3BlY2lmaWMgdGFncyB3aWxsXG50YWtlIHByZWNlZGVuY2UuXG4qL1xuZnVuY3Rpb24gdGFnSGlnaGxpZ2h0ZXIodGFncywgb3B0aW9ucykge1xuICAgIGxldCBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHN0eWxlIG9mIHRhZ3MpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlLnRhZykpXG4gICAgICAgICAgICBtYXBbc3R5bGUudGFnLmlkXSA9IHN0eWxlLmNsYXNzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgb2Ygc3R5bGUudGFnKVxuICAgICAgICAgICAgICAgIG1hcFt0YWcuaWRdID0gc3R5bGUuY2xhc3M7XG4gICAgfVxuICAgIGxldCB7IHNjb3BlLCBhbGwgPSBudWxsIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0eWxlOiAodGFncykgPT4ge1xuICAgICAgICAgICAgbGV0IGNscyA9IGFsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHRhZy5zZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhZ0NsYXNzID0gbWFwW3N1Yi5pZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xzID0gY2xzID8gY2xzICsgXCIgXCIgKyB0YWdDbGFzcyA6IHRhZ0NsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICB9LFxuICAgICAgICBzY29wZVxuICAgIH07XG59XG5mdW5jdGlvbiBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgdGFncykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZvciAobGV0IGhpZ2hsaWdodGVyIG9mIGhpZ2hsaWdodGVycykge1xuICAgICAgICBsZXQgdmFsdWUgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IaWdobGlnaHQgdGhlIGdpdmVuIFt0cmVlXSgjY29tbW9uLlRyZWUpIHdpdGggdGhlIGdpdmVuXG5baGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpLiBPZnRlbiwgdGhlIGhpZ2hlci1sZXZlbFxuW2BoaWdobGlnaHRDb2RlYF0oI2hpZ2hsaWdodC5oaWdobGlnaHRDb2RlKSBmdW5jdGlvbiBpcyBlYXNpZXIgdG9cbnVzZS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRUcmVlKHRyZWUsIGhpZ2hsaWdodGVyLCBcbi8qKlxuQXNzaWduIHN0eWxpbmcgdG8gYSByZWdpb24gb2YgdGhlIHRleHQuIFdpbGwgYmUgY2FsbGVkLCBpbiBvcmRlclxub2YgcG9zaXRpb24sIGZvciBhbnkgcmFuZ2VzIHdoZXJlIG1vcmUgdGhhbiB6ZXJvIGNsYXNzZXMgYXBwbHkuXG5gY2xhc3Nlc2AgaXMgYSBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIENTUyBjbGFzc2VzLlxuKi9cbnB1dFN0eWxlLCBcbi8qKlxuVGhlIHN0YXJ0IG9mIHRoZSByYW5nZSB0byBoaWdobGlnaHQuXG4qL1xuZnJvbSA9IDAsIFxuLyoqXG5UaGUgZW5kIG9mIHRoZSByYW5nZS5cbiovXG50byA9IHRyZWUubGVuZ3RoKSB7XG4gICAgbGV0IGJ1aWxkZXIgPSBuZXcgSGlnaGxpZ2h0QnVpbGRlcihmcm9tLCBBcnJheS5pc0FycmF5KGhpZ2hsaWdodGVyKSA/IGhpZ2hsaWdodGVyIDogW2hpZ2hsaWdodGVyXSwgcHV0U3R5bGUpO1xuICAgIGJ1aWxkZXIuaGlnaGxpZ2h0UmFuZ2UodHJlZS5jdXJzb3IoKSwgZnJvbSwgdG8sIFwiXCIsIGJ1aWxkZXIuaGlnaGxpZ2h0ZXJzKTtcbiAgICBidWlsZGVyLmZsdXNoKHRvKTtcbn1cbi8qKlxuSGlnaGxpZ2h0IHRoZSBnaXZlbiB0cmVlIHdpdGggdGhlIGdpdmVuIGhpZ2hsaWdodGVyLCBjYWxsaW5nXG5gcHV0VGV4dGAgZm9yIGV2ZXJ5IHBpZWNlIG9mIHRleHQsIGVpdGhlciB3aXRoIGEgc2V0IG9mIGNsYXNzZXMgb3JcbndpdGggdGhlIGVtcHR5IHN0cmluZyB3aGVuIHVuc3R5bGVkLCBhbmQgYHB1dEJyZWFrYCBmb3IgZXZlcnkgbGluZVxuYnJlYWsuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0Q29kZShjb2RlLCB0cmVlLCBoaWdobGlnaHRlciwgcHV0VGV4dCwgcHV0QnJlYWssIGZyb20gPSAwLCB0byA9IGNvZGUubGVuZ3RoKSB7XG4gICAgbGV0IHBvcyA9IGZyb207XG4gICAgZnVuY3Rpb24gd3JpdGVUbyhwLCBjbGFzc2VzKSB7XG4gICAgICAgIGlmIChwIDw9IHBvcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgdGV4dCA9IGNvZGUuc2xpY2UocG9zLCBwKSwgaSA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG5leHRCcmVhayA9IHRleHQuaW5kZXhPZihcIlxcblwiLCBpKTtcbiAgICAgICAgICAgIGxldCB1cHRvID0gbmV4dEJyZWFrIDwgMCA/IHRleHQubGVuZ3RoIDogbmV4dEJyZWFrO1xuICAgICAgICAgICAgaWYgKHVwdG8gPiBpKVxuICAgICAgICAgICAgICAgIHB1dFRleHQodGV4dC5zbGljZShpLCB1cHRvKSwgY2xhc3Nlcyk7XG4gICAgICAgICAgICBpZiAobmV4dEJyZWFrIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHB1dEJyZWFrKCk7XG4gICAgICAgICAgICBpID0gbmV4dEJyZWFrICsgMTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSBwO1xuICAgIH1cbiAgICBoaWdobGlnaHRUcmVlKHRyZWUsIGhpZ2hsaWdodGVyLCAoZnJvbSwgdG8sIGNsYXNzZXMpID0+IHtcbiAgICAgICAgd3JpdGVUbyhmcm9tLCBcIlwiKTtcbiAgICAgICAgd3JpdGVUbyh0bywgY2xhc3Nlcyk7XG4gICAgfSwgZnJvbSwgdG8pO1xuICAgIHdyaXRlVG8odG8sIFwiXCIpO1xufVxuY2xhc3MgSGlnaGxpZ2h0QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoYXQsIGhpZ2hsaWdodGVycywgc3Bhbikge1xuICAgICAgICB0aGlzLmF0ID0gYXQ7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZXJzID0gaGlnaGxpZ2h0ZXJzO1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICB0aGlzLmNsYXNzID0gXCJcIjtcbiAgICB9XG4gICAgc3RhcnRTcGFuKGF0LCBjbHMpIHtcbiAgICAgICAgaWYgKGNscyAhPSB0aGlzLmNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKGF0KTtcbiAgICAgICAgICAgIGlmIChhdCA+IHRoaXMuYXQpXG4gICAgICAgICAgICAgICAgdGhpcy5hdCA9IGF0O1xuICAgICAgICAgICAgdGhpcy5jbGFzcyA9IGNscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmbHVzaCh0bykge1xuICAgICAgICBpZiAodG8gPiB0aGlzLmF0ICYmIHRoaXMuY2xhc3MpXG4gICAgICAgICAgICB0aGlzLnNwYW4odGhpcy5hdCwgdG8sIHRoaXMuY2xhc3MpO1xuICAgIH1cbiAgICBoaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGxldCB7IHR5cGUsIGZyb206IHN0YXJ0LCB0bzogZW5kIH0gPSBjdXJzb3I7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGUuaXNUb3ApXG4gICAgICAgICAgICBoaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKHR5cGUpKTtcbiAgICAgICAgbGV0IGNscyA9IGluaGVyaXRlZENsYXNzO1xuICAgICAgICBsZXQgcnVsZSA9IGdldFN0eWxlVGFncyhjdXJzb3IpIHx8IFJ1bGUuZW1wdHk7XG4gICAgICAgIGxldCB0YWdDbHMgPSBoaWdobGlnaHRUYWdzKGhpZ2hsaWdodGVycywgcnVsZS50YWdzKTtcbiAgICAgICAgaWYgKHRhZ0Nscykge1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBjbHMgKz0gXCIgXCI7XG4gICAgICAgICAgICBjbHMgKz0gdGFnQ2xzO1xuICAgICAgICAgICAgaWYgKHJ1bGUubW9kZSA9PSAxIC8qIE1vZGUuSW5oZXJpdCAqLylcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWRDbGFzcyArPSAoaW5oZXJpdGVkQ2xhc3MgPyBcIiBcIiA6IFwiXCIpICsgdGFnQ2xzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWF4KGZyb20sIHN0YXJ0KSwgY2xzKTtcbiAgICAgICAgaWYgKHJ1bGUub3BhcXVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbW91bnRlZCA9IGN1cnNvci50cmVlICYmIGN1cnNvci50cmVlLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgIGlmIChtb3VudGVkICYmIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gY3Vyc29yLm5vZGUuZW50ZXIobW91bnRlZC5vdmVybGF5WzBdLmZyb20gKyBzdGFydCwgMSk7XG4gICAgICAgICAgICBsZXQgaW5uZXJIaWdobGlnaHRlcnMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoaCA9PiAhaC5zY29wZSB8fCBoLnNjb3BlKG1vdW50ZWQudHJlZS50eXBlKSk7XG4gICAgICAgICAgICBsZXQgaGFzQ2hpbGQgPSBjdXJzb3IuZmlyc3RDaGlsZCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBpIDwgbW91bnRlZC5vdmVybGF5Lmxlbmd0aCA/IG1vdW50ZWQub3ZlcmxheVtpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRQb3MgPSBuZXh0ID8gbmV4dC5mcm9tICsgc3RhcnQgOiBlbmQ7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyksIHJhbmdlVG8gPSBNYXRoLm1pbih0bywgbmV4dFBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlRnJvbSA8IHJhbmdlVG8gJiYgaGFzQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnNvci5mcm9tIDwgcmFuZ2VUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIHJhbmdlRnJvbSwgcmFuZ2VUbywgaW5oZXJpdGVkQ2xhc3MsIGhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbihyYW5nZVRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBuZXh0UG9zIHx8ICFjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dFBvcyA+IHRvKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgc3RhcnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShpbm5lci5jdXJzb3IoKSwgTWF0aC5tYXgoZnJvbSwgbmV4dC5mcm9tICsgc3RhcnQpLCBNYXRoLm1pbih0bywgcG9zKSwgXCJcIiwgaW5uZXJIaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgcG9zKSwgY2xzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQ2hpbGQpXG4gICAgICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnNvci5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgIGlmIChtb3VudGVkKVxuICAgICAgICAgICAgICAgIGluaGVyaXRlZENsYXNzID0gXCJcIjtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnRvIDw9IGZyb20pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IuZnJvbSA+PSB0bylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShjdXJzb3IsIGZyb20sIHRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbih0bywgY3Vyc29yLnRvKSwgY2xzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnNvci5uZXh0U2libGluZygpKTtcbiAgICAgICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuTWF0Y2ggYSBzeW50YXggbm9kZSdzIFtoaWdobGlnaHQgcnVsZXNdKCNoaWdobGlnaHQuc3R5bGVUYWdzKS4gSWZcbnRoZXJlJ3MgYSBtYXRjaCwgcmV0dXJuIGl0cyBzZXQgb2YgdGFncywgYW5kIHdoZXRoZXIgaXQgaXNcbm9wYXF1ZSAodXNlcyBhIGAhYCkgb3IgYXBwbGllcyB0byBhbGwgY2hpbGQgbm9kZXMgKGAvLi4uYCkuXG4qL1xuZnVuY3Rpb24gZ2V0U3R5bGVUYWdzKG5vZGUpIHtcbiAgICBsZXQgcnVsZSA9IG5vZGUudHlwZS5wcm9wKHJ1bGVOb2RlUHJvcCk7XG4gICAgd2hpbGUgKHJ1bGUgJiYgcnVsZS5jb250ZXh0ICYmICFub2RlLm1hdGNoQ29udGV4dChydWxlLmNvbnRleHQpKVxuICAgICAgICBydWxlID0gcnVsZS5uZXh0O1xuICAgIHJldHVybiBydWxlIHx8IG51bGw7XG59XG5jb25zdCB0ID0gVGFnLmRlZmluZTtcbmNvbnN0IGNvbW1lbnQgPSB0KCksIG5hbWUgPSB0KCksIHR5cGVOYW1lID0gdChuYW1lKSwgcHJvcGVydHlOYW1lID0gdChuYW1lKSwgbGl0ZXJhbCA9IHQoKSwgc3RyaW5nID0gdChsaXRlcmFsKSwgbnVtYmVyID0gdChsaXRlcmFsKSwgY29udGVudCA9IHQoKSwgaGVhZGluZyA9IHQoY29udGVudCksIGtleXdvcmQgPSB0KCksIG9wZXJhdG9yID0gdCgpLCBwdW5jdHVhdGlvbiA9IHQoKSwgYnJhY2tldCA9IHQocHVuY3R1YXRpb24pLCBtZXRhID0gdCgpO1xuLyoqXG5UaGUgZGVmYXVsdCBzZXQgb2YgaGlnaGxpZ2h0aW5nIFt0YWdzXSgjaGlnaGxpZ2h0LlRhZykuXG5cblRoaXMgY29sbGVjdGlvbiBpcyBoZWF2aWx5IGJpYXNlZCB0b3dhcmRzIHByb2dyYW1taW5nIGxhbmd1YWdlcyxcbmFuZCBuZWNlc3NhcmlseSBpbmNvbXBsZXRlLiBBIGZ1bGwgb250b2xvZ3kgb2Ygc3ludGFjdGljXG5jb25zdHJ1Y3RzIHdvdWxkIGZpbGwgYSBzdGFjayBvZiBib29rcywgYW5kIGJlIGltcHJhY3RpY2FsIHRvXG53cml0ZSB0aGVtZXMgZm9yLiBTbyB0cnkgdG8gbWFrZSBkbyB3aXRoIHRoaXMgc2V0LiBJZiBhbGwgZWxzZVxuZmFpbHMsIFtvcGVuIGFuXG5pc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvY29kZW1pcnJvci5uZXh0KSB0byBwcm9wb3NlIGFcbm5ldyB0YWcsIG9yIFtkZWZpbmVdKCNoaWdobGlnaHQuVGFnXmRlZmluZSkgYSBsb2NhbCBjdXN0b20gdGFnIGZvclxueW91ciB1c2UgY2FzZS5cblxuTm90ZSB0aGF0IGl0IGlzIG5vdCBvYmxpZ2F0b3J5IHRvIGFsd2F5cyBhdHRhY2ggdGhlIG1vc3Qgc3BlY2lmaWNcbnRhZyBwb3NzaWJsZSB0byBhbiBlbGVtZW504oCUaWYgeW91ciBncmFtbWFyIGNhbid0IGVhc2lseVxuZGlzdGluZ3Vpc2ggYSBjZXJ0YWluIHR5cGUgb2YgZWxlbWVudCAoc3VjaCBhcyBhIGxvY2FsIHZhcmlhYmxlKSxcbml0IGlzIG9rYXkgdG8gc3R5bGUgaXQgYXMgaXRzIG1vcmUgZ2VuZXJhbCB2YXJpYW50IChhIHZhcmlhYmxlKS5cblxuRm9yIHRhZ3MgdGhhdCBleHRlbmQgc29tZSBwYXJlbnQgdGFnLCB0aGUgZG9jdW1lbnRhdGlvbiBsaW5rcyB0b1xudGhlIHBhcmVudC5cbiovXG5jb25zdCB0YWdzID0ge1xuICAgIC8qKlxuICAgIEEgY29tbWVudC5cbiAgICAqL1xuICAgIGNvbW1lbnQsXG4gICAgLyoqXG4gICAgQSBsaW5lIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBsaW5lQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBIGJsb2NrIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBibG9ja0NvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQSBkb2N1bWVudGF0aW9uIFtjb21tZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudCkuXG4gICAgKi9cbiAgICBkb2NDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEFueSBraW5kIG9mIGlkZW50aWZpZXIuXG4gICAgKi9cbiAgICBuYW1lLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgdmFyaWFibGUuXG4gICAgKi9cbiAgICB2YXJpYWJsZU5hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSB0eXBlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICB0eXBlTmFtZTogdHlwZU5hbWUsXG4gICAgLyoqXG4gICAgQSB0YWcgbmFtZSAoc3VidGFnIG9mIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpKS5cbiAgICAqL1xuICAgIHRhZ05hbWU6IHQodHlwZU5hbWUpLFxuICAgIC8qKlxuICAgIEEgcHJvcGVydHkgb3IgZmllbGQgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIHByb3BlcnR5TmFtZTogcHJvcGVydHlOYW1lLFxuICAgIC8qKlxuICAgIEFuIGF0dHJpYnV0ZSBuYW1lIChzdWJ0YWcgb2YgW2Bwcm9wZXJ0eU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSkuXG4gICAgKi9cbiAgICBhdHRyaWJ1dGVOYW1lOiB0KHByb3BlcnR5TmFtZSksXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBjbGFzcy5cbiAgICAqL1xuICAgIGNsYXNzTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIGxhYmVsIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICAgKi9cbiAgICBsYWJlbE5hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBuYW1lc3BhY2UgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIG5hbWVzcGFjZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIG1hY3JvLlxuICAgICovXG4gICAgbWFjcm9OYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbGl0ZXJhbCB2YWx1ZS5cbiAgICAqL1xuICAgIGxpdGVyYWwsXG4gICAgLyoqXG4gICAgQSBzdHJpbmcgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHN0cmluZyxcbiAgICAvKipcbiAgICBBIGRvY3VtZW50YXRpb24gW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykuXG4gICAgKi9cbiAgICBkb2NTdHJpbmc6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBIGNoYXJhY3RlciBsaXRlcmFsIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgICovXG4gICAgY2hhcmFjdGVyOiB0KHN0cmluZyksXG4gICAgLyoqXG4gICAgQW4gYXR0cmlidXRlIHZhbHVlIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAgICovXG4gICAgYXR0cmlidXRlVmFsdWU6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBIG51bWJlciBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgbnVtYmVyLFxuICAgIC8qKlxuICAgIEFuIGludGVnZXIgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICAqL1xuICAgIGludGVnZXI6IHQobnVtYmVyKSxcbiAgICAvKipcbiAgICBBIGZsb2F0aW5nLXBvaW50IFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICAgKi9cbiAgICBmbG9hdDogdChudW1iZXIpLFxuICAgIC8qKlxuICAgIEEgYm9vbGVhbiBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgYm9vbDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBSZWd1bGFyIGV4cHJlc3Npb24gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHJlZ2V4cDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBbiBlc2NhcGUgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKSwgZm9yIGV4YW1wbGUgYVxuICAgIGJhY2tzbGFzaCBlc2NhcGUgaW4gYSBzdHJpbmcuXG4gICAgKi9cbiAgICBlc2NhcGU6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBjb2xvciBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgY29sb3I6IHQobGl0ZXJhbCksXG4gICAgLyoqXG4gICAgQSBVUkwgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgICAqL1xuICAgIHVybDogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBIGxhbmd1YWdlIGtleXdvcmQuXG4gICAgKi9cbiAgICBrZXl3b3JkLFxuICAgIC8qKlxuICAgIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciB0aGUgc2VsZiBvciB0aGlzXG4gICAgb2JqZWN0LlxuICAgICovXG4gICAgc2VsZjogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBUaGUgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBmb3IgbnVsbC5cbiAgICAqL1xuICAgIG51bGw6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGRlbm90aW5nIHNvbWUgYXRvbWljIHZhbHVlLlxuICAgICovXG4gICAgYXRvbTogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCByZXByZXNlbnRzIGEgdW5pdC5cbiAgICAqL1xuICAgIHVuaXQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBtb2RpZmllciBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAgICovXG4gICAgbW9kaWZpZXI6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgYWN0cyBhcyBhbiBvcGVyYXRvci5cbiAgICAqL1xuICAgIG9wZXJhdG9yS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIGNvbnRyb2wtZmxvdyByZWxhdGVkIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgKi9cbiAgICBjb250cm9sS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlZmluaXRpb25LZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSByZWxhdGVkIHRvIGRlZmluaW5nIG9yXG4gICAgaW50ZXJmYWNpbmcgd2l0aCBtb2R1bGVzLlxuICAgICovXG4gICAgbW9kdWxlS2V5d29yZDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBbiBvcGVyYXRvci5cbiAgICAqL1xuICAgIG9wZXJhdG9yLFxuICAgIC8qKlxuICAgIEFuIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlcmVmZXJlbmNlcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZXJlZk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBBcml0aG1ldGljLXJlbGF0ZWQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgYXJpdGhtZXRpY09wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBMb2dpY2FsIFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGxvZ2ljT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIEJpdCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBiaXR3aXNlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIENvbXBhcmlzb24gW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgY29tcGFyZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCB1cGRhdGVzIGl0cyBvcGVyYW5kLlxuICAgICovXG4gICAgdXBkYXRlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVmaW5pdGlvbk9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBUeXBlLXJlbGF0ZWQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgdHlwZU9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBDb250cm9sLWZsb3cgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgY29udHJvbE9wZXJhdG9yOiB0KG9wZXJhdG9yKSxcbiAgICAvKipcbiAgICBQcm9ncmFtIG9yIG1hcmt1cCBwdW5jdHVhdGlvbi5cbiAgICAqL1xuICAgIHB1bmN0dWF0aW9uLFxuICAgIC8qKlxuICAgIFtQdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKSB0aGF0IHNlcGFyYXRlc1xuICAgIHRoaW5ncy5cbiAgICAqL1xuICAgIHNlcGFyYXRvcjogdChwdW5jdHVhdGlvbiksXG4gICAgLyoqXG4gICAgQnJhY2tldC1zdHlsZSBbcHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikuXG4gICAgKi9cbiAgICBicmFja2V0LFxuICAgIC8qKlxuICAgIEFuZ2xlIFticmFja2V0c10oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpICh1c3VhbGx5IGA8YCBhbmQgYD5gXG4gICAgdG9rZW5zKS5cbiAgICAqL1xuICAgIGFuZ2xlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBTcXVhcmUgW2JyYWNrZXRzXSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYFtgIGFuZCBgXWBcbiAgICB0b2tlbnMpLlxuICAgICovXG4gICAgc3F1YXJlQnJhY2tldDogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBQYXJlbnRoZXNlcyAodXN1YWxseSBgKGAgYW5kIGApYCB0b2tlbnMpLiBTdWJ0YWcgb2ZcbiAgICBbYnJhY2tldF0oI2hpZ2hsaWdodC50YWdzLmJyYWNrZXQpLlxuICAgICovXG4gICAgcGFyZW46IHQoYnJhY2tldCksXG4gICAgLyoqXG4gICAgQnJhY2VzICh1c3VhbGx5IGB7YCBhbmQgYH1gIHRva2VucykuIFN1YnRhZyBvZlxuICAgIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICAgKi9cbiAgICBicmFjZTogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBDb250ZW50LCBmb3IgZXhhbXBsZSBwbGFpbiB0ZXh0IGluIFhNTCBvciBtYXJrdXAgZG9jdW1lbnRzLlxuICAgICovXG4gICAgY29udGVudCxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGhlYWRpbmcuXG4gICAgKi9cbiAgICBoZWFkaW5nLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzE6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCAyIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMjogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDMgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmczOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNCBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzQ6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA1IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNTogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDYgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc2OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgcHJvc2UgW2NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSBzZXBhcmF0b3IgKHN1Y2ggYXMgYSBob3Jpem9udGFsIHJ1bGUpLlxuICAgICovXG4gICAgY29udGVudFNlcGFyYXRvcjogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGxpc3QuXG4gICAgKi9cbiAgICBsaXN0OiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgcXVvdGUuXG4gICAgKi9cbiAgICBxdW90ZTogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgZW1waGFzaXplZC5cbiAgICAqL1xuICAgIGVtcGhhc2lzOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBzdHlsZWQgc3Ryb25nLlxuICAgICovXG4gICAgc3Ryb25nOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBwYXJ0IG9mIGEgbGluay5cbiAgICAqL1xuICAgIGxpbms6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBhcyBjb2RlIG9yXG4gICAgbW9ub3NwYWNlLlxuICAgICovXG4gICAgbW9ub3NwYWNlOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBoYXMgYSBzdHJpa2UtdGhyb3VnaFxuICAgIHN0eWxlLlxuICAgICovXG4gICAgc3RyaWtldGhyb3VnaDogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBJbnNlcnRlZCB0ZXh0IGluIGEgY2hhbmdlLXRyYWNraW5nIGZvcm1hdC5cbiAgICAqL1xuICAgIGluc2VydGVkOiB0KCksXG4gICAgLyoqXG4gICAgRGVsZXRlZCB0ZXh0LlxuICAgICovXG4gICAgZGVsZXRlZDogdCgpLFxuICAgIC8qKlxuICAgIENoYW5nZWQgdGV4dC5cbiAgICAqL1xuICAgIGNoYW5nZWQ6IHQoKSxcbiAgICAvKipcbiAgICBBbiBpbnZhbGlkIG9yIHVuc3ludGFjdGljIGVsZW1lbnQuXG4gICAgKi9cbiAgICBpbnZhbGlkOiB0KCksXG4gICAgLyoqXG4gICAgTWV0YWRhdGEgb3IgbWV0YS1pbnN0cnVjdGlvbi5cbiAgICAqL1xuICAgIG1ldGEsXG4gICAgLyoqXG4gICAgW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhcHBsaWVzIHRvIHRoZSBlbnRpcmVcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIGRvY3VtZW50TWV0YTogdChtZXRhKSxcbiAgICAvKipcbiAgICBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFubm90YXRlcyBvciBhZGRzXG4gICAgYXR0cmlidXRlcyB0byBhIGdpdmVuIHN5bnRhY3RpYyBlbGVtZW50LlxuICAgICovXG4gICAgYW5ub3RhdGlvbjogdChtZXRhKSxcbiAgICAvKipcbiAgICBQcm9jZXNzaW5nIGluc3RydWN0aW9uIG9yIHByZXByb2Nlc3NvciBkaXJlY3RpdmUuIFN1YnRhZyBvZlxuICAgIFttZXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkuXG4gICAgKi9cbiAgICBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb246IHQobWV0YSksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhXG4gICAgZ2l2ZW4gZWxlbWVudCBpcyBiZWluZyBkZWZpbmVkLiBFeHBlY3RlZCB0byBiZSB1c2VkIHdpdGggdGhlXG4gICAgdmFyaW91cyBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRhZ3MuXG4gICAgKi9cbiAgICBkZWZpbml0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJkZWZpbml0aW9uXCIpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgaW5kaWNhdGVzIHRoYXRcbiAgICBzb21ldGhpbmcgaXMgY29uc3RhbnQuIE1vc3RseSBleHBlY3RlZCB0byBiZSB1c2VkIHdpdGhcbiAgICBbdmFyaWFibGUgbmFtZXNdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpLlxuICAgICovXG4gICAgY29uc3RhbnQ6IFRhZy5kZWZpbmVNb2RpZmllcihcImNvbnN0YW50XCIpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHVzZWQgdG8gaW5kaWNhdGUgdGhhdFxuICAgIGEgW3ZhcmlhYmxlXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSBvciBbcHJvcGVydHlcbiAgICBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSBpcyBiZWluZyBjYWxsZWQgb3IgZGVmaW5lZFxuICAgIGFzIGEgZnVuY3Rpb24uXG4gICAgKi9cbiAgICBmdW5jdGlvbjogVGFnLmRlZmluZU1vZGlmaWVyKFwiZnVuY3Rpb25cIiksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBjYW4gYmUgYXBwbGllZCB0b1xuICAgIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRvIGluZGljYXRlIHRoYXQgdGhleSBiZWxvbmcgdG9cbiAgICB0aGUgbGFuZ3VhZ2UncyBzdGFuZGFyZCBlbnZpcm9ubWVudC5cbiAgICAqL1xuICAgIHN0YW5kYXJkOiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJzdGFuZGFyZFwiKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyBhIGdpdmVuXG4gICAgW25hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgaXMgbG9jYWwgdG8gc29tZSBzY29wZS5cbiAgICAqL1xuICAgIGxvY2FsOiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJsb2NhbFwiKSxcbiAgICAvKipcbiAgICBBIGdlbmVyaWMgdmFyaWFudCBbbW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0XG4gICAgY2FuIGJlIHVzZWQgdG8gdGFnIGxhbmd1YWdlLXNwZWNpZmljIGFsdGVybmF0aXZlIHZhcmlhbnRzIG9mXG4gICAgc29tZSBjb21tb24gdGFnLiBJdCBpcyByZWNvbW1lbmRlZCBmb3IgdGhlbWVzIHRvIGRlZmluZSBzcGVjaWFsXG4gICAgZm9ybXMgb2YgYXQgbGVhc3QgdGhlIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpIGFuZFxuICAgIFt2YXJpYWJsZSBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKSB0YWdzLCBzaW5jZSB0aG9zZVxuICAgIGNvbWUgdXAgYSBsb3QuXG4gICAgKi9cbiAgICBzcGVjaWFsOiBUYWcuZGVmaW5lTW9kaWZpZXIoXCJzcGVjaWFsXCIpXG59O1xuZm9yIChsZXQgbmFtZSBpbiB0YWdzKSB7XG4gICAgbGV0IHZhbCA9IHRhZ3NbbmFtZV07XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIFRhZylcbiAgICAgICAgdmFsLm5hbWUgPSBuYW1lO1xufVxuLyoqXG5UaGlzIGlzIGEgaGlnaGxpZ2h0ZXIgdGhhdCBhZGRzIHN0YWJsZSwgcHJlZGljdGFibGUgY2xhc3NlcyB0b1xudG9rZW5zLCBmb3Igc3R5bGluZyB3aXRoIGV4dGVybmFsIENTUy5cblxuVGhlIGZvbGxvd2luZyB0YWdzIGFyZSBtYXBwZWQgdG8gdGhlaXIgbmFtZSBwcmVmaXhlZCB3aXRoIGBcInRvay1cImBcbihmb3IgZXhhbXBsZSBgXCJ0b2stY29tbWVudFwiYCk6XG5cbiogW2BsaW5rYF0oI2hpZ2hsaWdodC50YWdzLmxpbmspXG4qIFtgaGVhZGluZ2BdKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKVxuKiBbYGVtcGhhc2lzYF0oI2hpZ2hsaWdodC50YWdzLmVtcGhhc2lzKVxuKiBbYHN0cm9uZ2BdKCNoaWdobGlnaHQudGFncy5zdHJvbmcpXG4qIFtga2V5d29yZGBdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKVxuKiBbYGF0b21gXSgjaGlnaGxpZ2h0LnRhZ3MuYXRvbSlcbiogW2Bib29sYF0oI2hpZ2hsaWdodC50YWdzLmJvb2wpXG4qIFtgdXJsYF0oI2hpZ2hsaWdodC50YWdzLnVybClcbiogW2BsYWJlbE5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MubGFiZWxOYW1lKVxuKiBbYGluc2VydGVkYF0oI2hpZ2hsaWdodC50YWdzLmluc2VydGVkKVxuKiBbYGRlbGV0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuZGVsZXRlZClcbiogW2BsaXRlcmFsYF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpXG4qIFtgc3RyaW5nYF0oI2hpZ2hsaWdodC50YWdzLnN0cmluZylcbiogW2BudW1iZXJgXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKVxuKiBbYHZhcmlhYmxlTmFtZWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4qIFtgdHlwZU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MudHlwZU5hbWUpXG4qIFtgbmFtZXNwYWNlYF0oI2hpZ2hsaWdodC50YWdzLm5hbWVzcGFjZSlcbiogW2BjbGFzc05hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MuY2xhc3NOYW1lKVxuKiBbYG1hY3JvTmFtZWBdKCNoaWdobGlnaHQudGFncy5tYWNyb05hbWUpXG4qIFtgcHJvcGVydHlOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSlcbiogW2BvcGVyYXRvcmBdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcilcbiogW2Bjb21tZW50YF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpXG4qIFtgbWV0YWBdKCNoaWdobGlnaHQudGFncy5tZXRhKVxuKiBbYHB1bmN0dWF0aW9uYF0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKVxuKiBbYGludmFsaWRgXSgjaGlnaGxpZ2h0LnRhZ3MuaW52YWxpZClcblxuSW4gYWRkaXRpb24sIHRoZXNlIG1hcHBpbmdzIGFyZSBwcm92aWRlZDpcblxuKiBbYHJlZ2V4cGBdKCNoaWdobGlnaHQudGFncy5yZWdleHApLFxuICBbYGVzY2FwZWBdKCNoaWdobGlnaHQudGFncy5lc2NhcGUpLCBhbmRcbiAgW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2Aoc3RyaW5nKWBdKCNoaWdobGlnaHQudGFncy5zdHJpbmcpXG4gIGFyZSBtYXBwZWQgdG8gYFwidG9rLXN0cmluZzJcImBcbiogW2BzcGVjaWFsYF0oI2hpZ2hsaWdodC50YWdzLnNwZWNpYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUyXCJgXG4qIFtgbG9jYWxgXSgjaGlnaGxpZ2h0LnRhZ3MubG9jYWwpW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUgdG9rLWxvY2FsXCJgXG4qIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHZhcmlhYmxlTmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKVxuICB0byBgXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCJgXG4qIFtgZGVmaW5pdGlvbmBdKCNoaWdobGlnaHQudGFncy5kZWZpbml0aW9uKVtgKHByb3BlcnR5TmFtZSlgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKVxuICB0byBgXCJ0b2stcHJvcGVydHlOYW1lIHRvay1kZWZpbml0aW9uXCJgXG4qL1xuY29uc3QgY2xhc3NIaWdobGlnaHRlciA9IHRhZ0hpZ2hsaWdodGVyKFtcbiAgICB7IHRhZzogdGFncy5saW5rLCBjbGFzczogXCJ0b2stbGlua1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZywgY2xhc3M6IFwidG9rLWhlYWRpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmVtcGhhc2lzLCBjbGFzczogXCJ0b2stZW1waGFzaXNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZywgY2xhc3M6IFwidG9rLXN0cm9uZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCwgY2xhc3M6IFwidG9rLWtleXdvcmRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmF0b20sIGNsYXNzOiBcInRvay1hdG9tXCIgfSxcbiAgICB7IHRhZzogdGFncy5ib29sLCBjbGFzczogXCJ0b2stYm9vbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudXJsLCBjbGFzczogXCJ0b2stdXJsXCIgfSxcbiAgICB7IHRhZzogdGFncy5sYWJlbE5hbWUsIGNsYXNzOiBcInRvay1sYWJlbE5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmluc2VydGVkLCBjbGFzczogXCJ0b2staW5zZXJ0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmRlbGV0ZWQsIGNsYXNzOiBcInRvay1kZWxldGVkXCIgfSxcbiAgICB7IHRhZzogdGFncy5saXRlcmFsLCBjbGFzczogXCJ0b2stbGl0ZXJhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaW5nLCBjbGFzczogXCJ0b2stc3RyaW5nXCIgfSxcbiAgICB7IHRhZzogdGFncy5udW1iZXIsIGNsYXNzOiBcInRvay1udW1iZXJcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5yZWdleHAsIHRhZ3MuZXNjYXBlLCB0YWdzLnNwZWNpYWwodGFncy5zdHJpbmcpXSwgY2xhc3M6IFwidG9rLXN0cmluZzJcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnZhcmlhYmxlTmFtZSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubG9jYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lMlwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICAgIHsgdGFnOiB0YWdzLnR5cGVOYW1lLCBjbGFzczogXCJ0b2stdHlwZU5hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm5hbWVzcGFjZSwgY2xhc3M6IFwidG9rLW5hbWVzcGFjZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY2xhc3NOYW1lLCBjbGFzczogXCJ0b2stY2xhc3NOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5tYWNyb05hbWUsIGNsYXNzOiBcInRvay1tYWNyb05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnByb3BlcnR5TmFtZSwgY2xhc3M6IFwidG9rLXByb3BlcnR5TmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3Mub3BlcmF0b3IsIGNsYXNzOiBcInRvay1vcGVyYXRvclwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuY29tbWVudCwgY2xhc3M6IFwidG9rLWNvbW1lbnRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1ldGEsIGNsYXNzOiBcInRvay1tZXRhXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLCBjbGFzczogXCJ0b2staW52YWxpZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHVuY3R1YXRpb24sIGNsYXNzOiBcInRvay1wdW5jdHVhdGlvblwiIH1cbl0pO1xuXG5leHBvcnQgeyBUYWcsIGNsYXNzSGlnaGxpZ2h0ZXIsIGdldFN0eWxlVGFncywgaGlnaGxpZ2h0Q29kZSwgaGlnaGxpZ2h0VHJlZSwgc3R5bGVUYWdzLCB0YWdIaWdobGlnaHRlciwgdGFncyB9O1xuIl0sIm5hbWVzIjpbIk5vZGVQcm9wIiwibmV4dFRhZ0lEIiwiVGFnIiwiY29uc3RydWN0b3IiLCJuYW1lIiwic2V0IiwiYmFzZSIsIm1vZGlmaWVkIiwiaWQiLCJ0b1N0cmluZyIsIm1vZCIsImRlZmluZSIsIm5hbWVPclBhcmVudCIsInBhcmVudCIsIkVycm9yIiwidGFnIiwicHVzaCIsInQiLCJkZWZpbmVNb2RpZmllciIsIk1vZGlmaWVyIiwiaW5kZXhPZiIsImdldCIsImNvbmNhdCIsInNvcnQiLCJhIiwiYiIsIm5leHRNb2RpZmllcklEIiwiaW5zdGFuY2VzIiwibW9kcyIsImxlbmd0aCIsImV4aXN0cyIsImZpbmQiLCJzYW1lQXJyYXkiLCJtIiwiY29uZmlncyIsInBvd2VyU2V0IiwiY29uZmlnIiwiZXZlcnkiLCJ4IiwiaSIsImFycmF5Iiwic2V0cyIsImoiLCJlIiwic3R5bGVUYWdzIiwic3BlYyIsImJ5TmFtZSIsIk9iamVjdCIsImNyZWF0ZSIsInByb3AiLCJ0YWdzIiwiQXJyYXkiLCJpc0FycmF5IiwicGFydCIsInNwbGl0IiwicGllY2VzIiwibW9kZSIsInJlc3QiLCJwb3MiLCJleGVjIiwiUmFuZ2VFcnJvciIsIkpTT04iLCJwYXJzZSIsIm5leHQiLCJzbGljZSIsImxhc3QiLCJpbm5lciIsInJ1bGUiLCJSdWxlIiwicnVsZU5vZGVQcm9wIiwiYWRkIiwiY29udGV4dCIsIm9wYXF1ZSIsImluaGVyaXQiLCJvdGhlciIsImRlcHRoIiwiZW1wdHkiLCJ0YWdIaWdobGlnaHRlciIsIm9wdGlvbnMiLCJtYXAiLCJzdHlsZSIsImNsYXNzIiwic2NvcGUiLCJhbGwiLCJjbHMiLCJzdWIiLCJ0YWdDbGFzcyIsImhpZ2hsaWdodFRhZ3MiLCJoaWdobGlnaHRlcnMiLCJyZXN1bHQiLCJoaWdobGlnaHRlciIsInZhbHVlIiwiaGlnaGxpZ2h0VHJlZSIsInRyZWUiLCJwdXRTdHlsZSIsImZyb20iLCJ0byIsImJ1aWxkZXIiLCJIaWdobGlnaHRCdWlsZGVyIiwiaGlnaGxpZ2h0UmFuZ2UiLCJjdXJzb3IiLCJmbHVzaCIsImhpZ2hsaWdodENvZGUiLCJjb2RlIiwicHV0VGV4dCIsInB1dEJyZWFrIiwid3JpdGVUbyIsInAiLCJjbGFzc2VzIiwidGV4dCIsIm5leHRCcmVhayIsInVwdG8iLCJhdCIsInNwYW4iLCJzdGFydFNwYW4iLCJpbmhlcml0ZWRDbGFzcyIsInR5cGUiLCJzdGFydCIsImVuZCIsImlzVG9wIiwiZmlsdGVyIiwiaCIsImdldFN0eWxlVGFncyIsInRhZ0NscyIsIk1hdGgiLCJtYXgiLCJtb3VudGVkIiwib3ZlcmxheSIsIm5vZGUiLCJlbnRlciIsImlubmVySGlnaGxpZ2h0ZXJzIiwiaGFzQ2hpbGQiLCJmaXJzdENoaWxkIiwibmV4dFBvcyIsInJhbmdlRnJvbSIsInJhbmdlVG8iLCJtaW4iLCJuZXh0U2libGluZyIsIm1hdGNoQ29udGV4dCIsImNvbW1lbnQiLCJ0eXBlTmFtZSIsInByb3BlcnR5TmFtZSIsImxpdGVyYWwiLCJzdHJpbmciLCJudW1iZXIiLCJjb250ZW50IiwiaGVhZGluZyIsImtleXdvcmQiLCJvcGVyYXRvciIsInB1bmN0dWF0aW9uIiwiYnJhY2tldCIsIm1ldGEiLCJsaW5lQ29tbWVudCIsImJsb2NrQ29tbWVudCIsImRvY0NvbW1lbnQiLCJ2YXJpYWJsZU5hbWUiLCJ0YWdOYW1lIiwiYXR0cmlidXRlTmFtZSIsImNsYXNzTmFtZSIsImxhYmVsTmFtZSIsIm5hbWVzcGFjZSIsIm1hY3JvTmFtZSIsImRvY1N0cmluZyIsImNoYXJhY3RlciIsImF0dHJpYnV0ZVZhbHVlIiwiaW50ZWdlciIsImZsb2F0IiwiYm9vbCIsInJlZ2V4cCIsImVzY2FwZSIsImNvbG9yIiwidXJsIiwic2VsZiIsIm51bGwiLCJhdG9tIiwidW5pdCIsIm1vZGlmaWVyIiwib3BlcmF0b3JLZXl3b3JkIiwiY29udHJvbEtleXdvcmQiLCJkZWZpbml0aW9uS2V5d29yZCIsIm1vZHVsZUtleXdvcmQiLCJkZXJlZk9wZXJhdG9yIiwiYXJpdGhtZXRpY09wZXJhdG9yIiwibG9naWNPcGVyYXRvciIsImJpdHdpc2VPcGVyYXRvciIsImNvbXBhcmVPcGVyYXRvciIsInVwZGF0ZU9wZXJhdG9yIiwiZGVmaW5pdGlvbk9wZXJhdG9yIiwidHlwZU9wZXJhdG9yIiwiY29udHJvbE9wZXJhdG9yIiwic2VwYXJhdG9yIiwiYW5nbGVCcmFja2V0Iiwic3F1YXJlQnJhY2tldCIsInBhcmVuIiwiYnJhY2UiLCJoZWFkaW5nMSIsImhlYWRpbmcyIiwiaGVhZGluZzMiLCJoZWFkaW5nNCIsImhlYWRpbmc1IiwiaGVhZGluZzYiLCJjb250ZW50U2VwYXJhdG9yIiwibGlzdCIsInF1b3RlIiwiZW1waGFzaXMiLCJzdHJvbmciLCJsaW5rIiwibW9ub3NwYWNlIiwic3RyaWtldGhyb3VnaCIsImluc2VydGVkIiwiZGVsZXRlZCIsImNoYW5nZWQiLCJpbnZhbGlkIiwiZG9jdW1lbnRNZXRhIiwiYW5ub3RhdGlvbiIsInByb2Nlc3NpbmdJbnN0cnVjdGlvbiIsImRlZmluaXRpb24iLCJjb25zdGFudCIsImZ1bmN0aW9uIiwic3RhbmRhcmQiLCJsb2NhbCIsInNwZWNpYWwiLCJ2YWwiLCJjbGFzc0hpZ2hsaWdodGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lezer/highlight/dist/index.js\n");

/***/ })

};
;