"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@codemirror";
exports.ids = ["vendor-chunks/@codemirror"];
exports.modules = {

/***/ "(ssr)/./node_modules/@codemirror/autocomplete/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/autocomplete/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompletionContext: () => (/* binding */ CompletionContext),\n/* harmony export */   acceptCompletion: () => (/* binding */ acceptCompletion),\n/* harmony export */   autocompletion: () => (/* binding */ autocompletion),\n/* harmony export */   clearSnippet: () => (/* binding */ clearSnippet),\n/* harmony export */   closeBrackets: () => (/* binding */ closeBrackets),\n/* harmony export */   closeBracketsKeymap: () => (/* binding */ closeBracketsKeymap),\n/* harmony export */   closeCompletion: () => (/* binding */ closeCompletion),\n/* harmony export */   completeAnyWord: () => (/* binding */ completeAnyWord),\n/* harmony export */   completeFromList: () => (/* binding */ completeFromList),\n/* harmony export */   completionKeymap: () => (/* binding */ completionKeymap),\n/* harmony export */   completionStatus: () => (/* binding */ completionStatus),\n/* harmony export */   currentCompletions: () => (/* binding */ currentCompletions),\n/* harmony export */   deleteBracketPair: () => (/* binding */ deleteBracketPair),\n/* harmony export */   hasNextSnippetField: () => (/* binding */ hasNextSnippetField),\n/* harmony export */   hasPrevSnippetField: () => (/* binding */ hasPrevSnippetField),\n/* harmony export */   ifIn: () => (/* binding */ ifIn),\n/* harmony export */   ifNotIn: () => (/* binding */ ifNotIn),\n/* harmony export */   insertBracket: () => (/* binding */ insertBracket),\n/* harmony export */   insertCompletionText: () => (/* binding */ insertCompletionText),\n/* harmony export */   moveCompletionSelection: () => (/* binding */ moveCompletionSelection),\n/* harmony export */   nextSnippetField: () => (/* binding */ nextSnippetField),\n/* harmony export */   pickedCompletion: () => (/* binding */ pickedCompletion),\n/* harmony export */   prevSnippetField: () => (/* binding */ prevSnippetField),\n/* harmony export */   selectedCompletion: () => (/* binding */ selectedCompletion),\n/* harmony export */   selectedCompletionIndex: () => (/* binding */ selectedCompletionIndex),\n/* harmony export */   setSelectedCompletion: () => (/* binding */ setSelectedCompletion),\n/* harmony export */   snippet: () => (/* binding */ snippet),\n/* harmony export */   snippetCompletion: () => (/* binding */ snippetCompletion),\n/* harmony export */   snippetKeymap: () => (/* binding */ snippetKeymap),\n/* harmony export */   startCompletion: () => (/* binding */ startCompletion)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n\n\n\n/**\nAn instance of this is passed to completion source functions.\n*/ class CompletionContext {\n    /**\n    Create a new completion context. (Mostly useful for testing\n    completion sources—in the editor, the extension will create\n    these for you.)\n    */ constructor(/**\n    The editor state that the completion happens in.\n    */ state, /**\n    The position at which the completion is happening.\n    */ pos, /**\n    Indicates whether completion was activated explicitly, or\n    implicitly by typing. The usual way to respond to this is to\n    only return completions when either there is part of a\n    completable entity before the cursor, or `explicit` is true.\n    */ explicit, /**\n    The editor view. May be undefined if the context was created\n    in a situation where there is no such view available, such as\n    in synchronous updates via\n    [`CompletionResult.update`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.update)\n    or when called by test code.\n    */ view){\n        this.state = state;\n        this.pos = pos;\n        this.explicit = explicit;\n        this.view = view;\n        /**\n        @internal\n        */ this.abortListeners = [];\n        /**\n        @internal\n        */ this.abortOnDocChange = false;\n    }\n    /**\n    Get the extent, content, and (if there is a token) type of the\n    token before `this.pos`.\n    */ tokenBefore(types) {\n        let token = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(this.state).resolveInner(this.pos, -1);\n        while(token && types.indexOf(token.name) < 0)token = token.parent;\n        return token ? {\n            from: token.from,\n            to: this.pos,\n            text: this.state.sliceDoc(token.from, this.pos),\n            type: token.type\n        } : null;\n    }\n    /**\n    Get the match of the given expression directly before the\n    cursor.\n    */ matchBefore(expr) {\n        let line = this.state.doc.lineAt(this.pos);\n        let start = Math.max(line.from, this.pos - 250);\n        let str = line.text.slice(start - line.from, this.pos - line.from);\n        let found = str.search(ensureAnchor(expr, false));\n        return found < 0 ? null : {\n            from: start + found,\n            to: this.pos,\n            text: str.slice(found)\n        };\n    }\n    /**\n    Yields true when the query has been aborted. Can be useful in\n    asynchronous queries to avoid doing work that will be ignored.\n    */ get aborted() {\n        return this.abortListeners == null;\n    }\n    /**\n    Allows you to register abort handlers, which will be called when\n    the query is\n    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n    \n    By default, running queries will not be aborted for regular\n    typing or backspacing, on the assumption that they are likely to\n    return a result with a\n    [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that\n    allows the result to be used after all. Passing `onDocChange:\n    true` will cause this query to be aborted for any document\n    change.\n    */ addEventListener(type, listener, options) {\n        if (type == \"abort\" && this.abortListeners) {\n            this.abortListeners.push(listener);\n            if (options && options.onDocChange) this.abortOnDocChange = true;\n        }\n    }\n}\nfunction toSet(chars) {\n    let flat = Object.keys(chars).join(\"\");\n    let words = /\\w/.test(flat);\n    if (words) flat = flat.replace(/\\w/g, \"\");\n    return `[${words ? \"\\\\w\" : \"\"}${flat.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction prefixMatch(options) {\n    let first = Object.create(null), rest = Object.create(null);\n    for (let { label } of options){\n        first[label[0]] = true;\n        for(let i = 1; i < label.length; i++)rest[label[i]] = true;\n    }\n    let source = toSet(first) + toSet(rest) + \"*$\";\n    return [\n        new RegExp(\"^\" + source),\n        new RegExp(source)\n    ];\n}\n/**\nGiven a a fixed array of options, return an autocompleter that\ncompletes them.\n*/ function completeFromList(list) {\n    let options = list.map((o)=>typeof o == \"string\" ? {\n            label: o\n        } : o);\n    let [validFor, match] = options.every((o)=>/^\\w+$/.test(o.label)) ? [\n        /\\w*$/,\n        /\\w+$/\n    ] : prefixMatch(options);\n    return (context)=>{\n        let token = context.matchBefore(match);\n        return token || context.explicit ? {\n            from: token ? token.from : context.pos,\n            options,\n            validFor\n        } : null;\n    };\n}\n/**\nWrap the given completion source so that it will only fire when the\ncursor is in a syntax node with one of the given names.\n*/ function ifIn(nodes, source) {\n    return (context)=>{\n        for(let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent){\n            if (nodes.indexOf(pos.name) > -1) return source(context);\n            if (pos.type.isTop) break;\n        }\n        return null;\n    };\n}\n/**\nWrap the given completion source so that it will not fire when the\ncursor is in a syntax node with one of the given names.\n*/ function ifNotIn(nodes, source) {\n    return (context)=>{\n        for(let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent){\n            if (nodes.indexOf(pos.name) > -1) return null;\n            if (pos.type.isTop) break;\n        }\n        return source(context);\n    };\n}\nclass Option {\n    constructor(completion, source, match, score){\n        this.completion = completion;\n        this.source = source;\n        this.match = match;\n        this.score = score;\n    }\n}\nfunction cur(state) {\n    return state.selection.main.from;\n}\n// Make sure the given regexp has a $ at its end and, if `start` is\n// true, a ^ at its start.\nfunction ensureAnchor(expr, start) {\n    var _a;\n    let { source } = expr;\n    let addStart = start && source[0] != \"^\", addEnd = source[source.length - 1] != \"$\";\n    if (!addStart && !addEnd) return expr;\n    return new RegExp(`${addStart ? \"^\" : \"\"}(?:${source})${addEnd ? \"$\" : \"\"}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : expr.ignoreCase ? \"i\" : \"\");\n}\n/**\nThis annotation is added to transactions that are produced by\npicking a completion.\n*/ const pickedCompletion = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nHelper function that returns a transaction spec which inserts a\ncompletion's text in the main selection range, and any other\nselection range that has the same text in front of it.\n*/ function insertCompletionText(state, text, from, to) {\n    let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;\n    return Object.assign(Object.assign({}, state.changeByRange((range)=>{\n        if (range != main && from != to && state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to)) return {\n            range\n        };\n        let lines = state.toText(text);\n        return {\n            changes: {\n                from: range.from + fromOff,\n                to: to == main.from ? range.to : range.from + toOff,\n                insert: lines\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from + fromOff + lines.length)\n        };\n    })), {\n        scrollIntoView: true,\n        userEvent: \"input.complete\"\n    });\n}\nconst SourceCache = /*@__PURE__*/ new WeakMap();\nfunction asSource(source) {\n    if (!Array.isArray(source)) return source;\n    let known = SourceCache.get(source);\n    if (!known) SourceCache.set(source, known = completeFromList(source));\n    return known;\n}\nconst startCompletionEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst closeCompletionEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\n// A pattern matcher for fuzzy completion matching. Create an instance\n// once for a pattern, and then use that to match any number of\n// completions.\nclass FuzzyMatcher {\n    constructor(pattern){\n        this.pattern = pattern;\n        this.chars = [];\n        this.folded = [];\n        // Buffers reused by calls to `match` to track matched character\n        // positions.\n        this.any = [];\n        this.precise = [];\n        this.byWord = [];\n        this.score = 0;\n        this.matched = [];\n        for(let p = 0; p < pattern.length;){\n            let char = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(pattern, p), size = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(char);\n            this.chars.push(char);\n            let part = pattern.slice(p, p + size), upper = part.toUpperCase();\n            this.folded.push((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(upper == part ? part.toLowerCase() : upper, 0));\n            p += size;\n        }\n        this.astral = pattern.length != this.chars.length;\n    }\n    ret(score, matched) {\n        this.score = score;\n        this.matched = matched;\n        return this;\n    }\n    // Matches a given word (completion) against the pattern (input).\n    // Will return a boolean indicating whether there was a match and,\n    // on success, set `this.score` to the score, `this.matched` to an\n    // array of `from, to` pairs indicating the matched parts of `word`.\n    //\n    // The score is a number that is more negative the worse the match\n    // is. See `Penalty` above.\n    match(word) {\n        if (this.pattern.length == 0) return this.ret(-100 /* Penalty.NotFull */ , []);\n        if (word.length < this.pattern.length) return null;\n        let { chars, folded, any, precise, byWord } = this;\n        // For single-character queries, only match when they occur right\n        // at the start\n        if (chars.length == 1) {\n            let first = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, 0), firstSize = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(first);\n            let score = firstSize == word.length ? 0 : -100 /* Penalty.NotFull */ ;\n            if (first == chars[0]) ;\n            else if (first == folded[0]) score += -200 /* Penalty.CaseFold */ ;\n            else return null;\n            return this.ret(score, [\n                0,\n                firstSize\n            ]);\n        }\n        let direct = word.indexOf(this.pattern);\n        if (direct == 0) return this.ret(word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */ , [\n            0,\n            this.pattern.length\n        ]);\n        let len = chars.length, anyTo = 0;\n        if (direct < 0) {\n            for(let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;){\n                let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n                if (next == chars[anyTo] || next == folded[anyTo]) any[anyTo++] = i;\n                i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            }\n            // No match, exit immediately\n            if (anyTo < len) return null;\n        }\n        // This tracks the extent of the precise (non-folded, not\n        // necessarily adjacent) match\n        let preciseTo = 0;\n        // Tracks whether there is a match that hits only characters that\n        // appear to be starting words. `byWordFolded` is set to true when\n        // a case folded character is encountered in such a match\n        let byWordTo = 0, byWordFolded = false;\n        // If we've found a partial adjacent match, these track its state\n        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;\n        let hasLower = /[a-z]/.test(word), wordAdjacent = true;\n        // Go over the option's text, scanning for the various kinds of matches\n        for(let i = 0, e = Math.min(word.length, 200), prevType = 0 /* Tp.NonWord */ ; i < e && byWordTo < len;){\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, i);\n            if (direct < 0) {\n                if (preciseTo < len && next == chars[preciseTo]) precise[preciseTo++] = i;\n                if (adjacentTo < len) {\n                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {\n                        if (adjacentTo == 0) adjacentStart = i;\n                        adjacentEnd = i + 1;\n                        adjacentTo++;\n                    } else {\n                        adjacentTo = 0;\n                    }\n                }\n            }\n            let ch, type = next < 0xff ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Tp.Lower */  : next >= 65 && next <= 90 ? 1 /* Tp.Upper */  : 0 /* Tp.NonWord */  : (ch = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next)) != ch.toLowerCase() ? 1 /* Tp.Upper */  : ch != ch.toUpperCase() ? 2 /* Tp.Lower */  : 0 /* Tp.NonWord */ ;\n            if (!i || type == 1 /* Tp.Upper */  && hasLower || prevType == 0 /* Tp.NonWord */  && type != 0 /* Tp.NonWord */ ) {\n                if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true)) byWord[byWordTo++] = i;\n                else if (byWord.length) wordAdjacent = false;\n            }\n            prevType = type;\n            i += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n        }\n        if (byWordTo == len && byWord[0] == 0 && wordAdjacent) return this.result(-100 /* Penalty.ByWord */  + (byWordFolded ? -200 /* Penalty.CaseFold */  : 0), byWord, word);\n        if (adjacentTo == len && adjacentStart == 0) return this.ret(-200 /* Penalty.CaseFold */  - word.length + (adjacentEnd == word.length ? 0 : -100 /* Penalty.NotFull */ ), [\n            0,\n            adjacentEnd\n        ]);\n        if (direct > -1) return this.ret(-700 /* Penalty.NotStart */  - word.length, [\n            direct,\n            direct + this.pattern.length\n        ]);\n        if (adjacentTo == len) return this.ret(-200 /* Penalty.CaseFold */  + -700 /* Penalty.NotStart */  - word.length, [\n            adjacentStart,\n            adjacentEnd\n        ]);\n        if (byWordTo == len) return this.result(-100 /* Penalty.ByWord */  + (byWordFolded ? -200 /* Penalty.CaseFold */  : 0) + -700 /* Penalty.NotStart */  + (wordAdjacent ? 0 : -1100 /* Penalty.Gap */ ), byWord, word);\n        return chars.length == 2 ? null : this.result((any[0] ? -700 /* Penalty.NotStart */  : 0) + -200 /* Penalty.CaseFold */  + -1100 /* Penalty.Gap */ , any, word);\n    }\n    result(score, positions, word) {\n        let result = [], i = 0;\n        for (let pos of positions){\n            let to = pos + (this.astral ? (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(word, pos)) : 1);\n            if (i && result[i - 1] == pos) result[i - 1] = to;\n            else {\n                result[i++] = pos;\n                result[i++] = to;\n            }\n        }\n        return this.ret(score - word.length, result);\n    }\n}\nclass StrictMatcher {\n    constructor(pattern){\n        this.pattern = pattern;\n        this.matched = [];\n        this.score = 0;\n        this.folded = pattern.toLowerCase();\n    }\n    match(word) {\n        if (word.length < this.pattern.length) return null;\n        let start = word.slice(0, this.pattern.length);\n        let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 /* Penalty.CaseFold */  : null;\n        if (match == null) return null;\n        this.matched = [\n            0,\n            start.length\n        ];\n        this.score = match + (word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */ );\n        return this;\n    }\n}\nconst completionConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            activateOnTyping: true,\n            activateOnCompletion: ()=>false,\n            activateOnTypingDelay: 100,\n            selectOnOpen: true,\n            override: null,\n            closeOnBlur: true,\n            maxRenderedOptions: 100,\n            defaultKeymap: true,\n            tooltipClass: ()=>\"\",\n            optionClass: ()=>\"\",\n            aboveCursor: false,\n            icons: true,\n            addToOptions: [],\n            positionInfo: defaultPositionInfo,\n            filterStrict: false,\n            compareCompletions: (a, b)=>a.label.localeCompare(b.label),\n            interactionDelay: 75,\n            updateSyncTime: 100\n        }, {\n            defaultKeymap: (a, b)=>a && b,\n            closeOnBlur: (a, b)=>a && b,\n            icons: (a, b)=>a && b,\n            tooltipClass: (a, b)=>(c)=>joinClass(a(c), b(c)),\n            optionClass: (a, b)=>(c)=>joinClass(a(c), b(c)),\n            addToOptions: (a, b)=>a.concat(b),\n            filterStrict: (a, b)=>a || b\n        });\n    }\n});\nfunction joinClass(a, b) {\n    return a ? b ? a + \" \" + b : a : b;\n}\nfunction defaultPositionInfo(view, list, option, info, space, tooltip) {\n    let rtl = view.textDirection == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.RTL, left = rtl, narrow = false;\n    let side = \"top\", offset, maxWidth;\n    let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;\n    let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;\n    if (left && spaceLeft < Math.min(infoWidth, spaceRight)) left = false;\n    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft)) left = true;\n    if (infoWidth <= (left ? spaceLeft : spaceRight)) {\n        offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;\n        maxWidth = Math.min(400 /* Info.Width */ , left ? spaceLeft : spaceRight);\n    } else {\n        narrow = true;\n        maxWidth = Math.min(400 /* Info.Width */ , (rtl ? list.right : space.right - list.left) - 30 /* Info.Margin */ );\n        let spaceBelow = space.bottom - list.bottom;\n        if (spaceBelow >= infoHeight || spaceBelow > list.top) {\n            offset = option.bottom - list.top;\n        } else {\n            side = \"bottom\";\n            offset = list.bottom - option.top;\n        }\n    }\n    let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;\n    let scaleX = (list.right - list.left) / tooltip.offsetWidth;\n    return {\n        style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,\n        class: \"cm-completionInfo-\" + (narrow ? rtl ? \"left-narrow\" : \"right-narrow\" : left ? \"left\" : \"right\")\n    };\n}\nfunction optionContent(config) {\n    let content = config.addToOptions.slice();\n    if (config.icons) content.push({\n        render (completion) {\n            let icon = document.createElement(\"div\");\n            icon.classList.add(\"cm-completionIcon\");\n            if (completion.type) icon.classList.add(...completion.type.split(/\\s+/g).map((cls)=>\"cm-completionIcon-\" + cls));\n            icon.setAttribute(\"aria-hidden\", \"true\");\n            return icon;\n        },\n        position: 20\n    });\n    content.push({\n        render (completion, _s, _v, match) {\n            let labelElt = document.createElement(\"span\");\n            labelElt.className = \"cm-completionLabel\";\n            let label = completion.displayLabel || completion.label, off = 0;\n            for(let j = 0; j < match.length;){\n                let from = match[j++], to = match[j++];\n                if (from > off) labelElt.appendChild(document.createTextNode(label.slice(off, from)));\n                let span = labelElt.appendChild(document.createElement(\"span\"));\n                span.appendChild(document.createTextNode(label.slice(from, to)));\n                span.className = \"cm-completionMatchedText\";\n                off = to;\n            }\n            if (off < label.length) labelElt.appendChild(document.createTextNode(label.slice(off)));\n            return labelElt;\n        },\n        position: 50\n    }, {\n        render (completion) {\n            if (!completion.detail) return null;\n            let detailElt = document.createElement(\"span\");\n            detailElt.className = \"cm-completionDetail\";\n            detailElt.textContent = completion.detail;\n            return detailElt;\n        },\n        position: 80\n    });\n    return content.sort((a, b)=>a.position - b.position).map((a)=>a.render);\n}\nfunction rangeAroundSelected(total, selected, max) {\n    if (total <= max) return {\n        from: 0,\n        to: total\n    };\n    if (selected < 0) selected = 0;\n    if (selected <= total >> 1) {\n        let off = Math.floor(selected / max);\n        return {\n            from: off * max,\n            to: (off + 1) * max\n        };\n    }\n    let off = Math.floor((total - selected) / max);\n    return {\n        from: total - (off + 1) * max,\n        to: total - off * max\n    };\n}\nclass CompletionTooltip {\n    constructor(view, stateField, applyCompletion){\n        this.view = view;\n        this.stateField = stateField;\n        this.applyCompletion = applyCompletion;\n        this.info = null;\n        this.infoDestroy = null;\n        this.placeInfoReq = {\n            read: ()=>this.measureInfo(),\n            write: (pos)=>this.placeInfo(pos),\n            key: this\n        };\n        this.space = null;\n        this.currentClass = \"\";\n        let cState = view.state.field(stateField);\n        let { options, selected } = cState.open;\n        let config = view.state.facet(completionConfig);\n        this.optionContent = optionContent(config);\n        this.optionClass = config.optionClass;\n        this.tooltipClass = config.tooltipClass;\n        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-tooltip-autocomplete\";\n        this.updateTooltipClass(view.state);\n        this.dom.addEventListener(\"mousedown\", (e)=>{\n            let { options } = view.state.field(stateField).open;\n            for(let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode){\n                if (dom.nodeName == \"LI\" && (match = /-(\\d+)$/.exec(dom.id)) && +match[1] < options.length) {\n                    this.applyCompletion(view, options[+match[1]]);\n                    e.preventDefault();\n                    return;\n                }\n            }\n        });\n        this.dom.addEventListener(\"focusout\", (e)=>{\n            let state = view.state.field(this.stateField, false);\n            if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur && e.relatedTarget != view.contentDOM) view.dispatch({\n                effects: closeCompletionEffect.of(null)\n            });\n        });\n        this.showOptions(options, cState.id);\n    }\n    mount() {\n        this.updateSel();\n    }\n    showOptions(options, id) {\n        if (this.list) this.list.remove();\n        this.list = this.dom.appendChild(this.createListBox(options, id, this.range));\n        this.list.addEventListener(\"scroll\", ()=>{\n            if (this.info) this.view.requestMeasure(this.placeInfoReq);\n        });\n    }\n    update(update) {\n        var _a;\n        let cState = update.state.field(this.stateField);\n        let prevState = update.startState.field(this.stateField);\n        this.updateTooltipClass(update.state);\n        if (cState != prevState) {\n            let { options, selected, disabled } = cState.open;\n            if (!prevState.open || prevState.open.options != options) {\n                this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);\n                this.showOptions(options, cState.id);\n            }\n            this.updateSel();\n            if (disabled != ((_a = prevState.open) === null || _a === void 0 ? void 0 : _a.disabled)) this.dom.classList.toggle(\"cm-tooltip-autocomplete-disabled\", !!disabled);\n        }\n    }\n    updateTooltipClass(state) {\n        let cls = this.tooltipClass(state);\n        if (cls != this.currentClass) {\n            for (let c of this.currentClass.split(\" \"))if (c) this.dom.classList.remove(c);\n            for (let c of cls.split(\" \"))if (c) this.dom.classList.add(c);\n            this.currentClass = cls;\n        }\n    }\n    positioned(space) {\n        this.space = space;\n        if (this.info) this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSel() {\n        let cState = this.view.state.field(this.stateField), open = cState.open;\n        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {\n            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);\n            this.showOptions(open.options, cState.id);\n        }\n        if (this.updateSelectedOption(open.selected)) {\n            this.destroyInfo();\n            let { completion } = open.options[open.selected];\n            let { info } = completion;\n            if (!info) return;\n            let infoResult = typeof info === \"string\" ? document.createTextNode(info) : info(completion);\n            if (!infoResult) return;\n            if (\"then\" in infoResult) {\n                infoResult.then((obj)=>{\n                    if (obj && this.view.state.field(this.stateField, false) == cState) this.addInfoPane(obj, completion);\n                }).catch((e)=>(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e, \"completion info\"));\n            } else {\n                this.addInfoPane(infoResult, completion);\n            }\n        }\n    }\n    addInfoPane(content, completion) {\n        this.destroyInfo();\n        let wrap = this.info = document.createElement(\"div\");\n        wrap.className = \"cm-tooltip cm-completionInfo\";\n        if (content.nodeType != null) {\n            wrap.appendChild(content);\n            this.infoDestroy = null;\n        } else {\n            let { dom, destroy } = content;\n            wrap.appendChild(dom);\n            this.infoDestroy = destroy || null;\n        }\n        this.dom.appendChild(wrap);\n        this.view.requestMeasure(this.placeInfoReq);\n    }\n    updateSelectedOption(selected) {\n        let set = null;\n        for(let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++){\n            if (opt.nodeName != \"LI\" || !opt.id) {\n                i--; // A section header\n            } else if (i == selected) {\n                if (!opt.hasAttribute(\"aria-selected\")) {\n                    opt.setAttribute(\"aria-selected\", \"true\");\n                    set = opt;\n                }\n            } else {\n                if (opt.hasAttribute(\"aria-selected\")) opt.removeAttribute(\"aria-selected\");\n            }\n        }\n        if (set) scrollIntoView(this.list, set);\n        return set;\n    }\n    measureInfo() {\n        let sel = this.dom.querySelector(\"[aria-selected]\");\n        if (!sel || !this.info) return null;\n        let listRect = this.dom.getBoundingClientRect();\n        let infoRect = this.info.getBoundingClientRect();\n        let selRect = sel.getBoundingClientRect();\n        let space = this.space;\n        if (!space) {\n            let docElt = this.dom.ownerDocument.documentElement;\n            space = {\n                left: 0,\n                top: 0,\n                right: docElt.clientWidth,\n                bottom: docElt.clientHeight\n            };\n        }\n        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 || selRect.bottom < Math.max(space.top, listRect.top) + 10) return null;\n        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);\n    }\n    placeInfo(pos) {\n        if (this.info) {\n            if (pos) {\n                if (pos.style) this.info.style.cssText = pos.style;\n                this.info.className = \"cm-tooltip cm-completionInfo \" + (pos.class || \"\");\n            } else {\n                this.info.style.cssText = \"top: -1e6px\";\n            }\n        }\n    }\n    createListBox(options, id, range) {\n        const ul = document.createElement(\"ul\");\n        ul.id = id;\n        ul.setAttribute(\"role\", \"listbox\");\n        ul.setAttribute(\"aria-expanded\", \"true\");\n        ul.setAttribute(\"aria-label\", this.view.state.phrase(\"Completions\"));\n        ul.addEventListener(\"mousedown\", (e)=>{\n            // Prevent focus change when clicking the scrollbar\n            if (e.target == ul) e.preventDefault();\n        });\n        let curSection = null;\n        for(let i = range.from; i < range.to; i++){\n            let { completion, match } = options[i], { section } = completion;\n            if (section) {\n                let name = typeof section == \"string\" ? section : section.name;\n                if (name != curSection && (i > range.from || range.from == 0)) {\n                    curSection = name;\n                    if (typeof section != \"string\" && section.header) {\n                        ul.appendChild(section.header(section));\n                    } else {\n                        let header = ul.appendChild(document.createElement(\"completion-section\"));\n                        header.textContent = name;\n                    }\n                }\n            }\n            const li = ul.appendChild(document.createElement(\"li\"));\n            li.id = id + \"-\" + i;\n            li.setAttribute(\"role\", \"option\");\n            let cls = this.optionClass(completion);\n            if (cls) li.className = cls;\n            for (let source of this.optionContent){\n                let node = source(completion, this.view.state, this.view, match);\n                if (node) li.appendChild(node);\n            }\n        }\n        if (range.from) ul.classList.add(\"cm-completionListIncompleteTop\");\n        if (range.to < options.length) ul.classList.add(\"cm-completionListIncompleteBottom\");\n        return ul;\n    }\n    destroyInfo() {\n        if (this.info) {\n            if (this.infoDestroy) this.infoDestroy();\n            this.info.remove();\n            this.info = null;\n        }\n    }\n    destroy() {\n        this.destroyInfo();\n    }\n}\nfunction completionTooltip(stateField, applyCompletion) {\n    return (view)=>new CompletionTooltip(view, stateField, applyCompletion);\n}\nfunction scrollIntoView(container, element) {\n    let parent = container.getBoundingClientRect();\n    let self = element.getBoundingClientRect();\n    let scaleY = parent.height / container.offsetHeight;\n    if (self.top < parent.top) container.scrollTop -= (parent.top - self.top) / scaleY;\n    else if (self.bottom > parent.bottom) container.scrollTop += (self.bottom - parent.bottom) / scaleY;\n}\n// Used to pick a preferred option when two options with the same\n// label occur in the result.\nfunction score(option) {\n    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);\n}\nfunction sortOptions(active, state) {\n    let options = [];\n    let sections = null;\n    let addOption = (option)=>{\n        options.push(option);\n        let { section } = option.completion;\n        if (section) {\n            if (!sections) sections = [];\n            let name = typeof section == \"string\" ? section : section.name;\n            if (!sections.some((s)=>s.name == name)) sections.push(typeof section == \"string\" ? {\n                name\n            } : section);\n        }\n    };\n    let conf = state.facet(completionConfig);\n    for (let a of active)if (a.hasResult()) {\n        let getMatch = a.result.getMatch;\n        if (a.result.filter === false) {\n            for (let option of a.result.options){\n                addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));\n            }\n        } else {\n            let pattern = state.sliceDoc(a.from, a.to), match;\n            let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);\n            for (let option of a.result.options)if (match = matcher.match(option.label)) {\n                let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];\n                addOption(new Option(option, a.source, matched, match.score + (option.boost || 0)));\n            }\n        }\n    }\n    if (sections) {\n        let sectionOrder = Object.create(null), pos = 0;\n        let cmp = (a, b)=>{\n            var _a, _b;\n            return ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1);\n        };\n        for (let s of sections.sort(cmp)){\n            pos -= 1e5;\n            sectionOrder[s.name] = pos;\n        }\n        for (let option of options){\n            let { section } = option.completion;\n            if (section) option.score += sectionOrder[typeof section == \"string\" ? section : section.name];\n        }\n    }\n    let result = [], prev = null;\n    let compare = conf.compareCompletions;\n    for (let opt of options.sort((a, b)=>b.score - a.score || compare(a.completion, b.completion))){\n        let cur = opt.completion;\n        if (!prev || prev.label != cur.label || prev.detail != cur.detail || prev.type != null && cur.type != null && prev.type != cur.type || prev.apply != cur.apply || prev.boost != cur.boost) result.push(opt);\n        else if (score(opt.completion) > score(prev)) result[result.length - 1] = opt;\n        prev = opt.completion;\n    }\n    return result;\n}\nclass CompletionDialog {\n    constructor(options, attrs, tooltip, timestamp, selected, disabled){\n        this.options = options;\n        this.attrs = attrs;\n        this.tooltip = tooltip;\n        this.timestamp = timestamp;\n        this.selected = selected;\n        this.disabled = disabled;\n    }\n    setSelected(selected, id) {\n        return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);\n    }\n    static build(active, state, id, prev, conf, didSetActive) {\n        if (prev && !didSetActive && active.some((s)=>s.isPending)) return prev.setDisabled();\n        let options = sortOptions(active, state);\n        if (!options.length) return prev && active.some((a)=>a.isPending) ? prev.setDisabled() : null;\n        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;\n        if (prev && prev.selected != selected && prev.selected != -1) {\n            let selectedValue = prev.options[prev.selected].completion;\n            for(let i = 0; i < options.length; i++)if (options[i].completion == selectedValue) {\n                selected = i;\n                break;\n            }\n        }\n        return new CompletionDialog(options, makeAttrs(id, selected), {\n            pos: active.reduce((a, b)=>b.hasResult() ? Math.min(a, b.from) : a, 1e8),\n            create: createTooltip,\n            above: conf.aboveCursor\n        }, prev ? prev.timestamp : Date.now(), selected, false);\n    }\n    map(changes) {\n        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), {\n            pos: changes.mapPos(this.tooltip.pos)\n        }), this.timestamp, this.selected, this.disabled);\n    }\n    setDisabled() {\n        return new CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);\n    }\n}\nclass CompletionState {\n    constructor(active, id, open){\n        this.active = active;\n        this.id = id;\n        this.open = open;\n    }\n    static start() {\n        return new CompletionState(none, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n    }\n    update(tr) {\n        let { state } = tr, conf = state.facet(completionConfig);\n        let sources = conf.override || state.languageDataAt(\"autocomplete\", cur(state)).map(asSource);\n        let active = sources.map((source)=>{\n            let value = this.active.find((s)=>s.source == source) || new ActiveSource(source, this.active.some((a)=>a.state != 0 /* State.Inactive */ ) ? 1 /* State.Pending */  : 0 /* State.Inactive */ );\n            return value.update(tr, conf);\n        });\n        if (active.length == this.active.length && active.every((a, i)=>a == this.active[i])) active = this.active;\n        let open = this.open, didSet = tr.effects.some((e)=>e.is(setActiveEffect));\n        if (open && tr.docChanged) open = open.map(tr.changes);\n        if (tr.selection || active.some((a)=>a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) || didSet) open = CompletionDialog.build(active, state, this.id, open, conf, didSet);\n        else if (open && open.disabled && !active.some((a)=>a.isPending)) open = null;\n        if (!open && active.every((a)=>!a.isPending) && active.some((a)=>a.hasResult())) active = active.map((a)=>a.hasResult() ? new ActiveSource(a.source, 0 /* State.Inactive */ ) : a);\n        for (let effect of tr.effects)if (effect.is(setSelectedEffect)) open = open && open.setSelected(effect.value, this.id);\n        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);\n    }\n    get tooltip() {\n        return this.open ? this.open.tooltip : null;\n    }\n    get attrs() {\n        return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs;\n    }\n}\nfunction sameResults(a, b) {\n    if (a == b) return true;\n    for(let iA = 0, iB = 0;;){\n        while(iA < a.length && !a[iA].hasResult())iA++;\n        while(iB < b.length && !b[iB].hasResult())iB++;\n        let endA = iA == a.length, endB = iB == b.length;\n        if (endA || endB) return endA == endB;\n        if (a[iA++].result != b[iB++].result) return false;\n    }\n}\nconst baseAttrs = {\n    \"aria-autocomplete\": \"list\"\n};\nconst noAttrs = {};\nfunction makeAttrs(id, selected) {\n    let result = {\n        \"aria-autocomplete\": \"list\",\n        \"aria-haspopup\": \"listbox\",\n        \"aria-controls\": id\n    };\n    if (selected > -1) result[\"aria-activedescendant\"] = id + \"-\" + selected;\n    return result;\n}\nconst none = [];\nfunction getUpdateType(tr, conf) {\n    if (tr.isUserEvent(\"input.complete\")) {\n        let completion = tr.annotation(pickedCompletion);\n        if (completion && conf.activateOnCompletion(completion)) return 4 /* UpdateType.Activate */  | 8 /* UpdateType.Reset */ ;\n    }\n    let typing = tr.isUserEvent(\"input.type\");\n    return typing && conf.activateOnTyping ? 4 /* UpdateType.Activate */  | 1 /* UpdateType.Typing */  : typing ? 1 /* UpdateType.Typing */  : tr.isUserEvent(\"delete.backward\") ? 2 /* UpdateType.Backspacing */  : tr.selection ? 8 /* UpdateType.Reset */  : tr.docChanged ? 16 /* UpdateType.ResetIfTouching */  : 0 /* UpdateType.None */ ;\n}\nclass ActiveSource {\n    constructor(source, state, explicit = false){\n        this.source = source;\n        this.state = state;\n        this.explicit = explicit;\n    }\n    hasResult() {\n        return false;\n    }\n    get isPending() {\n        return this.state == 1 /* State.Pending */ ;\n    }\n    update(tr, conf) {\n        let type = getUpdateType(tr, conf), value = this;\n        if (type & 8 /* UpdateType.Reset */  || type & 16 /* UpdateType.ResetIfTouching */  && this.touches(tr)) value = new ActiveSource(value.source, 0 /* State.Inactive */ );\n        if (type & 4 /* UpdateType.Activate */  && value.state == 0 /* State.Inactive */ ) value = new ActiveSource(this.source, 1 /* State.Pending */ );\n        value = value.updateFor(tr, type);\n        for (let effect of tr.effects){\n            if (effect.is(startCompletionEffect)) value = new ActiveSource(value.source, 1 /* State.Pending */ , effect.value);\n            else if (effect.is(closeCompletionEffect)) value = new ActiveSource(value.source, 0 /* State.Inactive */ );\n            else if (effect.is(setActiveEffect)) {\n                for (let active of effect.value)if (active.source == value.source) value = active;\n            }\n        }\n        return value;\n    }\n    updateFor(tr, type) {\n        return this.map(tr.changes);\n    }\n    map(changes) {\n        return this;\n    }\n    touches(tr) {\n        return tr.changes.touchesRange(cur(tr.state));\n    }\n}\nclass ActiveResult extends ActiveSource {\n    constructor(source, explicit, limit, result, from, to){\n        super(source, 3 /* State.Result */ , explicit);\n        this.limit = limit;\n        this.result = result;\n        this.from = from;\n        this.to = to;\n    }\n    hasResult() {\n        return true;\n    }\n    updateFor(tr, type) {\n        var _a;\n        if (!(type & 3 /* UpdateType.SimpleInteraction */ )) return this.map(tr.changes);\n        let result = this.result;\n        if (result.map && !tr.changes.empty) result = result.map(result, tr.changes);\n        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);\n        let pos = cur(tr.state);\n        if (pos > to || !result || type & 2 /* UpdateType.Backspacing */  && (cur(tr.startState) == this.from || pos < this.limit)) return new ActiveSource(this.source, type & 4 /* UpdateType.Activate */  ? 1 /* State.Pending */  : 0 /* State.Inactive */ );\n        let limit = tr.changes.mapPos(this.limit);\n        if (checkValid(result.validFor, tr.state, from, to)) return new ActiveResult(this.source, this.explicit, limit, result, from, to);\n        if (result.update && (result = result.update(result, from, to, new CompletionContext(tr.state, pos, false)))) return new ActiveResult(this.source, this.explicit, limit, result, result.from, (_a = result.to) !== null && _a !== void 0 ? _a : cur(tr.state));\n        return new ActiveSource(this.source, 1 /* State.Pending */ , this.explicit);\n    }\n    map(mapping) {\n        if (mapping.empty) return this;\n        let result = this.result.map ? this.result.map(this.result, mapping) : this.result;\n        if (!result) return new ActiveSource(this.source, 0 /* State.Inactive */ );\n        return new ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));\n    }\n    touches(tr) {\n        return tr.changes.touchesRange(this.from, this.to);\n    }\n}\nfunction checkValid(validFor, state, from, to) {\n    if (!validFor) return false;\n    let text = state.sliceDoc(from, to);\n    return typeof validFor == \"function\" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);\n}\nconst setActiveEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (sources, mapping) {\n        return sources.map((s)=>s.map(mapping));\n    }\n});\nconst setSelectedEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst completionState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return CompletionState.start();\n    },\n    update (value, tr) {\n        return value.update(tr);\n    },\n    provide: (f)=>[\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showTooltip.from(f, (val)=>val.tooltip),\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.contentAttributes.from(f, (state)=>state.attrs)\n        ]\n});\nfunction applyCompletion(view, option) {\n    const apply = option.completion.apply || option.completion.label;\n    let result = view.state.field(completionState).active.find((a)=>a.source == option.source);\n    if (!(result instanceof ActiveResult)) return false;\n    if (typeof apply == \"string\") view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), {\n        annotations: pickedCompletion.of(option.completion)\n    }));\n    else apply(view, option.completion, result.from, result.to);\n    return true;\n}\nconst createTooltip = /*@__PURE__*/ completionTooltip(completionState, applyCompletion);\n/**\nReturns a command that moves the completion selection forward or\nbackward by the given amount.\n*/ function moveCompletionSelection(forward, by = \"option\") {\n    return (view)=>{\n        let cState = view.state.field(completionState, false);\n        if (!cState || !cState.open || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n        let step = 1, tooltip;\n        if (by == \"page\" && (tooltip = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(view, cState.open.tooltip))) step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector(\"li\").offsetHeight) - 1);\n        let { length } = cState.open.options;\n        let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;\n        if (selected < 0) selected = by == \"page\" ? 0 : length - 1;\n        else if (selected >= length) selected = by == \"page\" ? length - 1 : 0;\n        view.dispatch({\n            effects: setSelectedEffect.of(selected)\n        });\n        return true;\n    };\n}\n/**\nAccept the current completion.\n*/ const acceptCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay) return false;\n    return applyCompletion(view, cState.open.options[cState.open.selected]);\n};\n/**\nExplicitly start autocompletion.\n*/ const startCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (!cState) return false;\n    view.dispatch({\n        effects: startCompletionEffect.of(true)\n    });\n    return true;\n};\n/**\nClose the currently active completion.\n*/ const closeCompletion = (view)=>{\n    let cState = view.state.field(completionState, false);\n    if (!cState || !cState.active.some((a)=>a.state != 0 /* State.Inactive */ )) return false;\n    view.dispatch({\n        effects: closeCompletionEffect.of(null)\n    });\n    return true;\n};\nclass RunningQuery {\n    constructor(active, context){\n        this.active = active;\n        this.context = context;\n        this.time = Date.now();\n        this.updates = [];\n        // Note that 'undefined' means 'not done yet', whereas 'null' means\n        // 'query returned null'.\n        this.done = undefined;\n    }\n}\nconst MaxUpdateCount = 50, MinAbortTime = 1000;\nconst completionPlugin = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.debounceUpdate = -1;\n        this.running = [];\n        this.debounceAccept = -1;\n        this.pendingStart = false;\n        this.composing = 0 /* CompositionState.None */ ;\n        for (let active of view.state.field(completionState).active)if (active.isPending) this.startQuery(active);\n    }\n    update(update) {\n        let cState = update.state.field(completionState);\n        let conf = update.state.facet(completionConfig);\n        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState) return;\n        let doesReset = update.transactions.some((tr)=>{\n            let type = getUpdateType(tr, conf);\n            return type & 8 /* UpdateType.Reset */  || (tr.selection || tr.docChanged) && !(type & 3 /* UpdateType.SimpleInteraction */ );\n        });\n        for(let i = 0; i < this.running.length; i++){\n            let query = this.running[i];\n            if (doesReset || query.context.abortOnDocChange && update.docChanged || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {\n                for (let handler of query.context.abortListeners){\n                    try {\n                        handler();\n                    } catch (e) {\n                        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, e);\n                    }\n                }\n                query.context.abortListeners = null;\n                this.running.splice(i--, 1);\n            } else {\n                query.updates.push(...update.transactions);\n            }\n        }\n        if (this.debounceUpdate > -1) clearTimeout(this.debounceUpdate);\n        if (update.transactions.some((tr)=>tr.effects.some((e)=>e.is(startCompletionEffect)))) this.pendingStart = true;\n        let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;\n        this.debounceUpdate = cState.active.some((a)=>a.isPending && !this.running.some((q)=>q.active.source == a.source)) ? setTimeout(()=>this.startUpdate(), delay) : -1;\n        if (this.composing != 0 /* CompositionState.None */ ) for (let tr of update.transactions){\n            if (tr.isUserEvent(\"input.type\")) this.composing = 2 /* CompositionState.Changed */ ;\n            else if (this.composing == 2 /* CompositionState.Changed */  && tr.selection) this.composing = 3 /* CompositionState.ChangedAndMoved */ ;\n        }\n    }\n    startUpdate() {\n        this.debounceUpdate = -1;\n        this.pendingStart = false;\n        let { state } = this.view, cState = state.field(completionState);\n        for (let active of cState.active){\n            if (active.isPending && !this.running.some((r)=>r.active.source == active.source)) this.startQuery(active);\n        }\n        if (this.running.length && cState.open && cState.open.disabled) this.debounceAccept = setTimeout(()=>this.accept(), this.view.state.facet(completionConfig).updateSyncTime);\n    }\n    startQuery(active) {\n        let { state } = this.view, pos = cur(state);\n        let context = new CompletionContext(state, pos, active.explicit, this.view);\n        let pending = new RunningQuery(active, context);\n        this.running.push(pending);\n        Promise.resolve(active.source(context)).then((result)=>{\n            if (!pending.context.aborted) {\n                pending.done = result || null;\n                this.scheduleAccept();\n            }\n        }, (err)=>{\n            this.view.dispatch({\n                effects: closeCompletionEffect.of(null)\n            });\n            (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, err);\n        });\n    }\n    scheduleAccept() {\n        if (this.running.every((q)=>q.done !== undefined)) this.accept();\n        else if (this.debounceAccept < 0) this.debounceAccept = setTimeout(()=>this.accept(), this.view.state.facet(completionConfig).updateSyncTime);\n    }\n    // For each finished query in this.running, try to create a result\n    // or, if appropriate, restart the query.\n    accept() {\n        var _a;\n        if (this.debounceAccept > -1) clearTimeout(this.debounceAccept);\n        this.debounceAccept = -1;\n        let updated = [];\n        let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);\n        for(let i = 0; i < this.running.length; i++){\n            let query = this.running[i];\n            if (query.done === undefined) continue;\n            this.running.splice(i--, 1);\n            if (query.done) {\n                let pos = cur(query.updates.length ? query.updates[0].startState : this.view.state);\n                let limit = Math.min(pos, query.done.from + (query.active.explicit ? 0 : 1));\n                let active = new ActiveResult(query.active.source, query.active.explicit, limit, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : pos);\n                // Replay the transactions that happened since the start of\n                // the request and see if that preserves the result\n                for (let tr of query.updates)active = active.update(tr, conf);\n                if (active.hasResult()) {\n                    updated.push(active);\n                    continue;\n                }\n            }\n            let current = cState.active.find((a)=>a.source == query.active.source);\n            if (current && current.isPending) {\n                if (query.done == null) {\n                    // Explicitly failed. Should clear the pending status if it\n                    // hasn't been re-set in the meantime.\n                    let active = new ActiveSource(query.active.source, 0 /* State.Inactive */ );\n                    for (let tr of query.updates)active = active.update(tr, conf);\n                    if (!active.isPending) updated.push(active);\n                } else {\n                    // Cleared by subsequent transactions. Restart.\n                    this.startQuery(current);\n                }\n            }\n        }\n        if (updated.length || cState.open && cState.open.disabled) this.view.dispatch({\n            effects: setActiveEffect.of(updated)\n        });\n    }\n}, {\n    eventHandlers: {\n        blur (event) {\n            let state = this.view.state.field(completionState, false);\n            if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {\n                let dialog = state.open && (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getTooltip)(this.view, state.open.tooltip);\n                if (!dialog || !dialog.dom.contains(event.relatedTarget)) setTimeout(()=>this.view.dispatch({\n                        effects: closeCompletionEffect.of(null)\n                    }), 10);\n            }\n        },\n        compositionstart () {\n            this.composing = 1 /* CompositionState.Started */ ;\n        },\n        compositionend () {\n            if (this.composing == 3 /* CompositionState.ChangedAndMoved */ ) {\n                // Safari fires compositionend events synchronously, possibly\n                // from inside an update, so dispatch asynchronously to avoid reentrancy\n                setTimeout(()=>this.view.dispatch({\n                        effects: startCompletionEffect.of(false)\n                    }), 20);\n            }\n            this.composing = 0 /* CompositionState.None */ ;\n        }\n    }\n});\nconst windows = typeof navigator == \"object\" && /*@__PURE__*/ /Win/.test(navigator.platform);\nconst commitCharacters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n    keydown (event, view) {\n        let field = view.state.field(completionState, false);\n        if (!field || !field.open || field.open.disabled || field.open.selected < 0 || event.key.length > 1 || event.ctrlKey && !(windows && event.altKey) || event.metaKey) return false;\n        let option = field.open.options[field.open.selected];\n        let result = field.active.find((a)=>a.source == option.source);\n        let commitChars = option.completion.commitCharacters || result.result.commitCharacters;\n        if (commitChars && commitChars.indexOf(event.key) > -1) applyCompletion(view, option);\n        return false;\n    }\n}));\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-tooltip.cm-tooltip-autocomplete\": {\n        \"& > ul\": {\n            fontFamily: \"monospace\",\n            whiteSpace: \"nowrap\",\n            overflow: \"hidden auto\",\n            maxWidth_fallback: \"700px\",\n            maxWidth: \"min(700px, 95vw)\",\n            minWidth: \"250px\",\n            maxHeight: \"10em\",\n            height: \"100%\",\n            listStyle: \"none\",\n            margin: 0,\n            padding: 0,\n            \"& > li, & > completion-section\": {\n                padding: \"1px 3px\",\n                lineHeight: 1.2\n            },\n            \"& > li\": {\n                overflowX: \"hidden\",\n                textOverflow: \"ellipsis\",\n                cursor: \"pointer\"\n            },\n            \"& > completion-section\": {\n                display: \"list-item\",\n                borderBottom: \"1px solid silver\",\n                paddingLeft: \"0.5em\",\n                opacity: 0.7\n            }\n        }\n    },\n    \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#17c\",\n        color: \"white\"\n    },\n    \"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#777\"\n    },\n    \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n        background: \"#347\",\n        color: \"white\"\n    },\n    \"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n        background: \"#444\"\n    },\n    \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n        content: '\"\\xb7\\xb7\\xb7\"',\n        opacity: 0.5,\n        display: \"block\",\n        textAlign: \"center\"\n    },\n    \".cm-tooltip.cm-completionInfo\": {\n        position: \"absolute\",\n        padding: \"3px 9px\",\n        width: \"max-content\",\n        maxWidth: `${400 /* Info.Width */ }px`,\n        boxSizing: \"border-box\",\n        whiteSpace: \"pre-line\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left\": {\n        right: \"100%\"\n    },\n    \".cm-completionInfo.cm-completionInfo-right\": {\n        left: \"100%\"\n    },\n    \".cm-completionInfo.cm-completionInfo-left-narrow\": {\n        right: `${30 /* Info.Margin */ }px`\n    },\n    \".cm-completionInfo.cm-completionInfo-right-narrow\": {\n        left: `${30 /* Info.Margin */ }px`\n    },\n    \"&light .cm-snippetField\": {\n        backgroundColor: \"#00000022\"\n    },\n    \"&dark .cm-snippetField\": {\n        backgroundColor: \"#ffffff22\"\n    },\n    \".cm-snippetFieldPosition\": {\n        verticalAlign: \"text-top\",\n        width: 0,\n        height: \"1.15em\",\n        display: \"inline-block\",\n        margin: \"0 -0.7px -.7em\",\n        borderLeft: \"1.4px dotted #888\"\n    },\n    \".cm-completionMatchedText\": {\n        textDecoration: \"underline\"\n    },\n    \".cm-completionDetail\": {\n        marginLeft: \"0.5em\",\n        fontStyle: \"italic\"\n    },\n    \".cm-completionIcon\": {\n        fontSize: \"90%\",\n        width: \".8em\",\n        display: \"inline-block\",\n        textAlign: \"center\",\n        paddingRight: \".6em\",\n        opacity: \"0.6\",\n        boxSizing: \"content-box\"\n    },\n    \".cm-completionIcon-function, .cm-completionIcon-method\": {\n        \"&:after\": {\n            content: \"'ƒ'\"\n        }\n    },\n    \".cm-completionIcon-class\": {\n        \"&:after\": {\n            content: \"'○'\"\n        }\n    },\n    \".cm-completionIcon-interface\": {\n        \"&:after\": {\n            content: \"'◌'\"\n        }\n    },\n    \".cm-completionIcon-variable\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC65'\"\n        }\n    },\n    \".cm-completionIcon-constant\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC36'\"\n        }\n    },\n    \".cm-completionIcon-type\": {\n        \"&:after\": {\n            content: \"'\\uD835\\uDC61'\"\n        }\n    },\n    \".cm-completionIcon-enum\": {\n        \"&:after\": {\n            content: \"'∪'\"\n        }\n    },\n    \".cm-completionIcon-property\": {\n        \"&:after\": {\n            content: \"'□'\"\n        }\n    },\n    \".cm-completionIcon-keyword\": {\n        \"&:after\": {\n            content: \"'\\uD83D\\uDD11︎'\"\n        } // Disable emoji rendering\n    },\n    \".cm-completionIcon-namespace\": {\n        \"&:after\": {\n            content: \"'▢'\"\n        }\n    },\n    \".cm-completionIcon-text\": {\n        \"&:after\": {\n            content: \"'abc'\",\n            fontSize: \"50%\",\n            verticalAlign: \"middle\"\n        }\n    }\n});\nclass FieldPos {\n    constructor(field, line, from, to){\n        this.field = field;\n        this.line = line;\n        this.from = from;\n        this.to = to;\n    }\n}\nclass FieldRange {\n    constructor(field, from, to){\n        this.field = field;\n        this.from = from;\n        this.to = to;\n    }\n    map(changes) {\n        let from = changes.mapPos(this.from, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n        let to = changes.mapPos(this.to, 1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackDel);\n        return from == null || to == null ? null : new FieldRange(this.field, from, to);\n    }\n}\nclass Snippet {\n    constructor(lines, fieldPositions){\n        this.lines = lines;\n        this.fieldPositions = fieldPositions;\n    }\n    instantiate(state, pos) {\n        let text = [], lineStart = [\n            pos\n        ];\n        let lineObj = state.doc.lineAt(pos), baseIndent = /^\\s*/.exec(lineObj.text)[0];\n        for (let line of this.lines){\n            if (text.length) {\n                let indent = baseIndent, tabs = /^\\t*/.exec(line)[0].length;\n                for(let i = 0; i < tabs; i++)indent += state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.indentUnit);\n                lineStart.push(pos + indent.length - tabs);\n                line = indent + line.slice(tabs);\n            }\n            text.push(line);\n            pos += line.length + 1;\n        }\n        let ranges = this.fieldPositions.map((pos)=>new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));\n        return {\n            text,\n            ranges\n        };\n    }\n    static parse(template) {\n        let fields = [];\n        let lines = [], positions = [], m;\n        for (let line of template.split(/\\r\\n?|\\n/)){\n            while(m = /[#$]\\{(?:(\\d+)(?::([^}]*))?|((?:\\\\[{}]|[^}])*))\\}/.exec(line)){\n                let seq = m[1] ? +m[1] : null, rawName = m[2] || m[3] || \"\", found = -1;\n                let name = rawName.replace(/\\\\[{}]/g, (m)=>m[1]);\n                for(let i = 0; i < fields.length; i++){\n                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false) found = i;\n                }\n                if (found < 0) {\n                    let i = 0;\n                    while(i < fields.length && (seq == null || fields[i].seq != null && fields[i].seq < seq))i++;\n                    fields.splice(i, 0, {\n                        seq,\n                        name\n                    });\n                    found = i;\n                    for (let pos of positions)if (pos.field >= found) pos.field++;\n                }\n                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));\n                line = line.slice(0, m.index) + rawName + line.slice(m.index + m[0].length);\n            }\n            line = line.replace(/\\\\([{}])/g, (_, brace, index)=>{\n                for (let pos of positions)if (pos.line == lines.length && pos.from > index) {\n                    pos.from--;\n                    pos.to--;\n                }\n                return brace;\n            });\n            lines.push(line);\n        }\n        return new Snippet(lines, positions);\n    }\n}\nlet fieldMarker = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget({\n    widget: /*@__PURE__*/ new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.WidgetType {\n        toDOM() {\n            let span = document.createElement(\"span\");\n            span.className = \"cm-snippetFieldPosition\";\n            return span;\n        }\n        ignoreEvent() {\n            return false;\n        }\n    }\n});\nlet fieldRange = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-snippetField\"\n});\nclass ActiveSnippet {\n    constructor(ranges, active){\n        this.ranges = ranges;\n        this.active = active;\n        this.deco = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(ranges.map((r)=>(r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));\n    }\n    map(changes) {\n        let ranges = [];\n        for (let r of this.ranges){\n            let mapped = r.map(changes);\n            if (!mapped) return null;\n            ranges.push(mapped);\n        }\n        return new ActiveSnippet(ranges, this.active);\n    }\n    selectionInsideField(sel) {\n        return sel.ranges.every((range)=>this.ranges.some((r)=>r.field == this.active && r.from <= range.from && r.to >= range.to));\n    }\n}\nconst setActive = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (value, changes) {\n        return value && value.map(changes);\n    }\n});\nconst moveToField = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst snippetState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return null;\n    },\n    update (value, tr) {\n        for (let effect of tr.effects){\n            if (effect.is(setActive)) return effect.value;\n            if (effect.is(moveToField) && value) return new ActiveSnippet(value.ranges, effect.value);\n        }\n        if (value && tr.docChanged) value = value.map(tr.changes);\n        if (value && tr.selection && !value.selectionInsideField(tr.selection)) value = null;\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.from(f, (val)=>val ? val.deco : _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none)\n});\nfunction fieldSelection(ranges, field) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.filter((r)=>r.field == field).map((r)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to)));\n}\n/**\nConvert a snippet template to a function that can\n[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written\nusing syntax like this:\n\n    \"for (let ${index} = 0; ${index} < ${end}; ${index}++) {\\n\\t${}\\n}\"\n\nEach `${}` placeholder (you may also use `#{}`) indicates a field\nthat the user can fill in. Its name, if any, will be the default\ncontent for the field.\n\nWhen the snippet is activated by calling the returned function,\nthe code is inserted at the given position. Newlines in the\ntemplate are indented by the indentation of the start line, plus\none [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after\nthe newline.\n\nOn activation, (all instances of) the first field are selected.\nThe user can move between fields with Tab and Shift-Tab as long as\nthe fields are active. Moving to the last field or moving the\ncursor out of the current field deactivates the fields.\n\nThe order of fields defaults to textual order, but you can add\nnumbers to placeholders (`${1}` or `${1:defaultText}`) to provide\na custom order.\n\nTo include a literal `{` or `}` in your template, put a backslash\nin front of it. This will be removed and the brace will not be\ninterpreted as indicating a placeholder.\n*/ function snippet(template) {\n    let snippet = Snippet.parse(template);\n    return (editor, completion, from, to)=>{\n        let { text, ranges } = snippet.instantiate(editor.state, from);\n        let { main } = editor.state.selection;\n        let spec = {\n            changes: {\n                from,\n                to: to == main.from ? main.to : to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(text)\n            },\n            scrollIntoView: true,\n            annotations: completion ? [\n                pickedCompletion.of(completion),\n                _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent.of(\"input.complete\")\n            ] : undefined\n        };\n        if (ranges.length) spec.selection = fieldSelection(ranges, 0);\n        if (ranges.some((r)=>r.field > 0)) {\n            let active = new ActiveSnippet(ranges, 0);\n            let effects = spec.effects = [\n                setActive.of(active)\n            ];\n            if (editor.state.field(snippetState, false) === undefined) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([\n                snippetState,\n                addSnippetKeymap,\n                snippetPointerHandler,\n                baseTheme\n            ]));\n        }\n        editor.dispatch(editor.state.update(spec));\n    };\n}\nfunction moveField(dir) {\n    return ({ state, dispatch })=>{\n        let active = state.field(snippetState, false);\n        if (!active || dir < 0 && active.active == 0) return false;\n        let next = active.active + dir, last = dir > 0 && !active.ranges.some((r)=>r.field == next + dir);\n        dispatch(state.update({\n            selection: fieldSelection(active.ranges, next),\n            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),\n            scrollIntoView: true\n        }));\n        return true;\n    };\n}\n/**\nA command that clears the active snippet, if any.\n*/ const clearSnippet = ({ state, dispatch })=>{\n    let active = state.field(snippetState, false);\n    if (!active) return false;\n    dispatch(state.update({\n        effects: setActive.of(null)\n    }));\n    return true;\n};\n/**\nMove to the next snippet field, if available.\n*/ const nextSnippetField = /*@__PURE__*/ moveField(1);\n/**\nMove to the previous snippet field, if available.\n*/ const prevSnippetField = /*@__PURE__*/ moveField(-1);\n/**\nCheck if there is an active snippet with a next field for\n`nextSnippetField` to move to.\n*/ function hasNextSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.ranges.some((r)=>r.field == active.active + 1));\n}\n/**\nReturns true if there is an active snippet and a previous field\nfor `prevSnippetField` to move to.\n*/ function hasPrevSnippetField(state) {\n    let active = state.field(snippetState, false);\n    return !!(active && active.active > 0);\n}\nconst defaultSnippetKeymap = [\n    {\n        key: \"Tab\",\n        run: nextSnippetField,\n        shift: prevSnippetField\n    },\n    {\n        key: \"Escape\",\n        run: clearSnippet\n    }\n];\n/**\nA facet that can be used to configure the key bindings used by\nsnippets. The default binds Tab to\n[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to\n[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape\nto [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).\n*/ const snippetKeymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (maps) {\n        return maps.length ? maps[0] : defaultSnippetKeymap;\n    }\n});\nconst addSnippetKeymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.compute([\n    snippetKeymap\n], (state)=>state.facet(snippetKeymap)));\n/**\nCreate a completion from a snippet. Returns an object with the\nproperties from `completion`, plus an `apply` function that\napplies the snippet.\n*/ function snippetCompletion(template, completion) {\n    return Object.assign(Object.assign({}, completion), {\n        apply: snippet(template)\n    });\n}\nconst snippetPointerHandler = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n    mousedown (event, view) {\n        let active = view.state.field(snippetState, false), pos;\n        if (!active || (pos = view.posAtCoords({\n            x: event.clientX,\n            y: event.clientY\n        })) == null) return false;\n        let match = active.ranges.find((r)=>r.from <= pos && r.to >= pos);\n        if (!match || match.field == active.active) return false;\n        view.dispatch({\n            selection: fieldSelection(active.ranges, match.field),\n            effects: setActive.of(active.ranges.some((r)=>r.field > match.field) ? new ActiveSnippet(active.ranges, match.field) : null),\n            scrollIntoView: true\n        });\n        return true;\n    }\n});\nfunction wordRE(wordChars) {\n    let escaped = wordChars.replace(/[\\]\\-\\\\]/g, \"\\\\$&\");\n    try {\n        return new RegExp(`[\\\\p{Alphabetic}\\\\p{Number}_${escaped}]+`, \"ug\");\n    } catch (_a) {\n        return new RegExp(`[\\w${escaped}]`, \"g\");\n    }\n}\nfunction mapRE(re, f) {\n    return new RegExp(f(re.source), re.unicode ? \"u\" : \"\");\n}\nconst wordCaches = /*@__PURE__*/ Object.create(null);\nfunction wordCache(wordChars) {\n    return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);\n}\nfunction storeWords(doc, wordRE, result, seen, ignoreAt) {\n    for(let lines = doc.iterLines(), pos = 0; !lines.next().done;){\n        let { value } = lines, m;\n        wordRE.lastIndex = 0;\n        while(m = wordRE.exec(value)){\n            if (!seen[m[0]] && pos + m.index != ignoreAt) {\n                result.push({\n                    type: \"text\",\n                    label: m[0]\n                });\n                seen[m[0]] = true;\n                if (result.length >= 2000 /* C.MaxList */ ) return;\n            }\n        }\n        pos += value.length + 1;\n    }\n}\nfunction collectWords(doc, cache, wordRE, to, ignoreAt) {\n    let big = doc.length >= 1000 /* C.MinCacheLen */ ;\n    let cached = big && cache.get(doc);\n    if (cached) return cached;\n    let result = [], seen = Object.create(null);\n    if (doc.children) {\n        let pos = 0;\n        for (let ch of doc.children){\n            if (ch.length >= 1000 /* C.MinCacheLen */ ) {\n                for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)){\n                    if (!seen[c.label]) {\n                        seen[c.label] = true;\n                        result.push(c);\n                    }\n                }\n            } else {\n                storeWords(ch, wordRE, result, seen, ignoreAt - pos);\n            }\n            pos += ch.length + 1;\n        }\n    } else {\n        storeWords(doc, wordRE, result, seen, ignoreAt);\n    }\n    if (big && result.length < 2000 /* C.MaxList */ ) cache.set(doc, result);\n    return result;\n}\n/**\nA completion source that will scan the document for words (using a\n[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and\nreturn those as completions.\n*/ const completeAnyWord = (context)=>{\n    let wordChars = context.state.languageDataAt(\"wordChars\", context.pos).join(\"\");\n    let re = wordRE(wordChars);\n    let token = context.matchBefore(mapRE(re, (s)=>s + \"$\"));\n    if (!token && !context.explicit) return null;\n    let from = token ? token.from : context.pos;\n    let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* C.Range */ , from);\n    return {\n        from,\n        options,\n        validFor: mapRE(re, (s)=>\"^\" + s)\n    };\n};\nconst defaults = {\n    brackets: [\n        \"(\",\n        \"[\",\n        \"{\",\n        \"'\",\n        '\"'\n    ],\n    before: \")]}:;>\",\n    stringPrefixes: []\n};\nconst closeBracketEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define({\n    map (value, mapping) {\n        let mapped = mapping.mapPos(value, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.MapMode.TrackAfter);\n        return mapped == null ? undefined : mapped;\n    }\n});\nconst closedBracket = /*@__PURE__*/ new class extends _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeValue {\n};\nclosedBracket.startSide = 1;\nclosedBracket.endSide = -1;\nconst bracketState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\n    },\n    update (value, tr) {\n        value = value.map(tr.changes);\n        if (tr.selection) {\n            let line = tr.state.doc.lineAt(tr.selection.main.head);\n            value = value.update({\n                filter: (from)=>from >= line.from && from <= line.to\n            });\n        }\n        for (let effect of tr.effects)if (effect.is(closeBracketEffect)) value = value.update({\n            add: [\n                closedBracket.range(effect.value, effect.value + 1)\n            ]\n        });\n        return value;\n    }\n});\n/**\nExtension to enable bracket-closing behavior. When a closeable\nbracket is typed, its closing bracket is immediately inserted\nafter the cursor. When closing a bracket directly in front of a\nclosing bracket inserted by the extension, the cursor moves over\nthat bracket.\n*/ function closeBrackets() {\n    return [\n        inputHandler,\n        bracketState\n    ];\n}\nconst definedClosing = \"()[]{}<>\\xab\\xbb\\xbb\\xab［］｛｝\";\nfunction closing(ch) {\n    for(let i = 0; i < definedClosing.length; i += 2)if (definedClosing.charCodeAt(i) == ch) return definedClosing.charAt(i + 1);\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(ch < 128 ? ch : ch + 1);\n}\nfunction config(state, pos) {\n    return state.languageDataAt(\"closeBrackets\", pos)[0] || defaults;\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*/ /Android\\b/.test(navigator.userAgent);\nconst inputHandler = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.inputHandler.of((view, from, to, insert)=>{\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly) return false;\n    let sel = view.state.selection.main;\n    if (insert.length > 2 || insert.length == 2 && (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(insert, 0)) == 1 || from != sel.from || to != sel.to) return false;\n    let tr = insertBracket(view.state, insert);\n    if (!tr) return false;\n    view.dispatch(tr);\n    return true;\n});\n/**\nCommand that implements deleting a pair of matching brackets when\nthe cursor is between them.\n*/ const deleteBracketPair = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (range.empty) {\n            let before = prevChar(state.doc, range.head);\n            for (let token of tokens){\n                if (token == before && nextChar(state.doc, range.head) == closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(token, 0))) return {\n                    changes: {\n                        from: range.head - token.length,\n                        to: range.head + token.length\n                    },\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head - token.length)\n                };\n            }\n        }\n        return {\n            range: dont = range\n        };\n    });\n    if (!dont) dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"delete.backward\"\n    }));\n    return !dont;\n};\n/**\nClose-brackets related key bindings. Binds Backspace to\n[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).\n*/ const closeBracketsKeymap = [\n    {\n        key: \"Backspace\",\n        run: deleteBracketPair\n    }\n];\n/**\nImplements the extension's behavior on text insertion. If the\ngiven string counts as a bracket in the language around the\nselection, and replacing the selection with it requires custom\nbehavior (inserting a closing version or skipping past a\npreviously-closed bracket), this function returns a transaction\nrepresenting that custom behavior. (You only need this if you want\nto programmatically insert brackets—the\n[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will\ntake care of running this for user input.)\n*/ function insertBracket(state, bracket) {\n    let conf = config(state, state.selection.main.head);\n    let tokens = conf.brackets || defaults.brackets;\n    for (let tok of tokens){\n        let closed = closing((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(tok, 0));\n        if (bracket == tok) return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf) : handleOpen(state, tok, closed, conf.before || defaults.before);\n        if (bracket == closed && closedBracketAt(state, state.selection.main.from)) return handleClose(state, tok, closed);\n    }\n    return null;\n}\nfunction closedBracketAt(state, pos) {\n    let found = false;\n    state.field(bracketState).between(0, state.doc.length, (from)=>{\n        if (from == pos) found = true;\n    });\n    return found;\n}\nfunction nextChar(doc, pos) {\n    let next = doc.sliceString(pos, pos + 2);\n    return next.slice(0, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(next, 0)));\n}\nfunction prevChar(doc, pos) {\n    let prev = doc.sliceString(pos - 2, pos);\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(prev, 0)) == prev.length ? prev : prev.slice(1);\n}\nfunction handleOpen(state, open, close, closeBefore) {\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (!range.empty) return {\n            changes: [\n                {\n                    insert: open,\n                    from: range.from\n                },\n                {\n                    insert: close,\n                    from: range.to\n                }\n            ],\n            effects: closeBracketEffect.of(range.to + open.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + open.length, range.head + open.length)\n        };\n        let next = nextChar(state.doc, range.head);\n        if (!next || /\\s/.test(next) || closeBefore.indexOf(next) > -1) return {\n            changes: {\n                insert: open + close,\n                from: range.head\n            },\n            effects: closeBracketEffect.of(range.head + open.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + open.length)\n        };\n        return {\n            range: dont = range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction handleClose(state, _open, close) {\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (range.empty && nextChar(state.doc, range.head) == close) return {\n            changes: {\n                from: range.head,\n                to: range.head + close.length,\n                insert: close\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + close.length)\n        };\n        return dont = {\n            range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\n// Handles cases where the open and close token are the same, and\n// possibly triple quotes (as in `\"\"\"abc\"\"\"`-style quoting).\nfunction handleSame(state, token, allowTriple, config) {\n    let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;\n    let dont = null, changes = state.changeByRange((range)=>{\n        if (!range.empty) return {\n            changes: [\n                {\n                    insert: token,\n                    from: range.from\n                },\n                {\n                    insert: token,\n                    from: range.to\n                }\n            ],\n            effects: closeBracketEffect.of(range.to + token.length),\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor + token.length, range.head + token.length)\n        };\n        let pos = range.head, next = nextChar(state.doc, pos), start;\n        if (next == token) {\n            if (nodeStart(state, pos)) {\n                return {\n                    changes: {\n                        insert: token + token,\n                        from: pos\n                    },\n                    effects: closeBracketEffect.of(pos + token.length),\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n                };\n            } else if (closedBracketAt(state, pos)) {\n                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;\n                let content = isTriple ? token + token + token : token;\n                return {\n                    changes: {\n                        from: pos,\n                        to: pos + content.length,\n                        insert: content\n                    },\n                    range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + content.length)\n                };\n            }\n        } else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token && (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 && nodeStart(state, start)) {\n            return {\n                changes: {\n                    insert: token + token + token + token,\n                    from: pos\n                },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n            };\n        } else if (state.charCategorizer(pos)(next) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n            if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes)) return {\n                changes: {\n                    insert: token + token,\n                    from: pos\n                },\n                effects: closeBracketEffect.of(pos + token.length),\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos + token.length)\n            };\n        }\n        return {\n            range: dont = range\n        };\n    });\n    return dont ? null : state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input.type\"\n    });\n}\nfunction nodeStart(state, pos) {\n    let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos + 1);\n    return tree.parent && tree.from == pos;\n}\nfunction probablyInString(state, pos, quoteToken, prefixes) {\n    let node = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_0__.syntaxTree)(state).resolveInner(pos, -1);\n    let maxPrefix = prefixes.reduce((m, p)=>Math.max(m, p.length), 0);\n    for(let i = 0; i < 5; i++){\n        let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));\n        let quotePos = start.indexOf(quoteToken);\n        if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {\n            let first = node.firstChild;\n            while(first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos){\n                if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken) return false;\n                first = first.firstChild;\n            }\n            return true;\n        }\n        let parent = node.to == pos && node.parent;\n        if (!parent) break;\n        node = parent;\n    }\n    return false;\n}\nfunction canStartStringAt(state, pos, prefixes) {\n    let charCat = state.charCategorizer(pos);\n    if (charCat(state.sliceDoc(pos - 1, pos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) return pos;\n    for (let prefix of prefixes){\n        let start = pos - prefix.length;\n        if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) return start;\n    }\n    return -1;\n}\n/**\nReturns an extension that enables autocompletion.\n*/ function autocompletion(config = {}) {\n    return [\n        commitCharacters,\n        completionState,\n        completionConfig.of(config),\n        completionPlugin,\n        completionKeymapExt,\n        baseTheme\n    ];\n}\n/**\nBasic keybindings for autocompletion.\n\n - Ctrl-Space (and Alt-\\` on macOS): [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)\n - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)\n - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`\n - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, \"page\")`\n - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)\n*/ const completionKeymap = [\n    {\n        key: \"Ctrl-Space\",\n        run: startCompletion\n    },\n    {\n        mac: \"Alt-`\",\n        run: startCompletion\n    },\n    {\n        key: \"Escape\",\n        run: closeCompletion\n    },\n    {\n        key: \"ArrowDown\",\n        run: /*@__PURE__*/ moveCompletionSelection(true)\n    },\n    {\n        key: \"ArrowUp\",\n        run: /*@__PURE__*/ moveCompletionSelection(false)\n    },\n    {\n        key: \"PageDown\",\n        run: /*@__PURE__*/ moveCompletionSelection(true, \"page\")\n    },\n    {\n        key: \"PageUp\",\n        run: /*@__PURE__*/ moveCompletionSelection(false, \"page\")\n    },\n    {\n        key: \"Enter\",\n        run: acceptCompletion\n    }\n];\nconst completionKeymapExt = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.highest(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.keymap.computeN([\n    completionConfig\n], (state)=>state.facet(completionConfig).defaultKeymap ? [\n        completionKeymap\n    ] : []));\n/**\nGet the current completion status. When completions are available,\nthis will return `\"active\"`. When completions are pending (in the\nprocess of being queried), this returns `\"pending\"`. Otherwise, it\nreturns `null`.\n*/ function completionStatus(state) {\n    let cState = state.field(completionState, false);\n    return cState && cState.active.some((a)=>a.isPending) ? \"pending\" : cState && cState.active.some((a)=>a.state != 0 /* State.Inactive */ ) ? \"active\" : null;\n}\nconst completionArrayCache = /*@__PURE__*/ new WeakMap;\n/**\nReturns the available completions as an array.\n*/ function currentCompletions(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    if (!open || open.disabled) return [];\n    let completions = completionArrayCache.get(open.options);\n    if (!completions) completionArrayCache.set(open.options, completions = open.options.map((o)=>o.completion));\n    return completions;\n}\n/**\nReturn the currently selected completion, if any.\n*/ function selectedCompletion(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;\n}\n/**\nReturns the currently selected position in the active completion\nlist, or null if no completions are active.\n*/ function selectedCompletionIndex(state) {\n    var _a;\n    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;\n    return open && !open.disabled && open.selected >= 0 ? open.selected : null;\n}\n/**\nCreate an effect that can be attached to a transaction to change\nthe currently selected completion.\n*/ function setSelectedCompletion(index) {\n    return setSelectedEffect.of(index);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdPO0FBQ3BGO0FBQzlFO0FBRTlEOztBQUVBLEdBQ0EsTUFBTTJCO0lBQ0Y7Ozs7SUFJQSxHQUNBQyxZQUNBOztJQUVBLEdBQ0FDLEtBQUssRUFDTDs7SUFFQSxHQUNBQyxHQUFHLEVBQ0g7Ozs7O0lBS0EsR0FDQUMsUUFBUSxFQUNSOzs7Ozs7SUFNQSxHQUNBQyxJQUFJLENBQUU7UUFDRixJQUFJLENBQUNILEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO1FBQ1o7O1FBRUEsR0FDQSxJQUFJLENBQUNDLGNBQWMsR0FBRyxFQUFFO1FBQ3hCOztRQUVBLEdBQ0EsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztJQUM1QjtJQUNBOzs7SUFHQSxHQUNBQyxZQUFZQyxLQUFLLEVBQUU7UUFDZixJQUFJQyxRQUFRWixnRUFBVUEsQ0FBQyxJQUFJLENBQUNJLEtBQUssRUFBRVMsWUFBWSxDQUFDLElBQUksQ0FBQ1IsR0FBRyxFQUFFLENBQUM7UUFDM0QsTUFBT08sU0FBU0QsTUFBTUcsT0FBTyxDQUFDRixNQUFNRyxJQUFJLElBQUksRUFDeENILFFBQVFBLE1BQU1JLE1BQU07UUFDeEIsT0FBT0osUUFBUTtZQUFFSyxNQUFNTCxNQUFNSyxJQUFJO1lBQUVDLElBQUksSUFBSSxDQUFDYixHQUFHO1lBQzNDYyxNQUFNLElBQUksQ0FBQ2YsS0FBSyxDQUFDZ0IsUUFBUSxDQUFDUixNQUFNSyxJQUFJLEVBQUUsSUFBSSxDQUFDWixHQUFHO1lBQzlDZ0IsTUFBTVQsTUFBTVMsSUFBSTtRQUFDLElBQUk7SUFDN0I7SUFDQTs7O0lBR0EsR0FDQUMsWUFBWUMsSUFBSSxF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QUNBLFNBQVM0WSxzQkFBc0JqSSxLQUFLO0lBQ2hDLE9BQU9ySSxrQkFBa0J6RyxFQUFFLENBQUM4TztBQUNoQztBQUU2aEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmljaGUvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvYXV0b2NvbXBsZXRlL2Rpc3QvaW5kZXguanM/YTEwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbm5vdGF0aW9uLCBTdGF0ZUVmZmVjdCwgRWRpdG9yU2VsZWN0aW9uLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgZnJvbUNvZGVQb2ludCwgRmFjZXQsIGNvbWJpbmVDb25maWcsIFN0YXRlRmllbGQsIFByZWMsIFRleHQsIFRyYW5zYWN0aW9uLCBNYXBNb2RlLCBSYW5nZVZhbHVlLCBSYW5nZVNldCwgQ2hhckNhdGVnb3J5IH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgRGlyZWN0aW9uLCBsb2dFeGNlcHRpb24sIHNob3dUb29sdGlwLCBFZGl0b3JWaWV3LCBWaWV3UGx1Z2luLCBnZXRUb29sdGlwLCBEZWNvcmF0aW9uLCBXaWRnZXRUeXBlLCBrZXltYXAgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IHN5bnRheFRyZWUsIGluZGVudFVuaXQgfSBmcm9tICdAY29kZW1pcnJvci9sYW5ndWFnZSc7XG5cbi8qKlxuQW4gaW5zdGFuY2Ugb2YgdGhpcyBpcyBwYXNzZWQgdG8gY29tcGxldGlvbiBzb3VyY2UgZnVuY3Rpb25zLlxuKi9cbmNsYXNzIENvbXBsZXRpb25Db250ZXh0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgY29tcGxldGlvbiBjb250ZXh0LiAoTW9zdGx5IHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgIGNvbXBsZXRpb24gc291cmNlc+KAlGluIHRoZSBlZGl0b3IsIHRoZSBleHRlbnNpb24gd2lsbCBjcmVhdGVcbiAgICB0aGVzZSBmb3IgeW91LilcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igc3RhdGUgdGhhdCB0aGUgY29tcGxldGlvbiBoYXBwZW5zIGluLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB3aGljaCB0aGUgY29tcGxldGlvbiBpcyBoYXBwZW5pbmcuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIGNvbXBsZXRpb24gd2FzIGFjdGl2YXRlZCBleHBsaWNpdGx5LCBvclxuICAgIGltcGxpY2l0bHkgYnkgdHlwaW5nLiBUaGUgdXN1YWwgd2F5IHRvIHJlc3BvbmQgdG8gdGhpcyBpcyB0b1xuICAgIG9ubHkgcmV0dXJuIGNvbXBsZXRpb25zIHdoZW4gZWl0aGVyIHRoZXJlIGlzIHBhcnQgb2YgYVxuICAgIGNvbXBsZXRhYmxlIGVudGl0eSBiZWZvcmUgdGhlIGN1cnNvciwgb3IgYGV4cGxpY2l0YCBpcyB0cnVlLlxuICAgICovXG4gICAgZXhwbGljaXQsIFxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3Igdmlldy4gTWF5IGJlIHVuZGVmaW5lZCBpZiB0aGUgY29udGV4dCB3YXMgY3JlYXRlZFxuICAgIGluIGEgc2l0dWF0aW9uIHdoZXJlIHRoZXJlIGlzIG5vIHN1Y2ggdmlldyBhdmFpbGFibGUsIHN1Y2ggYXNcbiAgICBpbiBzeW5jaHJvbm91cyB1cGRhdGVzIHZpYVxuICAgIFtgQ29tcGxldGlvblJlc3VsdC51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5Db21wbGV0aW9uUmVzdWx0LnVwZGF0ZSlcbiAgICBvciB3aGVuIGNhbGxlZCBieSB0ZXN0IGNvZGUuXG4gICAgKi9cbiAgICB2aWV3KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZXhwbGljaXQgPSBleHBsaWNpdDtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmFib3J0TGlzdGVuZXJzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hYm9ydE9uRG9jQ2hhbmdlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZXh0ZW50LCBjb250ZW50LCBhbmQgKGlmIHRoZXJlIGlzIGEgdG9rZW4pIHR5cGUgb2YgdGhlXG4gICAgdG9rZW4gYmVmb3JlIGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICB0b2tlbkJlZm9yZSh0eXBlcykge1xuICAgICAgICBsZXQgdG9rZW4gPSBzeW50YXhUcmVlKHRoaXMuc3RhdGUpLnJlc29sdmVJbm5lcih0aGlzLnBvcywgLTEpO1xuICAgICAgICB3aGlsZSAodG9rZW4gJiYgdHlwZXMuaW5kZXhPZih0b2tlbi5uYW1lKSA8IDApXG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHRva2VuID8geyBmcm9tOiB0b2tlbi5mcm9tLCB0bzogdGhpcy5wb3MsXG4gICAgICAgICAgICB0ZXh0OiB0aGlzLnN0YXRlLnNsaWNlRG9jKHRva2VuLmZyb20sIHRoaXMucG9zKSxcbiAgICAgICAgICAgIHR5cGU6IHRva2VuLnR5cGUgfSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbWF0Y2ggb2YgdGhlIGdpdmVuIGV4cHJlc3Npb24gZGlyZWN0bHkgYmVmb3JlIHRoZVxuICAgIGN1cnNvci5cbiAgICAqL1xuICAgIG1hdGNoQmVmb3JlKGV4cHIpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChsaW5lLmZyb20sIHRoaXMucG9zIC0gMjUwKTtcbiAgICAgICAgbGV0IHN0ciA9IGxpbmUudGV4dC5zbGljZShzdGFydCAtIGxpbmUuZnJvbSwgdGhpcy5wb3MgLSBsaW5lLmZyb20pO1xuICAgICAgICBsZXQgZm91bmQgPSBzdHIuc2VhcmNoKGVuc3VyZUFuY2hvcihleHByLCBmYWxzZSkpO1xuICAgICAgICByZXR1cm4gZm91bmQgPCAwID8gbnVsbCA6IHsgZnJvbTogc3RhcnQgKyBmb3VuZCwgdG86IHRoaXMucG9zLCB0ZXh0OiBzdHIuc2xpY2UoZm91bmQpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIFlpZWxkcyB0cnVlIHdoZW4gdGhlIHF1ZXJ5IGhhcyBiZWVuIGFib3J0ZWQuIENhbiBiZSB1c2VmdWwgaW5cbiAgICBhc3luY2hyb25vdXMgcXVlcmllcyB0byBhdm9pZCBkb2luZyB3b3JrIHRoYXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgICovXG4gICAgZ2V0IGFib3J0ZWQoKSB7IHJldHVybiB0aGlzLmFib3J0TGlzdGVuZXJzID09IG51bGw7IH1cbiAgICAvKipcbiAgICBBbGxvd3MgeW91IHRvIHJlZ2lzdGVyIGFib3J0IGhhbmRsZXJzLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gICAgdGhlIHF1ZXJ5IGlzXG4gICAgW2Fib3J0ZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLkNvbXBsZXRpb25Db250ZXh0LmFib3J0ZWQpLlxuICAgIFxuICAgIEJ5IGRlZmF1bHQsIHJ1bm5pbmcgcXVlcmllcyB3aWxsIG5vdCBiZSBhYm9ydGVkIGZvciByZWd1bGFyXG4gICAgdHlwaW5nIG9yIGJhY2tzcGFjaW5nLCBvbiB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZXkgYXJlIGxpa2VseSB0b1xuICAgIHJldHVybiBhIHJlc3VsdCB3aXRoIGFcbiAgICBbYHZhbGlkRm9yYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvblJlc3VsdC52YWxpZEZvcikgZmllbGQgdGhhdFxuICAgIGFsbG93cyB0aGUgcmVzdWx0IHRvIGJlIHVzZWQgYWZ0ZXIgYWxsLiBQYXNzaW5nIGBvbkRvY0NoYW5nZTpcbiAgICB0cnVlYCB3aWxsIGNhdXNlIHRoaXMgcXVlcnkgdG8gYmUgYWJvcnRlZCBmb3IgYW55IGRvY3VtZW50XG4gICAgY2hhbmdlLlxuICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZSA9PSBcImFib3J0XCIgJiYgdGhpcy5hYm9ydExpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5hYm9ydExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMub25Eb2NDaGFuZ2UpXG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydE9uRG9jQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU2V0KGNoYXJzKSB7XG4gICAgbGV0IGZsYXQgPSBPYmplY3Qua2V5cyhjaGFycykuam9pbihcIlwiKTtcbiAgICBsZXQgd29yZHMgPSAvXFx3Ly50ZXN0KGZsYXQpO1xuICAgIGlmICh3b3JkcylcbiAgICAgICAgZmxhdCA9IGZsYXQucmVwbGFjZSgvXFx3L2csIFwiXCIpO1xuICAgIHJldHVybiBgWyR7d29yZHMgPyBcIlxcXFx3XCIgOiBcIlwifSR7ZmxhdC5yZXBsYWNlKC9bXlxcd1xcc10vZywgXCJcXFxcJCZcIil9XWA7XG59XG5mdW5jdGlvbiBwcmVmaXhNYXRjaChvcHRpb25zKSB7XG4gICAgbGV0IGZpcnN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcmVzdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgeyBsYWJlbCB9IG9mIG9wdGlvbnMpIHtcbiAgICAgICAgZmlyc3RbbGFiZWxbMF1dID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYWJlbC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3RbbGFiZWxbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHNvdXJjZSA9IHRvU2V0KGZpcnN0KSArIHRvU2V0KHJlc3QpICsgXCIqJFwiO1xuICAgIHJldHVybiBbbmV3IFJlZ0V4cChcIl5cIiArIHNvdXJjZSksIG5ldyBSZWdFeHAoc291cmNlKV07XG59XG4vKipcbkdpdmVuIGEgYSBmaXhlZCBhcnJheSBvZiBvcHRpb25zLCByZXR1cm4gYW4gYXV0b2NvbXBsZXRlciB0aGF0XG5jb21wbGV0ZXMgdGhlbS5cbiovXG5mdW5jdGlvbiBjb21wbGV0ZUZyb21MaXN0KGxpc3QpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGxpc3QubWFwKG8gPT4gdHlwZW9mIG8gPT0gXCJzdHJpbmdcIiA/IHsgbGFiZWw6IG8gfSA6IG8pO1xuICAgIGxldCBbdmFsaWRGb3IsIG1hdGNoXSA9IG9wdGlvbnMuZXZlcnkobyA9PiAvXlxcdyskLy50ZXN0KG8ubGFiZWwpKSA/IFsvXFx3KiQvLCAvXFx3KyQvXSA6IHByZWZpeE1hdGNoKG9wdGlvbnMpO1xuICAgIHJldHVybiAoY29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgdG9rZW4gPSBjb250ZXh0Lm1hdGNoQmVmb3JlKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuIHx8IGNvbnRleHQuZXhwbGljaXQgPyB7IGZyb206IHRva2VuID8gdG9rZW4uZnJvbSA6IGNvbnRleHQucG9zLCBvcHRpb25zLCB2YWxpZEZvciB9IDogbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgb25seSBmaXJlIHdoZW4gdGhlXG5jdXJzb3IgaXMgaW4gYSBzeW50YXggbm9kZSB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbmFtZXMuXG4qL1xuZnVuY3Rpb24gaWZJbihub2Rlcywgc291cmNlKSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHN5bnRheFRyZWUoY29udGV4dC5zdGF0ZSkucmVzb2x2ZUlubmVyKGNvbnRleHQucG9zLCAtMSk7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKG5vZGVzLmluZGV4T2YocG9zLm5hbWUpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZShjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChwb3MudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuLyoqXG5XcmFwIHRoZSBnaXZlbiBjb21wbGV0aW9uIHNvdXJjZSBzbyB0aGF0IGl0IHdpbGwgbm90IGZpcmUgd2hlbiB0aGVcbmN1cnNvciBpcyBpbiBhIHN5bnRheCBub2RlIHdpdGggb25lIG9mIHRoZSBnaXZlbiBuYW1lcy5cbiovXG5mdW5jdGlvbiBpZk5vdEluKG5vZGVzLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKS5yZXNvbHZlSW5uZXIoY29udGV4dC5wb3MsIC0xKTsgcG9zOyBwb3MgPSBwb3MucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZXMuaW5kZXhPZihwb3MubmFtZSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwb3MudHlwZS5pc1RvcClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlKGNvbnRleHQpO1xuICAgIH07XG59XG5jbGFzcyBPcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBsZXRpb24sIHNvdXJjZSwgbWF0Y2gsIHNjb3JlKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGlvbiA9IGNvbXBsZXRpb247XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIHRoaXMuc2NvcmUgPSBzY29yZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjdXIoc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnNlbGVjdGlvbi5tYWluLmZyb207IH1cbi8vIE1ha2Ugc3VyZSB0aGUgZ2l2ZW4gcmVnZXhwIGhhcyBhICQgYXQgaXRzIGVuZCBhbmQsIGlmIGBzdGFydGAgaXNcbi8vIHRydWUsIGEgXiBhdCBpdHMgc3RhcnQuXG5mdW5jdGlvbiBlbnN1cmVBbmNob3IoZXhwciwgc3RhcnQpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgc291cmNlIH0gPSBleHByO1xuICAgIGxldCBhZGRTdGFydCA9IHN0YXJ0ICYmIHNvdXJjZVswXSAhPSBcIl5cIiwgYWRkRW5kID0gc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPSBcIiRcIjtcbiAgICBpZiAoIWFkZFN0YXJ0ICYmICFhZGRFbmQpXG4gICAgICAgIHJldHVybiBleHByO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGAke2FkZFN0YXJ0ID8gXCJeXCIgOiBcIlwifSg/OiR7c291cmNlfSkke2FkZEVuZCA/IFwiJFwiIDogXCJcIn1gLCAoX2EgPSBleHByLmZsYWdzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoZXhwci5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSk7XG59XG4vKipcblRoaXMgYW5ub3RhdGlvbiBpcyBhZGRlZCB0byB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgcHJvZHVjZWQgYnlcbnBpY2tpbmcgYSBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IHBpY2tlZENvbXBsZXRpb24gPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHRyYW5zYWN0aW9uIHNwZWMgd2hpY2ggaW5zZXJ0cyBhXG5jb21wbGV0aW9uJ3MgdGV4dCBpbiB0aGUgbWFpbiBzZWxlY3Rpb24gcmFuZ2UsIGFuZCBhbnkgb3RoZXJcbnNlbGVjdGlvbiByYW5nZSB0aGF0IGhhcyB0aGUgc2FtZSB0ZXh0IGluIGZyb250IG9mIGl0LlxuKi9cbmZ1bmN0aW9uIGluc2VydENvbXBsZXRpb25UZXh0KHN0YXRlLCB0ZXh0LCBmcm9tLCB0bykge1xuICAgIGxldCB7IG1haW4gfSA9IHN0YXRlLnNlbGVjdGlvbiwgZnJvbU9mZiA9IGZyb20gLSBtYWluLmZyb20sIHRvT2ZmID0gdG8gLSBtYWluLmZyb207XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmIChyYW5nZSAhPSBtYWluICYmIGZyb20gIT0gdG8gJiZcbiAgICAgICAgICAgIHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20gKyBmcm9tT2ZmLCByYW5nZS5mcm9tICsgdG9PZmYpICE9IHN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSlcbiAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgIGxldCBsaW5lcyA9IHN0YXRlLnRvVGV4dCh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSArIGZyb21PZmYsIHRvOiB0byA9PSBtYWluLmZyb20gPyByYW5nZS50byA6IHJhbmdlLmZyb20gKyB0b09mZiwgaW5zZXJ0OiBsaW5lcyB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGZyb21PZmYgKyBsaW5lcy5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgfSkpLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXQuY29tcGxldGVcIiB9KTtcbn1cbmNvbnN0IFNvdXJjZUNhY2hlID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBhc1NvdXJjZShzb3VyY2UpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc291cmNlKSlcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICBsZXQga25vd24gPSBTb3VyY2VDYWNoZS5nZXQoc291cmNlKTtcbiAgICBpZiAoIWtub3duKVxuICAgICAgICBTb3VyY2VDYWNoZS5zZXQoc291cmNlLCBrbm93biA9IGNvbXBsZXRlRnJvbUxpc3Qoc291cmNlKSk7XG4gICAgcmV0dXJuIGtub3duO1xufVxuY29uc3Qgc3RhcnRDb21wbGV0aW9uRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgY2xvc2VDb21wbGV0aW9uRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuXG4vLyBBIHBhdHRlcm4gbWF0Y2hlciBmb3IgZnV6enkgY29tcGxldGlvbiBtYXRjaGluZy4gQ3JlYXRlIGFuIGluc3RhbmNlXG4vLyBvbmNlIGZvciBhIHBhdHRlcm4sIGFuZCB0aGVuIHVzZSB0aGF0IHRvIG1hdGNoIGFueSBudW1iZXIgb2Zcbi8vIGNvbXBsZXRpb25zLlxuY2xhc3MgRnV6enlNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMuY2hhcnMgPSBbXTtcbiAgICAgICAgdGhpcy5mb2xkZWQgPSBbXTtcbiAgICAgICAgLy8gQnVmZmVycyByZXVzZWQgYnkgY2FsbHMgdG8gYG1hdGNoYCB0byB0cmFjayBtYXRjaGVkIGNoYXJhY3RlclxuICAgICAgICAvLyBwb3NpdGlvbnMuXG4gICAgICAgIHRoaXMuYW55ID0gW107XG4gICAgICAgIHRoaXMucHJlY2lzZSA9IFtdO1xuICAgICAgICB0aGlzLmJ5V29yZCA9IFtdO1xuICAgICAgICB0aGlzLnNjb3JlID0gMDtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgcGF0dGVybi5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgY2hhciA9IGNvZGVQb2ludEF0KHBhdHRlcm4sIHApLCBzaXplID0gY29kZVBvaW50U2l6ZShjaGFyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhcnMucHVzaChjaGFyKTtcbiAgICAgICAgICAgIGxldCBwYXJ0ID0gcGF0dGVybi5zbGljZShwLCBwICsgc2l6ZSksIHVwcGVyID0gcGFydC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5mb2xkZWQucHVzaChjb2RlUG9pbnRBdCh1cHBlciA9PSBwYXJ0ID8gcGFydC50b0xvd2VyQ2FzZSgpIDogdXBwZXIsIDApKTtcbiAgICAgICAgICAgIHAgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzdHJhbCA9IHBhdHRlcm4ubGVuZ3RoICE9IHRoaXMuY2hhcnMubGVuZ3RoO1xuICAgIH1cbiAgICByZXQoc2NvcmUsIG1hdGNoZWQpIHtcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgICAgICB0aGlzLm1hdGNoZWQgPSBtYXRjaGVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gTWF0Y2hlcyBhIGdpdmVuIHdvcmQgKGNvbXBsZXRpb24pIGFnYWluc3QgdGhlIHBhdHRlcm4gKGlucHV0KS5cbiAgICAvLyBXaWxsIHJldHVybiBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZXJlIHdhcyBhIG1hdGNoIGFuZCxcbiAgICAvLyBvbiBzdWNjZXNzLCBzZXQgYHRoaXMuc2NvcmVgIHRvIHRoZSBzY29yZSwgYHRoaXMubWF0Y2hlZGAgdG8gYW5cbiAgICAvLyBhcnJheSBvZiBgZnJvbSwgdG9gIHBhaXJzIGluZGljYXRpbmcgdGhlIG1hdGNoZWQgcGFydHMgb2YgYHdvcmRgLlxuICAgIC8vXG4gICAgLy8gVGhlIHNjb3JlIGlzIGEgbnVtYmVyIHRoYXQgaXMgbW9yZSBuZWdhdGl2ZSB0aGUgd29yc2UgdGhlIG1hdGNoXG4gICAgLy8gaXMuIFNlZSBgUGVuYWx0eWAgYWJvdmUuXG4gICAgbWF0Y2god29yZCkge1xuICAgICAgICBpZiAodGhpcy5wYXR0ZXJuLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KC0xMDAgLyogUGVuYWx0eS5Ob3RGdWxsICovLCBbXSk7XG4gICAgICAgIGlmICh3b3JkLmxlbmd0aCA8IHRoaXMucGF0dGVybi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHsgY2hhcnMsIGZvbGRlZCwgYW55LCBwcmVjaXNlLCBieVdvcmQgfSA9IHRoaXM7XG4gICAgICAgIC8vIEZvciBzaW5nbGUtY2hhcmFjdGVyIHF1ZXJpZXMsIG9ubHkgbWF0Y2ggd2hlbiB0aGV5IG9jY3VyIHJpZ2h0XG4gICAgICAgIC8vIGF0IHRoZSBzdGFydFxuICAgICAgICBpZiAoY2hhcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IGNvZGVQb2ludEF0KHdvcmQsIDApLCBmaXJzdFNpemUgPSBjb2RlUG9pbnRTaXplKGZpcnN0KTtcbiAgICAgICAgICAgIGxldCBzY29yZSA9IGZpcnN0U2l6ZSA9PSB3b3JkLmxlbmd0aCA/IDAgOiAtMTAwIC8qIFBlbmFsdHkuTm90RnVsbCAqLztcbiAgICAgICAgICAgIGlmIChmaXJzdCA9PSBjaGFyc1swXSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QgPT0gZm9sZGVkWzBdKVxuICAgICAgICAgICAgICAgIHNjb3JlICs9IC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldChzY29yZSwgWzAsIGZpcnN0U2l6ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaXJlY3QgPSB3b3JkLmluZGV4T2YodGhpcy5wYXR0ZXJuKTtcbiAgICAgICAgaWYgKGRpcmVjdCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KHdvcmQubGVuZ3RoID09IHRoaXMucGF0dGVybi5sZW5ndGggPyAwIDogLTEwMCAvKiBQZW5hbHR5Lk5vdEZ1bGwgKi8sIFswLCB0aGlzLnBhdHRlcm4ubGVuZ3RoXSk7XG4gICAgICAgIGxldCBsZW4gPSBjaGFycy5sZW5ndGgsIGFueVRvID0gMDtcbiAgICAgICAgaWYgKGRpcmVjdCA8IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBlID0gTWF0aC5taW4od29yZC5sZW5ndGgsIDIwMCk7IGkgPCBlICYmIGFueVRvIDwgbGVuOykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQod29yZCwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gY2hhcnNbYW55VG9dIHx8IG5leHQgPT0gZm9sZGVkW2FueVRvXSlcbiAgICAgICAgICAgICAgICAgICAgYW55W2FueVRvKytdID0gaTtcbiAgICAgICAgICAgICAgICBpICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBtYXRjaCwgZXhpdCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGFueVRvIDwgbGVuKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgdHJhY2tzIHRoZSBleHRlbnQgb2YgdGhlIHByZWNpc2UgKG5vbi1mb2xkZWQsIG5vdFxuICAgICAgICAvLyBuZWNlc3NhcmlseSBhZGphY2VudCkgbWF0Y2hcbiAgICAgICAgbGV0IHByZWNpc2VUbyA9IDA7XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIHRoZXJlIGlzIGEgbWF0Y2ggdGhhdCBoaXRzIG9ubHkgY2hhcmFjdGVycyB0aGF0XG4gICAgICAgIC8vIGFwcGVhciB0byBiZSBzdGFydGluZyB3b3Jkcy4gYGJ5V29yZEZvbGRlZGAgaXMgc2V0IHRvIHRydWUgd2hlblxuICAgICAgICAvLyBhIGNhc2UgZm9sZGVkIGNoYXJhY3RlciBpcyBlbmNvdW50ZXJlZCBpbiBzdWNoIGEgbWF0Y2hcbiAgICAgICAgbGV0IGJ5V29yZFRvID0gMCwgYnlXb3JkRm9sZGVkID0gZmFsc2U7XG4gICAgICAgIC8vIElmIHdlJ3ZlIGZvdW5kIGEgcGFydGlhbCBhZGphY2VudCBtYXRjaCwgdGhlc2UgdHJhY2sgaXRzIHN0YXRlXG4gICAgICAgIGxldCBhZGphY2VudFRvID0gMCwgYWRqYWNlbnRTdGFydCA9IC0xLCBhZGphY2VudEVuZCA9IC0xO1xuICAgICAgICBsZXQgaGFzTG93ZXIgPSAvW2Etel0vLnRlc3Qod29yZCksIHdvcmRBZGphY2VudCA9IHRydWU7XG4gICAgICAgIC8vIEdvIG92ZXIgdGhlIG9wdGlvbidzIHRleHQsIHNjYW5uaW5nIGZvciB0aGUgdmFyaW91cyBraW5kcyBvZiBtYXRjaGVzXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBlID0gTWF0aC5taW4od29yZC5sZW5ndGgsIDIwMCksIHByZXZUeXBlID0gMCAvKiBUcC5Ob25Xb3JkICovOyBpIDwgZSAmJiBieVdvcmRUbyA8IGxlbjspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQod29yZCwgaSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0IDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChwcmVjaXNlVG8gPCBsZW4gJiYgbmV4dCA9PSBjaGFyc1twcmVjaXNlVG9dKVxuICAgICAgICAgICAgICAgICAgICBwcmVjaXNlW3ByZWNpc2VUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKGFkamFjZW50VG8gPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gY2hhcnNbYWRqYWNlbnRUb10gfHwgbmV4dCA9PSBmb2xkZWRbYWRqYWNlbnRUb10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGphY2VudFRvID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGphY2VudEVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRUbysrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRqYWNlbnRUbyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2gsIHR5cGUgPSBuZXh0IDwgMHhmZlxuICAgICAgICAgICAgICAgID8gKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NyB8fCBuZXh0ID49IDk3ICYmIG5leHQgPD0gMTIyID8gMiAvKiBUcC5Mb3dlciAqLyA6IG5leHQgPj0gNjUgJiYgbmV4dCA8PSA5MCA/IDEgLyogVHAuVXBwZXIgKi8gOiAwIC8qIFRwLk5vbldvcmQgKi8pXG4gICAgICAgICAgICAgICAgOiAoKGNoID0gZnJvbUNvZGVQb2ludChuZXh0KSkgIT0gY2gudG9Mb3dlckNhc2UoKSA/IDEgLyogVHAuVXBwZXIgKi8gOiBjaCAhPSBjaC50b1VwcGVyQ2FzZSgpID8gMiAvKiBUcC5Mb3dlciAqLyA6IDAgLyogVHAuTm9uV29yZCAqLyk7XG4gICAgICAgICAgICBpZiAoIWkgfHwgdHlwZSA9PSAxIC8qIFRwLlVwcGVyICovICYmIGhhc0xvd2VyIHx8IHByZXZUeXBlID09IDAgLyogVHAuTm9uV29yZCAqLyAmJiB0eXBlICE9IDAgLyogVHAuTm9uV29yZCAqLykge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyc1tieVdvcmRUb10gPT0gbmV4dCB8fCAoZm9sZGVkW2J5V29yZFRvXSA9PSBuZXh0ICYmIChieVdvcmRGb2xkZWQgPSB0cnVlKSkpXG4gICAgICAgICAgICAgICAgICAgIGJ5V29yZFtieVdvcmRUbysrXSA9IGk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYnlXb3JkLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgd29yZEFkamFjZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2VHlwZSA9IHR5cGU7XG4gICAgICAgICAgICBpICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ5V29yZFRvID09IGxlbiAmJiBieVdvcmRbMF0gPT0gMCAmJiB3b3JkQWRqYWNlbnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQoLTEwMCAvKiBQZW5hbHR5LkJ5V29yZCAqLyArIChieVdvcmRGb2xkZWQgPyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gOiAwKSwgYnlXb3JkLCB3b3JkKTtcbiAgICAgICAgaWYgKGFkamFjZW50VG8gPT0gbGVuICYmIGFkamFjZW50U3RhcnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldCgtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gLSB3b3JkLmxlbmd0aCArIChhZGphY2VudEVuZCA9PSB3b3JkLmxlbmd0aCA/IDAgOiAtMTAwIC8qIFBlbmFsdHkuTm90RnVsbCAqLyksIFswLCBhZGphY2VudEVuZF0pO1xuICAgICAgICBpZiAoZGlyZWN0ID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXQoLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovIC0gd29yZC5sZW5ndGgsIFtkaXJlY3QsIGRpcmVjdCArIHRoaXMucGF0dGVybi5sZW5ndGhdKTtcbiAgICAgICAgaWYgKGFkamFjZW50VG8gPT0gbGVuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0KC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyArIC03MDAgLyogUGVuYWx0eS5Ob3RTdGFydCAqLyAtIHdvcmQubGVuZ3RoLCBbYWRqYWNlbnRTdGFydCwgYWRqYWNlbnRFbmRdKTtcbiAgICAgICAgaWYgKGJ5V29yZFRvID09IGxlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCgtMTAwIC8qIFBlbmFsdHkuQnlXb3JkICovICsgKGJ5V29yZEZvbGRlZCA/IC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyA6IDApICsgLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovICtcbiAgICAgICAgICAgICAgICAod29yZEFkamFjZW50ID8gMCA6IC0xMTAwIC8qIFBlbmFsdHkuR2FwICovKSwgYnlXb3JkLCB3b3JkKTtcbiAgICAgICAgcmV0dXJuIGNoYXJzLmxlbmd0aCA9PSAyID8gbnVsbFxuICAgICAgICAgICAgOiB0aGlzLnJlc3VsdCgoYW55WzBdID8gLTcwMCAvKiBQZW5hbHR5Lk5vdFN0YXJ0ICovIDogMCkgKyAtMjAwIC8qIFBlbmFsdHkuQ2FzZUZvbGQgKi8gKyAtMTEwMCAvKiBQZW5hbHR5LkdhcCAqLywgYW55LCB3b3JkKTtcbiAgICB9XG4gICAgcmVzdWx0KHNjb3JlLCBwb3NpdGlvbnMsIHdvcmQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgcG9zIG9mIHBvc2l0aW9ucykge1xuICAgICAgICAgICAgbGV0IHRvID0gcG9zICsgKHRoaXMuYXN0cmFsID8gY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdCh3b3JkLCBwb3MpKSA6IDEpO1xuICAgICAgICAgICAgaWYgKGkgJiYgcmVzdWx0W2kgLSAxXSA9PSBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2kgLSAxXSA9IHRvO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSBwb3M7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXQoc2NvcmUgLSB3b3JkLmxlbmd0aCwgcmVzdWx0KTtcbiAgICB9XG59XG5jbGFzcyBTdHJpY3RNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IFtdO1xuICAgICAgICB0aGlzLnNjb3JlID0gMDtcbiAgICAgICAgdGhpcy5mb2xkZWQgPSBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIG1hdGNoKHdvcmQpIHtcbiAgICAgICAgaWYgKHdvcmQubGVuZ3RoIDwgdGhpcy5wYXR0ZXJuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgc3RhcnQgPSB3b3JkLnNsaWNlKDAsIHRoaXMucGF0dGVybi5sZW5ndGgpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBzdGFydCA9PSB0aGlzLnBhdHRlcm4gPyAwIDogc3RhcnQudG9Mb3dlckNhc2UoKSA9PSB0aGlzLmZvbGRlZCA/IC0yMDAgLyogUGVuYWx0eS5DYXNlRm9sZCAqLyA6IG51bGw7XG4gICAgICAgIGlmIChtYXRjaCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IFswLCBzdGFydC5sZW5ndGhdO1xuICAgICAgICB0aGlzLnNjb3JlID0gbWF0Y2ggKyAod29yZC5sZW5ndGggPT0gdGhpcy5wYXR0ZXJuLmxlbmd0aCA/IDAgOiAtMTAwIC8qIFBlbmFsdHkuTm90RnVsbCAqLyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuY29uc3QgY29tcGxldGlvbkNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBhY3RpdmF0ZU9uVHlwaW5nOiB0cnVlLFxuICAgICAgICAgICAgYWN0aXZhdGVPbkNvbXBsZXRpb246ICgpID0+IGZhbHNlLFxuICAgICAgICAgICAgYWN0aXZhdGVPblR5cGluZ0RlbGF5OiAxMDAsXG4gICAgICAgICAgICBzZWxlY3RPbk9wZW46IHRydWUsXG4gICAgICAgICAgICBvdmVycmlkZTogbnVsbCxcbiAgICAgICAgICAgIGNsb3NlT25CbHVyOiB0cnVlLFxuICAgICAgICAgICAgbWF4UmVuZGVyZWRPcHRpb25zOiAxMDAsXG4gICAgICAgICAgICBkZWZhdWx0S2V5bWFwOiB0cnVlLFxuICAgICAgICAgICAgdG9vbHRpcENsYXNzOiAoKSA9PiBcIlwiLFxuICAgICAgICAgICAgb3B0aW9uQ2xhc3M6ICgpID0+IFwiXCIsXG4gICAgICAgICAgICBhYm92ZUN1cnNvcjogZmFsc2UsXG4gICAgICAgICAgICBpY29uczogdHJ1ZSxcbiAgICAgICAgICAgIGFkZFRvT3B0aW9uczogW10sXG4gICAgICAgICAgICBwb3NpdGlvbkluZm86IGRlZmF1bHRQb3NpdGlvbkluZm8sXG4gICAgICAgICAgICBmaWx0ZXJTdHJpY3Q6IGZhbHNlLFxuICAgICAgICAgICAgY29tcGFyZUNvbXBsZXRpb25zOiAoYSwgYikgPT4gYS5sYWJlbC5sb2NhbGVDb21wYXJlKGIubGFiZWwpLFxuICAgICAgICAgICAgaW50ZXJhY3Rpb25EZWxheTogNzUsXG4gICAgICAgICAgICB1cGRhdGVTeW5jVGltZTogMTAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGRlZmF1bHRLZXltYXA6IChhLCBiKSA9PiBhICYmIGIsXG4gICAgICAgICAgICBjbG9zZU9uQmx1cjogKGEsIGIpID0+IGEgJiYgYixcbiAgICAgICAgICAgIGljb25zOiAoYSwgYikgPT4gYSAmJiBiLFxuICAgICAgICAgICAgdG9vbHRpcENsYXNzOiAoYSwgYikgPT4gYyA9PiBqb2luQ2xhc3MoYShjKSwgYihjKSksXG4gICAgICAgICAgICBvcHRpb25DbGFzczogKGEsIGIpID0+IGMgPT4gam9pbkNsYXNzKGEoYyksIGIoYykpLFxuICAgICAgICAgICAgYWRkVG9PcHRpb25zOiAoYSwgYikgPT4gYS5jb25jYXQoYiksXG4gICAgICAgICAgICBmaWx0ZXJTdHJpY3Q6IChhLCBiKSA9PiBhIHx8IGIsXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gam9pbkNsYXNzKGEsIGIpIHtcbiAgICByZXR1cm4gYSA/IGIgPyBhICsgXCIgXCIgKyBiIDogYSA6IGI7XG59XG5mdW5jdGlvbiBkZWZhdWx0UG9zaXRpb25JbmZvKHZpZXcsIGxpc3QsIG9wdGlvbiwgaW5mbywgc3BhY2UsIHRvb2x0aXApIHtcbiAgICBsZXQgcnRsID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5SVEwsIGxlZnQgPSBydGwsIG5hcnJvdyA9IGZhbHNlO1xuICAgIGxldCBzaWRlID0gXCJ0b3BcIiwgb2Zmc2V0LCBtYXhXaWR0aDtcbiAgICBsZXQgc3BhY2VMZWZ0ID0gbGlzdC5sZWZ0IC0gc3BhY2UubGVmdCwgc3BhY2VSaWdodCA9IHNwYWNlLnJpZ2h0IC0gbGlzdC5yaWdodDtcbiAgICBsZXQgaW5mb1dpZHRoID0gaW5mby5yaWdodCAtIGluZm8ubGVmdCwgaW5mb0hlaWdodCA9IGluZm8uYm90dG9tIC0gaW5mby50b3A7XG4gICAgaWYgKGxlZnQgJiYgc3BhY2VMZWZ0IDwgTWF0aC5taW4oaW5mb1dpZHRoLCBzcGFjZVJpZ2h0KSlcbiAgICAgICAgbGVmdCA9IGZhbHNlO1xuICAgIGVsc2UgaWYgKCFsZWZ0ICYmIHNwYWNlUmlnaHQgPCBNYXRoLm1pbihpbmZvV2lkdGgsIHNwYWNlTGVmdCkpXG4gICAgICAgIGxlZnQgPSB0cnVlO1xuICAgIGlmIChpbmZvV2lkdGggPD0gKGxlZnQgPyBzcGFjZUxlZnQgOiBzcGFjZVJpZ2h0KSkge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChzcGFjZS50b3AsIE1hdGgubWluKG9wdGlvbi50b3AsIHNwYWNlLmJvdHRvbSAtIGluZm9IZWlnaHQpKSAtIGxpc3QudG9wO1xuICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKDQwMCAvKiBJbmZvLldpZHRoICovLCBsZWZ0ID8gc3BhY2VMZWZ0IDogc3BhY2VSaWdodCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuYXJyb3cgPSB0cnVlO1xuICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWluKDQwMCAvKiBJbmZvLldpZHRoICovLCAocnRsID8gbGlzdC5yaWdodCA6IHNwYWNlLnJpZ2h0IC0gbGlzdC5sZWZ0KSAtIDMwIC8qIEluZm8uTWFyZ2luICovKTtcbiAgICAgICAgbGV0IHNwYWNlQmVsb3cgPSBzcGFjZS5ib3R0b20gLSBsaXN0LmJvdHRvbTtcbiAgICAgICAgaWYgKHNwYWNlQmVsb3cgPj0gaW5mb0hlaWdodCB8fCBzcGFjZUJlbG93ID4gbGlzdC50b3ApIHsgLy8gQmVsb3cgdGhlIGNvbXBsZXRpb25cbiAgICAgICAgICAgIG9mZnNldCA9IG9wdGlvbi5ib3R0b20gLSBsaXN0LnRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gQWJvdmUgaXRcbiAgICAgICAgICAgIHNpZGUgPSBcImJvdHRvbVwiO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbGlzdC5ib3R0b20gLSBvcHRpb24udG9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzY2FsZVkgPSAobGlzdC5ib3R0b20gLSBsaXN0LnRvcCkgLyB0b29sdGlwLm9mZnNldEhlaWdodDtcbiAgICBsZXQgc2NhbGVYID0gKGxpc3QucmlnaHQgLSBsaXN0LmxlZnQpIC8gdG9vbHRpcC5vZmZzZXRXaWR0aDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZTogYCR7c2lkZX06ICR7b2Zmc2V0IC8gc2NhbGVZfXB4OyBtYXgtd2lkdGg6ICR7bWF4V2lkdGggLyBzY2FsZVh9cHhgLFxuICAgICAgICBjbGFzczogXCJjbS1jb21wbGV0aW9uSW5mby1cIiArIChuYXJyb3cgPyAocnRsID8gXCJsZWZ0LW5hcnJvd1wiIDogXCJyaWdodC1uYXJyb3dcIikgOiBsZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gb3B0aW9uQ29udGVudChjb25maWcpIHtcbiAgICBsZXQgY29udGVudCA9IGNvbmZpZy5hZGRUb09wdGlvbnMuc2xpY2UoKTtcbiAgICBpZiAoY29uZmlnLmljb25zKVxuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgcmVuZGVyKGNvbXBsZXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgaWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkljb25cIik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRpb24udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKC4uLmNvbXBsZXRpb24udHlwZS5zcGxpdCgvXFxzKy9nKS5tYXAoY2xzID0+IFwiY20tY29tcGxldGlvbkljb24tXCIgKyBjbHMpKTtcbiAgICAgICAgICAgICAgICBpY29uLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWNvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb3NpdGlvbjogMjBcbiAgICAgICAgfSk7XG4gICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgcmVuZGVyKGNvbXBsZXRpb24sIF9zLCBfdiwgbWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBsYWJlbEVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgbGFiZWxFbHQuY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uTGFiZWxcIjtcbiAgICAgICAgICAgIGxldCBsYWJlbCA9IGNvbXBsZXRpb24uZGlzcGxheUxhYmVsIHx8IGNvbXBsZXRpb24ubGFiZWwsIG9mZiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IG1hdGNoW2orK10sIHRvID0gbWF0Y2hbaisrXTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IG9mZilcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2Uob2ZmLCBmcm9tKSkpO1xuICAgICAgICAgICAgICAgIGxldCBzcGFuID0gbGFiZWxFbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpO1xuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGFiZWwuc2xpY2UoZnJvbSwgdG8pKSk7XG4gICAgICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLWNvbXBsZXRpb25NYXRjaGVkVGV4dFwiO1xuICAgICAgICAgICAgICAgIG9mZiA9IHRvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZiA8IGxhYmVsLmxlbmd0aClcbiAgICAgICAgICAgICAgICBsYWJlbEVsdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsYWJlbC5zbGljZShvZmYpKSk7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxFbHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiA1MFxuICAgIH0sIHtcbiAgICAgICAgcmVuZGVyKGNvbXBsZXRpb24pIHtcbiAgICAgICAgICAgIGlmICghY29tcGxldGlvbi5kZXRhaWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgZGV0YWlsRWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBkZXRhaWxFbHQuY2xhc3NOYW1lID0gXCJjbS1jb21wbGV0aW9uRGV0YWlsXCI7XG4gICAgICAgICAgICBkZXRhaWxFbHQudGV4dENvbnRlbnQgPSBjb21wbGV0aW9uLmRldGFpbDtcbiAgICAgICAgICAgIHJldHVybiBkZXRhaWxFbHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiA4MFxuICAgIH0pO1xuICAgIHJldHVybiBjb250ZW50LnNvcnQoKGEsIGIpID0+IGEucG9zaXRpb24gLSBiLnBvc2l0aW9uKS5tYXAoYSA9PiBhLnJlbmRlcik7XG59XG5mdW5jdGlvbiByYW5nZUFyb3VuZFNlbGVjdGVkKHRvdGFsLCBzZWxlY3RlZCwgbWF4KSB7XG4gICAgaWYgKHRvdGFsIDw9IG1heClcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogMCwgdG86IHRvdGFsIH07XG4gICAgaWYgKHNlbGVjdGVkIDwgMClcbiAgICAgICAgc2VsZWN0ZWQgPSAwO1xuICAgIGlmIChzZWxlY3RlZCA8PSAodG90YWwgPj4gMSkpIHtcbiAgICAgICAgbGV0IG9mZiA9IE1hdGguZmxvb3Ioc2VsZWN0ZWQgLyBtYXgpO1xuICAgICAgICByZXR1cm4geyBmcm9tOiBvZmYgKiBtYXgsIHRvOiAob2ZmICsgMSkgKiBtYXggfTtcbiAgICB9XG4gICAgbGV0IG9mZiA9IE1hdGguZmxvb3IoKHRvdGFsIC0gc2VsZWN0ZWQpIC8gbWF4KTtcbiAgICByZXR1cm4geyBmcm9tOiB0b3RhbCAtIChvZmYgKyAxKSAqIG1heCwgdG86IHRvdGFsIC0gb2ZmICogbWF4IH07XG59XG5jbGFzcyBDb21wbGV0aW9uVG9vbHRpcCB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhdGVGaWVsZCwgYXBwbHlDb21wbGV0aW9uKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGVGaWVsZCA9IHN0YXRlRmllbGQ7XG4gICAgICAgIHRoaXMuYXBwbHlDb21wbGV0aW9uID0gYXBwbHlDb21wbGV0aW9uO1xuICAgICAgICB0aGlzLmluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLmluZm9EZXN0cm95ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wbGFjZUluZm9SZXEgPSB7XG4gICAgICAgICAgICByZWFkOiAoKSA9PiB0aGlzLm1lYXN1cmVJbmZvKCksXG4gICAgICAgICAgICB3cml0ZTogKHBvcykgPT4gdGhpcy5wbGFjZUluZm8ocG9zKSxcbiAgICAgICAgICAgIGtleTogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNwYWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2xhc3MgPSBcIlwiO1xuICAgICAgICBsZXQgY1N0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzdGF0ZUZpZWxkKTtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgc2VsZWN0ZWQgfSA9IGNTdGF0ZS5vcGVuO1xuICAgICAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy5vcHRpb25Db250ZW50ID0gb3B0aW9uQ29udGVudChjb25maWcpO1xuICAgICAgICB0aGlzLm9wdGlvbkNsYXNzID0gY29uZmlnLm9wdGlvbkNsYXNzO1xuICAgICAgICB0aGlzLnRvb2x0aXBDbGFzcyA9IGNvbmZpZy50b29sdGlwQ2xhc3M7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wdGlvbnMubGVuZ3RoLCBzZWxlY3RlZCwgY29uZmlnLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZVwiO1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBDbGFzcyh2aWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gdmlldy5zdGF0ZS5maWVsZChzdGF0ZUZpZWxkKS5vcGVuO1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tID0gZS50YXJnZXQsIG1hdGNoOyBkb20gJiYgZG9tICE9IHRoaXMuZG9tOyBkb20gPSBkb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJMSVwiICYmIChtYXRjaCA9IC8tKFxcZCspJC8uZXhlYyhkb20uaWQpKSAmJiArbWF0Y2hbMV0gPCBvcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb25zWyttYXRjaFsxXV0pO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgKGUpID0+IHtcbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9vbHRpcCAmJiB2aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmNsb3NlT25CbHVyICYmXG4gICAgICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ICE9IHZpZXcuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zaG93T3B0aW9ucyhvcHRpb25zLCBjU3RhdGUuaWQpO1xuICAgIH1cbiAgICBtb3VudCgpIHsgdGhpcy51cGRhdGVTZWwoKTsgfVxuICAgIHNob3dPcHRpb25zKG9wdGlvbnMsIGlkKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3QpXG4gICAgICAgICAgICB0aGlzLmxpc3QucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMubGlzdCA9IHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlTGlzdEJveChvcHRpb25zLCBpZCwgdGhpcy5yYW5nZSkpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mb1JlcSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHVwZGF0ZS5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQpO1xuICAgICAgICBsZXQgcHJldlN0YXRlID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKTtcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwQ2xhc3ModXBkYXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKGNTdGF0ZSAhPSBwcmV2U3RhdGUpIHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMsIHNlbGVjdGVkLCBkaXNhYmxlZCB9ID0gY1N0YXRlLm9wZW47XG4gICAgICAgICAgICBpZiAoIXByZXZTdGF0ZS5vcGVuIHx8IHByZXZTdGF0ZS5vcGVuLm9wdGlvbnMgIT0gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZUFyb3VuZFNlbGVjdGVkKG9wdGlvbnMubGVuZ3RoLCBzZWxlY3RlZCwgdXBkYXRlLnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93T3B0aW9ucyhvcHRpb25zLCBjU3RhdGUuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWwoKTtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZCAhPSAoKF9hID0gcHJldlN0YXRlLm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNhYmxlZCkpXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkXCIsICEhZGlzYWJsZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVRvb2x0aXBDbGFzcyhzdGF0ZSkge1xuICAgICAgICBsZXQgY2xzID0gdGhpcy50b29sdGlwQ2xhc3Moc3RhdGUpO1xuICAgICAgICBpZiAoY2xzICE9IHRoaXMuY3VycmVudENsYXNzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIHRoaXMuY3VycmVudENsYXNzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY2xzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChjKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENsYXNzID0gY2xzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvc2l0aW9uZWQoc3BhY2UpIHtcbiAgICAgICAgdGhpcy5zcGFjZSA9IHNwYWNlO1xuICAgICAgICBpZiAodGhpcy5pbmZvKVxuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvUmVxKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsKCkge1xuICAgICAgICBsZXQgY1N0YXRlID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCksIG9wZW4gPSBjU3RhdGUub3BlbjtcbiAgICAgICAgaWYgKG9wZW4uc2VsZWN0ZWQgPiAtMSAmJiBvcGVuLnNlbGVjdGVkIDwgdGhpcy5yYW5nZS5mcm9tIHx8IG9wZW4uc2VsZWN0ZWQgPj0gdGhpcy5yYW5nZS50bykge1xuICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlQXJvdW5kU2VsZWN0ZWQob3Blbi5vcHRpb25zLmxlbmd0aCwgb3Blbi5zZWxlY3RlZCwgdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLm1heFJlbmRlcmVkT3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnNob3dPcHRpb25zKG9wZW4ub3B0aW9ucywgY1N0YXRlLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51cGRhdGVTZWxlY3RlZE9wdGlvbihvcGVuLnNlbGVjdGVkKSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95SW5mbygpO1xuICAgICAgICAgICAgbGV0IHsgY29tcGxldGlvbiB9ID0gb3Blbi5vcHRpb25zW29wZW4uc2VsZWN0ZWRdO1xuICAgICAgICAgICAgbGV0IHsgaW5mbyB9ID0gY29tcGxldGlvbjtcbiAgICAgICAgICAgIGlmICghaW5mbylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgaW5mb1Jlc3VsdCA9IHR5cGVvZiBpbmZvID09PSBcInN0cmluZ1wiID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoaW5mbykgOiBpbmZvKGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgaWYgKCFpbmZvUmVzdWx0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChcInRoZW5cIiBpbiBpbmZvUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaW5mb1Jlc3VsdC50aGVuKG9iaiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogJiYgdGhpcy52aWV3LnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCwgZmFsc2UpID09IGNTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5mb1BhbmUob2JqLCBjb21wbGV0aW9uKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlID0+IGxvZ0V4Y2VwdGlvbih0aGlzLnZpZXcuc3RhdGUsIGUsIFwiY29tcGxldGlvbiBpbmZvXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5mb1BhbmUoaW5mb1Jlc3VsdCwgY29tcGxldGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkSW5mb1BhbmUoY29udGVudCwgY29tcGxldGlvbikge1xuICAgICAgICB0aGlzLmRlc3Ryb3lJbmZvKCk7XG4gICAgICAgIGxldCB3cmFwID0gdGhpcy5pbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAgY20tY29tcGxldGlvbkluZm9cIjtcbiAgICAgICAgaWYgKGNvbnRlbnQubm9kZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuaW5mb0Rlc3Ryb3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHsgZG9tLCBkZXN0cm95IH0gPSBjb250ZW50O1xuICAgICAgICAgICAgd3JhcC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgdGhpcy5pbmZvRGVzdHJveSA9IGRlc3Ryb3kgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh3cmFwKTtcbiAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvUmVxKTtcbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0ZWRPcHRpb24oc2VsZWN0ZWQpIHtcbiAgICAgICAgbGV0IHNldCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IG9wdCA9IHRoaXMubGlzdC5maXJzdENoaWxkLCBpID0gdGhpcy5yYW5nZS5mcm9tOyBvcHQ7IG9wdCA9IG9wdC5uZXh0U2libGluZywgaSsrKSB7XG4gICAgICAgICAgICBpZiAob3B0Lm5vZGVOYW1lICE9IFwiTElcIiB8fCAhb3B0LmlkKSB7XG4gICAgICAgICAgICAgICAgaS0tOyAvLyBBIHNlY3Rpb24gaGVhZGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpID09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHQuaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHQuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgIHNldCA9IG9wdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0Lmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpXG4gICAgICAgICAgICAgICAgICAgIG9wdC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXQpXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldyh0aGlzLmxpc3QsIHNldCk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIG1lYXN1cmVJbmZvKCkge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5kb20ucXVlcnlTZWxlY3RvcihcIlthcmlhLXNlbGVjdGVkXVwiKTtcbiAgICAgICAgaWYgKCFzZWwgfHwgIXRoaXMuaW5mbylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGlzdFJlY3QgPSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGluZm9SZWN0ID0gdGhpcy5pbmZvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2VsUmVjdCA9IHNlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNwYWNlID0gdGhpcy5zcGFjZTtcbiAgICAgICAgaWYgKCFzcGFjZSkge1xuICAgICAgICAgICAgbGV0IGRvY0VsdCA9IHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgc3BhY2UgPSB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IGRvY0VsdC5jbGllbnRXaWR0aCwgYm90dG9tOiBkb2NFbHQuY2xpZW50SGVpZ2h0IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbFJlY3QudG9wID4gTWF0aC5taW4oc3BhY2UuYm90dG9tLCBsaXN0UmVjdC5ib3R0b20pIC0gMTAgfHxcbiAgICAgICAgICAgIHNlbFJlY3QuYm90dG9tIDwgTWF0aC5tYXgoc3BhY2UudG9wLCBsaXN0UmVjdC50b3ApICsgMTApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5wb3NpdGlvbkluZm8odGhpcy52aWV3LCBsaXN0UmVjdCwgc2VsUmVjdCwgaW5mb1JlY3QsIHNwYWNlLCB0aGlzLmRvbSk7XG4gICAgfVxuICAgIHBsYWNlSW5mbyhwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5mbykge1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIGlmIChwb3Muc3R5bGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdHlsZS5jc3NUZXh0ID0gcG9zLnN0eWxlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAgY20tY29tcGxldGlvbkluZm8gXCIgKyAocG9zLmNsYXNzIHx8IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLnN0eWxlLmNzc1RleHQgPSBcInRvcDogLTFlNnB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlTGlzdEJveChvcHRpb25zLCBpZCwgcmFuZ2UpIHtcbiAgICAgICAgY29uc3QgdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgICAgIHVsLmlkID0gaWQ7XG4gICAgICAgIHVsLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJsaXN0Ym94XCIpO1xuICAgICAgICB1bC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdWwuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiQ29tcGxldGlvbnNcIikpO1xuICAgICAgICB1bC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGUgPT4ge1xuICAgICAgICAgICAgLy8gUHJldmVudCBmb2N1cyBjaGFuZ2Ugd2hlbiBjbGlja2luZyB0aGUgc2Nyb2xsYmFyXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgPT0gdWwpXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGN1clNlY3Rpb24gPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2UuZnJvbTsgaSA8IHJhbmdlLnRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGNvbXBsZXRpb24sIG1hdGNoIH0gPSBvcHRpb25zW2ldLCB7IHNlY3Rpb24gfSA9IGNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gdHlwZW9mIHNlY3Rpb24gPT0gXCJzdHJpbmdcIiA/IHNlY3Rpb24gOiBzZWN0aW9uLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT0gY3VyU2VjdGlvbiAmJiAoaSA+IHJhbmdlLmZyb20gfHwgcmFuZ2UuZnJvbSA9PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJTZWN0aW9uID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWN0aW9uICE9IFwic3RyaW5nXCIgJiYgc2VjdGlvbi5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVsLmFwcGVuZENoaWxkKHNlY3Rpb24uaGVhZGVyKHNlY3Rpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoZWFkZXIgPSB1bC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY29tcGxldGlvbi1zZWN0aW9uXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci50ZXh0Q29udGVudCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaSA9IHVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKSk7XG4gICAgICAgICAgICBsaS5pZCA9IGlkICsgXCItXCIgKyBpO1xuICAgICAgICAgICAgbGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIGxldCBjbHMgPSB0aGlzLm9wdGlvbkNsYXNzKGNvbXBsZXRpb24pO1xuICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICBsaS5jbGFzc05hbWUgPSBjbHM7XG4gICAgICAgICAgICBmb3IgKGxldCBzb3VyY2Ugb2YgdGhpcy5vcHRpb25Db250ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSBzb3VyY2UoY29tcGxldGlvbiwgdGhpcy52aWV3LnN0YXRlLCB0aGlzLnZpZXcsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlLmZyb20pXG4gICAgICAgICAgICB1bC5jbGFzc0xpc3QuYWRkKFwiY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlVG9wXCIpO1xuICAgICAgICBpZiAocmFuZ2UudG8gPCBvcHRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHVsLmNsYXNzTGlzdC5hZGQoXCJjbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b21cIik7XG4gICAgICAgIHJldHVybiB1bDtcbiAgICB9XG4gICAgZGVzdHJveUluZm8oKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZm9EZXN0cm95KVxuICAgICAgICAgICAgICAgIHRoaXMuaW5mb0Rlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5mby5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95SW5mbygpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBsZXRpb25Ub29sdGlwKHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbikge1xuICAgIHJldHVybiAodmlldykgPT4gbmV3IENvbXBsZXRpb25Ub29sdGlwKHZpZXcsIHN0YXRlRmllbGQsIGFwcGx5Q29tcGxldGlvbik7XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICBsZXQgcGFyZW50ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBzZWxmID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc2NhbGVZID0gcGFyZW50LmhlaWdodCAvIGNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgaWYgKHNlbGYudG9wIDwgcGFyZW50LnRvcClcbiAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCAtPSAocGFyZW50LnRvcCAtIHNlbGYudG9wKSAvIHNjYWxlWTtcbiAgICBlbHNlIGlmIChzZWxmLmJvdHRvbSA+IHBhcmVudC5ib3R0b20pXG4gICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gKHNlbGYuYm90dG9tIC0gcGFyZW50LmJvdHRvbSkgLyBzY2FsZVk7XG59XG5cbi8vIFVzZWQgdG8gcGljayBhIHByZWZlcnJlZCBvcHRpb24gd2hlbiB0d28gb3B0aW9ucyB3aXRoIHRoZSBzYW1lXG4vLyBsYWJlbCBvY2N1ciBpbiB0aGUgcmVzdWx0LlxuZnVuY3Rpb24gc2NvcmUob3B0aW9uKSB7XG4gICAgcmV0dXJuIChvcHRpb24uYm9vc3QgfHwgMCkgKiAxMDAgKyAob3B0aW9uLmFwcGx5ID8gMTAgOiAwKSArIChvcHRpb24uaW5mbyA/IDUgOiAwKSArXG4gICAgICAgIChvcHRpb24udHlwZSA/IDEgOiAwKTtcbn1cbmZ1bmN0aW9uIHNvcnRPcHRpb25zKGFjdGl2ZSwgc3RhdGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IFtdO1xuICAgIGxldCBzZWN0aW9ucyA9IG51bGw7XG4gICAgbGV0IGFkZE9wdGlvbiA9IChvcHRpb24pID0+IHtcbiAgICAgICAgb3B0aW9ucy5wdXNoKG9wdGlvbik7XG4gICAgICAgIGxldCB7IHNlY3Rpb24gfSA9IG9wdGlvbi5jb21wbGV0aW9uO1xuICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgaWYgKCFzZWN0aW9ucylcbiAgICAgICAgICAgICAgICBzZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgbGV0IG5hbWUgPSB0eXBlb2Ygc2VjdGlvbiA9PSBcInN0cmluZ1wiID8gc2VjdGlvbiA6IHNlY3Rpb24ubmFtZTtcbiAgICAgICAgICAgIGlmICghc2VjdGlvbnMuc29tZShzID0+IHMubmFtZSA9PSBuYW1lKSlcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHR5cGVvZiBzZWN0aW9uID09IFwic3RyaW5nXCIgPyB7IG5hbWUgfSA6IHNlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgY29uZiA9IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpO1xuICAgIGZvciAobGV0IGEgb2YgYWN0aXZlKVxuICAgICAgICBpZiAoYS5oYXNSZXN1bHQoKSkge1xuICAgICAgICAgICAgbGV0IGdldE1hdGNoID0gYS5yZXN1bHQuZ2V0TWF0Y2g7XG4gICAgICAgICAgICBpZiAoYS5yZXN1bHQuZmlsdGVyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbiBvZiBhLnJlc3VsdC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE9wdGlvbihuZXcgT3B0aW9uKG9wdGlvbiwgYS5zb3VyY2UsIGdldE1hdGNoID8gZ2V0TWF0Y2gob3B0aW9uKSA6IFtdLCAxZTkgLSBvcHRpb25zLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBwYXR0ZXJuID0gc3RhdGUuc2xpY2VEb2MoYS5mcm9tLCBhLnRvKSwgbWF0Y2g7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoZXIgPSBjb25mLmZpbHRlclN0cmljdCA/IG5ldyBTdHJpY3RNYXRjaGVyKHBhdHRlcm4pIDogbmV3IEZ1enp5TWF0Y2hlcihwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvcHRpb24gb2YgYS5yZXN1bHQub3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID0gbWF0Y2hlci5tYXRjaChvcHRpb24ubGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlZCA9ICFvcHRpb24uZGlzcGxheUxhYmVsID8gbWF0Y2gubWF0Y2hlZCA6IGdldE1hdGNoID8gZ2V0TWF0Y2gob3B0aW9uLCBtYXRjaC5tYXRjaGVkKSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW9uKG5ldyBPcHRpb24ob3B0aW9uLCBhLnNvdXJjZSwgbWF0Y2hlZCwgbWF0Y2guc2NvcmUgKyAob3B0aW9uLmJvb3N0IHx8IDApKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIGlmIChzZWN0aW9ucykge1xuICAgICAgICBsZXQgc2VjdGlvbk9yZGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKSwgcG9zID0gMDtcbiAgICAgICAgbGV0IGNtcCA9IChhLCBiKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoKF9hID0gYS5yYW5rKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxZTkpIC0gKChfYiA9IGIucmFuaykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMWU5KSB8fCAoYS5uYW1lIDwgYi5uYW1lID8gLTEgOiAxKTsgfTtcbiAgICAgICAgZm9yIChsZXQgcyBvZiBzZWN0aW9ucy5zb3J0KGNtcCkpIHtcbiAgICAgICAgICAgIHBvcyAtPSAxZTU7XG4gICAgICAgICAgICBzZWN0aW9uT3JkZXJbcy5uYW1lXSA9IHBvcztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgbGV0IHsgc2VjdGlvbiB9ID0gb3B0aW9uLmNvbXBsZXRpb247XG4gICAgICAgICAgICBpZiAoc2VjdGlvbilcbiAgICAgICAgICAgICAgICBvcHRpb24uc2NvcmUgKz0gc2VjdGlvbk9yZGVyW3R5cGVvZiBzZWN0aW9uID09IFwic3RyaW5nXCIgPyBzZWN0aW9uIDogc2VjdGlvbi5uYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW10sIHByZXYgPSBudWxsO1xuICAgIGxldCBjb21wYXJlID0gY29uZi5jb21wYXJlQ29tcGxldGlvbnM7XG4gICAgZm9yIChsZXQgb3B0IG9mIG9wdGlvbnMuc29ydCgoYSwgYikgPT4gKGIuc2NvcmUgLSBhLnNjb3JlKSB8fCBjb21wYXJlKGEuY29tcGxldGlvbiwgYi5jb21wbGV0aW9uKSkpIHtcbiAgICAgICAgbGV0IGN1ciA9IG9wdC5jb21wbGV0aW9uO1xuICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5sYWJlbCAhPSBjdXIubGFiZWwgfHwgcHJldi5kZXRhaWwgIT0gY3VyLmRldGFpbCB8fFxuICAgICAgICAgICAgKHByZXYudHlwZSAhPSBudWxsICYmIGN1ci50eXBlICE9IG51bGwgJiYgcHJldi50eXBlICE9IGN1ci50eXBlKSB8fFxuICAgICAgICAgICAgcHJldi5hcHBseSAhPSBjdXIuYXBwbHkgfHwgcHJldi5ib29zdCAhPSBjdXIuYm9vc3QpXG4gICAgICAgICAgICByZXN1bHQucHVzaChvcHQpO1xuICAgICAgICBlbHNlIGlmIChzY29yZShvcHQuY29tcGxldGlvbikgPiBzY29yZShwcmV2KSlcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBvcHQ7XG4gICAgICAgIHByZXYgPSBvcHQuY29tcGxldGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIENvbXBsZXRpb25EaWFsb2cge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGF0dHJzLCB0b29sdGlwLCB0aW1lc3RhbXAsIHNlbGVjdGVkLCBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMudG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIGlkKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZCA9PSB0aGlzLnNlbGVjdGVkIHx8IHNlbGVjdGVkID49IHRoaXMub3B0aW9ucy5sZW5ndGggPyB0aGlzXG4gICAgICAgICAgICA6IG5ldyBDb21wbGV0aW9uRGlhbG9nKHRoaXMub3B0aW9ucywgbWFrZUF0dHJzKGlkLCBzZWxlY3RlZCksIHRoaXMudG9vbHRpcCwgdGhpcy50aW1lc3RhbXAsIHNlbGVjdGVkLCB0aGlzLmRpc2FibGVkKTtcbiAgICB9XG4gICAgc3RhdGljIGJ1aWxkKGFjdGl2ZSwgc3RhdGUsIGlkLCBwcmV2LCBjb25mLCBkaWRTZXRBY3RpdmUpIHtcbiAgICAgICAgaWYgKHByZXYgJiYgIWRpZFNldEFjdGl2ZSAmJiBhY3RpdmUuc29tZShzID0+IHMuaXNQZW5kaW5nKSlcbiAgICAgICAgICAgIHJldHVybiBwcmV2LnNldERpc2FibGVkKCk7XG4gICAgICAgIGxldCBvcHRpb25zID0gc29ydE9wdGlvbnMoYWN0aXZlLCBzdGF0ZSk7XG4gICAgICAgIGlmICghb3B0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gcHJldiAmJiBhY3RpdmUuc29tZShhID0+IGEuaXNQZW5kaW5nKSA/IHByZXYuc2V0RGlzYWJsZWQoKSA6IG51bGw7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IHN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLnNlbGVjdE9uT3BlbiA/IDAgOiAtMTtcbiAgICAgICAgaWYgKHByZXYgJiYgcHJldi5zZWxlY3RlZCAhPSBzZWxlY3RlZCAmJiBwcmV2LnNlbGVjdGVkICE9IC0xKSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRWYWx1ZSA9IHByZXYub3B0aW9uc1twcmV2LnNlbGVjdGVkXS5jb21wbGV0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zW2ldLmNvbXBsZXRpb24gPT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25EaWFsb2cob3B0aW9ucywgbWFrZUF0dHJzKGlkLCBzZWxlY3RlZCksIHtcbiAgICAgICAgICAgIHBvczogYWN0aXZlLnJlZHVjZSgoYSwgYikgPT4gYi5oYXNSZXN1bHQoKSA/IE1hdGgubWluKGEsIGIuZnJvbSkgOiBhLCAxZTgpLFxuICAgICAgICAgICAgY3JlYXRlOiBjcmVhdGVUb29sdGlwLFxuICAgICAgICAgICAgYWJvdmU6IGNvbmYuYWJvdmVDdXJzb3IsXG4gICAgICAgIH0sIHByZXYgPyBwcmV2LnRpbWVzdGFtcCA6IERhdGUubm93KCksIHNlbGVjdGVkLCBmYWxzZSk7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcGxldGlvbkRpYWxvZyh0aGlzLm9wdGlvbnMsIHRoaXMuYXR0cnMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy50b29sdGlwKSwgeyBwb3M6IGNoYW5nZXMubWFwUG9zKHRoaXMudG9vbHRpcC5wb3MpIH0pLCB0aGlzLnRpbWVzdGFtcCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5kaXNhYmxlZCk7XG4gICAgfVxuICAgIHNldERpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25EaWFsb2codGhpcy5vcHRpb25zLCB0aGlzLmF0dHJzLCB0aGlzLnRvb2x0aXAsIHRoaXMudGltZXN0YW1wLCB0aGlzLnNlbGVjdGVkLCB0cnVlKTtcbiAgICB9XG59XG5jbGFzcyBDb21wbGV0aW9uU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGFjdGl2ZSwgaWQsIG9wZW4pIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICB9XG4gICAgc3RhdGljIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXRpb25TdGF0ZShub25lLCBcImNtLWFjLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMmU2KS50b1N0cmluZygzNiksIG51bGwpO1xuICAgIH1cbiAgICB1cGRhdGUodHIpIHtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRyLCBjb25mID0gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIGxldCBzb3VyY2VzID0gY29uZi5vdmVycmlkZSB8fFxuICAgICAgICAgICAgc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJhdXRvY29tcGxldGVcIiwgY3VyKHN0YXRlKSkubWFwKGFzU291cmNlKTtcbiAgICAgICAgbGV0IGFjdGl2ZSA9IHNvdXJjZXMubWFwKHNvdXJjZSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmFjdGl2ZS5maW5kKHMgPT4gcy5zb3VyY2UgPT0gc291cmNlKSB8fFxuICAgICAgICAgICAgICAgIG5ldyBBY3RpdmVTb3VyY2Uoc291cmNlLCB0aGlzLmFjdGl2ZS5zb21lKGEgPT4gYS5zdGF0ZSAhPSAwIC8qIFN0YXRlLkluYWN0aXZlICovKSA/IDEgLyogU3RhdGUuUGVuZGluZyAqLyA6IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnVwZGF0ZSh0ciwgY29uZik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCA9PSB0aGlzLmFjdGl2ZS5sZW5ndGggJiYgYWN0aXZlLmV2ZXJ5KChhLCBpKSA9PiBhID09IHRoaXMuYWN0aXZlW2ldKSlcbiAgICAgICAgICAgIGFjdGl2ZSA9IHRoaXMuYWN0aXZlO1xuICAgICAgICBsZXQgb3BlbiA9IHRoaXMub3BlbiwgZGlkU2V0ID0gdHIuZWZmZWN0cy5zb21lKGUgPT4gZS5pcyhzZXRBY3RpdmVFZmZlY3QpKTtcbiAgICAgICAgaWYgKG9wZW4gJiYgdHIuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIG9wZW4gPSBvcGVuLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbiB8fCBhY3RpdmUuc29tZShhID0+IGEuaGFzUmVzdWx0KCkgJiYgdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UoYS5mcm9tLCBhLnRvKSkgfHxcbiAgICAgICAgICAgICFzYW1lUmVzdWx0cyhhY3RpdmUsIHRoaXMuYWN0aXZlKSB8fCBkaWRTZXQpXG4gICAgICAgICAgICBvcGVuID0gQ29tcGxldGlvbkRpYWxvZy5idWlsZChhY3RpdmUsIHN0YXRlLCB0aGlzLmlkLCBvcGVuLCBjb25mLCBkaWRTZXQpO1xuICAgICAgICBlbHNlIGlmIChvcGVuICYmIG9wZW4uZGlzYWJsZWQgJiYgIWFjdGl2ZS5zb21lKGEgPT4gYS5pc1BlbmRpbmcpKVxuICAgICAgICAgICAgb3BlbiA9IG51bGw7XG4gICAgICAgIGlmICghb3BlbiAmJiBhY3RpdmUuZXZlcnkoYSA9PiAhYS5pc1BlbmRpbmcpICYmIGFjdGl2ZS5zb21lKGEgPT4gYS5oYXNSZXN1bHQoKSkpXG4gICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUubWFwKGEgPT4gYS5oYXNSZXN1bHQoKSA/IG5ldyBBY3RpdmVTb3VyY2UoYS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pIDogYSk7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRTZWxlY3RlZEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgb3BlbiA9IG9wZW4gJiYgb3Blbi5zZXRTZWxlY3RlZChlZmZlY3QudmFsdWUsIHRoaXMuaWQpO1xuICAgICAgICByZXR1cm4gYWN0aXZlID09IHRoaXMuYWN0aXZlICYmIG9wZW4gPT0gdGhpcy5vcGVuID8gdGhpcyA6IG5ldyBDb21wbGV0aW9uU3RhdGUoYWN0aXZlLCB0aGlzLmlkLCBvcGVuKTtcbiAgICB9XG4gICAgZ2V0IHRvb2x0aXAoKSB7IHJldHVybiB0aGlzLm9wZW4gPyB0aGlzLm9wZW4udG9vbHRpcCA6IG51bGw7IH1cbiAgICBnZXQgYXR0cnMoKSB7IHJldHVybiB0aGlzLm9wZW4gPyB0aGlzLm9wZW4uYXR0cnMgOiB0aGlzLmFjdGl2ZS5sZW5ndGggPyBiYXNlQXR0cnMgOiBub0F0dHJzOyB9XG59XG5mdW5jdGlvbiBzYW1lUmVzdWx0cyhhLCBiKSB7XG4gICAgaWYgKGEgPT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgaUEgPSAwLCBpQiA9IDA7Oykge1xuICAgICAgICB3aGlsZSAoaUEgPCBhLmxlbmd0aCAmJiAhYVtpQV0uaGFzUmVzdWx0KCkpXG4gICAgICAgICAgICBpQSsrO1xuICAgICAgICB3aGlsZSAoaUIgPCBiLmxlbmd0aCAmJiAhYltpQl0uaGFzUmVzdWx0KCkpXG4gICAgICAgICAgICBpQisrO1xuICAgICAgICBsZXQgZW5kQSA9IGlBID09IGEubGVuZ3RoLCBlbmRCID0gaUIgPT0gYi5sZW5ndGg7XG4gICAgICAgIGlmIChlbmRBIHx8IGVuZEIpXG4gICAgICAgICAgICByZXR1cm4gZW5kQSA9PSBlbmRCO1xuICAgICAgICBpZiAoYVtpQSsrXS5yZXN1bHQgIT0gYltpQisrXS5yZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY29uc3QgYmFzZUF0dHJzID0ge1xuICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogXCJsaXN0XCJcbn07XG5jb25zdCBub0F0dHJzID0ge307XG5mdW5jdGlvbiBtYWtlQXR0cnMoaWQsIHNlbGVjdGVkKSB7XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBcImxpc3RcIixcbiAgICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IFwibGlzdGJveFwiLFxuICAgICAgICBcImFyaWEtY29udHJvbHNcIjogaWRcbiAgICB9O1xuICAgIGlmIChzZWxlY3RlZCA+IC0xKVxuICAgICAgICByZXN1bHRbXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIl0gPSBpZCArIFwiLVwiICsgc2VsZWN0ZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IG5vbmUgPSBbXTtcbmZ1bmN0aW9uIGdldFVwZGF0ZVR5cGUodHIsIGNvbmYpIHtcbiAgICBpZiAodHIuaXNVc2VyRXZlbnQoXCJpbnB1dC5jb21wbGV0ZVwiKSkge1xuICAgICAgICBsZXQgY29tcGxldGlvbiA9IHRyLmFubm90YXRpb24ocGlja2VkQ29tcGxldGlvbik7XG4gICAgICAgIGlmIChjb21wbGV0aW9uICYmIGNvbmYuYWN0aXZhdGVPbkNvbXBsZXRpb24oY29tcGxldGlvbikpXG4gICAgICAgICAgICByZXR1cm4gNCAvKiBVcGRhdGVUeXBlLkFjdGl2YXRlICovIHwgOCAvKiBVcGRhdGVUeXBlLlJlc2V0ICovO1xuICAgIH1cbiAgICBsZXQgdHlwaW5nID0gdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpO1xuICAgIHJldHVybiB0eXBpbmcgJiYgY29uZi5hY3RpdmF0ZU9uVHlwaW5nID8gNCAvKiBVcGRhdGVUeXBlLkFjdGl2YXRlICovIHwgMSAvKiBVcGRhdGVUeXBlLlR5cGluZyAqL1xuICAgICAgICA6IHR5cGluZyA/IDEgLyogVXBkYXRlVHlwZS5UeXBpbmcgKi9cbiAgICAgICAgICAgIDogdHIuaXNVc2VyRXZlbnQoXCJkZWxldGUuYmFja3dhcmRcIikgPyAyIC8qIFVwZGF0ZVR5cGUuQmFja3NwYWNpbmcgKi9cbiAgICAgICAgICAgICAgICA6IHRyLnNlbGVjdGlvbiA/IDggLyogVXBkYXRlVHlwZS5SZXNldCAqL1xuICAgICAgICAgICAgICAgICAgICA6IHRyLmRvY0NoYW5nZWQgPyAxNiAvKiBVcGRhdGVUeXBlLlJlc2V0SWZUb3VjaGluZyAqLyA6IDAgLyogVXBkYXRlVHlwZS5Ob25lICovO1xufVxuY2xhc3MgQWN0aXZlU291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHN0YXRlLCBleHBsaWNpdCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZXhwbGljaXQgPSBleHBsaWNpdDtcbiAgICB9XG4gICAgaGFzUmVzdWx0KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaXNQZW5kaW5nKCkgeyByZXR1cm4gdGhpcy5zdGF0ZSA9PSAxIC8qIFN0YXRlLlBlbmRpbmcgKi87IH1cbiAgICB1cGRhdGUodHIsIGNvbmYpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBnZXRVcGRhdGVUeXBlKHRyLCBjb25mKSwgdmFsdWUgPSB0aGlzO1xuICAgICAgICBpZiAoKHR5cGUgJiA4IC8qIFVwZGF0ZVR5cGUuUmVzZXQgKi8pIHx8ICh0eXBlICYgMTYgLyogVXBkYXRlVHlwZS5SZXNldElmVG91Y2hpbmcgKi8pICYmIHRoaXMudG91Y2hlcyh0cikpXG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBBY3RpdmVTb3VyY2UodmFsdWUuc291cmNlLCAwIC8qIFN0YXRlLkluYWN0aXZlICovKTtcbiAgICAgICAgaWYgKCh0eXBlICYgNCAvKiBVcGRhdGVUeXBlLkFjdGl2YXRlICovKSAmJiB2YWx1ZS5zdGF0ZSA9PSAwIC8qIFN0YXRlLkluYWN0aXZlICovKVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCAxIC8qIFN0YXRlLlBlbmRpbmcgKi8pO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZUZvcih0ciwgdHlwZSk7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHN0YXJ0Q29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKGNsb3NlQ29tcGxldGlvbkVmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWN0aXZlU291cmNlKHZhbHVlLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoc2V0QWN0aXZlRWZmZWN0KSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2YgZWZmZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLnNvdXJjZSA9PSB2YWx1ZS5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFjdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHVwZGF0ZUZvcih0ciwgdHlwZSkgeyByZXR1cm4gdGhpcy5tYXAodHIuY2hhbmdlcyk7IH1cbiAgICBtYXAoY2hhbmdlcykgeyByZXR1cm4gdGhpczsgfVxuICAgIHRvdWNoZXModHIpIHtcbiAgICAgICAgcmV0dXJuIHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGN1cih0ci5zdGF0ZSkpO1xuICAgIH1cbn1cbmNsYXNzIEFjdGl2ZVJlc3VsdCBleHRlbmRzIEFjdGl2ZVNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBleHBsaWNpdCwgbGltaXQsIHJlc3VsdCwgZnJvbSwgdG8pIHtcbiAgICAgICAgc3VwZXIoc291cmNlLCAzIC8qIFN0YXRlLlJlc3VsdCAqLywgZXhwbGljaXQpO1xuICAgICAgICB0aGlzLmxpbWl0ID0gbGltaXQ7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIGhhc1Jlc3VsdCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICB1cGRhdGVGb3IodHIsIHR5cGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoISh0eXBlICYgMyAvKiBVcGRhdGVUeXBlLlNpbXBsZUludGVyYWN0aW9uICovKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucmVzdWx0O1xuICAgICAgICBpZiAocmVzdWx0Lm1hcCAmJiAhdHIuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAocmVzdWx0LCB0ci5jaGFuZ2VzKTtcbiAgICAgICAgbGV0IGZyb20gPSB0ci5jaGFuZ2VzLm1hcFBvcyh0aGlzLmZyb20pLCB0byA9IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEpO1xuICAgICAgICBsZXQgcG9zID0gY3VyKHRyLnN0YXRlKTtcbiAgICAgICAgaWYgKHBvcyA+IHRvIHx8ICFyZXN1bHQgfHxcbiAgICAgICAgICAgICh0eXBlICYgMiAvKiBVcGRhdGVUeXBlLkJhY2tzcGFjaW5nICovKSAmJiAoY3VyKHRyLnN0YXJ0U3RhdGUpID09IHRoaXMuZnJvbSB8fCBwb3MgPCB0aGlzLmxpbWl0KSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlU291cmNlKHRoaXMuc291cmNlLCB0eXBlICYgNCAvKiBVcGRhdGVUeXBlLkFjdGl2YXRlICovID8gMSAvKiBTdGF0ZS5QZW5kaW5nICovIDogMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgIGxldCBsaW1pdCA9IHRyLmNoYW5nZXMubWFwUG9zKHRoaXMubGltaXQpO1xuICAgICAgICBpZiAoY2hlY2tWYWxpZChyZXN1bHQudmFsaWRGb3IsIHRyLnN0YXRlLCBmcm9tLCB0bykpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVJlc3VsdCh0aGlzLnNvdXJjZSwgdGhpcy5leHBsaWNpdCwgbGltaXQsIHJlc3VsdCwgZnJvbSwgdG8pO1xuICAgICAgICBpZiAocmVzdWx0LnVwZGF0ZSAmJlxuICAgICAgICAgICAgKHJlc3VsdCA9IHJlc3VsdC51cGRhdGUocmVzdWx0LCBmcm9tLCB0bywgbmV3IENvbXBsZXRpb25Db250ZXh0KHRyLnN0YXRlLCBwb3MsIGZhbHNlKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVSZXN1bHQodGhpcy5zb3VyY2UsIHRoaXMuZXhwbGljaXQsIGxpbWl0LCByZXN1bHQsIHJlc3VsdC5mcm9tLCAoX2EgPSByZXN1bHQudG8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN1cih0ci5zdGF0ZSkpO1xuICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMSAvKiBTdGF0ZS5QZW5kaW5nICovLCB0aGlzLmV4cGxpY2l0KTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucmVzdWx0Lm1hcCA/IHRoaXMucmVzdWx0Lm1hcCh0aGlzLnJlc3VsdCwgbWFwcGluZykgOiB0aGlzLnJlc3VsdDtcbiAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVNvdXJjZSh0aGlzLnNvdXJjZSwgMCAvKiBTdGF0ZS5JbmFjdGl2ZSAqLyk7XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlUmVzdWx0KHRoaXMuc291cmNlLCB0aGlzLmV4cGxpY2l0LCBtYXBwaW5nLm1hcFBvcyh0aGlzLmxpbWl0KSwgdGhpcy5yZXN1bHQsIG1hcHBpbmcubWFwUG9zKHRoaXMuZnJvbSksIG1hcHBpbmcubWFwUG9zKHRoaXMudG8sIDEpKTtcbiAgICB9XG4gICAgdG91Y2hlcyh0cikge1xuICAgICAgICByZXR1cm4gdHIuY2hhbmdlcy50b3VjaGVzUmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkKHZhbGlkRm9yLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICBpZiAoIXZhbGlkRm9yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHRleHQgPSBzdGF0ZS5zbGljZURvYyhmcm9tLCB0byk7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWxpZEZvciA9PSBcImZ1bmN0aW9uXCIgPyB2YWxpZEZvcih0ZXh0LCBmcm9tLCB0bywgc3RhdGUpIDogZW5zdXJlQW5jaG9yKHZhbGlkRm9yLCB0cnVlKS50ZXN0KHRleHQpO1xufVxuY29uc3Qgc2V0QWN0aXZlRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHNvdXJjZXMsIG1hcHBpbmcpIHsgcmV0dXJuIHNvdXJjZXMubWFwKHMgPT4gcy5tYXAobWFwcGluZykpOyB9XG59KTtcbmNvbnN0IHNldFNlbGVjdGVkRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgY29tcGxldGlvblN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBDb21wbGV0aW9uU3RhdGUuc3RhcnQoKTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7IHJldHVybiB2YWx1ZS51cGRhdGUodHIpOyB9LFxuICAgIHByb3ZpZGU6IGYgPT4gW1xuICAgICAgICBzaG93VG9vbHRpcC5mcm9tKGYsIHZhbCA9PiB2YWwudG9vbHRpcCksXG4gICAgICAgIEVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMuZnJvbShmLCBzdGF0ZSA9PiBzdGF0ZS5hdHRycylcbiAgICBdXG59KTtcbmZ1bmN0aW9uIGFwcGx5Q29tcGxldGlvbih2aWV3LCBvcHRpb24pIHtcbiAgICBjb25zdCBhcHBseSA9IG9wdGlvbi5jb21wbGV0aW9uLmFwcGx5IHx8IG9wdGlvbi5jb21wbGV0aW9uLmxhYmVsO1xuICAgIGxldCByZXN1bHQgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSkuYWN0aXZlLmZpbmQoYSA9PiBhLnNvdXJjZSA9PSBvcHRpb24uc291cmNlKTtcbiAgICBpZiAoIShyZXN1bHQgaW5zdGFuY2VvZiBBY3RpdmVSZXN1bHQpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBhcHBseSA9PSBcInN0cmluZ1wiKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5zZXJ0Q29tcGxldGlvblRleHQodmlldy5zdGF0ZSwgYXBwbHksIHJlc3VsdC5mcm9tLCByZXN1bHQudG8pKSwgeyBhbm5vdGF0aW9uczogcGlja2VkQ29tcGxldGlvbi5vZihvcHRpb24uY29tcGxldGlvbikgfSkpO1xuICAgIGVsc2VcbiAgICAgICAgYXBwbHkodmlldywgb3B0aW9uLmNvbXBsZXRpb24sIHJlc3VsdC5mcm9tLCByZXN1bHQudG8pO1xuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgY3JlYXRlVG9vbHRpcCA9IC8qQF9fUFVSRV9fKi9jb21wbGV0aW9uVG9vbHRpcChjb21wbGV0aW9uU3RhdGUsIGFwcGx5Q29tcGxldGlvbik7XG5cbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgdGhhdCBtb3ZlcyB0aGUgY29tcGxldGlvbiBzZWxlY3Rpb24gZm9yd2FyZCBvclxuYmFja3dhcmQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiovXG5mdW5jdGlvbiBtb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmb3J3YXJkLCBieSA9IFwib3B0aW9uXCIpIHtcbiAgICByZXR1cm4gKHZpZXcpID0+IHtcbiAgICAgICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICghY1N0YXRlIHx8ICFjU3RhdGUub3BlbiB8fCBjU3RhdGUub3Blbi5kaXNhYmxlZCB8fFxuICAgICAgICAgICAgRGF0ZS5ub3coKSAtIGNTdGF0ZS5vcGVuLnRpbWVzdGFtcCA8IHZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuaW50ZXJhY3Rpb25EZWxheSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0ZXAgPSAxLCB0b29sdGlwO1xuICAgICAgICBpZiAoYnkgPT0gXCJwYWdlXCIgJiYgKHRvb2x0aXAgPSBnZXRUb29sdGlwKHZpZXcsIGNTdGF0ZS5vcGVuLnRvb2x0aXApKSlcbiAgICAgICAgICAgIHN0ZXAgPSBNYXRoLm1heCgyLCBNYXRoLmZsb29yKHRvb2x0aXAuZG9tLm9mZnNldEhlaWdodCAvXG4gICAgICAgICAgICAgICAgdG9vbHRpcC5kb20ucXVlcnlTZWxlY3RvcihcImxpXCIpLm9mZnNldEhlaWdodCkgLSAxKTtcbiAgICAgICAgbGV0IHsgbGVuZ3RoIH0gPSBjU3RhdGUub3Blbi5vcHRpb25zO1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBjU3RhdGUub3Blbi5zZWxlY3RlZCA+IC0xID8gY1N0YXRlLm9wZW4uc2VsZWN0ZWQgKyBzdGVwICogKGZvcndhcmQgPyAxIDogLTEpIDogZm9yd2FyZCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgICBpZiAoc2VsZWN0ZWQgPCAwKVxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBieSA9PSBcInBhZ2VcIiA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgICBlbHNlIGlmIChzZWxlY3RlZCA+PSBsZW5ndGgpXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGJ5ID09IFwicGFnZVwiID8gbGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWxlY3RlZEVmZmVjdC5vZihzZWxlY3RlZCkgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkFjY2VwdCB0aGUgY3VycmVudCBjb21wbGV0aW9uLlxuKi9cbmNvbnN0IGFjY2VwdENvbXBsZXRpb24gPSAodmlldykgPT4ge1xuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5IHx8ICFjU3RhdGUgfHwgIWNTdGF0ZS5vcGVuIHx8IGNTdGF0ZS5vcGVuLnNlbGVjdGVkIDwgMCB8fCBjU3RhdGUub3Blbi5kaXNhYmxlZCB8fFxuICAgICAgICBEYXRlLm5vdygpIC0gY1N0YXRlLm9wZW4udGltZXN0YW1wIDwgdmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS5pbnRlcmFjdGlvbkRlbGF5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGFwcGx5Q29tcGxldGlvbih2aWV3LCBjU3RhdGUub3Blbi5vcHRpb25zW2NTdGF0ZS5vcGVuLnNlbGVjdGVkXSk7XG59O1xuLyoqXG5FeHBsaWNpdGx5IHN0YXJ0IGF1dG9jb21wbGV0aW9uLlxuKi9cbmNvbnN0IHN0YXJ0Q29tcGxldGlvbiA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGNTdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFjU3RhdGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc3RhcnRDb21wbGV0aW9uRWZmZWN0Lm9mKHRydWUpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ2xvc2UgdGhlIGN1cnJlbnRseSBhY3RpdmUgY29tcGxldGlvbi5cbiovXG5jb25zdCBjbG9zZUNvbXBsZXRpb24gPSAodmlldykgPT4ge1xuICAgIGxldCBjU3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghY1N0YXRlIHx8ICFjU3RhdGUuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlICE9IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGNsb3NlQ29tcGxldGlvbkVmZmVjdC5vZihudWxsKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jbGFzcyBSdW5uaW5nUXVlcnkge1xuICAgIGNvbnN0cnVjdG9yKGFjdGl2ZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy50aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy51cGRhdGVzID0gW107XG4gICAgICAgIC8vIE5vdGUgdGhhdCAndW5kZWZpbmVkJyBtZWFucyAnbm90IGRvbmUgeWV0Jywgd2hlcmVhcyAnbnVsbCcgbWVhbnNcbiAgICAgICAgLy8gJ3F1ZXJ5IHJldHVybmVkIG51bGwnLlxuICAgICAgICB0aGlzLmRvbmUgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuY29uc3QgTWF4VXBkYXRlQ291bnQgPSA1MCwgTWluQWJvcnRUaW1lID0gMTAwMDtcbmNvbnN0IGNvbXBsZXRpb25QbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IC0xO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IC0xO1xuICAgICAgICB0aGlzLnBlbmRpbmdTdGFydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDAgLyogQ29tcG9zaXRpb25TdGF0ZS5Ob25lICovO1xuICAgICAgICBmb3IgKGxldCBhY3RpdmUgb2Ygdmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpLmFjdGl2ZSlcbiAgICAgICAgICAgIGlmIChhY3RpdmUuaXNQZW5kaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRRdWVyeShhY3RpdmUpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjU3RhdGUgPSB1cGRhdGUuc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKTtcbiAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyk7XG4gICAgICAgIGlmICghdXBkYXRlLnNlbGVjdGlvblNldCAmJiAhdXBkYXRlLmRvY0NoYW5nZWQgJiYgdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlKSA9PSBjU3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkb2VzUmVzZXQgPSB1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4ge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBnZXRVcGRhdGVUeXBlKHRyLCBjb25mKTtcbiAgICAgICAgICAgIHJldHVybiAodHlwZSAmIDggLyogVXBkYXRlVHlwZS5SZXNldCAqLykgfHwgKHRyLnNlbGVjdGlvbiB8fCB0ci5kb2NDaGFuZ2VkKSAmJiAhKHR5cGUgJiAzIC8qIFVwZGF0ZVR5cGUuU2ltcGxlSW50ZXJhY3Rpb24gKi8pO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJ1bm5pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMucnVubmluZ1tpXTtcbiAgICAgICAgICAgIGlmIChkb2VzUmVzZXQgfHxcbiAgICAgICAgICAgICAgICBxdWVyeS5jb250ZXh0LmFib3J0T25Eb2NDaGFuZ2UgJiYgdXBkYXRlLmRvY0NoYW5nZWQgfHxcbiAgICAgICAgICAgICAgICBxdWVyeS51cGRhdGVzLmxlbmd0aCArIHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoID4gTWF4VXBkYXRlQ291bnQgJiYgRGF0ZS5ub3coKSAtIHF1ZXJ5LnRpbWUgPiBNaW5BYm9ydFRpbWUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIHF1ZXJ5LmNvbnRleHQuYWJvcnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXVlcnkuY29udGV4dC5hYm9ydExpc3RlbmVycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5uaW5nLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVlcnkudXBkYXRlcy5wdXNoKC4uLnVwZGF0ZS50cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlYm91bmNlVXBkYXRlID4gLTEpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVVwZGF0ZSk7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuZWZmZWN0cy5zb21lKGUgPT4gZS5pcyhzdGFydENvbXBsZXRpb25FZmZlY3QpKSkpXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTdGFydCA9IHRydWU7XG4gICAgICAgIGxldCBkZWxheSA9IHRoaXMucGVuZGluZ1N0YXJ0ID8gNTAgOiBjb25mLmFjdGl2YXRlT25UeXBpbmdEZWxheTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IGNTdGF0ZS5hY3RpdmUuc29tZShhID0+IGEuaXNQZW5kaW5nICYmICF0aGlzLnJ1bm5pbmcuc29tZShxID0+IHEuYWN0aXZlLnNvdXJjZSA9PSBhLnNvdXJjZSkpXG4gICAgICAgICAgICA/IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGFydFVwZGF0ZSgpLCBkZWxheSkgOiAtMTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nICE9IDAgLyogQ29tcG9zaXRpb25TdGF0ZS5Ob25lICovKVxuICAgICAgICAgICAgZm9yIChsZXQgdHIgb2YgdXBkYXRlLnRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh0ci5pc1VzZXJFdmVudChcImlucHV0LnR5cGVcIikpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gMiAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWQgKi87XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb21wb3NpbmcgPT0gMiAvKiBDb21wb3NpdGlvblN0YXRlLkNoYW5nZWQgKi8gJiYgdHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDMgLyogQ29tcG9zaXRpb25TdGF0ZS5DaGFuZ2VkQW5kTW92ZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0VXBkYXRlKCkge1xuICAgICAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gLTE7XG4gICAgICAgIHRoaXMucGVuZGluZ1N0YXJ0ID0gZmFsc2U7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGNTdGF0ZSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGFjdGl2ZSBvZiBjU3RhdGUuYWN0aXZlKSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlLmlzUGVuZGluZyAmJiAhdGhpcy5ydW5uaW5nLnNvbWUociA9PiByLmFjdGl2ZS5zb3VyY2UgPT0gYWN0aXZlLnNvdXJjZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucnVubmluZy5sZW5ndGggJiYgY1N0YXRlLm9wZW4gJiYgY1N0YXRlLm9wZW4uZGlzYWJsZWQpXG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlQWNjZXB0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjY2VwdCgpLCB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykudXBkYXRlU3luY1RpbWUpO1xuICAgIH1cbiAgICBzdGFydFF1ZXJ5KGFjdGl2ZSkge1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBwb3MgPSBjdXIoc3RhdGUpO1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBDb21wbGV0aW9uQ29udGV4dChzdGF0ZSwgcG9zLCBhY3RpdmUuZXhwbGljaXQsIHRoaXMudmlldyk7XG4gICAgICAgIGxldCBwZW5kaW5nID0gbmV3IFJ1bm5pbmdRdWVyeShhY3RpdmUsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnJ1bm5pbmcucHVzaChwZW5kaW5nKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGFjdGl2ZS5zb3VyY2UoY29udGV4dCkpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGlmICghcGVuZGluZy5jb250ZXh0LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLmRvbmUgPSByZXN1bHQgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQWNjZXB0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBjbG9zZUNvbXBsZXRpb25FZmZlY3Qub2YobnVsbCkgfSk7XG4gICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2NoZWR1bGVBY2NlcHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcuZXZlcnkocSA9PiBxLmRvbmUgIT09IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICB0aGlzLmFjY2VwdCgpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmRlYm91bmNlQWNjZXB0IDwgMClcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYWNjZXB0KCksIHRoaXMudmlldy5zdGF0ZS5mYWNldChjb21wbGV0aW9uQ29uZmlnKS51cGRhdGVTeW5jVGltZSk7XG4gICAgfVxuICAgIC8vIEZvciBlYWNoIGZpbmlzaGVkIHF1ZXJ5IGluIHRoaXMucnVubmluZywgdHJ5IHRvIGNyZWF0ZSBhIHJlc3VsdFxuICAgIC8vIG9yLCBpZiBhcHByb3ByaWF0ZSwgcmVzdGFydCB0aGUgcXVlcnkuXG4gICAgYWNjZXB0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmRlYm91bmNlQWNjZXB0ID4gLTEpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZUFjY2VwdCk7XG4gICAgICAgIHRoaXMuZGVib3VuY2VBY2NlcHQgPSAtMTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBbXTtcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZyksIGNTdGF0ZSA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChjb21wbGV0aW9uU3RhdGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5ydW5uaW5nW2ldO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmRvbmUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXMucnVubmluZy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIGlmIChxdWVyeS5kb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvcyA9IGN1cihxdWVyeS51cGRhdGVzLmxlbmd0aCA/IHF1ZXJ5LnVwZGF0ZXNbMF0uc3RhcnRTdGF0ZSA6IHRoaXMudmlldy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgbGV0IGxpbWl0ID0gTWF0aC5taW4ocG9zLCBxdWVyeS5kb25lLmZyb20gKyAocXVlcnkuYWN0aXZlLmV4cGxpY2l0ID8gMCA6IDEpKTtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gbmV3IEFjdGl2ZVJlc3VsdChxdWVyeS5hY3RpdmUuc291cmNlLCBxdWVyeS5hY3RpdmUuZXhwbGljaXQsIGxpbWl0LCBxdWVyeS5kb25lLCBxdWVyeS5kb25lLmZyb20sIChfYSA9IHF1ZXJ5LmRvbmUudG8pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHBvcyk7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGF5IHRoZSB0cmFuc2FjdGlvbnMgdGhhdCBoYXBwZW5lZCBzaW5jZSB0aGUgc3RhcnQgb2ZcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCBhbmQgc2VlIGlmIHRoYXQgcHJlc2VydmVzIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0ciBvZiBxdWVyeS51cGRhdGVzKVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUudXBkYXRlKHRyLCBjb25mKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlLmhhc1Jlc3VsdCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQucHVzaChhY3RpdmUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGNTdGF0ZS5hY3RpdmUuZmluZChhID0+IGEuc291cmNlID09IHF1ZXJ5LmFjdGl2ZS5zb3VyY2UpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5pc1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnkuZG9uZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgZmFpbGVkLiBTaG91bGQgY2xlYXIgdGhlIHBlbmRpbmcgc3RhdHVzIGlmIGl0XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhc24ndCBiZWVuIHJlLXNldCBpbiB0aGUgbWVhbnRpbWUuXG4gICAgICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSBuZXcgQWN0aXZlU291cmNlKHF1ZXJ5LmFjdGl2ZS5zb3VyY2UsIDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0ciBvZiBxdWVyeS51cGRhdGVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gYWN0aXZlLnVwZGF0ZSh0ciwgY29uZik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWN0aXZlLmlzUGVuZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQucHVzaChhY3RpdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXJlZCBieSBzdWJzZXF1ZW50IHRyYW5zYWN0aW9ucy4gUmVzdGFydC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFF1ZXJ5KGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZC5sZW5ndGggfHwgY1N0YXRlLm9wZW4gJiYgY1N0YXRlLm9wZW4uZGlzYWJsZWQpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRBY3RpdmVFZmZlY3Qub2YodXBkYXRlZCkgfSk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgICAgYmx1cihldmVudCkge1xuICAgICAgICAgICAgbGV0IHN0YXRlID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHN0YXRlICYmIHN0YXRlLnRvb2x0aXAgJiYgdGhpcy52aWV3LnN0YXRlLmZhY2V0KGNvbXBsZXRpb25Db25maWcpLmNsb3NlT25CbHVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpYWxvZyA9IHN0YXRlLm9wZW4gJiYgZ2V0VG9vbHRpcCh0aGlzLnZpZXcsIHN0YXRlLm9wZW4udG9vbHRpcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaWFsb2cgfHwgIWRpYWxvZy5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogY2xvc2VDb21wbGV0aW9uRWZmZWN0Lm9mKG51bGwpIH0pLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvc2l0aW9uc3RhcnQoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZyA9IDEgLyogQ29tcG9zaXRpb25TdGF0ZS5TdGFydGVkICovO1xuICAgICAgICB9LFxuICAgICAgICBjb21wb3NpdGlvbmVuZCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyA9PSAzIC8qIENvbXBvc2l0aW9uU3RhdGUuQ2hhbmdlZEFuZE1vdmVkICovKSB7XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIGZpcmVzIGNvbXBvc2l0aW9uZW5kIGV2ZW50cyBzeW5jaHJvbm91c2x5LCBwb3NzaWJseVxuICAgICAgICAgICAgICAgIC8vIGZyb20gaW5zaWRlIGFuIHVwZGF0ZSwgc28gZGlzcGF0Y2ggYXN5bmNocm9ub3VzbHkgdG8gYXZvaWQgcmVlbnRyYW5jeVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc3RhcnRDb21wbGV0aW9uRWZmZWN0Lm9mKGZhbHNlKSB9KSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSAwIC8qIENvbXBvc2l0aW9uU3RhdGUuTm9uZSAqLztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuY29uc3Qgd2luZG93cyA9IHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJvYmplY3RcIiAmJiAvKkBfX1BVUkVfXyovL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgY29tbWl0Q2hhcmFjdGVycyA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL0VkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAga2V5ZG93bihldmVudCwgdmlldykge1xuICAgICAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5vcGVuIHx8IGZpZWxkLm9wZW4uZGlzYWJsZWQgfHwgZmllbGQub3Blbi5zZWxlY3RlZCA8IDAgfHxcbiAgICAgICAgICAgIGV2ZW50LmtleS5sZW5ndGggPiAxIHx8IGV2ZW50LmN0cmxLZXkgJiYgISh3aW5kb3dzICYmIGV2ZW50LmFsdEtleSkgfHwgZXZlbnQubWV0YUtleSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IG9wdGlvbiA9IGZpZWxkLm9wZW4ub3B0aW9uc1tmaWVsZC5vcGVuLnNlbGVjdGVkXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZpZWxkLmFjdGl2ZS5maW5kKGEgPT4gYS5zb3VyY2UgPT0gb3B0aW9uLnNvdXJjZSk7XG4gICAgICAgIGxldCBjb21taXRDaGFycyA9IG9wdGlvbi5jb21wbGV0aW9uLmNvbW1pdENoYXJhY3RlcnMgfHwgcmVzdWx0LnJlc3VsdC5jb21taXRDaGFyYWN0ZXJzO1xuICAgICAgICBpZiAoY29tbWl0Q2hhcnMgJiYgY29tbWl0Q2hhcnMuaW5kZXhPZihldmVudC5rZXkpID4gLTEpXG4gICAgICAgICAgICBhcHBseUNvbXBsZXRpb24odmlldywgb3B0aW9uKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0pKTtcblxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS10b29sdGlwLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlXCI6IHtcbiAgICAgICAgXCImID4gdWxcIjoge1xuICAgICAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwibm93cmFwXCIsXG4gICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW4gYXV0b1wiLFxuICAgICAgICAgICAgbWF4V2lkdGhfZmFsbGJhY2s6IFwiNzAwcHhcIixcbiAgICAgICAgICAgIG1heFdpZHRoOiBcIm1pbig3MDBweCwgOTV2dylcIixcbiAgICAgICAgICAgIG1pbldpZHRoOiBcIjI1MHB4XCIsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IFwiMTBlbVwiLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgICAgIGxpc3RTdHlsZTogXCJub25lXCIsXG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgXCImID4gbGksICYgPiBjb21wbGV0aW9uLXNlY3Rpb25cIjoge1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiMXB4IDNweFwiLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDEuMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJiA+IGxpXCI6IHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1g6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiBcImVsbGlwc2lzXCIsXG4gICAgICAgICAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJiA+IGNvbXBsZXRpb24tc2VjdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJsaXN0LWl0ZW1cIixcbiAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkIHNpbHZlclwiLFxuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiBcIjAuNWVtXCIsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMC43XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZSB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzE3Y1wiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjNzc3XCIsXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZSB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzM0N1wiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgIH0sXG4gICAgXCImZGFyayAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUtZGlzYWJsZWQgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM0NDRcIixcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZVRvcDpiZWZvcmUsIC5jbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVCb3R0b206YWZ0ZXJcIjoge1xuICAgICAgICBjb250ZW50OiAnXCLCt8K3wrdcIicsXG4gICAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAuY20tY29tcGxldGlvbkluZm9cIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjNweCA5cHhcIixcbiAgICAgICAgd2lkdGg6IFwibWF4LWNvbnRlbnRcIixcbiAgICAgICAgbWF4V2lkdGg6IGAkezQwMCAvKiBJbmZvLldpZHRoICovfXB4YCxcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJwcmUtbGluZVwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1sZWZ0XCI6IHsgcmlnaHQ6IFwiMTAwJVwiIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tcmlnaHRcIjogeyBsZWZ0OiBcIjEwMCVcIiB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLWxlZnQtbmFycm93XCI6IHsgcmlnaHQ6IGAkezMwIC8qIEluZm8uTWFyZ2luICovfXB4YCB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLXJpZ2h0LW5hcnJvd1wiOiB7IGxlZnQ6IGAkezMwIC8qIEluZm8uTWFyZ2luICovfXB4YCB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zbmlwcGV0RmllbGRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwMDAwMDIyXCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zbmlwcGV0RmllbGRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZmZmZjIyXCIgfSxcbiAgICBcIi5jbS1zbmlwcGV0RmllbGRQb3NpdGlvblwiOiB7XG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwidGV4dC10b3BcIixcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogXCIxLjE1ZW1cIixcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgbWFyZ2luOiBcIjAgLTAuN3B4IC0uN2VtXCIsXG4gICAgICAgIGJvcmRlckxlZnQ6IFwiMS40cHggZG90dGVkICM4ODhcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbk1hdGNoZWRUZXh0XCI6IHtcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCJcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25EZXRhaWxcIjoge1xuICAgICAgICBtYXJnaW5MZWZ0OiBcIjAuNWVtXCIsXG4gICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb25cIjoge1xuICAgICAgICBmb250U2l6ZTogXCI5MCVcIixcbiAgICAgICAgd2lkdGg6IFwiLjhlbVwiLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIHBhZGRpbmdSaWdodDogXCIuNmVtXCIsXG4gICAgICAgIG9wYWNpdHk6IFwiMC42XCIsXG4gICAgICAgIGJveFNpemluZzogXCJjb250ZW50LWJveFwiXG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi1mdW5jdGlvbiwgLmNtLWNvbXBsZXRpb25JY29uLW1ldGhvZFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ8aSJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWNsYXNzXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4peLJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWludGVyZmFjZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KXjCdcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi12YXJpYWJsZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ/CdkaUnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tY29uc3RhbnRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwnZC2J1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLXR5cGVcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwnZGhJ1wiIH1cbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLWVudW1cIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifiiKonXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24tcHJvcGVydHlcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifilqEnXCIgfVxuICAgIH0sXG4gICAgXCIuY20tY29tcGxldGlvbkljb24ta2V5d29yZFwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ/CflJFcXHVGRTBFJ1wiIH0gLy8gRGlzYWJsZSBlbW9qaSByZW5kZXJpbmdcbiAgICB9LFxuICAgIFwiLmNtLWNvbXBsZXRpb25JY29uLW5hbWVzcGFjZVwiOiB7XG4gICAgICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KWoidcIiB9XG4gICAgfSxcbiAgICBcIi5jbS1jb21wbGV0aW9uSWNvbi10ZXh0XCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInYWJjJ1wiLCBmb250U2l6ZTogXCI1MCVcIiwgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIiB9XG4gICAgfVxufSk7XG5cbmNsYXNzIEZpZWxkUG9zIHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZCwgbGluZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxufVxuY2xhc3MgRmllbGRSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGQsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbiAgICBtYXAoY2hhbmdlcykge1xuICAgICAgICBsZXQgZnJvbSA9IGNoYW5nZXMubWFwUG9zKHRoaXMuZnJvbSwgLTEsIE1hcE1vZGUuVHJhY2tEZWwpO1xuICAgICAgICBsZXQgdG8gPSBjaGFuZ2VzLm1hcFBvcyh0aGlzLnRvLCAxLCBNYXBNb2RlLlRyYWNrRGVsKTtcbiAgICAgICAgcmV0dXJuIGZyb20gPT0gbnVsbCB8fCB0byA9PSBudWxsID8gbnVsbCA6IG5ldyBGaWVsZFJhbmdlKHRoaXMuZmllbGQsIGZyb20sIHRvKTtcbiAgICB9XG59XG5jbGFzcyBTbmlwcGV0IHtcbiAgICBjb25zdHJ1Y3RvcihsaW5lcywgZmllbGRQb3NpdGlvbnMpIHtcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLmZpZWxkUG9zaXRpb25zID0gZmllbGRQb3NpdGlvbnM7XG4gICAgfVxuICAgIGluc3RhbnRpYXRlKHN0YXRlLCBwb3MpIHtcbiAgICAgICAgbGV0IHRleHQgPSBbXSwgbGluZVN0YXJ0ID0gW3Bvc107XG4gICAgICAgIGxldCBsaW5lT2JqID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBiYXNlSW5kZW50ID0gL15cXHMqLy5leGVjKGxpbmVPYmoudGV4dClbMF07XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy5saW5lcykge1xuICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudCA9IGJhc2VJbmRlbnQsIHRhYnMgPSAvXlxcdCovLmV4ZWMobGluZSlbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFiczsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKz0gc3RhdGUuZmFjZXQoaW5kZW50VW5pdCk7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0LnB1c2gocG9zICsgaW5kZW50Lmxlbmd0aCAtIHRhYnMpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBpbmRlbnQgKyBsaW5lLnNsaWNlKHRhYnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dC5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgcG9zICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZ2VzID0gdGhpcy5maWVsZFBvc2l0aW9ucy5tYXAocG9zID0+IG5ldyBGaWVsZFJhbmdlKHBvcy5maWVsZCwgbGluZVN0YXJ0W3Bvcy5saW5lXSArIHBvcy5mcm9tLCBsaW5lU3RhcnRbcG9zLmxpbmVdICsgcG9zLnRvKSk7XG4gICAgICAgIHJldHVybiB7IHRleHQsIHJhbmdlcyB9O1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodGVtcGxhdGUpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFtdO1xuICAgICAgICBsZXQgbGluZXMgPSBbXSwgcG9zaXRpb25zID0gW10sIG07XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGVtcGxhdGUuc3BsaXQoL1xcclxcbj98XFxuLykpIHtcbiAgICAgICAgICAgIHdoaWxlIChtID0gL1sjJF1cXHsoPzooXFxkKykoPzo6KFtefV0qKSk/fCgoPzpcXFxcW3t9XXxbXn1dKSopKVxcfS8uZXhlYyhsaW5lKSkge1xuICAgICAgICAgICAgICAgIGxldCBzZXEgPSBtWzFdID8gK21bMV0gOiBudWxsLCByYXdOYW1lID0gbVsyXSB8fCBtWzNdIHx8IFwiXCIsIGZvdW5kID0gLTE7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSByYXdOYW1lLnJlcGxhY2UoL1xcXFxbe31dL2csIG0gPT4gbVsxXSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcSAhPSBudWxsID8gZmllbGRzW2ldLnNlcSA9PSBzZXEgOiBuYW1lID8gZmllbGRzW2ldLm5hbWUgPT0gbmFtZSA6IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm91bmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBmaWVsZHMubGVuZ3RoICYmIChzZXEgPT0gbnVsbCB8fCAoZmllbGRzW2ldLnNlcSAhPSBudWxsICYmIGZpZWxkc1tpXS5zZXEgPCBzZXEpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnNwbGljZShpLCAwLCB7IHNlcSwgbmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3Mgb2YgcG9zaXRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcy5maWVsZCA+PSBmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MuZmllbGQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2gobmV3IEZpZWxkUG9zKGZvdW5kLCBsaW5lcy5sZW5ndGgsIG0uaW5kZXgsIG0uaW5kZXggKyBuYW1lLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIG0uaW5kZXgpICsgcmF3TmFtZSArIGxpbmUuc2xpY2UobS5pbmRleCArIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL1xcXFwoW3t9XSkvZywgKF8sIGJyYWNlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBwb3NpdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MubGluZSA9PSBsaW5lcy5sZW5ndGggJiYgcG9zLmZyb20gPiBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLmZyb20tLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy50by0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyYWNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU25pcHBldChsaW5lcywgcG9zaXRpb25zKTtcbiAgICB9XG59XG5sZXQgZmllbGRNYXJrZXIgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi53aWRnZXQoeyB3aWRnZXQ6IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICAgICAgdG9ET00oKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCI7XG4gICAgICAgICAgICByZXR1cm4gc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfSB9KTtcbmxldCBmaWVsZFJhbmdlID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNuaXBwZXRGaWVsZFwiIH0pO1xuY2xhc3MgQWN0aXZlU25pcHBldCB7XG4gICAgY29uc3RydWN0b3IocmFuZ2VzLCBhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICB0aGlzLmRlY28gPSBEZWNvcmF0aW9uLnNldChyYW5nZXMubWFwKHIgPT4gKHIuZnJvbSA9PSByLnRvID8gZmllbGRNYXJrZXIgOiBmaWVsZFJhbmdlKS5yYW5nZShyLmZyb20sIHIudG8pKSk7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnJhbmdlcykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHIubWFwKGNoYW5nZXMpO1xuICAgICAgICAgICAgaWYgKCFtYXBwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlU25pcHBldChyYW5nZXMsIHRoaXMuYWN0aXZlKTtcbiAgICB9XG4gICAgc2VsZWN0aW9uSW5zaWRlRmllbGQoc2VsKSB7XG4gICAgICAgIHJldHVybiBzZWwucmFuZ2VzLmV2ZXJ5KHJhbmdlID0+IHRoaXMucmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID09IHRoaXMuYWN0aXZlICYmIHIuZnJvbSA8PSByYW5nZS5mcm9tICYmIHIudG8gPj0gcmFuZ2UudG8pKTtcbiAgICB9XG59XG5jb25zdCBzZXRBY3RpdmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAodmFsdWUsIGNoYW5nZXMpIHsgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm1hcChjaGFuZ2VzKTsgfVxufSk7XG5jb25zdCBtb3ZlVG9GaWVsZCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHNuaXBwZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEFjdGl2ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMobW92ZVRvRmllbGQpICYmIHZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlU25pcHBldCh2YWx1ZS5yYW5nZXMsIGVmZmVjdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICYmIHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRyLnNlbGVjdGlvbiAmJiAhdmFsdWUuc2VsZWN0aW9uSW5zaWRlRmllbGQodHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiwgdmFsID0+IHZhbCA/IHZhbC5kZWNvIDogRGVjb3JhdGlvbi5ub25lKVxufSk7XG5mdW5jdGlvbiBmaWVsZFNlbGVjdGlvbihyYW5nZXMsIGZpZWxkKSB7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLmZpbHRlcihyID0+IHIuZmllbGQgPT0gZmllbGQpLm1hcChyID0+IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyLmZyb20sIHIudG8pKSk7XG59XG4vKipcbkNvbnZlcnQgYSBzbmlwcGV0IHRlbXBsYXRlIHRvIGEgZnVuY3Rpb24gdGhhdCBjYW5cblthcHBseV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ29tcGxldGlvbi5hcHBseSkgaXQuIFNuaXBwZXRzIGFyZSB3cml0dGVuXG51c2luZyBzeW50YXggbGlrZSB0aGlzOlxuXG4gICAgXCJmb3IgKGxldCAke2luZGV4fSA9IDA7ICR7aW5kZXh9IDwgJHtlbmR9OyAke2luZGV4fSsrKSB7XFxuXFx0JHt9XFxufVwiXG5cbkVhY2ggYCR7fWAgcGxhY2Vob2xkZXIgKHlvdSBtYXkgYWxzbyB1c2UgYCN7fWApIGluZGljYXRlcyBhIGZpZWxkXG50aGF0IHRoZSB1c2VyIGNhbiBmaWxsIGluLiBJdHMgbmFtZSwgaWYgYW55LCB3aWxsIGJlIHRoZSBkZWZhdWx0XG5jb250ZW50IGZvciB0aGUgZmllbGQuXG5cbldoZW4gdGhlIHNuaXBwZXQgaXMgYWN0aXZhdGVkIGJ5IGNhbGxpbmcgdGhlIHJldHVybmVkIGZ1bmN0aW9uLFxudGhlIGNvZGUgaXMgaW5zZXJ0ZWQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBOZXdsaW5lcyBpbiB0aGVcbnRlbXBsYXRlIGFyZSBpbmRlbnRlZCBieSB0aGUgaW5kZW50YXRpb24gb2YgdGhlIHN0YXJ0IGxpbmUsIHBsdXNcbm9uZSBbaW5kZW50IHVuaXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgcGVyIHRhYiBjaGFyYWN0ZXIgYWZ0ZXJcbnRoZSBuZXdsaW5lLlxuXG5PbiBhY3RpdmF0aW9uLCAoYWxsIGluc3RhbmNlcyBvZikgdGhlIGZpcnN0IGZpZWxkIGFyZSBzZWxlY3RlZC5cblRoZSB1c2VyIGNhbiBtb3ZlIGJldHdlZW4gZmllbGRzIHdpdGggVGFiIGFuZCBTaGlmdC1UYWIgYXMgbG9uZyBhc1xudGhlIGZpZWxkcyBhcmUgYWN0aXZlLiBNb3ZpbmcgdG8gdGhlIGxhc3QgZmllbGQgb3IgbW92aW5nIHRoZVxuY3Vyc29yIG91dCBvZiB0aGUgY3VycmVudCBmaWVsZCBkZWFjdGl2YXRlcyB0aGUgZmllbGRzLlxuXG5UaGUgb3JkZXIgb2YgZmllbGRzIGRlZmF1bHRzIHRvIHRleHR1YWwgb3JkZXIsIGJ1dCB5b3UgY2FuIGFkZFxubnVtYmVycyB0byBwbGFjZWhvbGRlcnMgKGAkezF9YCBvciBgJHsxOmRlZmF1bHRUZXh0fWApIHRvIHByb3ZpZGVcbmEgY3VzdG9tIG9yZGVyLlxuXG5UbyBpbmNsdWRlIGEgbGl0ZXJhbCBge2Agb3IgYH1gIGluIHlvdXIgdGVtcGxhdGUsIHB1dCBhIGJhY2tzbGFzaFxuaW4gZnJvbnQgb2YgaXQuIFRoaXMgd2lsbCBiZSByZW1vdmVkIGFuZCB0aGUgYnJhY2Ugd2lsbCBub3QgYmVcbmludGVycHJldGVkIGFzIGluZGljYXRpbmcgYSBwbGFjZWhvbGRlci5cbiovXG5mdW5jdGlvbiBzbmlwcGV0KHRlbXBsYXRlKSB7XG4gICAgbGV0IHNuaXBwZXQgPSBTbmlwcGV0LnBhcnNlKHRlbXBsYXRlKTtcbiAgICByZXR1cm4gKGVkaXRvciwgY29tcGxldGlvbiwgZnJvbSwgdG8pID0+IHtcbiAgICAgICAgbGV0IHsgdGV4dCwgcmFuZ2VzIH0gPSBzbmlwcGV0Lmluc3RhbnRpYXRlKGVkaXRvci5zdGF0ZSwgZnJvbSk7XG4gICAgICAgIGxldCB7IG1haW4gfSA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCBzcGVjID0ge1xuICAgICAgICAgICAgY2hhbmdlczogeyBmcm9tLCB0bzogdG8gPT0gbWFpbi5mcm9tID8gbWFpbi50byA6IHRvLCBpbnNlcnQ6IFRleHQub2YodGV4dCkgfSxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICAgICAgYW5ub3RhdGlvbnM6IGNvbXBsZXRpb24gPyBbcGlja2VkQ29tcGxldGlvbi5vZihjb21wbGV0aW9uKSwgVHJhbnNhY3Rpb24udXNlckV2ZW50Lm9mKFwiaW5wdXQuY29tcGxldGVcIildIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgc3BlYy5zZWxlY3Rpb24gPSBmaWVsZFNlbGVjdGlvbihyYW5nZXMsIDApO1xuICAgICAgICBpZiAocmFuZ2VzLnNvbWUociA9PiByLmZpZWxkID4gMCkpIHtcbiAgICAgICAgICAgIGxldCBhY3RpdmUgPSBuZXcgQWN0aXZlU25pcHBldChyYW5nZXMsIDApO1xuICAgICAgICAgICAgbGV0IGVmZmVjdHMgPSBzcGVjLmVmZmVjdHMgPSBbc2V0QWN0aXZlLm9mKGFjdGl2ZSldO1xuICAgICAgICAgICAgaWYgKGVkaXRvci5zdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGVmZmVjdHMucHVzaChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoW3NuaXBwZXRTdGF0ZSwgYWRkU25pcHBldEtleW1hcCwgc25pcHBldFBvaW50ZXJIYW5kbGVyLCBiYXNlVGhlbWVdKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoKGVkaXRvci5zdGF0ZS51cGRhdGUoc3BlYykpO1xuICAgIH07XG59XG5mdW5jdGlvbiBtb3ZlRmllbGQoZGlyKSB7XG4gICAgcmV0dXJuICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKCFhY3RpdmUgfHwgZGlyIDwgMCAmJiBhY3RpdmUuYWN0aXZlID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBuZXh0ID0gYWN0aXZlLmFjdGl2ZSArIGRpciwgbGFzdCA9IGRpciA+IDAgJiYgIWFjdGl2ZS5yYW5nZXMuc29tZShyID0+IHIuZmllbGQgPT0gbmV4dCArIGRpcik7XG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICBzZWxlY3Rpb246IGZpZWxkU2VsZWN0aW9uKGFjdGl2ZS5yYW5nZXMsIG5leHQpLFxuICAgICAgICAgICAgZWZmZWN0czogc2V0QWN0aXZlLm9mKGxhc3QgPyBudWxsIDogbmV3IEFjdGl2ZVNuaXBwZXQoYWN0aXZlLnJhbmdlcywgbmV4dCkpLFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5BIGNvbW1hbmQgdGhhdCBjbGVhcnMgdGhlIGFjdGl2ZSBzbmlwcGV0LCBpZiBhbnkuXG4qL1xuY29uc3QgY2xlYXJTbmlwcGV0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgYWN0aXZlID0gc3RhdGUuZmllbGQoc25pcHBldFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFhY3RpdmUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBlZmZlY3RzOiBzZXRBY3RpdmUub2YobnVsbCkgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0byB0aGUgbmV4dCBzbmlwcGV0IGZpZWxkLCBpZiBhdmFpbGFibGUuXG4qL1xuY29uc3QgbmV4dFNuaXBwZXRGaWVsZCA9IC8qQF9fUFVSRV9fKi9tb3ZlRmllbGQoMSk7XG4vKipcbk1vdmUgdG8gdGhlIHByZXZpb3VzIHNuaXBwZXQgZmllbGQsIGlmIGF2YWlsYWJsZS5cbiovXG5jb25zdCBwcmV2U25pcHBldEZpZWxkID0gLypAX19QVVJFX18qL21vdmVGaWVsZCgtMSk7XG4vKipcbkNoZWNrIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSBzbmlwcGV0IHdpdGggYSBuZXh0IGZpZWxkIGZvclxuYG5leHRTbmlwcGV0RmllbGRgIHRvIG1vdmUgdG8uXG4qL1xuZnVuY3Rpb24gaGFzTmV4dFNuaXBwZXRGaWVsZChzdGF0ZSkge1xuICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gISEoYWN0aXZlICYmIGFjdGl2ZS5yYW5nZXMuc29tZShyID0+IHIuZmllbGQgPT0gYWN0aXZlLmFjdGl2ZSArIDEpKTtcbn1cbi8qKlxuUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSBzbmlwcGV0IGFuZCBhIHByZXZpb3VzIGZpZWxkXG5mb3IgYHByZXZTbmlwcGV0RmllbGRgIHRvIG1vdmUgdG8uXG4qL1xuZnVuY3Rpb24gaGFzUHJldlNuaXBwZXRGaWVsZChzdGF0ZSkge1xuICAgIGxldCBhY3RpdmUgPSBzdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gISEoYWN0aXZlICYmIGFjdGl2ZS5hY3RpdmUgPiAwKTtcbn1cbmNvbnN0IGRlZmF1bHRTbmlwcGV0S2V5bWFwID0gW1xuICAgIHsga2V5OiBcIlRhYlwiLCBydW46IG5leHRTbmlwcGV0RmllbGQsIHNoaWZ0OiBwcmV2U25pcHBldEZpZWxkIH0sXG4gICAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogY2xlYXJTbmlwcGV0IH1cbl07XG4vKipcbkEgZmFjZXQgdGhhdCBjYW4gYmUgdXNlZCB0byBjb25maWd1cmUgdGhlIGtleSBiaW5kaW5ncyB1c2VkIGJ5XG5zbmlwcGV0cy4gVGhlIGRlZmF1bHQgYmluZHMgVGFiIHRvXG5bYG5leHRTbmlwcGV0RmllbGRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5uZXh0U25pcHBldEZpZWxkKSwgU2hpZnQtVGFiIHRvXG5bYHByZXZTbmlwcGV0RmllbGRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5wcmV2U25pcHBldEZpZWxkKSwgYW5kIEVzY2FwZVxudG8gW2BjbGVhclNuaXBwZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbGVhclNuaXBwZXQpLlxuKi9cbmNvbnN0IHNuaXBwZXRLZXltYXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKG1hcHMpIHsgcmV0dXJuIG1hcHMubGVuZ3RoID8gbWFwc1swXSA6IGRlZmF1bHRTbmlwcGV0S2V5bWFwOyB9XG59KTtcbmNvbnN0IGFkZFNuaXBwZXRLZXltYXAgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9rZXltYXAuY29tcHV0ZShbc25pcHBldEtleW1hcF0sIHN0YXRlID0+IHN0YXRlLmZhY2V0KHNuaXBwZXRLZXltYXApKSk7XG4vKipcbkNyZWF0ZSBhIGNvbXBsZXRpb24gZnJvbSBhIHNuaXBwZXQuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlXG5wcm9wZXJ0aWVzIGZyb20gYGNvbXBsZXRpb25gLCBwbHVzIGFuIGBhcHBseWAgZnVuY3Rpb24gdGhhdFxuYXBwbGllcyB0aGUgc25pcHBldC5cbiovXG5mdW5jdGlvbiBzbmlwcGV0Q29tcGxldGlvbih0ZW1wbGF0ZSwgY29tcGxldGlvbikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbXBsZXRpb24pLCB7IGFwcGx5OiBzbmlwcGV0KHRlbXBsYXRlKSB9KTtcbn1cbmNvbnN0IHNuaXBwZXRQb2ludGVySGFuZGxlciA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgIG1vdXNlZG93bihldmVudCwgdmlldykge1xuICAgICAgICBsZXQgYWN0aXZlID0gdmlldy5zdGF0ZS5maWVsZChzbmlwcGV0U3RhdGUsIGZhbHNlKSwgcG9zO1xuICAgICAgICBpZiAoIWFjdGl2ZSB8fCAocG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSkpID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBtYXRjaCA9IGFjdGl2ZS5yYW5nZXMuZmluZChyID0+IHIuZnJvbSA8PSBwb3MgJiYgci50byA+PSBwb3MpO1xuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmZpZWxkID09IGFjdGl2ZS5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgc2VsZWN0aW9uOiBmaWVsZFNlbGVjdGlvbihhY3RpdmUucmFuZ2VzLCBtYXRjaC5maWVsZCksXG4gICAgICAgICAgICBlZmZlY3RzOiBzZXRBY3RpdmUub2YoYWN0aXZlLnJhbmdlcy5zb21lKHIgPT4gci5maWVsZCA+IG1hdGNoLmZpZWxkKVxuICAgICAgICAgICAgICAgID8gbmV3IEFjdGl2ZVNuaXBwZXQoYWN0aXZlLnJhbmdlcywgbWF0Y2guZmllbGQpIDogbnVsbCksXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIHdvcmRSRSh3b3JkQ2hhcnMpIHtcbiAgICBsZXQgZXNjYXBlZCA9IHdvcmRDaGFycy5yZXBsYWNlKC9bXFxdXFwtXFxcXF0vZywgXCJcXFxcJCZcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYFtcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fJHtlc2NhcGVkfV0rYCwgXCJ1Z1wiKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBbXFx3JHtlc2NhcGVkfV1gLCBcImdcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwUkUocmUsIGYpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChmKHJlLnNvdXJjZSksIHJlLnVuaWNvZGUgPyBcInVcIiA6IFwiXCIpO1xufVxuY29uc3Qgd29yZENhY2hlcyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gd29yZENhY2hlKHdvcmRDaGFycykge1xuICAgIHJldHVybiB3b3JkQ2FjaGVzW3dvcmRDaGFyc10gfHwgKHdvcmRDYWNoZXNbd29yZENoYXJzXSA9IG5ldyBXZWFrTWFwKTtcbn1cbmZ1bmN0aW9uIHN0b3JlV29yZHMoZG9jLCB3b3JkUkUsIHJlc3VsdCwgc2VlbiwgaWdub3JlQXQpIHtcbiAgICBmb3IgKGxldCBsaW5lcyA9IGRvYy5pdGVyTGluZXMoKSwgcG9zID0gMDsgIWxpbmVzLm5leHQoKS5kb25lOykge1xuICAgICAgICBsZXQgeyB2YWx1ZSB9ID0gbGluZXMsIG07XG4gICAgICAgIHdvcmRSRS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAobSA9IHdvcmRSRS5leGVjKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCFzZWVuW21bMF1dICYmIHBvcyArIG0uaW5kZXggIT0gaWdub3JlQXQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6IFwidGV4dFwiLCBsYWJlbDogbVswXSB9KTtcbiAgICAgICAgICAgICAgICBzZWVuW21bMF1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+PSAyMDAwIC8qIEMuTWF4TGlzdCAqLylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBvcyArPSB2YWx1ZS5sZW5ndGggKyAxO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RXb3Jkcyhkb2MsIGNhY2hlLCB3b3JkUkUsIHRvLCBpZ25vcmVBdCkge1xuICAgIGxldCBiaWcgPSBkb2MubGVuZ3RoID49IDEwMDAgLyogQy5NaW5DYWNoZUxlbiAqLztcbiAgICBsZXQgY2FjaGVkID0gYmlnICYmIGNhY2hlLmdldChkb2MpO1xuICAgIGlmIChjYWNoZWQpXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgbGV0IHJlc3VsdCA9IFtdLCBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoZG9jLmNoaWxkcmVuKSB7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiBkb2MuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaC5sZW5ndGggPj0gMTAwMCAvKiBDLk1pbkNhY2hlTGVuICovKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYyBvZiBjb2xsZWN0V29yZHMoY2gsIGNhY2hlLCB3b3JkUkUsIHRvIC0gcG9zLCBpZ25vcmVBdCAtIHBvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuW2MubGFiZWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW2MubGFiZWxdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmVXb3JkcyhjaCwgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0IC0gcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSBjaC5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdG9yZVdvcmRzKGRvYywgd29yZFJFLCByZXN1bHQsIHNlZW4sIGlnbm9yZUF0KTtcbiAgICB9XG4gICAgaWYgKGJpZyAmJiByZXN1bHQubGVuZ3RoIDwgMjAwMCAvKiBDLk1heExpc3QgKi8pXG4gICAgICAgIGNhY2hlLnNldChkb2MsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuQSBjb21wbGV0aW9uIHNvdXJjZSB0aGF0IHdpbGwgc2NhbiB0aGUgZG9jdW1lbnQgZm9yIHdvcmRzICh1c2luZyBhXG5bY2hhcmFjdGVyIGNhdGVnb3JpemVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikpLCBhbmRcbnJldHVybiB0aG9zZSBhcyBjb21wbGV0aW9ucy5cbiovXG5jb25zdCBjb21wbGV0ZUFueVdvcmQgPSBjb250ZXh0ID0+IHtcbiAgICBsZXQgd29yZENoYXJzID0gY29udGV4dC5zdGF0ZS5sYW5ndWFnZURhdGFBdChcIndvcmRDaGFyc1wiLCBjb250ZXh0LnBvcykuam9pbihcIlwiKTtcbiAgICBsZXQgcmUgPSB3b3JkUkUod29yZENoYXJzKTtcbiAgICBsZXQgdG9rZW4gPSBjb250ZXh0Lm1hdGNoQmVmb3JlKG1hcFJFKHJlLCBzID0+IHMgKyBcIiRcIikpO1xuICAgIGlmICghdG9rZW4gJiYgIWNvbnRleHQuZXhwbGljaXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmcm9tID0gdG9rZW4gPyB0b2tlbi5mcm9tIDogY29udGV4dC5wb3M7XG4gICAgbGV0IG9wdGlvbnMgPSBjb2xsZWN0V29yZHMoY29udGV4dC5zdGF0ZS5kb2MsIHdvcmRDYWNoZSh3b3JkQ2hhcnMpLCByZSwgNTAwMDAgLyogQy5SYW5nZSAqLywgZnJvbSk7XG4gICAgcmV0dXJuIHsgZnJvbSwgb3B0aW9ucywgdmFsaWRGb3I6IG1hcFJFKHJlLCBzID0+IFwiXlwiICsgcykgfTtcbn07XG5cbmNvbnN0IGRlZmF1bHRzID0ge1xuICAgIGJyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgXCInXCIsICdcIiddLFxuICAgIGJlZm9yZTogXCIpXX06Oz5cIixcbiAgICBzdHJpbmdQcmVmaXhlczogW11cbn07XG5jb25zdCBjbG9zZUJyYWNrZXRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAodmFsdWUsIG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IG1hcHBlZCA9IG1hcHBpbmcubWFwUG9zKHZhbHVlLCAtMSwgTWFwTW9kZS5UcmFja0FmdGVyKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZCA9PSBudWxsID8gdW5kZWZpbmVkIDogbWFwcGVkO1xuICAgIH1cbn0pO1xuY29uc3QgY2xvc2VkQnJhY2tldCA9IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbn07XG5jbG9zZWRCcmFja2V0LnN0YXJ0U2lkZSA9IDE7XG5jbG9zZWRCcmFja2V0LmVuZFNpZGUgPSAtMTtcbmNvbnN0IGJyYWNrZXRTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gUmFuZ2VTZXQuZW1wdHk7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHRyLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB0ci5zdGF0ZS5kb2MubGluZUF0KHRyLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGUoeyBmaWx0ZXI6IGZyb20gPT4gZnJvbSA+PSBsaW5lLmZyb20gJiYgZnJvbSA8PSBsaW5lLnRvIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhjbG9zZUJyYWNrZXRFZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudXBkYXRlKHsgYWRkOiBbY2xvc2VkQnJhY2tldC5yYW5nZShlZmZlY3QudmFsdWUsIGVmZmVjdC52YWx1ZSArIDEpXSB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn0pO1xuLyoqXG5FeHRlbnNpb24gdG8gZW5hYmxlIGJyYWNrZXQtY2xvc2luZyBiZWhhdmlvci4gV2hlbiBhIGNsb3NlYWJsZVxuYnJhY2tldCBpcyB0eXBlZCwgaXRzIGNsb3NpbmcgYnJhY2tldCBpcyBpbW1lZGlhdGVseSBpbnNlcnRlZFxuYWZ0ZXIgdGhlIGN1cnNvci4gV2hlbiBjbG9zaW5nIGEgYnJhY2tldCBkaXJlY3RseSBpbiBmcm9udCBvZiBhXG5jbG9zaW5nIGJyYWNrZXQgaW5zZXJ0ZWQgYnkgdGhlIGV4dGVuc2lvbiwgdGhlIGN1cnNvciBtb3ZlcyBvdmVyXG50aGF0IGJyYWNrZXQuXG4qL1xuZnVuY3Rpb24gY2xvc2VCcmFja2V0cygpIHtcbiAgICByZXR1cm4gW2lucHV0SGFuZGxlciwgYnJhY2tldFN0YXRlXTtcbn1cbmNvbnN0IGRlZmluZWRDbG9zaW5nID0gXCIoKVtde308PsKrwrvCu8Kr77y777y9772b772dXCI7XG5mdW5jdGlvbiBjbG9zaW5nKGNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWZpbmVkQ2xvc2luZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgaWYgKGRlZmluZWRDbG9zaW5nLmNoYXJDb2RlQXQoaSkgPT0gY2gpXG4gICAgICAgICAgICByZXR1cm4gZGVmaW5lZENsb3NpbmcuY2hhckF0KGkgKyAxKTtcbiAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjaCA8IDEyOCA/IGNoIDogY2ggKyAxKTtcbn1cbmZ1bmN0aW9uIGNvbmZpZyhzdGF0ZSwgcG9zKSB7XG4gICAgcmV0dXJuIHN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiY2xvc2VCcmFja2V0c1wiLCBwb3MpWzBdIHx8IGRlZmF1bHRzO1xufVxuY29uc3QgYW5kcm9pZCA9IHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJvYmplY3RcIiAmJiAvKkBfX1BVUkVfXyovL0FuZHJvaWRcXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBpbnB1dEhhbmRsZXIgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIub2YoKHZpZXcsIGZyb20sIHRvLCBpbnNlcnQpID0+IHtcbiAgICBpZiAoKGFuZHJvaWQgPyB2aWV3LmNvbXBvc2luZyA6IHZpZXcuY29tcG9zaXRpb25TdGFydGVkKSB8fCB2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgaWYgKGluc2VydC5sZW5ndGggPiAyIHx8IGluc2VydC5sZW5ndGggPT0gMiAmJiBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KGluc2VydCwgMCkpID09IDEgfHxcbiAgICAgICAgZnJvbSAhPSBzZWwuZnJvbSB8fCB0byAhPSBzZWwudG8pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdHIgPSBpbnNlcnRCcmFja2V0KHZpZXcuc3RhdGUsIGluc2VydCk7XG4gICAgaWYgKCF0cilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbkNvbW1hbmQgdGhhdCBpbXBsZW1lbnRzIGRlbGV0aW5nIGEgcGFpciBvZiBtYXRjaGluZyBicmFja2V0cyB3aGVuXG50aGUgY3Vyc29yIGlzIGJldHdlZW4gdGhlbS5cbiovXG5jb25zdCBkZWxldGVCcmFja2V0UGFpciA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNvbmYgPSBjb25maWcoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgIGxldCB0b2tlbnMgPSBjb25mLmJyYWNrZXRzIHx8IGRlZmF1bHRzLmJyYWNrZXRzO1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBwcmV2Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09IGJlZm9yZSAmJiBuZXh0Q2hhcihzdGF0ZS5kb2MsIHJhbmdlLmhlYWQpID09IGNsb3NpbmcoY29kZVBvaW50QXQodG9rZW4sIDApKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5oZWFkIC0gdG9rZW4ubGVuZ3RoLCB0bzogcmFuZ2UuaGVhZCArIHRva2VuLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCAtIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByYW5nZTogZG9udCA9IHJhbmdlIH07XG4gICAgfSk7XG4gICAgaWYgKCFkb250KVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImRlbGV0ZS5iYWNrd2FyZFwiIH0pKTtcbiAgICByZXR1cm4gIWRvbnQ7XG59O1xuLyoqXG5DbG9zZS1icmFja2V0cyByZWxhdGVkIGtleSBiaW5kaW5ncy4gQmluZHMgQmFja3NwYWNlIHRvXG5bYGRlbGV0ZUJyYWNrZXRQYWlyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuZGVsZXRlQnJhY2tldFBhaXIpLlxuKi9cbmNvbnN0IGNsb3NlQnJhY2tldHNLZXltYXAgPSBbXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIHJ1bjogZGVsZXRlQnJhY2tldFBhaXIgfVxuXTtcbi8qKlxuSW1wbGVtZW50cyB0aGUgZXh0ZW5zaW9uJ3MgYmVoYXZpb3Igb24gdGV4dCBpbnNlcnRpb24uIElmIHRoZVxuZ2l2ZW4gc3RyaW5nIGNvdW50cyBhcyBhIGJyYWNrZXQgaW4gdGhlIGxhbmd1YWdlIGFyb3VuZCB0aGVcbnNlbGVjdGlvbiwgYW5kIHJlcGxhY2luZyB0aGUgc2VsZWN0aW9uIHdpdGggaXQgcmVxdWlyZXMgY3VzdG9tXG5iZWhhdmlvciAoaW5zZXJ0aW5nIGEgY2xvc2luZyB2ZXJzaW9uIG9yIHNraXBwaW5nIHBhc3QgYVxucHJldmlvdXNseS1jbG9zZWQgYnJhY2tldCksIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHRyYW5zYWN0aW9uXG5yZXByZXNlbnRpbmcgdGhhdCBjdXN0b20gYmVoYXZpb3IuIChZb3Ugb25seSBuZWVkIHRoaXMgaWYgeW91IHdhbnRcbnRvIHByb2dyYW1tYXRpY2FsbHkgaW5zZXJ0IGJyYWNrZXRz4oCUdGhlXG5bYGNsb3NlQnJhY2tldHNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5jbG9zZUJyYWNrZXRzKSBleHRlbnNpb24gd2lsbFxudGFrZSBjYXJlIG9mIHJ1bm5pbmcgdGhpcyBmb3IgdXNlciBpbnB1dC4pXG4qL1xuZnVuY3Rpb24gaW5zZXJ0QnJhY2tldChzdGF0ZSwgYnJhY2tldCkge1xuICAgIGxldCBjb25mID0gY29uZmlnKHN0YXRlLCBzdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICBsZXQgdG9rZW5zID0gY29uZi5icmFja2V0cyB8fCBkZWZhdWx0cy5icmFja2V0cztcbiAgICBmb3IgKGxldCB0b2sgb2YgdG9rZW5zKSB7XG4gICAgICAgIGxldCBjbG9zZWQgPSBjbG9zaW5nKGNvZGVQb2ludEF0KHRvaywgMCkpO1xuICAgICAgICBpZiAoYnJhY2tldCA9PSB0b2spXG4gICAgICAgICAgICByZXR1cm4gY2xvc2VkID09IHRvayA/IGhhbmRsZVNhbWUoc3RhdGUsIHRvaywgdG9rZW5zLmluZGV4T2YodG9rICsgdG9rICsgdG9rKSA+IC0xLCBjb25mKVxuICAgICAgICAgICAgICAgIDogaGFuZGxlT3BlbihzdGF0ZSwgdG9rLCBjbG9zZWQsIGNvbmYuYmVmb3JlIHx8IGRlZmF1bHRzLmJlZm9yZSk7XG4gICAgICAgIGlmIChicmFja2V0ID09IGNsb3NlZCAmJiBjbG9zZWRCcmFja2V0QXQoc3RhdGUsIHN0YXRlLnNlbGVjdGlvbi5tYWluLmZyb20pKVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNsb3NlKHN0YXRlLCB0b2ssIGNsb3NlZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2xvc2VkQnJhY2tldEF0KHN0YXRlLCBwb3MpIHtcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICBzdGF0ZS5maWVsZChicmFja2V0U3RhdGUpLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgZnJvbSA9PiB7XG4gICAgICAgIGlmIChmcm9tID09IHBvcylcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBuZXh0Q2hhcihkb2MsIHBvcykge1xuICAgIGxldCBuZXh0ID0gZG9jLnNsaWNlU3RyaW5nKHBvcywgcG9zICsgMik7XG4gICAgcmV0dXJuIG5leHQuc2xpY2UoMCwgY29kZVBvaW50U2l6ZShjb2RlUG9pbnRBdChuZXh0LCAwKSkpO1xufVxuZnVuY3Rpb24gcHJldkNoYXIoZG9jLCBwb3MpIHtcbiAgICBsZXQgcHJldiA9IGRvYy5zbGljZVN0cmluZyhwb3MgLSAyLCBwb3MpO1xuICAgIHJldHVybiBjb2RlUG9pbnRTaXplKGNvZGVQb2ludEF0KHByZXYsIDApKSA9PSBwcmV2Lmxlbmd0aCA/IHByZXYgOiBwcmV2LnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gaGFuZGxlT3BlbihzdGF0ZSwgb3BlbiwgY2xvc2UsIGNsb3NlQmVmb3JlKSB7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBbeyBpbnNlcnQ6IG9wZW4sIGZyb206IHJhbmdlLmZyb20gfSwgeyBpbnNlcnQ6IGNsb3NlLCBmcm9tOiByYW5nZS50byB9XSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UudG8gKyBvcGVuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5hbmNob3IgKyBvcGVuLmxlbmd0aCwgcmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSB9O1xuICAgICAgICBsZXQgbmV4dCA9IG5leHRDaGFyKHN0YXRlLmRvYywgcmFuZ2UuaGVhZCk7XG4gICAgICAgIGlmICghbmV4dCB8fCAvXFxzLy50ZXN0KG5leHQpIHx8IGNsb3NlQmVmb3JlLmluZGV4T2YobmV4dCkgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiBvcGVuICsgY2xvc2UsIGZyb206IHJhbmdlLmhlYWQgfSxcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBjbG9zZUJyYWNrZXRFZmZlY3Qub2YocmFuZ2UuaGVhZCArIG9wZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgb3Blbi5sZW5ndGgpIH07XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBkb250ID0gcmFuZ2UgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIlxuICAgIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlQ2xvc2Uoc3RhdGUsIF9vcGVuLCBjbG9zZSkge1xuICAgIGxldCBkb250ID0gbnVsbCwgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkgJiYgbmV4dENoYXIoc3RhdGUuZG9jLCByYW5nZS5oZWFkKSA9PSBjbG9zZSlcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuaGVhZCwgdG86IHJhbmdlLmhlYWQgKyBjbG9zZS5sZW5ndGgsIGluc2VydDogY2xvc2UgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5oZWFkICsgY2xvc2UubGVuZ3RoKSB9O1xuICAgICAgICByZXR1cm4gZG9udCA9IHsgcmFuZ2UgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9udCA/IG51bGwgOiBzdGF0ZS51cGRhdGUoY2hhbmdlcywge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIlxuICAgIH0pO1xufVxuLy8gSGFuZGxlcyBjYXNlcyB3aGVyZSB0aGUgb3BlbiBhbmQgY2xvc2UgdG9rZW4gYXJlIHRoZSBzYW1lLCBhbmRcbi8vIHBvc3NpYmx5IHRyaXBsZSBxdW90ZXMgKGFzIGluIGBcIlwiXCJhYmNcIlwiXCJgLXN0eWxlIHF1b3RpbmcpLlxuZnVuY3Rpb24gaGFuZGxlU2FtZShzdGF0ZSwgdG9rZW4sIGFsbG93VHJpcGxlLCBjb25maWcpIHtcbiAgICBsZXQgc3RyaW5nUHJlZml4ZXMgPSBjb25maWcuc3RyaW5nUHJlZml4ZXMgfHwgZGVmYXVsdHMuc3RyaW5nUHJlZml4ZXM7XG4gICAgbGV0IGRvbnQgPSBudWxsLCBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBbeyBpbnNlcnQ6IHRva2VuLCBmcm9tOiByYW5nZS5mcm9tIH0sIHsgaW5zZXJ0OiB0b2tlbiwgZnJvbTogcmFuZ2UudG8gfV0sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHJhbmdlLnRvICsgdG9rZW4ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciArIHRva2VuLmxlbmd0aCwgcmFuZ2UuaGVhZCArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgbGV0IHBvcyA9IHJhbmdlLmhlYWQsIG5leHQgPSBuZXh0Q2hhcihzdGF0ZS5kb2MsIHBvcyksIHN0YXJ0O1xuICAgICAgICBpZiAobmV4dCA9PSB0b2tlbikge1xuICAgICAgICAgICAgaWYgKG5vZGVTdGFydChzdGF0ZSwgcG9zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgaW5zZXJ0OiB0b2tlbiArIHRva2VuLCBmcm9tOiBwb3MgfSxcbiAgICAgICAgICAgICAgICAgICAgZWZmZWN0czogY2xvc2VCcmFja2V0RWZmZWN0Lm9mKHBvcyArIHRva2VuLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsb3NlZEJyYWNrZXRBdChzdGF0ZSwgcG9zKSkge1xuICAgICAgICAgICAgICAgIGxldCBpc1RyaXBsZSA9IGFsbG93VHJpcGxlICYmIHN0YXRlLnNsaWNlRG9jKHBvcywgcG9zICsgdG9rZW4ubGVuZ3RoICogMykgPT0gdG9rZW4gKyB0b2tlbiArIHRva2VuO1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50ID0gaXNUcmlwbGUgPyB0b2tlbiArIHRva2VuICsgdG9rZW4gOiB0b2tlbjtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHBvcywgdG86IHBvcyArIGNvbnRlbnQubGVuZ3RoLCBpbnNlcnQ6IGNvbnRlbnQgfSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zICsgY29udGVudC5sZW5ndGgpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWxsb3dUcmlwbGUgJiYgc3RhdGUuc2xpY2VEb2MocG9zIC0gMiAqIHRva2VuLmxlbmd0aCwgcG9zKSA9PSB0b2tlbiArIHRva2VuICYmXG4gICAgICAgICAgICAoc3RhcnQgPSBjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MgLSAyICogdG9rZW4ubGVuZ3RoLCBzdHJpbmdQcmVmaXhlcykpID4gLTEgJiZcbiAgICAgICAgICAgIG5vZGVTdGFydChzdGF0ZSwgc3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiArIHRva2VuICsgdG9rZW4sIGZyb206IHBvcyB9LFxuICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcyArIHRva2VuLmxlbmd0aCkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKShuZXh0KSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgaWYgKGNhblN0YXJ0U3RyaW5nQXQoc3RhdGUsIHBvcywgc3RyaW5nUHJlZml4ZXMpID4gLTEgJiYgIXByb2JhYmx5SW5TdHJpbmcoc3RhdGUsIHBvcywgdG9rZW4sIHN0cmluZ1ByZWZpeGVzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGluc2VydDogdG9rZW4gKyB0b2tlbiwgZnJvbTogcG9zIH0sXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6IGNsb3NlQnJhY2tldEVmZmVjdC5vZihwb3MgKyB0b2tlbi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MgKyB0b2tlbi5sZW5ndGgpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGRvbnQgPSByYW5nZSB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkb250ID8gbnVsbCA6IHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gICAgfSk7XG59XG5mdW5jdGlvbiBub2RlU3RhcnQoc3RhdGUsIHBvcykge1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcyArIDEpO1xuICAgIHJldHVybiB0cmVlLnBhcmVudCAmJiB0cmVlLmZyb20gPT0gcG9zO1xufVxuZnVuY3Rpb24gcHJvYmFibHlJblN0cmluZyhzdGF0ZSwgcG9zLCBxdW90ZVRva2VuLCBwcmVmaXhlcykge1xuICAgIGxldCBub2RlID0gc3ludGF4VHJlZShzdGF0ZSkucmVzb2x2ZUlubmVyKHBvcywgLTEpO1xuICAgIGxldCBtYXhQcmVmaXggPSBwcmVmaXhlcy5yZWR1Y2UoKG0sIHApID0+IE1hdGgubWF4KG0sIHAubGVuZ3RoKSwgMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhdGUuc2xpY2VEb2Mobm9kZS5mcm9tLCBNYXRoLm1pbihub2RlLnRvLCBub2RlLmZyb20gKyBxdW90ZVRva2VuLmxlbmd0aCArIG1heFByZWZpeCkpO1xuICAgICAgICBsZXQgcXVvdGVQb3MgPSBzdGFydC5pbmRleE9mKHF1b3RlVG9rZW4pO1xuICAgICAgICBpZiAoIXF1b3RlUG9zIHx8IHF1b3RlUG9zID4gLTEgJiYgcHJlZml4ZXMuaW5kZXhPZihzdGFydC5zbGljZSgwLCBxdW90ZVBvcykpID4gLTEpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdCAmJiBmaXJzdC5mcm9tID09IG5vZGUuZnJvbSAmJiBmaXJzdC50byAtIGZpcnN0LmZyb20gPiBxdW90ZVRva2VuLmxlbmd0aCArIHF1b3RlUG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNsaWNlRG9jKGZpcnN0LnRvIC0gcXVvdGVUb2tlbi5sZW5ndGgsIGZpcnN0LnRvKSA9PSBxdW90ZVRva2VuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmaXJzdC5maXJzdENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUudG8gPT0gcG9zICYmIG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjYW5TdGFydFN0cmluZ0F0KHN0YXRlLCBwb3MsIHByZWZpeGVzKSB7XG4gICAgbGV0IGNoYXJDYXQgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBpZiAoY2hhckNhdChzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBmb3IgKGxldCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gcG9zIC0gcHJlZml4Lmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YXRlLnNsaWNlRG9jKHN0YXJ0LCBwb3MpID09IHByZWZpeCAmJiBjaGFyQ2F0KHN0YXRlLnNsaWNlRG9jKHN0YXJ0IC0gMSwgc3RhcnQpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZClcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhdXRvY29tcGxldGlvbi5cbiovXG5mdW5jdGlvbiBhdXRvY29tcGxldGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGNvbW1pdENoYXJhY3RlcnMsXG4gICAgICAgIGNvbXBsZXRpb25TdGF0ZSxcbiAgICAgICAgY29tcGxldGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBjb21wbGV0aW9uUGx1Z2luLFxuICAgICAgICBjb21wbGV0aW9uS2V5bWFwRXh0LFxuICAgICAgICBiYXNlVGhlbWVcbiAgICBdO1xufVxuLyoqXG5CYXNpYyBrZXliaW5kaW5ncyBmb3IgYXV0b2NvbXBsZXRpb24uXG5cbiAtIEN0cmwtU3BhY2UgKGFuZCBBbHQtXFxgIG9uIG1hY09TKTogW2BzdGFydENvbXBsZXRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5zdGFydENvbXBsZXRpb24pXG4gLSBFc2NhcGU6IFtgY2xvc2VDb21wbGV0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuY2xvc2VDb21wbGV0aW9uKVxuIC0gQXJyb3dEb3duOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYCh0cnVlKWBcbiAtIEFycm93VXA6IFtgbW92ZUNvbXBsZXRpb25TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5tb3ZlQ29tcGxldGlvblNlbGVjdGlvbilgKGZhbHNlKWBcbiAtIFBhZ2VEb3duOiBbYG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUubW92ZUNvbXBsZXRpb25TZWxlY3Rpb24pYCh0cnVlLCBcInBhZ2VcIilgXG4gLSBQYWdlRG93bjogW2Btb3ZlQ29tcGxldGlvblNlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLm1vdmVDb21wbGV0aW9uU2VsZWN0aW9uKWAodHJ1ZSwgXCJwYWdlXCIpYFxuIC0gRW50ZXI6IFtgYWNjZXB0Q29tcGxldGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jYXV0b2NvbXBsZXRlLmFjY2VwdENvbXBsZXRpb24pXG4qL1xuY29uc3QgY29tcGxldGlvbktleW1hcCA9IFtcbiAgICB7IGtleTogXCJDdHJsLVNwYWNlXCIsIHJ1bjogc3RhcnRDb21wbGV0aW9uIH0sXG4gICAgeyBtYWM6IFwiQWx0LWBcIiwgcnVuOiBzdGFydENvbXBsZXRpb24gfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbG9zZUNvbXBsZXRpb24gfSxcbiAgICB7IGtleTogXCJBcnJvd0Rvd25cIiwgcnVuOiAvKkBfX1BVUkVfXyovbW92ZUNvbXBsZXRpb25TZWxlY3Rpb24odHJ1ZSkgfSxcbiAgICB7IGtleTogXCJBcnJvd1VwXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKGZhbHNlKSB9LFxuICAgIHsga2V5OiBcIlBhZ2VEb3duXCIsIHJ1bjogLypAX19QVVJFX18qL21vdmVDb21wbGV0aW9uU2VsZWN0aW9uKHRydWUsIFwicGFnZVwiKSB9LFxuICAgIHsga2V5OiBcIlBhZ2VVcFwiLCBydW46IC8qQF9fUFVSRV9fKi9tb3ZlQ29tcGxldGlvblNlbGVjdGlvbihmYWxzZSwgXCJwYWdlXCIpIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwgcnVuOiBhY2NlcHRDb21wbGV0aW9uIH1cbl07XG5jb25zdCBjb21wbGV0aW9uS2V5bWFwRXh0ID0gLypAX19QVVJFX18qL1ByZWMuaGlnaGVzdCgvKkBfX1BVUkVfXyova2V5bWFwLmNvbXB1dGVOKFtjb21wbGV0aW9uQ29uZmlnXSwgc3RhdGUgPT4gc3RhdGUuZmFjZXQoY29tcGxldGlvbkNvbmZpZykuZGVmYXVsdEtleW1hcCA/IFtjb21wbGV0aW9uS2V5bWFwXSA6IFtdKSk7XG4vKipcbkdldCB0aGUgY3VycmVudCBjb21wbGV0aW9uIHN0YXR1cy4gV2hlbiBjb21wbGV0aW9ucyBhcmUgYXZhaWxhYmxlLFxudGhpcyB3aWxsIHJldHVybiBgXCJhY3RpdmVcImAuIFdoZW4gY29tcGxldGlvbnMgYXJlIHBlbmRpbmcgKGluIHRoZVxucHJvY2VzcyBvZiBiZWluZyBxdWVyaWVkKSwgdGhpcyByZXR1cm5zIGBcInBlbmRpbmdcImAuIE90aGVyd2lzZSwgaXRcbnJldHVybnMgYG51bGxgLlxuKi9cbmZ1bmN0aW9uIGNvbXBsZXRpb25TdGF0dXMoc3RhdGUpIHtcbiAgICBsZXQgY1N0YXRlID0gc3RhdGUuZmllbGQoY29tcGxldGlvblN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGNTdGF0ZSAmJiBjU3RhdGUuYWN0aXZlLnNvbWUoYSA9PiBhLmlzUGVuZGluZykgPyBcInBlbmRpbmdcIlxuICAgICAgICA6IGNTdGF0ZSAmJiBjU3RhdGUuYWN0aXZlLnNvbWUoYSA9PiBhLnN0YXRlICE9IDAgLyogU3RhdGUuSW5hY3RpdmUgKi8pID8gXCJhY3RpdmVcIiA6IG51bGw7XG59XG5jb25zdCBjb21wbGV0aW9uQXJyYXlDYWNoZSA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcDtcbi8qKlxuUmV0dXJucyB0aGUgYXZhaWxhYmxlIGNvbXBsZXRpb25zIGFzIGFuIGFycmF5LlxuKi9cbmZ1bmN0aW9uIGN1cnJlbnRDb21wbGV0aW9ucyhzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgb3BlbiA9IChfYSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3BlbjtcbiAgICBpZiAoIW9wZW4gfHwgb3Blbi5kaXNhYmxlZClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBjb21wbGV0aW9ucyA9IGNvbXBsZXRpb25BcnJheUNhY2hlLmdldChvcGVuLm9wdGlvbnMpO1xuICAgIGlmICghY29tcGxldGlvbnMpXG4gICAgICAgIGNvbXBsZXRpb25BcnJheUNhY2hlLnNldChvcGVuLm9wdGlvbnMsIGNvbXBsZXRpb25zID0gb3Blbi5vcHRpb25zLm1hcChvID0+IG8uY29tcGxldGlvbikpO1xuICAgIHJldHVybiBjb21wbGV0aW9ucztcbn1cbi8qKlxuUmV0dXJuIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY29tcGxldGlvbiwgaWYgYW55LlxuKi9cbmZ1bmN0aW9uIHNlbGVjdGVkQ29tcGxldGlvbihzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgb3BlbiA9IChfYSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3BlbjtcbiAgICByZXR1cm4gb3BlbiAmJiAhb3Blbi5kaXNhYmxlZCAmJiBvcGVuLnNlbGVjdGVkID49IDAgPyBvcGVuLm9wdGlvbnNbb3Blbi5zZWxlY3RlZF0uY29tcGxldGlvbiA6IG51bGw7XG59XG4vKipcblJldHVybnMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBwb3NpdGlvbiBpbiB0aGUgYWN0aXZlIGNvbXBsZXRpb25cbmxpc3QsIG9yIG51bGwgaWYgbm8gY29tcGxldGlvbnMgYXJlIGFjdGl2ZS5cbiovXG5mdW5jdGlvbiBzZWxlY3RlZENvbXBsZXRpb25JbmRleChzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgb3BlbiA9IChfYSA9IHN0YXRlLmZpZWxkKGNvbXBsZXRpb25TdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3BlbjtcbiAgICByZXR1cm4gb3BlbiAmJiAhb3Blbi5kaXNhYmxlZCAmJiBvcGVuLnNlbGVjdGVkID49IDAgPyBvcGVuLnNlbGVjdGVkIDogbnVsbDtcbn1cbi8qKlxuQ3JlYXRlIGFuIGVmZmVjdCB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIHRyYW5zYWN0aW9uIHRvIGNoYW5nZVxudGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb21wbGV0aW9uLlxuKi9cbmZ1bmN0aW9uIHNldFNlbGVjdGVkQ29tcGxldGlvbihpbmRleCkge1xuICAgIHJldHVybiBzZXRTZWxlY3RlZEVmZmVjdC5vZihpbmRleCk7XG59XG5cbmV4cG9ydCB7IENvbXBsZXRpb25Db250ZXh0LCBhY2NlcHRDb21wbGV0aW9uLCBhdXRvY29tcGxldGlvbiwgY2xlYXJTbmlwcGV0LCBjbG9zZUJyYWNrZXRzLCBjbG9zZUJyYWNrZXRzS2V5bWFwLCBjbG9zZUNvbXBsZXRpb24sIGNvbXBsZXRlQW55V29yZCwgY29tcGxldGVGcm9tTGlzdCwgY29tcGxldGlvbktleW1hcCwgY29tcGxldGlvblN0YXR1cywgY3VycmVudENvbXBsZXRpb25zLCBkZWxldGVCcmFja2V0UGFpciwgaGFzTmV4dFNuaXBwZXRGaWVsZCwgaGFzUHJldlNuaXBwZXRGaWVsZCwgaWZJbiwgaWZOb3RJbiwgaW5zZXJ0QnJhY2tldCwgaW5zZXJ0Q29tcGxldGlvblRleHQsIG1vdmVDb21wbGV0aW9uU2VsZWN0aW9uLCBuZXh0U25pcHBldEZpZWxkLCBwaWNrZWRDb21wbGV0aW9uLCBwcmV2U25pcHBldEZpZWxkLCBzZWxlY3RlZENvbXBsZXRpb24sIHNlbGVjdGVkQ29tcGxldGlvbkluZGV4LCBzZXRTZWxlY3RlZENvbXBsZXRpb24sIHNuaXBwZXQsIHNuaXBwZXRDb21wbGV0aW9uLCBzbmlwcGV0S2V5bWFwLCBzdGFydENvbXBsZXRpb24gfTtcbiJdLCJuYW1lcyI6WyJBbm5vdGF0aW9uIiwiU3RhdGVFZmZlY3QiLCJFZGl0b3JTZWxlY3Rpb24iLCJjb2RlUG9pbnRBdCIsImNvZGVQb2ludFNpemUiLCJmcm9tQ29kZVBvaW50IiwiRmFjZXQiLCJjb21iaW5lQ29uZmlnIiwiU3RhdGVGaWVsZCIsIlByZWMiLCJUZXh0IiwiVHJhbnNhY3Rpb24iLCJNYXBNb2RlIiwiUmFuZ2VWYWx1ZSIsIlJhbmdlU2V0IiwiQ2hhckNhdGVnb3J5IiwiRGlyZWN0aW9uIiwibG9nRXhjZXB0aW9uIiwic2hvd1Rvb2x0aXAiLCJFZGl0b3JWaWV3IiwiVmlld1BsdWdpbiIsImdldFRvb2x0aXAiLCJEZWNvcmF0aW9uIiwiV2lkZ2V0VHlwZSIsImtleW1hcCIsInN5bnRheFRyZWUiLCJpbmRlbnRVbml0IiwiQ29tcGxldGlvbkNvbnRleHQiLCJjb25zdHJ1Y3RvciIsInN0YXRlIiwicG9zIiwiZXhwbGljaXQiLCJ2aWV3IiwiYWJvcnRMaXN0ZW5lcnMiLCJhYm9ydE9uRG9jQ2hhbmdlIiwidG9rZW5CZWZvcmUiLCJ0eXBlcyIsInRva2VuIiwicmVzb2x2ZUlubmVyIiwiaW5kZXhPZiIsIm5hbWUiLCJwYXJlbnQiLCJmcm9tIiwidG8iLCJ0ZXh0Iiwic2xpY2VEb2MiLCJ0eXBlIiwibWF0Y2hCZWZvcmUiLCJleHByIiwibGluZSIsImRvYyIsImxpbmVBdCIsInN0YXJ0IiwiTWF0aCIsIm1heCIsInN0ciIsInNsaWNlIiwiZm91bmQiLCJzZWFyY2giLCJlbnN1cmVBbmNob3IiLCJhYm9ydGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyIiwib3B0aW9ucyIsInB1c2giLCJvbkRvY0NoYW5nZSIsInRvU2V0IiwiY2hhcnMiLCJmbGF0IiwiT2JqZWN0Iiwia2V5cyIsImpvaW4iLCJ3b3JkcyIsInRlc3QiLCJyZXBsYWNlIiwicHJlZml4TWF0Y2giLCJmaXJzdCIsImNyZWF0ZSIsInJlc3QiLCJsYWJlbCIsImkiLCJsZW5ndGgiLCJzb3VyY2UiLCJSZWdFeHAiLCJjb21wbGV0ZUZyb21MaXN0IiwibGlzdCIsIm1hcCIsIm8iLCJ2YWxpZEZvciIsIm1hdGNoIiwiZXZlcnkiLCJjb250ZXh0IiwiaWZJbiIsIm5vZGVzIiwiaXNUb3AiLCJpZk5vdEluIiwiT3B0aW9uIiwiY29tcGxldGlvbiIsInNjb3JlIiwiY3VyIiwic2VsZWN0aW9uIiwibWFpbiIsIl9hIiwiYWRkU3RhcnQiLCJhZGRFbmQiLCJmbGFncyIsImlnbm9yZUNhc2UiLCJwaWNrZWRDb21wbGV0aW9uIiwiZGVmaW5lIiwiaW5zZXJ0Q29tcGxldGlvblRleHQiLCJmcm9tT2ZmIiwidG9PZmYiLCJhc3NpZ24iLCJjaGFuZ2VCeVJhbmdlIiwicmFuZ2UiLCJsaW5lcyIsInRvVGV4dCIsImNoYW5nZXMiLCJpbnNlcnQiLCJjdXJzb3IiLCJzY3JvbGxJbnRvVmlldyIsInVzZXJFdmVudCIsIlNvdXJjZUNhY2hlIiwiV2Vha01hcCIsImFzU291cmNlIiwiQXJyYXkiLCJpc0FycmF5Iiwia25vd24iLCJnZXQiLCJzZXQiLCJzdGFydENvbXBsZXRpb25FZmZlY3QiLCJjbG9zZUNvbXBsZXRpb25FZmZlY3QiLCJGdXp6eU1hdGNoZXIiLCJwYXR0ZXJuIiwiZm9sZGVkIiwiYW55IiwicHJlY2lzZSIsImJ5V29yZCIsIm1hdGNoZWQiLCJwIiwiY2hhciIsInNpemUiLCJwYXJ0IiwidXBwZXIiLCJ0b1VwcGVyQ2FzZSIsInRvTG93ZXJDYXNlIiwiYXN0cmFsIiwicmV0Iiwid29yZCIsImZpcnN0U2l6ZSIsImRpcmVjdCIsImxlbiIsImFueVRvIiwiZSIsIm1pbiIsIm5leHQiLCJwcmVjaXNlVG8iLCJieVdvcmRUbyIsImJ5V29yZEZvbGRlZCIsImFkamFjZW50VG8iLCJhZGphY2VudFN0YXJ0IiwiYWRqYWNlbnRFbmQiLCJoYXNMb3dlciIsIndvcmRBZGphY2VudCIsInByZXZUeXBlIiwiY2giLCJyZXN1bHQiLCJwb3NpdGlvbnMiLCJTdHJpY3RNYXRjaGVyIiwiY29tcGxldGlvbkNvbmZpZyIsImNvbWJpbmUiLCJjb25maWdzIiwiYWN0aXZhdGVPblR5cGluZyIsImFjdGl2YXRlT25Db21wbGV0aW9uIiwiYWN0aXZhdGVPblR5cGluZ0RlbGF5Iiwic2VsZWN0T25PcGVuIiwib3ZlcnJpZGUiLCJjbG9zZU9uQmx1ciIsIm1heFJlbmRlcmVkT3B0aW9ucyIsImRlZmF1bHRLZXltYXAiLCJ0b29sdGlwQ2xhc3MiLCJvcHRpb25DbGFzcyIsImFib3ZlQ3Vyc29yIiwiaWNvbnMiLCJhZGRUb09wdGlvbnMiLCJwb3NpdGlvbkluZm8iLCJkZWZhdWx0UG9zaXRpb25JbmZvIiwiZmlsdGVyU3RyaWN0IiwiY29tcGFyZUNvbXBsZXRpb25zIiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwiaW50ZXJhY3Rpb25EZWxheSIsInVwZGF0ZVN5bmNUaW1lIiwiYyIsImpvaW5DbGFzcyIsImNvbmNhdCIsIm9wdGlvbiIsImluZm8iLCJzcGFjZSIsInRvb2x0aXAiLCJydGwiLCJ0ZXh0RGlyZWN0aW9uIiwiUlRMIiwibGVmdCIsIm5hcnJvdyIsInNpZGUiLCJvZmZzZXQiLCJtYXhXaWR0aCIsInNwYWNlTGVmdCIsInNwYWNlUmlnaHQiLCJyaWdodCIsImluZm9XaWR0aCIsImluZm9IZWlnaHQiLCJib3R0b20iLCJ0b3AiLCJzcGFjZUJlbG93Iiwic2NhbGVZIiwib2Zmc2V0SGVpZ2h0Iiwic2NhbGVYIiwib2Zmc2V0V2lkdGgiLCJzdHlsZSIsImNsYXNzIiwib3B0aW9uQ29udGVudCIsImNvbmZpZyIsImNvbnRlbnQiLCJyZW5kZXIiLCJpY29uIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwic3BsaXQiLCJjbHMiLCJzZXRBdHRyaWJ1dGUiLCJwb3NpdGlvbiIsIl9zIiwiX3YiLCJsYWJlbEVsdCIsImNsYXNzTmFtZSIsImRpc3BsYXlMYWJlbCIsIm9mZiIsImoiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwic3BhbiIsImRldGFpbCIsImRldGFpbEVsdCIsInRleHRDb250ZW50Iiwic29ydCIsInJhbmdlQXJvdW5kU2VsZWN0ZWQiLCJ0b3RhbCIsInNlbGVjdGVkIiwiZmxvb3IiLCJDb21wbGV0aW9uVG9vbHRpcCIsInN0YXRlRmllbGQiLCJhcHBseUNvbXBsZXRpb24iLCJpbmZvRGVzdHJveSIsInBsYWNlSW5mb1JlcSIsInJlYWQiLCJtZWFzdXJlSW5mbyIsIndyaXRlIiwicGxhY2VJbmZvIiwia2V5IiwiY3VycmVudENsYXNzIiwiY1N0YXRlIiwiZmllbGQiLCJvcGVuIiwiZmFjZXQiLCJkb20iLCJ1cGRhdGVUb29sdGlwQ2xhc3MiLCJ0YXJnZXQiLCJwYXJlbnROb2RlIiwibm9kZU5hbWUiLCJleGVjIiwiaWQiLCJwcmV2ZW50RGVmYXVsdCIsInJlbGF0ZWRUYXJnZXQiLCJjb250ZW50RE9NIiwiZGlzcGF0Y2giLCJlZmZlY3RzIiwib2YiLCJzaG93T3B0aW9ucyIsIm1vdW50IiwidXBkYXRlU2VsIiwicmVtb3ZlIiwiY3JlYXRlTGlzdEJveCIsInJlcXVlc3RNZWFzdXJlIiwidXBkYXRlIiwicHJldlN0YXRlIiwic3RhcnRTdGF0ZSIsImRpc2FibGVkIiwidG9nZ2xlIiwicG9zaXRpb25lZCIsInVwZGF0ZVNlbGVjdGVkT3B0aW9uIiwiZGVzdHJveUluZm8iLCJpbmZvUmVzdWx0IiwidGhlbiIsIm9iaiIsImFkZEluZm9QYW5lIiwiY2F0Y2giLCJ3cmFwIiwibm9kZVR5cGUiLCJkZXN0cm95Iiwib3B0IiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwic2VsIiwicXVlcnlTZWxlY3RvciIsImxpc3RSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaW5mb1JlY3QiLCJzZWxSZWN0IiwiZG9jRWx0Iiwib3duZXJEb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiY3NzVGV4dCIsInVsIiwicGhyYXNlIiwiY3VyU2VjdGlvbiIsInNlY3Rpb24iLCJoZWFkZXIiLCJsaSIsIm5vZGUiLCJjb21wbGV0aW9uVG9vbHRpcCIsImNvbnRhaW5lciIsImVsZW1lbnQiLCJzZWxmIiwiaGVpZ2h0Iiwic2Nyb2xsVG9wIiwiYm9vc3QiLCJhcHBseSIsInNvcnRPcHRpb25zIiwiYWN0aXZlIiwic2VjdGlvbnMiLCJhZGRPcHRpb24iLCJzb21lIiwicyIsImNvbmYiLCJoYXNSZXN1bHQiLCJnZXRNYXRjaCIsImZpbHRlciIsIm1hdGNoZXIiLCJzZWN0aW9uT3JkZXIiLCJjbXAiLCJfYiIsInJhbmsiLCJwcmV2IiwiY29tcGFyZSIsIkNvbXBsZXRpb25EaWFsb2ciLCJhdHRycyIsInRpbWVzdGFtcCIsInNldFNlbGVjdGVkIiwibWFrZUF0dHJzIiwiYnVpbGQiLCJkaWRTZXRBY3RpdmUiLCJpc1BlbmRpbmciLCJzZXREaXNhYmxlZCIsInNlbGVjdGVkVmFsdWUiLCJyZWR1Y2UiLCJjcmVhdGVUb29sdGlwIiwiYWJvdmUiLCJEYXRlIiwibm93IiwibWFwUG9zIiwiQ29tcGxldGlvblN0YXRlIiwibm9uZSIsInJhbmRvbSIsInRvU3RyaW5nIiwidHIiLCJzb3VyY2VzIiwibGFuZ3VhZ2VEYXRhQXQiLCJ2YWx1ZSIsImZpbmQiLCJBY3RpdmVTb3VyY2UiLCJkaWRTZXQiLCJpcyIsInNldEFjdGl2ZUVmZmVjdCIsImRvY0NoYW5nZWQiLCJ0b3VjaGVzUmFuZ2UiLCJzYW1lUmVzdWx0cyIsImVmZmVjdCIsInNldFNlbGVjdGVkRWZmZWN0IiwiYmFzZUF0dHJzIiwibm9BdHRycyIsImlBIiwiaUIiLCJlbmRBIiwiZW5kQiIsImdldFVwZGF0ZVR5cGUiLCJpc1VzZXJFdmVudCIsImFubm90YXRpb24iLCJ0eXBpbmciLCJ0b3VjaGVzIiwidXBkYXRlRm9yIiwiQWN0aXZlUmVzdWx0IiwibGltaXQiLCJlbXB0eSIsImNoZWNrVmFsaWQiLCJtYXBwaW5nIiwiY29tcGxldGlvblN0YXRlIiwicHJvdmlkZSIsImYiLCJ2YWwiLCJjb250ZW50QXR0cmlidXRlcyIsImFubm90YXRpb25zIiwibW92ZUNvbXBsZXRpb25TZWxlY3Rpb24iLCJmb3J3YXJkIiwiYnkiLCJzdGVwIiwiYWNjZXB0Q29tcGxldGlvbiIsInJlYWRPbmx5Iiwic3RhcnRDb21wbGV0aW9uIiwiY2xvc2VDb21wbGV0aW9uIiwiUnVubmluZ1F1ZXJ5IiwidGltZSIsInVwZGF0ZXMiLCJkb25lIiwidW5kZWZpbmVkIiwiTWF4VXBkYXRlQ291bnQiLCJNaW5BYm9ydFRpbWUiLCJjb21wbGV0aW9uUGx1Z2luIiwiZnJvbUNsYXNzIiwiZGVib3VuY2VVcGRhdGUiLCJydW5uaW5nIiwiZGVib3VuY2VBY2NlcHQiLCJwZW5kaW5nU3RhcnQiLCJjb21wb3NpbmciLCJzdGFydFF1ZXJ5Iiwic2VsZWN0aW9uU2V0IiwiZG9lc1Jlc2V0IiwidHJhbnNhY3Rpb25zIiwicXVlcnkiLCJoYW5kbGVyIiwic3BsaWNlIiwiY2xlYXJUaW1lb3V0IiwiZGVsYXkiLCJxIiwic2V0VGltZW91dCIsInN0YXJ0VXBkYXRlIiwiciIsImFjY2VwdCIsInBlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInNjaGVkdWxlQWNjZXB0IiwiZXJyIiwidXBkYXRlZCIsImN1cnJlbnQiLCJldmVudEhhbmRsZXJzIiwiYmx1ciIsImV2ZW50IiwiZGlhbG9nIiwiY29udGFpbnMiLCJjb21wb3NpdGlvbnN0YXJ0IiwiY29tcG9zaXRpb25lbmQiLCJ3aW5kb3dzIiwibmF2aWdhdG9yIiwicGxhdGZvcm0iLCJjb21taXRDaGFyYWN0ZXJzIiwiaGlnaGVzdCIsImRvbUV2ZW50SGFuZGxlcnMiLCJrZXlkb3duIiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJjb21taXRDaGFycyIsImJhc2VUaGVtZSIsImZvbnRGYW1pbHkiLCJ3aGl0ZVNwYWNlIiwib3ZlcmZsb3ciLCJtYXhXaWR0aF9mYWxsYmFjayIsIm1pbldpZHRoIiwibWF4SGVpZ2h0IiwibGlzdFN0eWxlIiwibWFyZ2luIiwicGFkZGluZyIsImxpbmVIZWlnaHQiLCJvdmVyZmxvd1giLCJ0ZXh0T3ZlcmZsb3ciLCJkaXNwbGF5IiwiYm9yZGVyQm90dG9tIiwicGFkZGluZ0xlZnQiLCJvcGFjaXR5IiwiYmFja2dyb3VuZCIsImNvbG9yIiwidGV4dEFsaWduIiwid2lkdGgiLCJib3hTaXppbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJ2ZXJ0aWNhbEFsaWduIiwiYm9yZGVyTGVmdCIsInRleHREZWNvcmF0aW9uIiwibWFyZ2luTGVmdCIsImZvbnRTdHlsZSIsImZvbnRTaXplIiwicGFkZGluZ1JpZ2h0IiwiRmllbGRQb3MiLCJGaWVsZFJhbmdlIiwiVHJhY2tEZWwiLCJTbmlwcGV0IiwiZmllbGRQb3NpdGlvbnMiLCJpbnN0YW50aWF0ZSIsImxpbmVTdGFydCIsImxpbmVPYmoiLCJiYXNlSW5kZW50IiwiaW5kZW50IiwidGFicyIsInJhbmdlcyIsInBhcnNlIiwidGVtcGxhdGUiLCJmaWVsZHMiLCJtIiwic2VxIiwicmF3TmFtZSIsImluZGV4IiwiXyIsImJyYWNlIiwiZmllbGRNYXJrZXIiLCJ3aWRnZXQiLCJ0b0RPTSIsImlnbm9yZUV2ZW50IiwiZmllbGRSYW5nZSIsIm1hcmsiLCJBY3RpdmVTbmlwcGV0IiwiZGVjbyIsIm1hcHBlZCIsInNlbGVjdGlvbkluc2lkZUZpZWxkIiwic2V0QWN0aXZlIiwibW92ZVRvRmllbGQiLCJzbmlwcGV0U3RhdGUiLCJkZWNvcmF0aW9ucyIsImZpZWxkU2VsZWN0aW9uIiwic25pcHBldCIsImVkaXRvciIsInNwZWMiLCJhcHBlbmRDb25maWciLCJhZGRTbmlwcGV0S2V5bWFwIiwic25pcHBldFBvaW50ZXJIYW5kbGVyIiwibW92ZUZpZWxkIiwiZGlyIiwibGFzdCIsImNsZWFyU25pcHBldCIsIm5leHRTbmlwcGV0RmllbGQiLCJwcmV2U25pcHBldEZpZWxkIiwiaGFzTmV4dFNuaXBwZXRGaWVsZCIsImhhc1ByZXZTbmlwcGV0RmllbGQiLCJkZWZhdWx0U25pcHBldEtleW1hcCIsInJ1biIsInNoaWZ0Iiwic25pcHBldEtleW1hcCIsIm1hcHMiLCJjb21wdXRlIiwic25pcHBldENvbXBsZXRpb24iLCJtb3VzZWRvd24iLCJwb3NBdENvb3JkcyIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJ3b3JkUkUiLCJ3b3JkQ2hhcnMiLCJlc2NhcGVkIiwibWFwUkUiLCJyZSIsInVuaWNvZGUiLCJ3b3JkQ2FjaGVzIiwid29yZENhY2hlIiwic3RvcmVXb3JkcyIsInNlZW4iLCJpZ25vcmVBdCIsIml0ZXJMaW5lcyIsImxhc3RJbmRleCIsImNvbGxlY3RXb3JkcyIsImNhY2hlIiwiYmlnIiwiY2FjaGVkIiwiY2hpbGRyZW4iLCJjb21wbGV0ZUFueVdvcmQiLCJkZWZhdWx0cyIsImJyYWNrZXRzIiwiYmVmb3JlIiwic3RyaW5nUHJlZml4ZXMiLCJjbG9zZUJyYWNrZXRFZmZlY3QiLCJUcmFja0FmdGVyIiwiY2xvc2VkQnJhY2tldCIsInN0YXJ0U2lkZSIsImVuZFNpZGUiLCJicmFja2V0U3RhdGUiLCJoZWFkIiwiY2xvc2VCcmFja2V0cyIsImlucHV0SGFuZGxlciIsImRlZmluZWRDbG9zaW5nIiwiY2xvc2luZyIsImNoYXJDb2RlQXQiLCJjaGFyQXQiLCJhbmRyb2lkIiwidXNlckFnZW50IiwiY29tcG9zaXRpb25TdGFydGVkIiwiaW5zZXJ0QnJhY2tldCIsImRlbGV0ZUJyYWNrZXRQYWlyIiwidG9rZW5zIiwiZG9udCIsInByZXZDaGFyIiwibmV4dENoYXIiLCJjbG9zZUJyYWNrZXRzS2V5bWFwIiwiYnJhY2tldCIsInRvayIsImNsb3NlZCIsImhhbmRsZVNhbWUiLCJoYW5kbGVPcGVuIiwiY2xvc2VkQnJhY2tldEF0IiwiaGFuZGxlQ2xvc2UiLCJiZXR3ZWVuIiwic2xpY2VTdHJpbmciLCJjbG9zZSIsImNsb3NlQmVmb3JlIiwiYW5jaG9yIiwiX29wZW4iLCJhbGxvd1RyaXBsZSIsIm5vZGVTdGFydCIsImlzVHJpcGxlIiwiY2FuU3RhcnRTdHJpbmdBdCIsImNoYXJDYXRlZ29yaXplciIsIldvcmQiLCJwcm9iYWJseUluU3RyaW5nIiwidHJlZSIsInF1b3RlVG9rZW4iLCJwcmVmaXhlcyIsIm1heFByZWZpeCIsInF1b3RlUG9zIiwiY2hhckNhdCIsInByZWZpeCIsImF1dG9jb21wbGV0aW9uIiwiY29tcGxldGlvbktleW1hcEV4dCIsImNvbXBsZXRpb25LZXltYXAiLCJtYWMiLCJjb21wdXRlTiIsImNvbXBsZXRpb25TdGF0dXMiLCJjb21wbGV0aW9uQXJyYXlDYWNoZSIsImN1cnJlbnRDb21wbGV0aW9ucyIsImNvbXBsZXRpb25zIiwic2VsZWN0ZWRDb21wbGV0aW9uIiwic2VsZWN0ZWRDb21wbGV0aW9uSW5kZXgiLCJzZXRTZWxlY3RlZENvbXBsZXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/autocomplete/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blockComment: () => (/* binding */ blockComment),\n/* harmony export */   blockUncomment: () => (/* binding */ blockUncomment),\n/* harmony export */   copyLineDown: () => (/* binding */ copyLineDown),\n/* harmony export */   copyLineUp: () => (/* binding */ copyLineUp),\n/* harmony export */   cursorCharBackward: () => (/* binding */ cursorCharBackward),\n/* harmony export */   cursorCharBackwardLogical: () => (/* binding */ cursorCharBackwardLogical),\n/* harmony export */   cursorCharForward: () => (/* binding */ cursorCharForward),\n/* harmony export */   cursorCharForwardLogical: () => (/* binding */ cursorCharForwardLogical),\n/* harmony export */   cursorCharLeft: () => (/* binding */ cursorCharLeft),\n/* harmony export */   cursorCharRight: () => (/* binding */ cursorCharRight),\n/* harmony export */   cursorDocEnd: () => (/* binding */ cursorDocEnd),\n/* harmony export */   cursorDocStart: () => (/* binding */ cursorDocStart),\n/* harmony export */   cursorGroupBackward: () => (/* binding */ cursorGroupBackward),\n/* harmony export */   cursorGroupForward: () => (/* binding */ cursorGroupForward),\n/* harmony export */   cursorGroupForwardWin: () => (/* binding */ cursorGroupForwardWin),\n/* harmony export */   cursorGroupLeft: () => (/* binding */ cursorGroupLeft),\n/* harmony export */   cursorGroupRight: () => (/* binding */ cursorGroupRight),\n/* harmony export */   cursorLineBoundaryBackward: () => (/* binding */ cursorLineBoundaryBackward),\n/* harmony export */   cursorLineBoundaryForward: () => (/* binding */ cursorLineBoundaryForward),\n/* harmony export */   cursorLineBoundaryLeft: () => (/* binding */ cursorLineBoundaryLeft),\n/* harmony export */   cursorLineBoundaryRight: () => (/* binding */ cursorLineBoundaryRight),\n/* harmony export */   cursorLineDown: () => (/* binding */ cursorLineDown),\n/* harmony export */   cursorLineEnd: () => (/* binding */ cursorLineEnd),\n/* harmony export */   cursorLineStart: () => (/* binding */ cursorLineStart),\n/* harmony export */   cursorLineUp: () => (/* binding */ cursorLineUp),\n/* harmony export */   cursorMatchingBracket: () => (/* binding */ cursorMatchingBracket),\n/* harmony export */   cursorPageDown: () => (/* binding */ cursorPageDown),\n/* harmony export */   cursorPageUp: () => (/* binding */ cursorPageUp),\n/* harmony export */   cursorSubwordBackward: () => (/* binding */ cursorSubwordBackward),\n/* harmony export */   cursorSubwordForward: () => (/* binding */ cursorSubwordForward),\n/* harmony export */   cursorSyntaxLeft: () => (/* binding */ cursorSyntaxLeft),\n/* harmony export */   cursorSyntaxRight: () => (/* binding */ cursorSyntaxRight),\n/* harmony export */   defaultKeymap: () => (/* binding */ defaultKeymap),\n/* harmony export */   deleteCharBackward: () => (/* binding */ deleteCharBackward),\n/* harmony export */   deleteCharBackwardStrict: () => (/* binding */ deleteCharBackwardStrict),\n/* harmony export */   deleteCharForward: () => (/* binding */ deleteCharForward),\n/* harmony export */   deleteGroupBackward: () => (/* binding */ deleteGroupBackward),\n/* harmony export */   deleteGroupForward: () => (/* binding */ deleteGroupForward),\n/* harmony export */   deleteLine: () => (/* binding */ deleteLine),\n/* harmony export */   deleteLineBoundaryBackward: () => (/* binding */ deleteLineBoundaryBackward),\n/* harmony export */   deleteLineBoundaryForward: () => (/* binding */ deleteLineBoundaryForward),\n/* harmony export */   deleteToLineEnd: () => (/* binding */ deleteToLineEnd),\n/* harmony export */   deleteToLineStart: () => (/* binding */ deleteToLineStart),\n/* harmony export */   deleteTrailingWhitespace: () => (/* binding */ deleteTrailingWhitespace),\n/* harmony export */   emacsStyleKeymap: () => (/* binding */ emacsStyleKeymap),\n/* harmony export */   history: () => (/* binding */ history),\n/* harmony export */   historyField: () => (/* binding */ historyField),\n/* harmony export */   historyKeymap: () => (/* binding */ historyKeymap),\n/* harmony export */   indentLess: () => (/* binding */ indentLess),\n/* harmony export */   indentMore: () => (/* binding */ indentMore),\n/* harmony export */   indentSelection: () => (/* binding */ indentSelection),\n/* harmony export */   indentWithTab: () => (/* binding */ indentWithTab),\n/* harmony export */   insertBlankLine: () => (/* binding */ insertBlankLine),\n/* harmony export */   insertNewline: () => (/* binding */ insertNewline),\n/* harmony export */   insertNewlineAndIndent: () => (/* binding */ insertNewlineAndIndent),\n/* harmony export */   insertNewlineKeepIndent: () => (/* binding */ insertNewlineKeepIndent),\n/* harmony export */   insertTab: () => (/* binding */ insertTab),\n/* harmony export */   invertedEffects: () => (/* binding */ invertedEffects),\n/* harmony export */   isolateHistory: () => (/* binding */ isolateHistory),\n/* harmony export */   lineComment: () => (/* binding */ lineComment),\n/* harmony export */   lineUncomment: () => (/* binding */ lineUncomment),\n/* harmony export */   moveLineDown: () => (/* binding */ moveLineDown),\n/* harmony export */   moveLineUp: () => (/* binding */ moveLineUp),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   redoDepth: () => (/* binding */ redoDepth),\n/* harmony export */   redoSelection: () => (/* binding */ redoSelection),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   selectCharBackward: () => (/* binding */ selectCharBackward),\n/* harmony export */   selectCharBackwardLogical: () => (/* binding */ selectCharBackwardLogical),\n/* harmony export */   selectCharForward: () => (/* binding */ selectCharForward),\n/* harmony export */   selectCharForwardLogical: () => (/* binding */ selectCharForwardLogical),\n/* harmony export */   selectCharLeft: () => (/* binding */ selectCharLeft),\n/* harmony export */   selectCharRight: () => (/* binding */ selectCharRight),\n/* harmony export */   selectDocEnd: () => (/* binding */ selectDocEnd),\n/* harmony export */   selectDocStart: () => (/* binding */ selectDocStart),\n/* harmony export */   selectGroupBackward: () => (/* binding */ selectGroupBackward),\n/* harmony export */   selectGroupForward: () => (/* binding */ selectGroupForward),\n/* harmony export */   selectGroupForwardWin: () => (/* binding */ selectGroupForwardWin),\n/* harmony export */   selectGroupLeft: () => (/* binding */ selectGroupLeft),\n/* harmony export */   selectGroupRight: () => (/* binding */ selectGroupRight),\n/* harmony export */   selectLine: () => (/* binding */ selectLine),\n/* harmony export */   selectLineBoundaryBackward: () => (/* binding */ selectLineBoundaryBackward),\n/* harmony export */   selectLineBoundaryForward: () => (/* binding */ selectLineBoundaryForward),\n/* harmony export */   selectLineBoundaryLeft: () => (/* binding */ selectLineBoundaryLeft),\n/* harmony export */   selectLineBoundaryRight: () => (/* binding */ selectLineBoundaryRight),\n/* harmony export */   selectLineDown: () => (/* binding */ selectLineDown),\n/* harmony export */   selectLineEnd: () => (/* binding */ selectLineEnd),\n/* harmony export */   selectLineStart: () => (/* binding */ selectLineStart),\n/* harmony export */   selectLineUp: () => (/* binding */ selectLineUp),\n/* harmony export */   selectMatchingBracket: () => (/* binding */ selectMatchingBracket),\n/* harmony export */   selectPageDown: () => (/* binding */ selectPageDown),\n/* harmony export */   selectPageUp: () => (/* binding */ selectPageUp),\n/* harmony export */   selectParentSyntax: () => (/* binding */ selectParentSyntax),\n/* harmony export */   selectSubwordBackward: () => (/* binding */ selectSubwordBackward),\n/* harmony export */   selectSubwordForward: () => (/* binding */ selectSubwordForward),\n/* harmony export */   selectSyntaxLeft: () => (/* binding */ selectSyntaxLeft),\n/* harmony export */   selectSyntaxRight: () => (/* binding */ selectSyntaxRight),\n/* harmony export */   simplifySelection: () => (/* binding */ simplifySelection),\n/* harmony export */   splitLine: () => (/* binding */ splitLine),\n/* harmony export */   standardKeymap: () => (/* binding */ standardKeymap),\n/* harmony export */   temporarilySetTabFocusMode: () => (/* binding */ temporarilySetTabFocusMode),\n/* harmony export */   toggleBlockComment: () => (/* binding */ toggleBlockComment),\n/* harmony export */   toggleBlockCommentByLine: () => (/* binding */ toggleBlockCommentByLine),\n/* harmony export */   toggleComment: () => (/* binding */ toggleComment),\n/* harmony export */   toggleLineComment: () => (/* binding */ toggleLineComment),\n/* harmony export */   toggleTabFocusMode: () => (/* binding */ toggleTabFocusMode),\n/* harmony export */   transposeChars: () => (/* binding */ transposeChars),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   undoDepth: () => (/* binding */ undoDepth),\n/* harmony export */   undoSelection: () => (/* binding */ undoSelection)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n\n\n\n\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/ const toggleComment = (target)=>{\n    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;\n};\nfunction command(f, option) {\n    return ({ state, dispatch })=>{\n        if (state.readOnly) return false;\n        let tr = f(option, state);\n        if (!tr) return false;\n        dispatch(state.update(tr));\n        return true;\n    };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/ const toggleLineComment = /*@__PURE__*/ command(changeLineComment, 0 /* CommentOption.Toggle */ );\n/**\nComment the current selection using line comments.\n*/ const lineComment = /*@__PURE__*/ command(changeLineComment, 1 /* CommentOption.Comment */ );\n/**\nUncomment the current selection using line comments.\n*/ const lineUncomment = /*@__PURE__*/ command(changeLineComment, 2 /* CommentOption.Uncomment */ );\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/ const toggleBlockComment = /*@__PURE__*/ command(changeBlockComment, 0 /* CommentOption.Toggle */ );\n/**\nComment the current selection using block comments.\n*/ const blockComment = /*@__PURE__*/ command(changeBlockComment, 1 /* CommentOption.Comment */ );\n/**\nUncomment the current selection using block comments.\n*/ const blockUncomment = /*@__PURE__*/ command(changeBlockComment, 2 /* CommentOption.Uncomment */ );\n/**\nComment or uncomment the lines around the current selection using\nblock comments.\n*/ const toggleBlockCommentByLine = /*@__PURE__*/ command((o, s)=>changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */ );\nfunction getConfig(state, pos) {\n    let data = state.languageDataAt(\"commentTokens\", pos);\n    return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/ function findBlockComment(state, { open, close }, from, to) {\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n    let beforeOff = textBefore.length - spaceBefore;\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n        return {\n            open: {\n                pos: from - spaceBefore,\n                margin: spaceBefore && 1\n            },\n            close: {\n                pos: to + spaceAfter,\n                margin: spaceAfter && 1\n            }\n        };\n    }\n    let startText, endText;\n    if (to - from <= 2 * SearchMargin) {\n        startText = endText = state.sliceDoc(from, to);\n    } else {\n        startText = state.sliceDoc(from, from + SearchMargin);\n        endText = state.sliceDoc(to - SearchMargin, to);\n    }\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n    let endOff = endText.length - endSpace - close.length;\n    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {\n        return {\n            open: {\n                pos: from + startSpace + open.length,\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0\n            },\n            close: {\n                pos: to - endSpace - close.length,\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0\n            }\n        };\n    }\n    return null;\n}\nfunction selectedLineRanges(state) {\n    let ranges = [];\n    for (let r of state.selection.ranges){\n        let fromLine = state.doc.lineAt(r.from);\n        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);\n        if (toLine.from > fromLine.from && toLine.from == r.to) toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);\n        let last = ranges.length - 1;\n        if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;\n        else ranges.push({\n            from: fromLine.from + /^\\s*/.exec(fromLine.text)[0].length,\n            to: toLine.to\n        });\n    }\n    return ranges;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, state, ranges = state.selection.ranges) {\n    let tokens = ranges.map((r)=>getConfig(state, r.from).block);\n    if (!tokens.every((c)=>c)) return null;\n    let comments = ranges.map((r, i)=>findBlockComment(state, tokens[i], r.from, r.to));\n    if (option != 2 /* CommentOption.Uncomment */  && !comments.every((c)=>c)) {\n        return {\n            changes: state.changes(ranges.map((range, i)=>{\n                if (comments[i]) return [];\n                return [\n                    {\n                        from: range.from,\n                        insert: tokens[i].open + \" \"\n                    },\n                    {\n                        from: range.to,\n                        insert: \" \" + tokens[i].close\n                    }\n                ];\n            }))\n        };\n    } else if (option != 1 /* CommentOption.Comment */  && comments.some((c)=>c)) {\n        let changes = [];\n        for(let i = 0, comment; i < comments.length; i++)if (comment = comments[i]) {\n            let token = tokens[i], { open, close } = comment;\n            changes.push({\n                from: open.pos - token.open.length,\n                to: open.pos + open.margin\n            }, {\n                from: close.pos - close.margin,\n                to: close.pos + token.close.length\n            });\n        }\n        return {\n            changes\n        };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, state, ranges = state.selection.ranges) {\n    let lines = [];\n    let prevLine = -1;\n    for (let { from, to } of ranges){\n        let startI = lines.length, minIndent = 1e9;\n        let token = getConfig(state, from).line;\n        if (!token) continue;\n        for(let pos = from; pos <= to;){\n            let line = state.doc.lineAt(pos);\n            if (line.from > prevLine && (from == to || to > line.from)) {\n                prevLine = line.from;\n                let indent = /^\\s*/.exec(line.text)[0].length;\n                let empty = indent == line.length;\n                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n                if (indent < line.text.length && indent < minIndent) minIndent = indent;\n                lines.push({\n                    line,\n                    comment,\n                    token,\n                    indent,\n                    empty,\n                    single: false\n                });\n            }\n            pos = line.to + 1;\n        }\n        if (minIndent < 1e9) {\n            for(let i = startI; i < lines.length; i++)if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;\n        }\n        if (lines.length == startI + 1) lines[startI].single = true;\n    }\n    if (option != 2 /* CommentOption.Uncomment */  && lines.some((l)=>l.comment < 0 && (!l.empty || l.single))) {\n        let changes = [];\n        for (let { line, token, indent, empty, single } of lines)if (single || !empty) changes.push({\n            from: line.from + indent,\n            insert: token + \" \"\n        });\n        let changeSet = state.changes(changes);\n        return {\n            changes: changeSet,\n            selection: state.selection.map(changeSet, 1)\n        };\n    } else if (option != 1 /* CommentOption.Comment */  && lines.some((l)=>l.comment >= 0)) {\n        let changes = [];\n        for (let { line, comment, token } of lines)if (comment >= 0) {\n            let from = line.from + comment, to = from + token.length;\n            if (line.text[to - line.from] == \" \") to++;\n            changes.push({\n                from,\n                to\n            });\n        }\n        return {\n            changes\n        };\n    }\n    return null;\n}\nconst fromHistory = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/ const isolateHistory = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/ const invertedEffects = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define();\nconst historyConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            minDepth: 100,\n            newGroupDelay: 500,\n            joinToEvent: (_t, isAdjacent)=>isAdjacent\n        }, {\n            minDepth: Math.max,\n            newGroupDelay: Math.min,\n            joinToEvent: (a, b)=>(tr, adj)=>a(tr, adj) || b(tr, adj)\n        });\n    }\n});\nconst historyField_ = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return HistoryState.empty;\n    },\n    update (state, tr) {\n        let config = tr.state.facet(historyConfig);\n        let fromHist = tr.annotation(fromHistory);\n        if (fromHist) {\n            let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;\n            let other = from == 0 /* BranchName.Done */  ? state.undone : state.done;\n            if (item) other = updateBranch(other, other.length, config.minDepth, item);\n            else other = addSelection(other, tr.startState.selection);\n            return new HistoryState(from == 0 /* BranchName.Done */  ? fromHist.rest : other, from == 0 /* BranchName.Done */  ? other : fromHist.rest);\n        }\n        let isolate = tr.annotation(isolateHistory);\n        if (isolate == \"full\" || isolate == \"before\") state = state.isolate();\n        if (tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n        let event = HistEvent.fromTransaction(tr);\n        let time = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.time), userEvent = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Transaction.userEvent);\n        if (event) state = state.addChanges(event, time, userEvent, config, tr);\n        else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n        if (isolate == \"full\" || isolate == \"after\") state = state.isolate();\n        return state;\n    },\n    toJSON (value) {\n        return {\n            done: value.done.map((e)=>e.toJSON()),\n            undone: value.undone.map((e)=>e.toJSON())\n        };\n    },\n    fromJSON (json) {\n        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n    }\n});\n/**\nCreate a history extension with the given configuration.\n*/ function history(config = {}) {\n    return [\n        historyField_,\n        historyConfig.of(config),\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.domEventHandlers({\n            beforeinput (e, view) {\n                let command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n                if (!command) return false;\n                e.preventDefault();\n                return command(view);\n            }\n        })\n    ];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/ const historyField = historyField_;\nfunction cmd(side, selection) {\n    return function({ state, dispatch }) {\n        if (!selection && state.readOnly) return false;\n        let historyState = state.field(historyField_, false);\n        if (!historyState) return false;\n        let tr = historyState.pop(side, state, selection);\n        if (!tr) return false;\n        dispatch(tr);\n        return true;\n    };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/ const undo = /*@__PURE__*/ cmd(0 /* BranchName.Done */ , false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/ const redo = /*@__PURE__*/ cmd(1 /* BranchName.Undone */ , false);\n/**\nUndo a change or selection change.\n*/ const undoSelection = /*@__PURE__*/ cmd(0 /* BranchName.Done */ , true);\n/**\nRedo a change or selection change.\n*/ const redoSelection = /*@__PURE__*/ cmd(1 /* BranchName.Undone */ , true);\nfunction depth(side) {\n    return function(state) {\n        let histState = state.field(historyField_, false);\n        if (!histState) return 0;\n        let branch = side == 0 /* BranchName.Done */  ? histState.done : histState.undone;\n        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n    };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/ const undoDepth = /*@__PURE__*/ depth(0 /* BranchName.Done */ );\n/**\nThe amount of redoable change events available in a given state.\n*/ const redoDepth = /*@__PURE__*/ depth(1 /* BranchName.Undone */ );\n// History events store groups of changes or effects that need to be\n// undone/redone together.\nclass HistEvent {\n    constructor(// The changes in this event. Normal events hold at least one\n    // change or effect. But it may be necessary to store selection\n    // events before the first change, in which case a special type of\n    // instance is created which doesn't hold any changes, with\n    // changes == startSelection == undefined\n    changes, // The effects associated with this event\n    effects, // Accumulated mapping (from addToHistory==false) that should be\n    // applied to events below this one.\n    mapped, // The selection before this event\n    startSelection, // Stores selection changes after this event, to be used for\n    // selection undo/redo.\n    selectionsAfter){\n        this.changes = changes;\n        this.effects = effects;\n        this.mapped = mapped;\n        this.startSelection = startSelection;\n        this.selectionsAfter = selectionsAfter;\n    }\n    setSelAfter(after) {\n        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n    toJSON() {\n        var _a, _b, _c;\n        return {\n            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n            selectionsAfter: this.selectionsAfter.map((s)=>s.toJSON())\n        };\n    }\n    static fromJSON(json) {\n        return new HistEvent(json.changes && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeSet.fromJSON(json.changes), [], json.mapped && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.ChangeDesc.fromJSON(json.mapped), json.startSelection && _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.fromJSON));\n    }\n    // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n    static fromTransaction(tr, selection) {\n        let effects = none;\n        for (let invert of tr.startState.facet(invertedEffects)){\n            let result = invert(tr);\n            if (result.length) effects = effects.concat(result);\n        }\n        if (!effects.length && tr.changes.empty) return null;\n        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n    }\n    static selection(selections) {\n        return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n}\nfunction updateBranch(branch, to, maxLen, newEvent) {\n    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n    let newBranch = branch.slice(start, to);\n    newBranch.push(newEvent);\n    return newBranch;\n}\nfunction isAdjacent(a, b) {\n    let ranges = [], isAdjacent = false;\n    a.iterChangedRanges((f, t)=>ranges.push(f, t));\n    b.iterChangedRanges((_f, _t, f, t)=>{\n        for(let i = 0; i < ranges.length;){\n            let from = ranges[i++], to = ranges[i++];\n            if (t >= from && f <= to) isAdjacent = true;\n        }\n    });\n    return isAdjacent;\n}\nfunction eqSelectionShape(a, b) {\n    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i)=>r.empty != b.ranges[i].empty).length === 0;\n}\nfunction conc(a, b) {\n    return !a.length ? b : !b.length ? a : a.concat(b);\n}\nconst none = [];\nconst MaxSelectionsPerEvent = 200;\nfunction addSelection(branch, selection) {\n    if (!branch.length) {\n        return [\n            HistEvent.selection([\n                selection\n            ])\n        ];\n    } else {\n        let lastEvent = branch[branch.length - 1];\n        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n        if (sels.length && sels[sels.length - 1].eq(selection)) return branch;\n        sels.push(selection);\n        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n    }\n}\n// Assumes the top item has one or more selectionAfter values\nfunction popSelection(branch) {\n    let last = branch[branch.length - 1];\n    let newBranch = branch.slice();\n    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n    return newBranch;\n}\n// Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\nfunction addMappingToBranch(branch, mapping) {\n    if (!branch.length) return branch;\n    let length = branch.length, selections = none;\n    while(length){\n        let event = mapEvent(branch[length - 1], mapping, selections);\n        if (event.changes && !event.changes.empty || event.effects.length) {\n            let result = branch.slice(0, length);\n            result[length - 1] = event;\n            return result;\n        } else {\n            mapping = event.mapped;\n            length--;\n            selections = event.selectionsAfter;\n        }\n    }\n    return selections.length ? [\n        HistEvent.selection(selections)\n    ] : none;\n}\nfunction mapEvent(event, mapping, extraSelections) {\n    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s)=>s.map(mapping)) : none, extraSelections);\n    // Change-less events don't store mappings (they are always the last event in a branch)\n    if (!event.changes) return HistEvent.selection(selections);\n    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);\n    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n    return new HistEvent(mappedChanges, _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\nconst joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\nclass HistoryState {\n    constructor(done, undone, prevTime = 0, prevUserEvent = undefined){\n        this.done = done;\n        this.undone = undone;\n        this.prevTime = prevTime;\n        this.prevUserEvent = prevUserEvent;\n    }\n    isolate() {\n        return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n    addChanges(event, time, userEvent, config, tr) {\n        let done = this.done, lastEvent = done[done.length - 1];\n        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event\n        userEvent == \"input.type.compose\")) {\n            done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n        } else {\n            done = updateBranch(done, done.length, config.minDepth, event);\n        }\n        return new HistoryState(done, none, time, userEvent);\n    }\n    addSelection(selection, time, userEvent, newGroupDelay) {\n        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n        if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;\n        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n    addMapping(mapping) {\n        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n    pop(side, state, onlySelection) {\n        let branch = side == 0 /* BranchName.Done */  ? this.done : this.undone;\n        if (branch.length == 0) return null;\n        let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;\n        if (onlySelection && event.selectionsAfter.length) {\n            return state.update({\n                selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n                annotations: fromHistory.of({\n                    side,\n                    rest: popSelection(branch),\n                    selection\n                }),\n                userEvent: side == 0 /* BranchName.Done */  ? \"select.undo\" : \"select.redo\",\n                scrollIntoView: true\n            });\n        } else if (!event.changes) {\n            return null;\n        } else {\n            let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n            if (event.mapped) rest = addMappingToBranch(rest, event.mapped);\n            return state.update({\n                changes: event.changes,\n                selection: event.startSelection,\n                effects: event.effects,\n                annotations: fromHistory.of({\n                    side,\n                    rest,\n                    selection\n                }),\n                filter: false,\n                userEvent: side == 0 /* BranchName.Done */  ? \"undo\" : \"redo\",\n                scrollIntoView: true\n            });\n        }\n    }\n}\nHistoryState.empty = /*@__PURE__*/ new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).\n- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).\n*/ const historyKeymap = [\n    {\n        key: \"Mod-z\",\n        run: undo,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-y\",\n        mac: \"Mod-Shift-z\",\n        run: redo,\n        preventDefault: true\n    },\n    {\n        linux: \"Ctrl-Shift-z\",\n        run: redo,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-u\",\n        run: undoSelection,\n        preventDefault: true\n    },\n    {\n        key: \"Alt-u\",\n        mac: \"Mod-Shift-u\",\n        run: redoSelection,\n        preventDefault: true\n    }\n];\nfunction updateSel(sel, by) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(sel.ranges.map(by), sel.mainIndex);\n}\nfunction setSel(state, selection) {\n    return state.update({\n        selection,\n        scrollIntoView: true,\n        userEvent: \"select\"\n    });\n}\nfunction moveSel({ state, dispatch }, how) {\n    let selection = updateSel(state.selection, how);\n    if (selection.eq(state.selection, true)) return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\nfunction rangeEnd(range, forward) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(forward ? range.to : range.from);\n}\nfunction cursorByChar(view, forward) {\n    return moveSel(view, (range)=>range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));\n}\nfunction ltrAtCursor(view) {\n    return view.textDirectionAt(view.state.selection.main.head) == _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Direction.LTR;\n}\n/**\nMove the selection one character to the left (which is backward in\nleft-to-right text, forward in right-to-left text).\n*/ const cursorCharLeft = (view)=>cursorByChar(view, !ltrAtCursor(view));\n/**\nMove the selection one character to the right.\n*/ const cursorCharRight = (view)=>cursorByChar(view, ltrAtCursor(view));\n/**\nMove the selection one character forward.\n*/ const cursorCharForward = (view)=>cursorByChar(view, true);\n/**\nMove the selection one character backward.\n*/ const cursorCharBackward = (view)=>cursorByChar(view, false);\nfunction byCharLogical(state, range, forward) {\n    let pos = range.head, line = state.doc.lineAt(pos);\n    if (pos == (forward ? line.to : line.from)) pos = forward ? Math.min(state.doc.length, line.to + 1) : Math.max(0, line.from - 1);\n    else pos = line.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(pos, forward ? -1 : 1);\n}\nfunction moveByCharLogical(target, forward) {\n    return moveSel(target, (range)=>range.empty ? byCharLogical(target.state, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one character forward, in logical\n(non-text-direction-aware) string index order.\n*/ const cursorCharForwardLogical = (target)=>moveByCharLogical(target, true);\n/**\nMove the selection one character backward, in logical string index\norder.\n*/ const cursorCharBackwardLogical = (target)=>moveByCharLogical(target, false);\nfunction cursorByGroup(view, forward) {\n    return moveSel(view, (range)=>range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection to the left across one group of word or\nnon-word (but also non-space) characters.\n*/ const cursorGroupLeft = (view)=>cursorByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection one group to the right.\n*/ const cursorGroupRight = (view)=>cursorByGroup(view, ltrAtCursor(view));\n/**\nMove the selection one group forward.\n*/ const cursorGroupForward = (view)=>cursorByGroup(view, true);\n/**\nMove the selection one group backward.\n*/ const cursorGroupBackward = (view)=>cursorByGroup(view, false);\nfunction toGroupStart(view, pos, start) {\n    let categorize = view.state.charCategorizer(pos);\n    let cat = categorize(start), initial = cat != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space;\n    return (next)=>{\n        let nextCat = categorize(next);\n        if (nextCat != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space) return initial && nextCat == cat;\n        initial = false;\n        return true;\n    };\n}\n/**\nMove the cursor one group forward in the default Windows style,\nwhere it moves to the start of the next group.\n*/ const cursorGroupForwardWin = (view)=>{\n    return moveSel(view, (range)=>range.empty ? view.moveByChar(range, true, (start)=>toGroupStart(view, range.head, start)) : rangeEnd(range, true));\n};\nconst segmenter = typeof Intl != \"undefined\" && Intl.Segmenter ? /*@__PURE__*/ new Intl.Segmenter(undefined, {\n    granularity: \"word\"\n}) : null;\nfunction moveBySubword(view, range, forward) {\n    let categorize = view.state.charCategorizer(range.from);\n    let cat = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space, pos = range.from, steps = 0;\n    let done = false, sawUpper = false, sawLower = false;\n    let step = (next)=>{\n        if (done) return false;\n        pos += forward ? next.length : -next.length;\n        let nextCat = categorize(next), ahead;\n        if (nextCat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && next.charCodeAt(0) < 128 && /[\\W_]/.test(next)) nextCat = -1; // Treat word punctuation specially\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Space) cat = nextCat;\n        if (cat != nextCat) return false;\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) {\n            if (next.toLowerCase() == next) {\n                if (!forward && sawUpper) return false;\n                sawLower = true;\n            } else if (sawLower) {\n                if (forward) return false;\n                done = true;\n            } else {\n                if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && ahead.toLowerCase() == ahead) return false;\n                sawUpper = true;\n            }\n        }\n        steps++;\n        return true;\n    };\n    let end = view.moveByChar(range, forward, (start)=>{\n        step(start);\n        return step;\n    });\n    if (segmenter && cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {\n        let from = Math.min(range.head, end.head), to = Math.max(range.head, end.head);\n        let skipped = view.state.sliceDoc(from, to);\n        if (skipped.length > 1 && /[\\u4E00-\\uffff]/.test(skipped)) {\n            let segments = Array.from(segmenter.segment(skipped));\n            if (segments.length > 1) {\n                if (forward) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head + segments[1].index, -1);\n                return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);\n            }\n        }\n    }\n    return end;\n}\nfunction cursorBySubword(view, forward) {\n    return moveSel(view, (range)=>range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));\n}\n/**\nMove the selection one group or camel-case subword forward.\n*/ const cursorSubwordForward = (view)=>cursorBySubword(view, true);\n/**\nMove the selection one group or camel-case subword backward.\n*/ const cursorSubwordBackward = (view)=>cursorBySubword(view, false);\nfunction interestingNode(state, node, bracketProp) {\n    if (node.type.prop(bracketProp)) return true;\n    let len = node.to - node.from;\n    return len && (len > 2 || /[^\\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;\n}\nfunction moveBySyntax(state, start, forward) {\n    let pos = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(start.head);\n    let bracketProp = forward ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy;\n    // Scan forward through child nodes to see if there's an interesting\n    // node ahead.\n    for(let at = start.head;;){\n        let next = forward ? pos.childAfter(at) : pos.childBefore(at);\n        if (!next) break;\n        if (interestingNode(state, next, bracketProp)) pos = next;\n        else at = forward ? next.to : next.from;\n    }\n    let bracket = pos.type.prop(bracketProp), match, newPos;\n    if (bracket && (match = forward ? (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.from, 1) : (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;\n    else newPos = forward ? pos.to : pos.from;\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(newPos, forward ? -1 : 1);\n}\n/**\nMove the cursor over the next syntactic element to the left.\n*/ const cursorSyntaxLeft = (view)=>moveSel(view, (range)=>moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the cursor over the next syntactic element to the right.\n*/ const cursorSyntaxRight = (view)=>moveSel(view, (range)=>moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction cursorByLine(view, forward) {\n    return moveSel(view, (range)=>{\n        if (!range.empty) return rangeEnd(range, forward);\n        let moved = view.moveVertically(range, forward);\n        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);\n    });\n}\n/**\nMove the selection one line up.\n*/ const cursorLineUp = (view)=>cursorByLine(view, false);\n/**\nMove the selection one line down.\n*/ const cursorLineDown = (view)=>cursorByLine(view, true);\nfunction pageInfo(view) {\n    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;\n    let marginTop = 0, marginBottom = 0, height;\n    if (selfScroll) {\n        for (let source of view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollMargins)){\n            let margins = source(view);\n            if (margins === null || margins === void 0 ? void 0 : margins.top) marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);\n            if (margins === null || margins === void 0 ? void 0 : margins.bottom) marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);\n        }\n        height = view.scrollDOM.clientHeight - marginTop - marginBottom;\n    } else {\n        height = (view.dom.ownerDocument.defaultView || window).innerHeight;\n    }\n    return {\n        marginTop,\n        marginBottom,\n        selfScroll,\n        height: Math.max(view.defaultLineHeight, height - 5)\n    };\n}\nfunction cursorByPage(view, forward) {\n    let page = pageInfo(view);\n    let { state } = view, selection = updateSel(state.selection, (range)=>{\n        return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);\n    });\n    if (selection.eq(state.selection)) return false;\n    let effect;\n    if (page.selfScroll) {\n        let startPos = view.coordsAtPos(state.selection.main.head);\n        let scrollRect = view.scrollDOM.getBoundingClientRect();\n        let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;\n        if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom) effect = _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.main.head, {\n            y: \"start\",\n            yMargin: startPos.top - scrollTop\n        });\n    }\n    view.dispatch(setSel(state, selection), {\n        effects: effect\n    });\n    return true;\n}\n/**\nMove the selection one page up.\n*/ const cursorPageUp = (view)=>cursorByPage(view, false);\n/**\nMove the selection one page down.\n*/ const cursorPageDown = (view)=>cursorByPage(view, true);\nfunction moveByLineBoundary(view, start, forward) {\n    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);\n    if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);\n    if (!forward && moved.head == line.from && line.length) {\n        let space = /^\\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;\n        if (space && start.head != line.from + space) moved = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(line.from + space);\n    }\n    return moved;\n}\n/**\nMove the selection to the next line wrap point, or to the end of\nthe line if there isn't one left on this line.\n*/ const cursorLineBoundaryForward = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, true));\n/**\nMove the selection to previous line wrap point, or failing that to\nthe start of the line. If the line is indented, and the cursor\nisn't already at the end of the indentation, this will move to the\nend of the indentation instead of the start of the line.\n*/ const cursorLineBoundaryBackward = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, false));\n/**\nMove the selection one line wrap point to the left.\n*/ const cursorLineBoundaryLeft = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection one line wrap point to the right.\n*/ const cursorLineBoundaryRight = (view)=>moveSel(view, (range)=>moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection to the start of the line.\n*/ const cursorLineStart = (view)=>moveSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));\n/**\nMove the selection to the end of the line.\n*/ const cursorLineEnd = (view)=>moveSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));\nfunction toMatchingBracket(state, dispatch, extend) {\n    let found = false, selection = updateSel(state.selection, (range)=>{\n        let matching = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, -1) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head, 1) || range.head > 0 && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head - 1, 1) || range.head < state.doc.length && (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.matchBrackets)(state, range.head + 1, -1);\n        if (!matching || !matching.end) return range;\n        found = true;\n        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;\n        return extend ? _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(head);\n    });\n    if (!found) return false;\n    dispatch(setSel(state, selection));\n    return true;\n}\n/**\nMove the selection to the bracket matching the one it is currently\non, if any.\n*/ const cursorMatchingBracket = ({ state, dispatch })=>toMatchingBracket(state, dispatch, false);\n/**\nExtend the selection to the bracket matching the one the selection\nhead is currently on, if any.\n*/ const selectMatchingBracket = ({ state, dispatch })=>toMatchingBracket(state, dispatch, true);\nfunction extendSel(target, how) {\n    let selection = updateSel(target.state.selection, (range)=>{\n        let head = how(range);\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);\n    });\n    if (selection.eq(target.state.selection)) return false;\n    target.dispatch(setSel(target.state, selection));\n    return true;\n}\nfunction selectByChar(view, forward) {\n    return extendSel(view, (range)=>view.moveByChar(range, forward));\n}\n/**\nMove the selection head one character to the left, while leaving\nthe anchor in place.\n*/ const selectCharLeft = (view)=>selectByChar(view, !ltrAtCursor(view));\n/**\nMove the selection head one character to the right.\n*/ const selectCharRight = (view)=>selectByChar(view, ltrAtCursor(view));\n/**\nMove the selection head one character forward.\n*/ const selectCharForward = (view)=>selectByChar(view, true);\n/**\nMove the selection head one character backward.\n*/ const selectCharBackward = (view)=>selectByChar(view, false);\n/**\nMove the selection head one character forward by logical\n(non-direction aware) string index order.\n*/ const selectCharForwardLogical = (target)=>extendSel(target, (range)=>byCharLogical(target.state, range, true));\n/**\nMove the selection head one character backward by logical string\nindex order.\n*/ const selectCharBackwardLogical = (target)=>extendSel(target, (range)=>byCharLogical(target.state, range, false));\nfunction selectByGroup(view, forward) {\n    return extendSel(view, (range)=>view.moveByGroup(range, forward));\n}\n/**\nMove the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to\nthe left.\n*/ const selectGroupLeft = (view)=>selectByGroup(view, !ltrAtCursor(view));\n/**\nMove the selection head one group to the right.\n*/ const selectGroupRight = (view)=>selectByGroup(view, ltrAtCursor(view));\n/**\nMove the selection head one group forward.\n*/ const selectGroupForward = (view)=>selectByGroup(view, true);\n/**\nMove the selection head one group backward.\n*/ const selectGroupBackward = (view)=>selectByGroup(view, false);\n/**\nMove the selection head one group forward in the default Windows\nstyle, skipping to the start of the next group.\n*/ const selectGroupForwardWin = (view)=>{\n    return extendSel(view, (range)=>view.moveByChar(range, true, (start)=>toGroupStart(view, range.head, start)));\n};\nfunction selectBySubword(view, forward) {\n    return extendSel(view, (range)=>moveBySubword(view, range, forward));\n}\n/**\nMove the selection head one group or camel-case subword forward.\n*/ const selectSubwordForward = (view)=>selectBySubword(view, true);\n/**\nMove the selection head one group or subword backward.\n*/ const selectSubwordBackward = (view)=>selectBySubword(view, false);\n/**\nMove the selection head over the next syntactic element to the left.\n*/ const selectSyntaxLeft = (view)=>extendSel(view, (range)=>moveBySyntax(view.state, range, !ltrAtCursor(view)));\n/**\nMove the selection head over the next syntactic element to the right.\n*/ const selectSyntaxRight = (view)=>extendSel(view, (range)=>moveBySyntax(view.state, range, ltrAtCursor(view)));\nfunction selectByLine(view, forward) {\n    return extendSel(view, (range)=>view.moveVertically(range, forward));\n}\n/**\nMove the selection head one line up.\n*/ const selectLineUp = (view)=>selectByLine(view, false);\n/**\nMove the selection head one line down.\n*/ const selectLineDown = (view)=>selectByLine(view, true);\nfunction selectByPage(view, forward) {\n    return extendSel(view, (range)=>view.moveVertically(range, forward, pageInfo(view).height));\n}\n/**\nMove the selection head one page up.\n*/ const selectPageUp = (view)=>selectByPage(view, false);\n/**\nMove the selection head one page down.\n*/ const selectPageDown = (view)=>selectByPage(view, true);\n/**\nMove the selection head to the next line boundary.\n*/ const selectLineBoundaryForward = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, true));\n/**\nMove the selection head to the previous line boundary.\n*/ const selectLineBoundaryBackward = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, false));\n/**\nMove the selection head one line boundary to the left.\n*/ const selectLineBoundaryLeft = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, !ltrAtCursor(view)));\n/**\nMove the selection head one line boundary to the right.\n*/ const selectLineBoundaryRight = (view)=>extendSel(view, (range)=>moveByLineBoundary(view, range, ltrAtCursor(view)));\n/**\nMove the selection head to the start of the line.\n*/ const selectLineStart = (view)=>extendSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).from));\n/**\nMove the selection head to the end of the line.\n*/ const selectLineEnd = (view)=>extendSel(view, (range)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(view.lineBlockAt(range.head).to));\n/**\nMove the selection to the start of the document.\n*/ const cursorDocStart = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: 0\n    }));\n    return true;\n};\n/**\nMove the selection to the end of the document.\n*/ const cursorDocEnd = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.doc.length\n    }));\n    return true;\n};\n/**\nMove the selection head to the start of the document.\n*/ const selectDocStart = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.selection.main.anchor,\n        head: 0\n    }));\n    return true;\n};\n/**\nMove the selection head to the end of the document.\n*/ const selectDocEnd = ({ state, dispatch })=>{\n    dispatch(setSel(state, {\n        anchor: state.selection.main.anchor,\n        head: state.doc.length\n    }));\n    return true;\n};\n/**\nSelect the entire document.\n*/ const selectAll = ({ state, dispatch })=>{\n    dispatch(state.update({\n        selection: {\n            anchor: 0,\n            head: state.doc.length\n        },\n        userEvent: \"select\"\n    }));\n    return true;\n};\n/**\nExpand the selection to cover entire lines.\n*/ const selectLine = ({ state, dispatch })=>{\n    let ranges = selectedLineBlocks(state).map(({ from, to })=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(from, Math.min(to + 1, state.doc.length)));\n    dispatch(state.update({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges),\n        userEvent: \"select\"\n    }));\n    return true;\n};\n/**\nSelect the next syntactic construct that is larger than the\nselection. Note that this will only work insofar as the language\n[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full\nsyntax tree.\n*/ const selectParentSyntax = ({ state, dispatch })=>{\n    let selection = updateSel(state.selection, (range)=>{\n        let tree = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state), stack = tree.resolveStack(range.from, 1);\n        if (range.empty) {\n            let stackBefore = tree.resolveStack(range.from, -1);\n            if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to) stack = stackBefore;\n        }\n        for(let cur = stack; cur; cur = cur.next){\n            let { node } = cur;\n            if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur.next) return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(node.to, node.from);\n        }\n        return range;\n    });\n    if (selection.eq(state.selection)) return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\n/**\nSimplify the current selection. When multiple ranges are selected,\nreduce it to its main range. Otherwise, if the selection is\nnon-empty, convert it to a cursor selection.\n*/ const simplifySelection = ({ state, dispatch })=>{\n    let cur = state.selection, selection = null;\n    if (cur.ranges.length > 1) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([\n        cur.main\n    ]);\n    else if (!cur.main.empty) selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create([\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(cur.main.head)\n    ]);\n    if (!selection) return false;\n    dispatch(setSel(state, selection));\n    return true;\n};\nfunction deleteBy(target, by) {\n    if (target.state.readOnly) return false;\n    let event = \"delete.selection\", { state } = target;\n    let changes = state.changeByRange((range)=>{\n        let { from, to } = range;\n        if (from == to) {\n            let towards = by(range);\n            if (towards < from) {\n                event = \"delete.backward\";\n                towards = skipAtomic(target, towards, false);\n            } else if (towards > from) {\n                event = \"delete.forward\";\n                towards = skipAtomic(target, towards, true);\n            }\n            from = Math.min(from, towards);\n            to = Math.max(to, towards);\n        } else {\n            from = skipAtomic(target, from, false);\n            to = skipAtomic(target, to, true);\n        }\n        return from == to ? {\n            range\n        } : {\n            changes: {\n                from,\n                to\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from, from < range.head ? -1 : 1)\n        };\n    });\n    if (changes.changes.empty) return false;\n    target.dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: event,\n        effects: event == \"delete.selection\" ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"Selection deleted\")) : undefined\n    }));\n    return true;\n}\nfunction skipAtomic(target, pos, forward) {\n    if (target instanceof _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView) for (let ranges of target.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.atomicRanges).map((f)=>f(target)))ranges.between(pos, pos, (from, to)=>{\n        if (from < pos && to > pos) pos = forward ? to : from;\n    });\n    return pos;\n}\nconst deleteByChar = (target, forward, byIndentUnit)=>deleteBy(target, (range)=>{\n        let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;\n        if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \\t]/.test(before = line.text.slice(0, pos - line.from))) {\n            if (before[before.length - 1] == \"\t\") return pos - 1;\n            let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(before, state.tabSize), drop = col % (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state) || (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state);\n            for(let i = 0; i < drop && before[before.length - 1 - i] == \" \"; i++)pos--;\n            targetPos = pos;\n        } else {\n            targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward, forward) + line.from;\n            if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;\n            else if (!forward && /[\\ufe00-\\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from))) targetPos = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, targetPos - line.from, false, false) + line.from;\n        }\n        return targetPos;\n    });\n/**\nDelete the selection, or, for cursor selections, the character or\nindentation unit before the cursor.\n*/ const deleteCharBackward = (view)=>deleteByChar(view, false, true);\n/**\nDelete the selection or the character before the cursor. Does not\nimplement any extended behavior like deleting whole indentation\nunits in one go.\n*/ const deleteCharBackwardStrict = (view)=>deleteByChar(view, false, false);\n/**\nDelete the selection or the character after the cursor.\n*/ const deleteCharForward = (view)=>deleteByChar(view, true, false);\nconst deleteByGroup = (target, forward)=>deleteBy(target, (range)=>{\n        let pos = range.head, { state } = target, line = state.doc.lineAt(pos);\n        let categorize = state.charCategorizer(pos);\n        for(let cat = null;;){\n            if (pos == (forward ? line.to : line.from)) {\n                if (pos == range.head && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;\n                break;\n            }\n            let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, forward) + line.from;\n            let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);\n            let nextCat = categorize(nextChar);\n            if (cat != null && nextCat != cat) break;\n            if (nextChar != \" \" || pos != range.head) cat = nextCat;\n            pos = next;\n        }\n        return pos;\n    });\n/**\nDelete the selection or backward until the end of the next\n[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of\nwhitespace when they consist of a single space.\n*/ const deleteGroupBackward = (target)=>deleteByGroup(target, false);\n/**\nDelete the selection or forward until the end of the next group.\n*/ const deleteGroupForward = (target)=>deleteByGroup(target, true);\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line. If the cursor is directly at the end of the\nline, delete the line break after it.\n*/ const deleteToLineEnd = (view)=>deleteBy(view, (range)=>{\n        let lineEnd = view.lineBlockAt(range.head).to;\n        return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line. If the cursor is directly at the start of the\nline, delete the line break before it.\n*/ const deleteToLineStart = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.lineBlockAt(range.head).from;\n        return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe start of the line or the next line wrap before the cursor.\n*/ const deleteLineBoundaryBackward = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.moveToLineBoundary(range, false).head;\n        return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);\n    });\n/**\nDelete the selection, or, if it is a cursor selection, delete to\nthe end of the line or the next line wrap after the cursor.\n*/ const deleteLineBoundaryForward = (view)=>deleteBy(view, (range)=>{\n        let lineStart = view.moveToLineBoundary(range, true).head;\n        return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);\n    });\n/**\nDelete all whitespace directly before a line end from the\ndocument.\n*/ const deleteTrailingWhitespace = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = [];\n    for(let pos = 0, prev = \"\", iter = state.doc.iter();;){\n        iter.next();\n        if (iter.lineBreak || iter.done) {\n            let trailing = prev.search(/\\s+$/);\n            if (trailing > -1) changes.push({\n                from: pos - (prev.length - trailing),\n                to: pos\n            });\n            if (iter.done) break;\n            prev = \"\";\n        } else {\n            prev = iter.value;\n        }\n        pos += iter.value.length;\n    }\n    if (!changes.length) return false;\n    dispatch(state.update({\n        changes,\n        userEvent: \"delete\"\n    }));\n    return true;\n};\n/**\nReplace each selection range with a line break, leaving the cursor\non the line before the break.\n*/ const splitLine = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = state.changeByRange((range)=>{\n        return {\n            changes: {\n                from: range.from,\n                to: range.to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of([\n                    \"\",\n                    \"\"\n                ])\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from)\n        };\n    });\n    dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nFlip the characters before and after the cursor(s).\n*/ const transposeChars = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let changes = state.changeByRange((range)=>{\n        if (!range.empty || range.from == 0 || range.from == state.doc.length) return {\n            range\n        };\n        let pos = range.from, line = state.doc.lineAt(pos);\n        let from = pos == line.from ? pos - 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, false) + line.from;\n        let to = pos == line.to ? pos + 1 : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(line.text, pos - line.from, true) + line.from;\n        return {\n            changes: {\n                from,\n                to,\n                insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(to)\n        };\n    });\n    if (changes.changes.empty) return false;\n    dispatch(state.update(changes, {\n        scrollIntoView: true,\n        userEvent: \"move.character\"\n    }));\n    return true;\n};\nfunction selectedLineBlocks(state) {\n    let blocks = [], upto = -1;\n    for (let range of state.selection.ranges){\n        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);\n        if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);\n        if (upto >= startLine.number) {\n            let prev = blocks[blocks.length - 1];\n            prev.to = endLine.to;\n            prev.ranges.push(range);\n        } else {\n            blocks.push({\n                from: startLine.from,\n                to: endLine.to,\n                ranges: [\n                    range\n                ]\n            });\n        }\n        upto = endLine.number + 1;\n    }\n    return blocks;\n}\nfunction moveLine(state, dispatch, forward) {\n    if (state.readOnly) return false;\n    let changes = [], ranges = [];\n    for (let block of selectedLineBlocks(state)){\n        if (forward ? block.to == state.doc.length : block.from == 0) continue;\n        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);\n        let size = nextLine.length + 1;\n        if (forward) {\n            changes.push({\n                from: block.to,\n                to: nextLine.to\n            }, {\n                from: block.from,\n                insert: nextLine.text + state.lineBreak\n            });\n            for (let r of block.ranges)ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));\n        } else {\n            changes.push({\n                from: nextLine.from,\n                to: block.from\n            }, {\n                from: block.to,\n                insert: state.lineBreak + nextLine.text\n            });\n            for (let r of block.ranges)ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.anchor - size, r.head - size));\n        }\n    }\n    if (!changes.length) return false;\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, state.selection.mainIndex),\n        userEvent: \"move.line\"\n    }));\n    return true;\n}\n/**\nMove the selected lines up one line.\n*/ const moveLineUp = ({ state, dispatch })=>moveLine(state, dispatch, false);\n/**\nMove the selected lines down one line.\n*/ const moveLineDown = ({ state, dispatch })=>moveLine(state, dispatch, true);\nfunction copyLine(state, dispatch, forward) {\n    if (state.readOnly) return false;\n    let changes = [];\n    for (let block of selectedLineBlocks(state)){\n        if (forward) changes.push({\n            from: block.from,\n            insert: state.doc.slice(block.from, block.to) + state.lineBreak\n        });\n        else changes.push({\n            from: block.to,\n            insert: state.lineBreak + state.doc.slice(block.from, block.to)\n        });\n    }\n    dispatch(state.update({\n        changes,\n        scrollIntoView: true,\n        userEvent: \"input.copyline\"\n    }));\n    return true;\n}\n/**\nCreate a copy of the selected lines. Keep the selection in the top copy.\n*/ const copyLineUp = ({ state, dispatch })=>copyLine(state, dispatch, false);\n/**\nCreate a copy of the selected lines. Keep the selection in the bottom copy.\n*/ const copyLineDown = ({ state, dispatch })=>copyLine(state, dispatch, true);\n/**\nDelete selected lines.\n*/ const deleteLine = (view)=>{\n    if (view.state.readOnly) return false;\n    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to })=>{\n        if (from > 0) from--;\n        else if (to < state.doc.length) to++;\n        return {\n            from,\n            to\n        };\n    }));\n    let selection = updateSel(state.selection, (range)=>{\n        let dist = undefined;\n        if (view.lineWrapping) {\n            let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);\n            if (pos) dist = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;\n        }\n        return view.moveVertically(range, true, dist);\n    }).map(changes);\n    view.dispatch({\n        changes,\n        selection,\n        scrollIntoView: true,\n        userEvent: \"delete.line\"\n    });\n    return true;\n};\n/**\nReplace the selection with a newline.\n*/ const insertNewline = ({ state, dispatch })=>{\n    dispatch(state.update(state.replaceSelection(state.lineBreak), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nReplace the selection with a newline and the same amount of\nindentation as the line above.\n*/ const insertNewlineKeepIndent = ({ state, dispatch })=>{\n    dispatch(state.update(state.changeByRange((range)=>{\n        let indent = /^\\s*/.exec(state.doc.lineAt(range.from).text)[0];\n        return {\n            changes: {\n                from: range.from,\n                to: range.to,\n                insert: state.lineBreak + indent\n            },\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.from + indent.length + 1)\n        };\n    }), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\nfunction isBetweenBrackets(state, pos) {\n    if (/\\(\\)|\\[\\]|\\{\\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {\n        from: pos,\n        to: pos\n    };\n    let context = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.syntaxTree)(state).resolveInner(pos);\n    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;\n    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\\S/.test(state.sliceDoc(before.to, after.from))) return {\n        from: before.to,\n        to: after.from\n    };\n    return null;\n}\n/**\nReplace the selection with a newline and indent the newly created\nline(s). If the current line consists only of whitespace, this\nwill also delete that whitespace. When the cursor is between\nmatching brackets, an additional newline will be inserted after\nthe cursor.\n*/ const insertNewlineAndIndent = /*@__PURE__*/ newlineAndIndent(false);\n/**\nCreate a blank, indented line below the current line.\n*/ const insertBlankLine = /*@__PURE__*/ newlineAndIndent(true);\nfunction newlineAndIndent(atEof) {\n    return ({ state, dispatch })=>{\n        if (state.readOnly) return false;\n        let changes = state.changeByRange((range)=>{\n            let { from, to } = range, line = state.doc.lineAt(from);\n            let explode = !atEof && from == to && isBetweenBrackets(state, from);\n            if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;\n            let cx = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n                simulateBreak: from,\n                simulateDoubleBreak: !!explode\n            });\n            let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(cx, from);\n            if (indent == null) indent = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(/^\\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);\n            while(to < line.to && /\\s/.test(line.text[to - line.from]))to++;\n            if (explode) ({ from, to } = explode);\n            else if (from > line.from && from < line.from + 100 && !/\\S/.test(line.text.slice(0, from))) from = line.from;\n            let insert = [\n                \"\",\n                (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent)\n            ];\n            if (explode) insert.push((0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, cx.lineIndent(line.from, -1)));\n            return {\n                changes: {\n                    from,\n                    to,\n                    insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Text.of(insert)\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(from + 1 + insert[1].length)\n            };\n        });\n        dispatch(state.update(changes, {\n            scrollIntoView: true,\n            userEvent: \"input\"\n        }));\n        return true;\n    };\n}\nfunction changeBySelectedLine(state, f) {\n    let atLine = -1;\n    return state.changeByRange((range)=>{\n        let changes = [];\n        for(let pos = range.from; pos <= range.to;){\n            let line = state.doc.lineAt(pos);\n            if (line.number > atLine && (range.empty || range.to > line.from)) {\n                f(line, changes, range);\n                atLine = line.number;\n            }\n            pos = line.to + 1;\n        }\n        let changeSet = state.changes(changes);\n        return {\n            changes,\n            range: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))\n        };\n    });\n}\n/**\nAuto-indent the selected lines. This uses the [indentation service\nfacet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent\ninformation.\n*/ const indentSelection = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    let updated = Object.create(null);\n    let context = new _codemirror_language__WEBPACK_IMPORTED_MODULE_3__.IndentContext(state, {\n        overrideIndentation: (start)=>{\n            let found = updated[start];\n            return found == null ? -1 : found;\n        }\n    });\n    let changes = changeBySelectedLine(state, (line, changes, range)=>{\n        let indent = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentation)(context, line.from);\n        if (indent == null) return;\n        if (!/\\S/.test(line.text)) indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, indent);\n        if (cur != norm || range.from < line.from + cur.length) {\n            updated[line.from] = indent;\n            changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n    });\n    if (!changes.changes.empty) dispatch(state.update(changes, {\n        userEvent: \"indent\"\n    }));\n    return true;\n};\n/**\nAdd a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected\nlines.\n*/ const indentMore = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes)=>{\n        changes.push({\n            from: line.from,\n            insert: state.facet(_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentUnit)\n        });\n    }), {\n        userEvent: \"input.indent\"\n    }));\n    return true;\n};\n/**\nRemove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all\nselected lines.\n*/ const indentLess = ({ state, dispatch })=>{\n    if (state.readOnly) return false;\n    dispatch(state.update(changeBySelectedLine(state, (line, changes)=>{\n        let space = /^\\s*/.exec(line.text)[0];\n        if (!space) return;\n        let col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.countColumn)(space, state.tabSize), keep = 0;\n        let insert = (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.indentString)(state, Math.max(0, col - (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_3__.getIndentUnit)(state)));\n        while(keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))keep++;\n        changes.push({\n            from: line.from + keep,\n            to: line.from + space.length,\n            insert: insert.slice(keep)\n        });\n    }), {\n        userEvent: \"delete.dedent\"\n    }));\n    return true;\n};\n/**\nEnables or disables\n[tab-focus mode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode). While on, this\nprevents the editor's key bindings from capturing Tab or\nShift-Tab, making it possible for the user to move focus out of\nthe editor with the keyboard.\n*/ const toggleTabFocusMode = (view)=>{\n    view.setTabFocusMode();\n    return true;\n};\n/**\nTemporarily enables [tab-focus\nmode](https://codemirror.net/6/docs/ref/#view.EditorView.setTabFocusMode) for two seconds or until\nanother key is pressed.\n*/ const temporarilySetTabFocusMode = (view)=>{\n    view.setTabFocusMode(2000);\n    return true;\n};\n/**\nInsert a tab character at the cursor or, if something is selected,\nuse [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire\nselection.\n*/ const insertTab = ({ state, dispatch })=>{\n    if (state.selection.ranges.some((r)=>!r.empty)) return indentMore({\n        state,\n        dispatch\n    });\n    dispatch(state.update(state.replaceSelection(\"\t\"), {\n        scrollIntoView: true,\n        userEvent: \"input\"\n    }));\n    return true;\n};\n/**\nArray of key bindings containing the Emacs-style bindings that are\navailable on macOS by default.\n\n - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)\n - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)\n - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)\n - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)\n - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)\n*/ const emacsStyleKeymap = [\n    {\n        key: \"Ctrl-b\",\n        run: cursorCharLeft,\n        shift: selectCharLeft,\n        preventDefault: true\n    },\n    {\n        key: \"Ctrl-f\",\n        run: cursorCharRight,\n        shift: selectCharRight\n    },\n    {\n        key: \"Ctrl-p\",\n        run: cursorLineUp,\n        shift: selectLineUp\n    },\n    {\n        key: \"Ctrl-n\",\n        run: cursorLineDown,\n        shift: selectLineDown\n    },\n    {\n        key: \"Ctrl-a\",\n        run: cursorLineStart,\n        shift: selectLineStart\n    },\n    {\n        key: \"Ctrl-e\",\n        run: cursorLineEnd,\n        shift: selectLineEnd\n    },\n    {\n        key: \"Ctrl-d\",\n        run: deleteCharForward\n    },\n    {\n        key: \"Ctrl-h\",\n        run: deleteCharBackward\n    },\n    {\n        key: \"Ctrl-k\",\n        run: deleteToLineEnd\n    },\n    {\n        key: \"Ctrl-Alt-h\",\n        run: deleteGroupBackward\n    },\n    {\n        key: \"Ctrl-o\",\n        run: splitLine\n    },\n    {\n        key: \"Ctrl-t\",\n        run: transposeChars\n    },\n    {\n        key: \"Ctrl-v\",\n        run: cursorPageDown\n    }\n];\n/**\nAn array of key bindings closely sticking to platform-standard or\nwidely used bindings. (This includes the bindings from\n[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`\nproperty changed to `mac`.)\n\n - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)\n - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)\n - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)\n - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)\n - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)\n - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)\n - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)\n - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)\n - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)\n - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)\n - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)\n - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)\n - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)\n - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)\n - Enter and Shift-Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)\n - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)\n - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)\n - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)\n - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)\n - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)\n - Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).\n - Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).\n*/ const standardKeymap = /*@__PURE__*/ [\n    {\n        key: \"ArrowLeft\",\n        run: cursorCharLeft,\n        shift: selectCharLeft,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-ArrowLeft\",\n        mac: \"Alt-ArrowLeft\",\n        run: cursorGroupLeft,\n        shift: selectGroupLeft,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowLeft\",\n        run: cursorLineBoundaryLeft,\n        shift: selectLineBoundaryLeft,\n        preventDefault: true\n    },\n    {\n        key: \"ArrowRight\",\n        run: cursorCharRight,\n        shift: selectCharRight,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-ArrowRight\",\n        mac: \"Alt-ArrowRight\",\n        run: cursorGroupRight,\n        shift: selectGroupRight,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowRight\",\n        run: cursorLineBoundaryRight,\n        shift: selectLineBoundaryRight,\n        preventDefault: true\n    },\n    {\n        key: \"ArrowUp\",\n        run: cursorLineUp,\n        shift: selectLineUp,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowUp\",\n        run: cursorDocStart,\n        shift: selectDocStart\n    },\n    {\n        mac: \"Ctrl-ArrowUp\",\n        run: cursorPageUp,\n        shift: selectPageUp\n    },\n    {\n        key: \"ArrowDown\",\n        run: cursorLineDown,\n        shift: selectLineDown,\n        preventDefault: true\n    },\n    {\n        mac: \"Cmd-ArrowDown\",\n        run: cursorDocEnd,\n        shift: selectDocEnd\n    },\n    {\n        mac: \"Ctrl-ArrowDown\",\n        run: cursorPageDown,\n        shift: selectPageDown\n    },\n    {\n        key: \"PageUp\",\n        run: cursorPageUp,\n        shift: selectPageUp\n    },\n    {\n        key: \"PageDown\",\n        run: cursorPageDown,\n        shift: selectPageDown\n    },\n    {\n        key: \"Home\",\n        run: cursorLineBoundaryBackward,\n        shift: selectLineBoundaryBackward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-Home\",\n        run: cursorDocStart,\n        shift: selectDocStart\n    },\n    {\n        key: \"End\",\n        run: cursorLineBoundaryForward,\n        shift: selectLineBoundaryForward,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-End\",\n        run: cursorDocEnd,\n        shift: selectDocEnd\n    },\n    {\n        key: \"Enter\",\n        run: insertNewlineAndIndent,\n        shift: insertNewlineAndIndent\n    },\n    {\n        key: \"Mod-a\",\n        run: selectAll\n    },\n    {\n        key: \"Backspace\",\n        run: deleteCharBackward,\n        shift: deleteCharBackward\n    },\n    {\n        key: \"Delete\",\n        run: deleteCharForward\n    },\n    {\n        key: \"Mod-Backspace\",\n        mac: \"Alt-Backspace\",\n        run: deleteGroupBackward\n    },\n    {\n        key: \"Mod-Delete\",\n        mac: \"Alt-Delete\",\n        run: deleteGroupForward\n    },\n    {\n        mac: \"Mod-Backspace\",\n        run: deleteLineBoundaryBackward\n    },\n    {\n        mac: \"Mod-Delete\",\n        run: deleteLineBoundaryForward\n    }\n].concat(/*@__PURE__*/ emacsStyleKeymap.map((b)=>({\n        mac: b.key,\n        run: b.run,\n        shift: b.shift\n    })));\n/**\nThe default keymap. Includes all bindings from\n[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:\n\n- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)\n- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)\n- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)\n- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)\n- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)\n- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)\n- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)\n- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)\n- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)\n- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)\n- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)\n- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)\n- Ctrl-Alt-\\\\ (Cmd-Alt-\\\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)\n- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)\n- Shift-Ctrl-\\\\ (Shift-Cmd-\\\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)\n- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).\n- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).\n- Ctrl-m (Alt-Shift-m on macOS): [`toggleTabFocusMode`](https://codemirror.net/6/docs/ref/#commands.toggleTabFocusMode).\n*/ const defaultKeymap = /*@__PURE__*/ [\n    {\n        key: \"Alt-ArrowLeft\",\n        mac: \"Ctrl-ArrowLeft\",\n        run: cursorSyntaxLeft,\n        shift: selectSyntaxLeft\n    },\n    {\n        key: \"Alt-ArrowRight\",\n        mac: \"Ctrl-ArrowRight\",\n        run: cursorSyntaxRight,\n        shift: selectSyntaxRight\n    },\n    {\n        key: \"Alt-ArrowUp\",\n        run: moveLineUp\n    },\n    {\n        key: \"Shift-Alt-ArrowUp\",\n        run: copyLineUp\n    },\n    {\n        key: \"Alt-ArrowDown\",\n        run: moveLineDown\n    },\n    {\n        key: \"Shift-Alt-ArrowDown\",\n        run: copyLineDown\n    },\n    {\n        key: \"Escape\",\n        run: simplifySelection\n    },\n    {\n        key: \"Mod-Enter\",\n        run: insertBlankLine\n    },\n    {\n        key: \"Alt-l\",\n        mac: \"Ctrl-l\",\n        run: selectLine\n    },\n    {\n        key: \"Mod-i\",\n        run: selectParentSyntax,\n        preventDefault: true\n    },\n    {\n        key: \"Mod-[\",\n        run: indentLess\n    },\n    {\n        key: \"Mod-]\",\n        run: indentMore\n    },\n    {\n        key: \"Mod-Alt-\\\\\",\n        run: indentSelection\n    },\n    {\n        key: \"Shift-Mod-k\",\n        run: deleteLine\n    },\n    {\n        key: \"Shift-Mod-\\\\\",\n        run: cursorMatchingBracket\n    },\n    {\n        key: \"Mod-/\",\n        run: toggleComment\n    },\n    {\n        key: \"Alt-A\",\n        run: toggleBlockComment\n    },\n    {\n        key: \"Ctrl-m\",\n        mac: \"Shift-Alt-m\",\n        run: toggleTabFocusMode\n    }\n].concat(standardKeymap);\n/**\nA binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and\nShift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).\nPlease see the [Tab example](../../examples/tab/) before using\nthis.\n*/ const indentWithTab = {\n    key: \"Tab\",\n    run: indentMore,\n    shift: indentLess\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc007QUFDN0k7QUFDZ0Y7QUFDaEc7QUFFekM7OztBQUdBLEdBQ0EsTUFBTXVCLGdCQUFnQkMsQ0FBQUE7SUFDbEIsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBR0QsUUFBUUUsT0FBT0QsTUFBTUUsR0FBRyxDQUFDQyxNQUFNLENBQUNILE1BQU1JLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDQyxJQUFJLEdBQUdDLFNBQVNDLFVBQVVULE9BQU9DLEtBQUssRUFBRUMsS0FBS0ssSUFBSTtJQUN0SCxPQUFPQyxPQUFPTixJQUFJLEdBQUdRLGtCQUFrQlYsVUFBVVEsT0FBT0csS0FBSyxHQUFHQyx5QkFBeUJaLFVBQVU7QUFDdkc7QUFDQSxTQUFTYSxRQUFRQyxDQUFDLEVBQUVDLE1BQU07SUFDdEIsT0FBTyxDQUFDLEVBQUVkLEtBQUssRUFBRWUsUUFBUSxFQUFFO1FBQ3ZCLElBQUlmLE1BQU1nQixRQUFRLEVBQ2QsT0FBTztRQUNYLElBQUlDLEtBQUtKLEVBQUVDLFFBQVFkO1FBQ25CLElBQUksQ0FBQ2lCLElBQ0QsT0FBTztRQUNYRixTQUFTZixNQUFNa0IsTUFBTSxDQUFDRDtRQUN0QixPQUFPO0lBQ1g7QUFDSjtBQUNBOzs7OztBQUtBLEdBQ0EsTUFBTVIsb0JBQW9CLFdBQVcsR0FBRUcsUUFBUU8sbUJBQW1CLEVBQUUsd0JBQXdCO0FBQzVGOztBQUVBLEdBQ0EsTUFBTUMsY0FBYyxXQUFXLEdBQUVSLFFBQVFPLG1CQUFtQixFQUFFLHlCQUF5QjtBQUN2Rjs7QUFFQSxHQUNBLE1BQU1FLGdCQUFnQixXQUFXLEdBQUVULFFBQVFPLG1CQUFtQixFQUFFLDJCQUEyQjtBQUMzRjs7Ozs7QUFLQSxHQUNBLE1BQU1HLHFCQUFxQixXQUFXLEdBQUVWLFFBQVFXLG9CQUFvQixFQUFFLHdCQUF3QjtBQUM5Rjs7QUFFQSxHQUNBLE1BQU1DLGVBQWUsV0FBVyxHQUFFWixRQUFRVyxvQkFBb0IsRUFBRSx5QkFBeUI7QUFDekY7O0FBRUEsR0FDQSxNQUFNRSxpQkFBaUIsV0FBVyxHQUFFYixRQUFRVyxvQkFBb0IsRUFBRSwyQkFBMkI7QUFDN0Y7OztBQUdBLEdBQ0EsTUFBTVosMkJBQTJCLFdBQVcsR0FBRUMsUUFBUSxDQUFDYyxHQUFHQyxJQUFNSixtQkFBbUJHLEdBQUdDLEdBQUdDLG1CQUFtQkQsS0FBSyxFQUFFLHdCQUF3QjtBQUMzSSxTQUFTbkIsVUFBVVIsS0FBSyxFQUFFNkIsR0FBRztJQUN6QixJQUFJQyxPQUFPOUIsTUFBTStCLGNBQWMsQ0FBQyxpQkFBaUJGO0lBQ2pELE9BQU9DLEtBQUtFLE1BQU0sR0FBR0YsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDO0FBQ3BDO0FBQ0EsTUFBTUcsZUFBZTtBQUNyQjs7O0FBR0EsR0FDQSxTQUFTQyxpQkFBaUJsQyxLQUFLLEVBQUUsRUFBRW1DLElBQUksRUFBRUMsS0FBSyxFQUFFLEVBQUU5QixJQUFJLEVBQUUrQixFQUFFO0lBQ3RELElBQUlDLGFBQWF0QyxNQUFNdUMsUUFBUSxDQUFDakMsT0FBTzJCLGNBQWMzQjtJQUNyRCxJQUFJa0MsWUFBWXhDLE1BQU11QyxRQUFRLENBQUNGLElBQUlBLEtBQUtKO0lBQ3hDLElBQUlRLGNBQWMsT0FBT0MsSUFBSSxDQUFDSixXQUFXLENBQUMsRUFBRSxDQUFDTixNQUFNLEVBQUVXLGFBQWEsT0FBT0QsSUFBSSxDQUFDRixVQUFVLENBQUMsRUFBRSxDQUFDUixNQUFNO0lBQ2xHLElBQUlZLFlBQVlOLFdBQVdOLE1BQU0sR0FBR1M7SUFDcEMsSUFBSUgsV0FBV08sS0FBSyxDQUFDRCxZQUFZVCxLQUFLSCxNQUFNLEVBQUVZLGNBQWNULFFBQ3hESyxVQUFVSyxLQUFLLENBQUNGLFlBQVlBLGFBQWFQLE1BQU1KLE1BQU0sS0FBS0ksT0FBTztRQUNqRSxPQUFPO1lBQUVELE1BQU07Z0JBQUVOLEtBQUt2QixPQUFPbUM7Z0JBQWFLLFFBQVFMLGVBQWU7WUFBRTtZQUMvREwsT0FBTztnQkFBRVAsS0FBS1EsS0FBS007Z0JBQVlHLFFBQVFILGNBQWM7WUFBRTtRQUFFO0lBQ2pFO0lBQ0EsSUFBSUksV0FBV0M7SUFDZixJQUFJWCxLQUFLL0IsUUFBUSxJQUFJMkIsY0FBYztRQUMvQmMsWUFBWUMsVUFBVWhELE1BQU11QyxRQUFRLENBQUNqQyxNQUFNK0I7SUFDL0MsT0FDSztRQUNEVSxZQUFZL0MsTUFBTXVDLFFBQVEsQ0FBQ2pDLE1BQU1BLE9BQU8yQjtRQUN4Q2UsVUFBVWhELE1BQU11QyxRQUFRLENBQUNGLEtBQUtKLGNBQWNJO0lBQ2hEO0lBQ0EsSUFBSVksYUFBYSxPQUFPUCxJQUFJLENBQUNLLFVBQVUsQ0FBQyxFQUFFLENBQUNmLE1BQU0sRUFBRWtCLFdBQVcsT0FBT1IsSUFBSSxDQUFDTSxRQUFRLENBQUMsRUFBRSxDQUFDaEIsTUFBTTtJQUM1RixJQUFJbUIsU0FBU0gsUUFBUWhCLE1BQU0sR0FBR2tCLFdBQVdkLE1BQU1KLE1BQU07SUFDckQsSUFBSWUsVUFBVUYsS0FBSyxDQUFDSSxZQUFZQSxhQUFhZCxLQUFLSCxNQUFNLEtBQUtHLFFBQ3pEYSxRQUFRSCxLQUFLLENBQUNNLFFBQVFBLFNBQVNmLE1BQU1KLE1BQU0sS0FBS0ksT0FBTztRQUN2RCxPQUFPO1lBQUVELE1BQU07Z0JBQUVOLEtBQUt2QixPQUFPMkMsYUFBYWQsS0FBS0gsTUFBTTtnQkFDN0NjLFFBQVEsS0FBS00sSUFBSSxDQUFDTCxVQUFVTSxNQUFNLENBQUNKLGFBQWFkLEtBQUtILE1BQU0sS0FBSyxJQUFJO1lBQUU7WUFDMUVJLE9BQU87Z0JBQUVQLEtBQUtRLEtBQUthLFdBQVdkLE1BQU1KLE1BQU07Z0JBQ3RDYyxRQUFRLEtBQUtNLElBQUksQ0FBQ0osUUFBUUssTUFBTSxDQUFDRixTQUFTLE1BQU0sSUFBSTtZQUFFO1FBQUU7SUFDcEU7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTdkIsbUJBQW1CNUIsS0FBSztJQUM3QixJQUFJc0QsU0FBUyxFQUFFO0lBQ2YsS0FBSyxJQUFJQyxLQUFLdkQsTUFBTUksU0FBUyxDQUFDa0QsTUFBTSxDQUFFO1FBQ2xDLElBQUlFLFdBQVd4RCxNQUFNRSxHQUFHLENBQUNDLE1BQU0sQ0FBQ29ELEVBQUVqRCxJQUFJO1FBQ3RDLElBQUltRCxTQUFTRixFQUFFbEIsRUFBRSxJQUFJbUIsU0FBU25CLEVBQUUsR0FBR21CLFdBQVd4RCxNQUFNRSxHQUFHLENBQUNDLE1BQU0sQ0FBQ29ELEVBQUVsQixFQUFFO1FBQ25FLElBQUlvQixPQUFPbkQsSUFBSSxHQUFHa0QsU0FBU2xELElBQUksSUFBSW1ELE9BQU9uRCxJQUFJLElBQUlpRCxFQUFFbEIsRUFBRSxFQUNsRG9CLFNBQVNGLEVBQUVsQixFQUFFLElBQUltQixTQUFTbkIsRUFBRSxHQUFHLElBQUltQixXQUFXeEQsTUFBTUUsR0FBRyxDQUFDQyxNQUFNLENBQUNvRCxFQUFFbEIsRUFBRSxHQUFHO1FBQzFFLElBQUlxQixPQUFPSixPQUFPdEIsTUFBTSxHQUFHO1FBQzNCLElBQUkwQixRQUFRLEtBQUtKLE1BQU0sQ0FBQ0ksS0FBSyxDQUFDckIsRUFBRSxHQUFHbUIsU0FBU2xELElBQUksRUFDNUNnRCxNQUFNLENBQUNJLEtBQUssQ0FBQ3JCLEVBQUUsR0FBR29CLE9BQU9wQixFQUFFO2FBRTNCaUIsT0FBT0ssSUFBSSxDQUFDO1lBQUVyRCxNQUFNa0QsU0FBU2xELElBQUksR0FBRyxPQUFPb0MsSUFBSSxDQUFDYyxTQUFTSSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUM1QixNQUFNO1lBQUVLLElBQUlvQixPQUFPcEIsRUFBRTtRQUFDO0lBQ2hHO0lBQ0EsT0FBT2lCO0FBQ1g7QUFDQSw4REFBOEQ7QUFDOUQsK0JBQStCO0FBQy9CLFNBQVMvQixtQkFBbUJULE1BQU0sRUFBRWQsS0FBSyxFQUFFc0QsU0FBU3RELE1BQU1JLFNBQVMsQ0FBQ2tELE1BQU07SUFDdEUsSUFBSU8sU0FBU1AsT0FBT1EsR0FBRyxDQUFDUCxDQUFBQSxJQUFLL0MsVUFBVVIsT0FBT3VELEVBQUVqRCxJQUFJLEVBQUVJLEtBQUs7SUFDM0QsSUFBSSxDQUFDbUQsT0FBT0UsS0FBSyxDQUFDQyxDQUFBQSxJQUFLQSxJQUNuQixPQUFPO0lBQ1gsSUFBSUMsV0FBV1gsT0FBT1EsR0FBRyxDQUFDLENBQUNQLEdBQUdXLElBQU1oQyxpQkFBaUJsQyxPQUFPNkQsTUFBTSxDQUFDSyxFQUFFLEVBQUVYLEVBQUVqRCxJQUFJLEVBQUVpRCxFQUFFbEIsRUFBRTtJQUNuRixJQUFJdkIsVUFBVSxFQUFFLDJCQUEyQixPQUFNLENBQUNtRCxTQUFTRixLQUFLLENBQUNDLENBQUFBLElBQUtBLElBQUk7UUFDdEUsT0FBTztZQUFFRyxTQUFTbkUsTUFBTW1FLE9BQU8sQ0FBQ2IsT0FBT1EsR0FBRyxDQUFDLENBQUNNLE9BQU9GO2dCQUMzQyxJQUFJRCxRQUFRLENBQUNDLEVBQUUsRUFDWCxPQUFPLEVBQUU7Z0JBQ2IsT0FBTztvQkFBQzt3QkFBRTVELE1BQU04RCxNQUFNOUQsSUFBSTt3QkFBRStELFFBQVFSLE1BQU0sQ0FBQ0ssRUFBRSxDQUFDL0IsSUFBSSxHQUFHO29CQUFJO29CQUFHO3dCQUFFN0IsTUFBTThELE1BQU0vQixFQUFFO3dCQUFFZ0MsUUFBUSxNQUFNUixNQUFNLENBQUNLLEVBQUUsQ0FBQzlCLEtBQUs7b0JBQUM7aUJBQUU7WUFDbEg7UUFBSTtJQUNaLE9BQ0ssSUFBSXRCLFVBQVUsRUFBRSx5QkFBeUIsT0FBTW1ELFNBQVNLLElBQUksQ0FBQ04sQ0FBQUEsSUFBS0EsSUFBSTtRQUN2RSxJQUFJRyxVQUFVLEVBQUU7UUFDaEIsSUFBSyxJQUFJRCxJQUFJLEdBQUdLLFNBQVNMLElBQUlELFNBQVNqQyxNQUFNLEVBQUVrQyxJQUMxQyxJQUFJSyxVQUFVTixRQUFRLENBQUNDLEVBQUUsRUFBRTtZQUN2QixJQUFJTSxRQUFRWCxNQUFNLENBQUNLLEVBQUUsRUFBRSxFQUFFL0IsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBR21DO1lBQ3pDSixRQUFRUixJQUFJLENBQUM7Z0JBQUVyRCxNQUFNNkIsS0FBS04sR0FBRyxHQUFHMkMsTUFBTXJDLElBQUksQ0FBQ0gsTUFBTTtnQkFBRUssSUFBSUYsS0FBS04sR0FBRyxHQUFHTSxLQUFLVyxNQUFNO1lBQUMsR0FBRztnQkFBRXhDLE1BQU04QixNQUFNUCxHQUFHLEdBQUdPLE1BQU1VLE1BQU07Z0JBQUVULElBQUlELE1BQU1QLEdBQUcsR0FBRzJDLE1BQU1wQyxLQUFLLENBQUNKLE1BQU07WUFBQztRQUMxSjtRQUNKLE9BQU87WUFBRW1DO1FBQVE7SUFDckI7SUFDQSxPQUFPO0FBQ1g7QUFDQSwyREFBMkQ7QUFDM0QsU0FBU2hELGtCQUFrQkwsTUFBTSxFQUFFZCxLQUFLLEVBQUVzRCxTQUFTdEQsTUFBTUksU0FBUyxDQUFDa0QsTUFBTTtJQUNyRSxJQUFJbUIsUUFBUSxFQUFFO0lBQ2QsSUFBSUMsV0FBVyxDQUFDO0lBQ2hCLEtBQUssSUFBSSxFQUFFcEUsSUFBSSxFQUFFK0IsRUFBRSxFQUFFLElBQUlpQixPQUFRO1FBQzdCLElBQUlxQixTQUFTRixNQUFNekMsTUFBTSxFQUFFNEMsWUFBWTtRQUN2QyxJQUFJSixRQUFRaEUsVUFBVVIsT0FBT00sTUFBTUwsSUFBSTtRQUN2QyxJQUFJLENBQUN1RSxPQUNEO1FBQ0osSUFBSyxJQUFJM0MsTUFBTXZCLE1BQU11QixPQUFPUSxJQUFLO1lBQzdCLElBQUlwQyxPQUFPRCxNQUFNRSxHQUFHLENBQUNDLE1BQU0sQ0FBQzBCO1lBQzVCLElBQUk1QixLQUFLSyxJQUFJLEdBQUdvRSxZQUFhcEUsQ0FBQUEsUUFBUStCLE1BQU1BLEtBQUtwQyxLQUFLSyxJQUFJLEdBQUc7Z0JBQ3hEb0UsV0FBV3pFLEtBQUtLLElBQUk7Z0JBQ3BCLElBQUl1RSxTQUFTLE9BQU9uQyxJQUFJLENBQUN6QyxLQUFLMkQsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDNUIsTUFBTTtnQkFDN0MsSUFBSThDLFFBQVFELFVBQVU1RSxLQUFLK0IsTUFBTTtnQkFDakMsSUFBSXVDLFVBQVV0RSxLQUFLMkQsSUFBSSxDQUFDZixLQUFLLENBQUNnQyxRQUFRQSxTQUFTTCxNQUFNeEMsTUFBTSxLQUFLd0MsUUFBUUssU0FBUyxDQUFDO2dCQUNsRixJQUFJQSxTQUFTNUUsS0FBSzJELElBQUksQ0FBQzVCLE1BQU0sSUFBSTZDLFNBQVNELFdBQ3RDQSxZQUFZQztnQkFDaEJKLE1BQU1kLElBQUksQ0FBQztvQkFBRTFEO29CQUFNc0U7b0JBQVNDO29CQUFPSztvQkFBUUM7b0JBQU9DLFFBQVE7Z0JBQU07WUFDcEU7WUFDQWxELE1BQU01QixLQUFLb0MsRUFBRSxHQUFHO1FBQ3BCO1FBQ0EsSUFBSXVDLFlBQVksS0FDWjtZQUFBLElBQUssSUFBSVYsSUFBSVMsUUFBUVQsSUFBSU8sTUFBTXpDLE1BQU0sRUFBRWtDLElBQ25DLElBQUlPLEtBQUssQ0FBQ1AsRUFBRSxDQUFDVyxNQUFNLEdBQUdKLEtBQUssQ0FBQ1AsRUFBRSxDQUFDakUsSUFBSSxDQUFDMkQsSUFBSSxDQUFDNUIsTUFBTSxFQUMzQ3lDLEtBQUssQ0FBQ1AsRUFBRSxDQUFDVyxNQUFNLEdBQUdEO1FBQVM7UUFDdkMsSUFBSUgsTUFBTXpDLE1BQU0sSUFBSTJDLFNBQVMsR0FDekJGLEtBQUssQ0FBQ0UsT0FBTyxDQUFDSSxNQUFNLEdBQUc7SUFDL0I7SUFDQSxJQUFJakUsVUFBVSxFQUFFLDJCQUEyQixPQUFNMkQsTUFBTUgsSUFBSSxDQUFDVSxDQUFBQSxJQUFLQSxFQUFFVCxPQUFPLEdBQUcsS0FBTSxFQUFDUyxFQUFFRixLQUFLLElBQUlFLEVBQUVELE1BQU0sSUFBSTtRQUN2RyxJQUFJWixVQUFVLEVBQUU7UUFDaEIsS0FBSyxJQUFJLEVBQUVsRSxJQUFJLEVBQUV1RSxLQUFLLEVBQUVLLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUUsSUFBSU4sTUFDL0MsSUFBSU0sVUFBVSxDQUFDRCxPQUNYWCxRQUFRUixJQUFJLENBQUM7WUFBRXJELE1BQU1MLEtBQUtLLElBQUksR0FBR3VFO1lBQVFSLFFBQVFHLFFBQVE7UUFBSTtRQUNyRSxJQUFJUyxZQUFZakYsTUFBTW1FLE9BQU8sQ0FBQ0E7UUFDOUIsT0FBTztZQUFFQSxTQUFTYztZQUFXN0UsV0FBV0osTUFBTUksU0FBUyxDQUFDMEQsR0FBRyxDQUFDbUIsV0FBVztRQUFHO0lBQzlFLE9BQ0ssSUFBSW5FLFVBQVUsRUFBRSx5QkFBeUIsT0FBTTJELE1BQU1ILElBQUksQ0FBQ1UsQ0FBQUEsSUFBS0EsRUFBRVQsT0FBTyxJQUFJLElBQUk7UUFDakYsSUFBSUosVUFBVSxFQUFFO1FBQ2hCLEtBQUssSUFBSSxFQUFFbEUsSUFBSSxFQUFFc0UsT0FBTyxFQUFFQyxLQUFLLEVBQUUsSUFBSUMsTUFDakMsSUFBSUYsV0FBVyxHQUFHO1lBQ2QsSUFBSWpFLE9BQU9MLEtBQUtLLElBQUksR0FBR2lFLFNBQVNsQyxLQUFLL0IsT0FBT2tFLE1BQU14QyxNQUFNO1lBQ3hELElBQUkvQixLQUFLMkQsSUFBSSxDQUFDdkIsS0FBS3BDLEtBQUtLLElBQUksQ0FBQyxJQUFJLEtBQzdCK0I7WUFDSjhCLFFBQVFSLElBQUksQ0FBQztnQkFBRXJEO2dCQUFNK0I7WUFBRztRQUM1QjtRQUNKLE9BQU87WUFBRThCO1FBQVE7SUFDckI7SUFDQSxPQUFPO0FBQ1g7QUFFQSxNQUFNZSxjQUFjLFdBQVcsR0FBRTNHLHlEQUFVQSxDQUFDNEcsTUFBTTtBQUNsRDs7Ozs7O0FBTUEsR0FDQSxNQUFNQyxpQkFBaUIsV0FBVyxHQUFFN0cseURBQVVBLENBQUM0RyxNQUFNO0FBQ3JEOzs7Ozs7QUFNQSxHQUNBLE1BQU1FLGtCQUFrQixXQUFXLEdBQUU3RyxvREFBS0EsQ0FBQzJHLE1BQU07QUFDakQsTUFBTUcsZ0JBQWdCLFdBQVcsR0FBRTlHLG9EQUFLQSxDQUFDMkcsTUFBTSxDQUFDO0lBQzVDSSxTQUFRQyxPQUFPO1FBQ1gsT0FBTy9HLGdFQUFhQSxDQUFDK0csU0FBUztZQUMxQkMsVUFBVTtZQUNWQyxlQUFlO1lBQ2ZDLGFBQWEsQ0FBQ0MsSUFBSUMsYUFBZUE7UUFDckMsR0FBRztZQUNDSixVQUFVSyxLQUFLQyxHQUFHO1lBQ2xCTCxlQUFlSSxLQUFLRSxHQUFHO1lBQ3ZCTCxhQUFhLENBQUNNLEdBQUdDLElBQU0sQ0FBQ2pGLElBQUlrRixNQUFRRixFQUFFaEYsSUFBSWtGLFFBQVFELEVBQUVqRixJQUFJa0Y7UUFDNUQ7SUFDSjtBQUNKO0FBQ0EsTUFBTUMsZ0JBQWdCLFdBQVcsR0FBRTFILHlEQUFVQSxDQUFDeUcsTUFBTSxDQUFDO0lBQ2pEa0I7UUFDSSxPQUFPQyxhQUFheEIsS0FBSztJQUM3QjtJQUNBNUQsUUFBT2xCLEtBQUssRUFBRWlCLEVBQUU7UUFDWixJQUFJVixTQUFTVSxHQUFHakIsS0FBSyxDQUFDdUcsS0FBSyxDQUFDakI7UUFDNUIsSUFBSWtCLFdBQVd2RixHQUFHd0YsVUFBVSxDQUFDdkI7UUFDN0IsSUFBSXNCLFVBQVU7WUFDVixJQUFJRSxPQUFPQyxVQUFVQyxlQUFlLENBQUMzRixJQUFJdUYsU0FBU3BHLFNBQVMsR0FBR0UsT0FBT2tHLFNBQVNLLElBQUk7WUFDbEYsSUFBSUMsUUFBUXhHLFFBQVEsRUFBRSxtQkFBbUIsTUFBS04sTUFBTStHLE1BQU0sR0FBRy9HLE1BQU1nSCxJQUFJO1lBQ3ZFLElBQUlOLE1BQ0FJLFFBQVFHLGFBQWFILE9BQU9BLE1BQU05RSxNQUFNLEVBQUV6QixPQUFPa0YsUUFBUSxFQUFFaUI7aUJBRTNESSxRQUFRSSxhQUFhSixPQUFPN0YsR0FBR2tHLFVBQVUsQ0FBQy9HLFNBQVM7WUFDdkQsT0FBTyxJQUFJa0csYUFBYWhHLFFBQVEsRUFBRSxtQkFBbUIsTUFBS2tHLFNBQVNZLElBQUksR0FBR04sT0FBT3hHLFFBQVEsRUFBRSxtQkFBbUIsTUFBS3dHLFFBQVFOLFNBQVNZLElBQUk7UUFDNUk7UUFDQSxJQUFJQyxVQUFVcEcsR0FBR3dGLFVBQVUsQ0FBQ3JCO1FBQzVCLElBQUlpQyxXQUFXLFVBQVVBLFdBQVcsVUFDaENySCxRQUFRQSxNQUFNcUgsT0FBTztRQUN6QixJQUFJcEcsR0FBR3dGLFVBQVUsQ0FBQzlILDBEQUFXQSxDQUFDMkksWUFBWSxNQUFNLE9BQzVDLE9BQU8sQ0FBQ3JHLEdBQUdrRCxPQUFPLENBQUNXLEtBQUssR0FBRzlFLE1BQU11SCxVQUFVLENBQUN0RyxHQUFHa0QsT0FBTyxDQUFDcUQsSUFBSSxJQUFJeEg7UUFDbkUsSUFBSXlILFFBQVFkLFVBQVVDLGVBQWUsQ0FBQzNGO1FBQ3RDLElBQUl5RyxPQUFPekcsR0FBR3dGLFVBQVUsQ0FBQzlILDBEQUFXQSxDQUFDK0ksSUFBSSxHQUFHQyxZQUFZMUcsR0FBR3dGLFVBQVUsQ0FBQzlILDBEQUFXQSxDQUFDZ0osU0FBUztRQUMzRixJQUFJRixPQUNBekgsUUFBUUEsTUFBTTRILFVBQVUsQ0FBQ0gsT0FBT0MsTUFBTUMsV0FBV3BILFFBQVFVO2FBQ3hELElBQUlBLEdBQUdiLFNBQVMsRUFDakJKLFFBQVFBLE1BQU1rSCxZQUFZLENBQUNqRyxHQUFHa0csVUFBVSxDQUFDL0csU0FBUyxFQUFFc0gsTUFBTUMsV0FBV3BILE9BQU9tRixhQUFhO1FBQzdGLElBQUkyQixXQUFXLFVBQVVBLFdBQVcsU0FDaENySCxRQUFRQSxNQUFNcUgsT0FBTztRQUN6QixPQUFPckg7SUFDWDtJQUNBNkgsUUFBT0MsS0FBSztRQUNSLE9BQU87WUFBRWQsTUFBTWMsTUFBTWQsSUFBSSxDQUFDbEQsR0FBRyxDQUFDaUUsQ0FBQUEsSUFBS0EsRUFBRUYsTUFBTTtZQUFLZCxRQUFRZSxNQUFNZixNQUFNLENBQUNqRCxHQUFHLENBQUNpRSxDQUFBQSxJQUFLQSxFQUFFRixNQUFNO1FBQUk7SUFDOUY7SUFDQUcsVUFBU0MsSUFBSTtRQUNULE9BQU8sSUFBSTNCLGFBQWEyQixLQUFLakIsSUFBSSxDQUFDbEQsR0FBRyxDQUFDNkMsVUFBVXFCLFFBQVEsR0FBR0MsS0FBS2xCLE1BQU0sQ0FBQ2pELEdBQUcsQ0FBQzZDLFVBQVVxQixRQUFRO0lBQ2pHO0FBQ0o7QUFDQTs7QUFFQSxHQUNBLFNBQVNFLFFBQVEzSCxTQUFTLENBQUMsQ0FBQztJQUN4QixPQUFPO1FBQ0g2RjtRQUNBZCxjQUFjNkMsRUFBRSxDQUFDNUg7UUFDakJuQix3REFBVUEsQ0FBQ2dKLGdCQUFnQixDQUFDO1lBQ3hCQyxhQUFZTixDQUFDLEVBQUVPLElBQUk7Z0JBQ2YsSUFBSTFILFVBQVVtSCxFQUFFUSxTQUFTLElBQUksZ0JBQWdCQyxPQUFPVCxFQUFFUSxTQUFTLElBQUksZ0JBQWdCRSxPQUFPO2dCQUMxRixJQUFJLENBQUM3SCxTQUNELE9BQU87Z0JBQ1htSCxFQUFFVyxjQUFjO2dCQUNoQixPQUFPOUgsUUFBUTBIO1lBQ25CO1FBQ0o7S0FDSDtBQUNMO0FBQ0E7Ozs7OztBQU1BLEdBQ0EsTUFBTUssZUFBZXZDO0FBQ3JCLFNBQVN3QyxJQUFJL0IsSUFBSSxFQUFFekcsU0FBUztJQUN4QixPQUFPLFNBQVUsRUFBRUosS0FBSyxFQUFFZSxRQUFRLEVBQUU7UUFDaEMsSUFBSSxDQUFDWCxhQUFhSixNQUFNZ0IsUUFBUSxFQUM1QixPQUFPO1FBQ1gsSUFBSTZILGVBQWU3SSxNQUFNOEksS0FBSyxDQUFDMUMsZUFBZTtRQUM5QyxJQUFJLENBQUN5QyxjQUNELE9BQU87UUFDWCxJQUFJNUgsS0FBSzRILGFBQWFFLEdBQUcsQ0FBQ2xDLE1BQU03RyxPQUFPSTtRQUN2QyxJQUFJLENBQUNhLElBQ0QsT0FBTztRQUNYRixTQUFTRTtRQUNULE9BQU87SUFDWDtBQUNKO0FBQ0E7OztBQUdBLEdBQ0EsTUFBTXVILE9BQU8sV0FBVyxHQUFFSSxJQUFJLEVBQUUsbUJBQW1CLEtBQUk7QUFDdkQ7OztBQUdBLEdBQ0EsTUFBTUgsT0FBTyxXQUFXLEdBQUVHLElBQUksRUFBRSxxQkFBcUIsS0FBSTtBQUN6RDs7QUFFQSxHQUNBLE1BQU1JLGdCQUFnQixXQUFXLEdBQUVKLElBQUksRUFBRSxtQkFBbUIsS0FBSTtBQUNoRTs7QUFFQSxHQUNBLE1BQU1LLGdCQUFnQixXQUFXLEdBQUVMLElBQUksRUFBRSxxQkFBcUIsS0FBSTtBQUNsRSxTQUFTTSxNQUFNckMsSUFBSTtJQUNmLE9BQU8sU0FBVTdHLEtBQUs7UUFDbEIsSUFBSW1KLFlBQVluSixNQUFNOEksS0FBSyxDQUFDMUMsZUFBZTtRQUMzQyxJQUFJLENBQUMrQyxXQUNELE9BQU87UUFDWCxJQUFJQyxTQUFTdkMsUUFBUSxFQUFFLG1CQUFtQixNQUFLc0MsVUFBVW5DLElBQUksR0FBR21DLFVBQVVwQyxNQUFNO1FBQ2hGLE9BQU9xQyxPQUFPcEgsTUFBTSxHQUFJb0gsQ0FBQUEsT0FBT3BILE1BQU0sSUFBSSxDQUFDb0gsTUFBTSxDQUFDLEVBQUUsQ0FBQ2pGLE9BQU8sR0FBRyxJQUFJO0lBQ3RFO0FBQ0o7QUFDQTs7QUFFQSxHQUNBLE1BQU1rRixZQUFZLFdBQVcsR0FBRUgsTUFBTSxFQUFFLG1CQUFtQjtBQUMxRDs7QUFFQSxHQUNBLE1BQU1JLFlBQVksV0FBVyxHQUFFSixNQUFNLEVBQUUscUJBQXFCO0FBQzVELG9FQUFvRTtBQUNwRSwwQkFBMEI7QUFDMUIsTUFBTXZDO0lBQ0Y0QyxZQUNBLDZEQUE2RDtJQUM3RCwrREFBK0Q7SUFDL0Qsa0VBQWtFO0lBQ2xFLDJEQUEyRDtJQUMzRCx5Q0FBeUM7SUFDekNwRixPQUFPLEVBQ1AseUNBQXlDO0lBQ3pDcUYsT0FBTyxFQUNQLGdFQUFnRTtJQUNoRSxvQ0FBb0M7SUFDcENDLE1BQU0sRUFDTixrQ0FBa0M7SUFDbENDLGNBQWMsRUFDZCw0REFBNEQ7SUFDNUQsdUJBQXVCO0lBQ3ZCQyxlQUFlLENBQUU7UUFDYixJQUFJLENBQUN4RixPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDcUYsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsY0FBYyxHQUFHQTtRQUN0QixJQUFJLENBQUNDLGVBQWUsR0FBR0E7SUFDM0I7SUFDQUMsWUFBWUMsS0FBSyxFQUFFO1FBQ2YsT0FBTyxJQUFJbEQsVUFBVSxJQUFJLENBQUN4QyxPQUFPLEVBQUUsSUFBSSxDQUFDcUYsT0FBTyxFQUFFLElBQUksQ0FBQ0MsTUFBTSxFQUFFLElBQUksQ0FBQ0MsY0FBYyxFQUFFRztJQUN2RjtJQUNBaEMsU0FBUztRQUNMLElBQUlpQyxJQUFJQyxJQUFJQztRQUNaLE9BQU87WUFDSDdGLFNBQVMsQ0FBQzJGLEtBQUssSUFBSSxDQUFDM0YsT0FBTyxNQUFNLFFBQVEyRixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdqQyxNQUFNO1lBQzNFNEIsUUFBUSxDQUFDTSxLQUFLLElBQUksQ0FBQ04sTUFBTSxNQUFNLFFBQVFNLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2xDLE1BQU07WUFDekU2QixnQkFBZ0IsQ0FBQ00sS0FBSyxJQUFJLENBQUNOLGNBQWMsTUFBTSxRQUFRTSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUduQyxNQUFNO1lBQ3pGOEIsaUJBQWlCLElBQUksQ0FBQ0EsZUFBZSxDQUFDN0YsR0FBRyxDQUFDbkMsQ0FBQUEsSUFBS0EsRUFBRWtHLE1BQU07UUFDM0Q7SUFDSjtJQUNBLE9BQU9HLFNBQVNDLElBQUksRUFBRTtRQUNsQixPQUFPLElBQUl0QixVQUFVc0IsS0FBSzlELE9BQU8sSUFBSXZGLHdEQUFTQSxDQUFDb0osUUFBUSxDQUFDQyxLQUFLOUQsT0FBTyxHQUFHLEVBQUUsRUFBRThELEtBQUt3QixNQUFNLElBQUk1Syx5REFBVUEsQ0FBQ21KLFFBQVEsQ0FBQ0MsS0FBS3dCLE1BQU0sR0FBR3hCLEtBQUt5QixjQUFjLElBQUk1Syw4REFBZUEsQ0FBQ2tKLFFBQVEsQ0FBQ0MsS0FBS3lCLGNBQWMsR0FBR3pCLEtBQUswQixlQUFlLENBQUM3RixHQUFHLENBQUNoRiw4REFBZUEsQ0FBQ2tKLFFBQVE7SUFDdlA7SUFDQSw4REFBOEQ7SUFDOUQsa0VBQWtFO0lBQ2xFLHNEQUFzRDtJQUN0RCxPQUFPcEIsZ0JBQWdCM0YsRUFBRSxFQUFFYixTQUFTLEVBQUU7UUFDbEMsSUFBSW9KLFVBQVVTO1FBQ2QsS0FBSyxJQUFJQyxVQUFVakosR0FBR2tHLFVBQVUsQ0FBQ1osS0FBSyxDQUFDbEIsaUJBQWtCO1lBQ3JELElBQUk4RSxTQUFTRCxPQUFPako7WUFDcEIsSUFBSWtKLE9BQU9uSSxNQUFNLEVBQ2J3SCxVQUFVQSxRQUFRWSxNQUFNLENBQUNEO1FBQ2pDO1FBQ0EsSUFBSSxDQUFDWCxRQUFReEgsTUFBTSxJQUFJZixHQUFHa0QsT0FBTyxDQUFDVyxLQUFLLEVBQ25DLE9BQU87UUFDWCxPQUFPLElBQUk2QixVQUFVMUYsR0FBR2tELE9BQU8sQ0FBQytGLE1BQU0sQ0FBQ2pKLEdBQUdrRyxVQUFVLENBQUNqSCxHQUFHLEdBQUdzSixTQUFTYSxXQUFXakssYUFBYWEsR0FBR2tHLFVBQVUsQ0FBQy9HLFNBQVMsRUFBRTZKO0lBQ3pIO0lBQ0EsT0FBTzdKLFVBQVVrSyxVQUFVLEVBQUU7UUFDekIsT0FBTyxJQUFJM0QsVUFBVTBELFdBQVdKLE1BQU1JLFdBQVdBLFdBQVdDO0lBQ2hFO0FBQ0o7QUFDQSxTQUFTckQsYUFBYW1DLE1BQU0sRUFBRS9HLEVBQUUsRUFBRWtJLE1BQU0sRUFBRUMsUUFBUTtJQUM5QyxJQUFJQyxRQUFRcEksS0FBSyxJQUFJa0ksU0FBUyxLQUFLbEksS0FBS2tJLFNBQVMsSUFBSTtJQUNyRCxJQUFJRyxZQUFZdEIsT0FBT3ZHLEtBQUssQ0FBQzRILE9BQU9wSTtJQUNwQ3FJLFVBQVUvRyxJQUFJLENBQUM2RztJQUNmLE9BQU9FO0FBQ1g7QUFDQSxTQUFTN0UsV0FBV0ksQ0FBQyxFQUFFQyxDQUFDO0lBQ3BCLElBQUk1QyxTQUFTLEVBQUUsRUFBRXVDLGFBQWE7SUFDOUJJLEVBQUUwRSxpQkFBaUIsQ0FBQyxDQUFDOUosR0FBRytKLElBQU10SCxPQUFPSyxJQUFJLENBQUM5QyxHQUFHK0o7SUFDN0MxRSxFQUFFeUUsaUJBQWlCLENBQUMsQ0FBQ0UsSUFBSWpGLElBQUkvRSxHQUFHK0o7UUFDNUIsSUFBSyxJQUFJMUcsSUFBSSxHQUFHQSxJQUFJWixPQUFPdEIsTUFBTSxFQUFHO1lBQ2hDLElBQUkxQixPQUFPZ0QsTUFBTSxDQUFDWSxJQUFJLEVBQUU3QixLQUFLaUIsTUFBTSxDQUFDWSxJQUFJO1lBQ3hDLElBQUkwRyxLQUFLdEssUUFBUU8sS0FBS3dCLElBQ2xCd0QsYUFBYTtRQUNyQjtJQUNKO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNpRixpQkFBaUI3RSxDQUFDLEVBQUVDLENBQUM7SUFDMUIsT0FBT0QsRUFBRTNDLE1BQU0sQ0FBQ3RCLE1BQU0sSUFBSWtFLEVBQUU1QyxNQUFNLENBQUN0QixNQUFNLElBQ3JDaUUsRUFBRTNDLE1BQU0sQ0FBQ3lILE1BQU0sQ0FBQyxDQUFDeEgsR0FBR1csSUFBTVgsRUFBRXVCLEtBQUssSUFBSW9CLEVBQUU1QyxNQUFNLENBQUNZLEVBQUUsQ0FBQ1ksS0FBSyxFQUFFOUMsTUFBTSxLQUFLO0FBQzNFO0FBQ0EsU0FBU2dKLEtBQUsvRSxDQUFDLEVBQUVDLENBQUM7SUFDZCxPQUFPLENBQUNELEVBQUVqRSxNQUFNLEdBQUdrRSxJQUFJLENBQUNBLEVBQUVsRSxNQUFNLEdBQUdpRSxJQUFJQSxFQUFFbUUsTUFBTSxDQUFDbEU7QUFDcEQ7QUFDQSxNQUFNK0QsT0FBTyxFQUFFO0FBQ2YsTUFBTWdCLHdCQUF3QjtBQUM5QixTQUFTL0QsYUFBYWtDLE1BQU0sRUFBRWhKLFNBQVM7SUFDbkMsSUFBSSxDQUFDZ0osT0FBT3BILE1BQU0sRUFBRTtRQUNoQixPQUFPO1lBQUMyRSxVQUFVdkcsU0FBUyxDQUFDO2dCQUFDQTthQUFVO1NBQUU7SUFDN0MsT0FDSztRQUNELElBQUk4SyxZQUFZOUIsTUFBTSxDQUFDQSxPQUFPcEgsTUFBTSxHQUFHLEVBQUU7UUFDekMsSUFBSW1KLE9BQU9ELFVBQVV2QixlQUFlLENBQUM5RyxLQUFLLENBQUNpRCxLQUFLQyxHQUFHLENBQUMsR0FBR21GLFVBQVV2QixlQUFlLENBQUMzSCxNQUFNLEdBQUdpSjtRQUMxRixJQUFJRSxLQUFLbkosTUFBTSxJQUFJbUosSUFBSSxDQUFDQSxLQUFLbkosTUFBTSxHQUFHLEVBQUUsQ0FBQ29KLEVBQUUsQ0FBQ2hMLFlBQ3hDLE9BQU9nSjtRQUNYK0IsS0FBS3hILElBQUksQ0FBQ3ZEO1FBQ1YsT0FBTzZHLGFBQWFtQyxRQUFRQSxPQUFPcEgsTUFBTSxHQUFHLEdBQUcsS0FBS2tKLFVBQVV0QixXQUFXLENBQUN1QjtJQUM5RTtBQUNKO0FBQ0EsNkRBQTZEO0FBQzdELFNBQVNFLGFBQWFqQyxNQUFNO0lBQ3hCLElBQUkxRixPQUFPMEYsTUFBTSxDQUFDQSxPQUFPcEgsTUFBTSxHQUFHLEVBQUU7SUFDcEMsSUFBSTBJLFlBQVl0QixPQUFPdkcsS0FBSztJQUM1QjZILFNBQVMsQ0FBQ3RCLE9BQU9wSCxNQUFNLEdBQUcsRUFBRSxHQUFHMEIsS0FBS2tHLFdBQVcsQ0FBQ2xHLEtBQUtpRyxlQUFlLENBQUM5RyxLQUFLLENBQUMsR0FBR2EsS0FBS2lHLGVBQWUsQ0FBQzNILE1BQU0sR0FBRztJQUM1RyxPQUFPMEk7QUFDWDtBQUNBLG1FQUFtRTtBQUNuRSw2REFBNkQ7QUFDN0QsMENBQTBDO0FBQzFDLFNBQVNZLG1CQUFtQmxDLE1BQU0sRUFBRW1DLE9BQU87SUFDdkMsSUFBSSxDQUFDbkMsT0FBT3BILE1BQU0sRUFDZCxPQUFPb0g7SUFDWCxJQUFJcEgsU0FBU29ILE9BQU9wSCxNQUFNLEVBQUVzSSxhQUFhTDtJQUN6QyxNQUFPakksT0FBUTtRQUNYLElBQUl5RixRQUFRK0QsU0FBU3BDLE1BQU0sQ0FBQ3BILFNBQVMsRUFBRSxFQUFFdUosU0FBU2pCO1FBQ2xELElBQUk3QyxNQUFNdEQsT0FBTyxJQUFJLENBQUNzRCxNQUFNdEQsT0FBTyxDQUFDVyxLQUFLLElBQUkyQyxNQUFNK0IsT0FBTyxDQUFDeEgsTUFBTSxFQUFFO1lBQy9ELElBQUltSSxTQUFTZixPQUFPdkcsS0FBSyxDQUFDLEdBQUdiO1lBQzdCbUksTUFBTSxDQUFDbkksU0FBUyxFQUFFLEdBQUd5RjtZQUNyQixPQUFPMEM7UUFDWCxPQUNLO1lBQ0RvQixVQUFVOUQsTUFBTWdDLE1BQU07WUFDdEJ6SDtZQUNBc0ksYUFBYTdDLE1BQU1rQyxlQUFlO1FBQ3RDO0lBQ0o7SUFDQSxPQUFPVyxXQUFXdEksTUFBTSxHQUFHO1FBQUMyRSxVQUFVdkcsU0FBUyxDQUFDa0s7S0FBWSxHQUFHTDtBQUNuRTtBQUNBLFNBQVN1QixTQUFTL0QsS0FBSyxFQUFFOEQsT0FBTyxFQUFFRSxlQUFlO0lBQzdDLElBQUluQixhQUFhVSxLQUFLdkQsTUFBTWtDLGVBQWUsQ0FBQzNILE1BQU0sR0FBR3lGLE1BQU1rQyxlQUFlLENBQUM3RixHQUFHLENBQUNuQyxDQUFBQSxJQUFLQSxFQUFFbUMsR0FBRyxDQUFDeUgsWUFBWXRCLE1BQU13QjtJQUM1Ryx1RkFBdUY7SUFDdkYsSUFBSSxDQUFDaEUsTUFBTXRELE9BQU8sRUFDZCxPQUFPd0MsVUFBVXZHLFNBQVMsQ0FBQ2tLO0lBQy9CLElBQUlvQixnQkFBZ0JqRSxNQUFNdEQsT0FBTyxDQUFDTCxHQUFHLENBQUN5SCxVQUFVSSxTQUFTSixRQUFRSyxPQUFPLENBQUNuRSxNQUFNdEQsT0FBTyxFQUFFO0lBQ3hGLElBQUkwSCxjQUFjcEUsTUFBTWdDLE1BQU0sR0FBR2hDLE1BQU1nQyxNQUFNLENBQUNxQyxXQUFXLENBQUNILFVBQVVBO0lBQ3BFLE9BQU8sSUFBSWhGLFVBQVUrRSxlQUFlM00sMERBQVdBLENBQUNnTixVQUFVLENBQUN0RSxNQUFNK0IsT0FBTyxFQUFFK0IsVUFBVU0sYUFBYXBFLE1BQU1pQyxjQUFjLENBQUM1RixHQUFHLENBQUM2SCxTQUFTckI7QUFDdkk7QUFDQSxNQUFNMEIsb0JBQW9CO0FBQzFCLE1BQU0xRjtJQUNGaUQsWUFBWXZDLElBQUksRUFBRUQsTUFBTSxFQUFFa0YsV0FBVyxDQUFDLEVBQUVDLGdCQUFnQjdCLFNBQVMsQ0FBRTtRQUMvRCxJQUFJLENBQUNyRCxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDRCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDa0YsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLGFBQWEsR0FBR0E7SUFDekI7SUFDQTdFLFVBQVU7UUFDTixPQUFPLElBQUksQ0FBQzRFLFFBQVEsR0FBRyxJQUFJM0YsYUFBYSxJQUFJLENBQUNVLElBQUksRUFBRSxJQUFJLENBQUNELE1BQU0sSUFBSSxJQUFJO0lBQzFFO0lBQ0FhLFdBQVdILEtBQUssRUFBRUMsSUFBSSxFQUFFQyxTQUFTLEVBQUVwSCxNQUFNLEVBQUVVLEVBQUUsRUFBRTtRQUMzQyxJQUFJK0YsT0FBTyxJQUFJLENBQUNBLElBQUksRUFBRWtFLFlBQVlsRSxJQUFJLENBQUNBLEtBQUtoRixNQUFNLEdBQUcsRUFBRTtRQUN2RCxJQUFJa0osYUFBYUEsVUFBVS9HLE9BQU8sSUFBSSxDQUFDK0csVUFBVS9HLE9BQU8sQ0FBQ1csS0FBSyxJQUFJMkMsTUFBTXRELE9BQU8sSUFDMUUsRUFBQ3dELGFBQWFxRSxrQkFBa0I1SSxJQUFJLENBQUN1RSxVQUFTLEtBQzlDLEVBQUV1RCxVQUFVdkIsZUFBZSxDQUFDM0gsTUFBTSxJQUMvQjBGLE9BQU8sSUFBSSxDQUFDdUUsUUFBUSxHQUFHMUwsT0FBT21GLGFBQWEsSUFDM0NuRixPQUFPb0YsV0FBVyxDQUFDMUUsSUFBSTRFLFdBQVdxRixVQUFVL0csT0FBTyxFQUFFc0QsTUFBTXRELE9BQU8sTUFDbEUsOEVBQThFO1FBQzlFd0QsYUFBYSxvQkFBbUIsR0FBSTtZQUN4Q1gsT0FBT0MsYUFBYUQsTUFBTUEsS0FBS2hGLE1BQU0sR0FBRyxHQUFHekIsT0FBT2tGLFFBQVEsRUFBRSxJQUFJa0IsVUFBVWMsTUFBTXRELE9BQU8sQ0FBQ2dJLE9BQU8sQ0FBQ2pCLFVBQVUvRyxPQUFPLEdBQUc2RyxLQUFLak0sMERBQVdBLENBQUNnTixVQUFVLENBQUN0RSxNQUFNK0IsT0FBTyxFQUFFMEIsVUFBVS9HLE9BQU8sR0FBRytHLFVBQVUxQixPQUFPLEdBQUcwQixVQUFVekIsTUFBTSxFQUFFeUIsVUFBVXhCLGNBQWMsRUFBRU87UUFDdlAsT0FDSztZQUNEakQsT0FBT0MsYUFBYUQsTUFBTUEsS0FBS2hGLE1BQU0sRUFBRXpCLE9BQU9rRixRQUFRLEVBQUVnQztRQUM1RDtRQUNBLE9BQU8sSUFBSW5CLGFBQWFVLE1BQU1pRCxNQUFNdkMsTUFBTUM7SUFDOUM7SUFDQVQsYUFBYTlHLFNBQVMsRUFBRXNILElBQUksRUFBRUMsU0FBUyxFQUFFakMsYUFBYSxFQUFFO1FBQ3BELElBQUloQyxPQUFPLElBQUksQ0FBQ3NELElBQUksQ0FBQ2hGLE1BQU0sR0FBRyxJQUFJLENBQUNnRixJQUFJLENBQUMsSUFBSSxDQUFDQSxJQUFJLENBQUNoRixNQUFNLEdBQUcsRUFBRSxDQUFDMkgsZUFBZSxHQUFHTTtRQUNoRixJQUFJdkcsS0FBSzFCLE1BQU0sR0FBRyxLQUNkMEYsT0FBTyxJQUFJLENBQUN1RSxRQUFRLEdBQUd2RyxpQkFDdkJpQyxhQUFhLElBQUksQ0FBQ3VFLGFBQWEsSUFBSXZFLGFBQWEsZ0JBQWdCdkUsSUFBSSxDQUFDdUUsY0FDckVtRCxpQkFBaUJwSCxJQUFJLENBQUNBLEtBQUsxQixNQUFNLEdBQUcsRUFBRSxFQUFFNUIsWUFDeEMsT0FBTyxJQUFJO1FBQ2YsT0FBTyxJQUFJa0csYUFBYVksYUFBYSxJQUFJLENBQUNGLElBQUksRUFBRTVHLFlBQVksSUFBSSxDQUFDMkcsTUFBTSxFQUFFVyxNQUFNQztJQUNuRjtJQUNBSixXQUFXZ0UsT0FBTyxFQUFFO1FBQ2hCLE9BQU8sSUFBSWpGLGFBQWFnRixtQkFBbUIsSUFBSSxDQUFDdEUsSUFBSSxFQUFFdUUsVUFBVUQsbUJBQW1CLElBQUksQ0FBQ3ZFLE1BQU0sRUFBRXdFLFVBQVUsSUFBSSxDQUFDVSxRQUFRLEVBQUUsSUFBSSxDQUFDQyxhQUFhO0lBQy9JO0lBQ0FuRCxJQUFJbEMsSUFBSSxFQUFFN0csS0FBSyxFQUFFb00sYUFBYSxFQUFFO1FBQzVCLElBQUloRCxTQUFTdkMsUUFBUSxFQUFFLG1CQUFtQixNQUFLLElBQUksQ0FBQ0csSUFBSSxHQUFHLElBQUksQ0FBQ0QsTUFBTTtRQUN0RSxJQUFJcUMsT0FBT3BILE1BQU0sSUFBSSxHQUNqQixPQUFPO1FBQ1gsSUFBSXlGLFFBQVEyQixNQUFNLENBQUNBLE9BQU9wSCxNQUFNLEdBQUcsRUFBRSxFQUFFNUIsWUFBWXFILE1BQU1rQyxlQUFlLENBQUMsRUFBRSxJQUFJM0osTUFBTUksU0FBUztRQUM5RixJQUFJZ00saUJBQWlCM0UsTUFBTWtDLGVBQWUsQ0FBQzNILE1BQU0sRUFBRTtZQUMvQyxPQUFPaEMsTUFBTWtCLE1BQU0sQ0FBQztnQkFDaEJkLFdBQVdxSCxNQUFNa0MsZUFBZSxDQUFDbEMsTUFBTWtDLGVBQWUsQ0FBQzNILE1BQU0sR0FBRyxFQUFFO2dCQUNsRXFLLGFBQWFuSCxZQUFZaUQsRUFBRSxDQUFDO29CQUFFdEI7b0JBQU1PLE1BQU1pRSxhQUFhakM7b0JBQVNoSjtnQkFBVTtnQkFDMUV1SCxXQUFXZCxRQUFRLEVBQUUsbUJBQW1CLE1BQUssZ0JBQWdCO2dCQUM3RHlGLGdCQUFnQjtZQUNwQjtRQUNKLE9BQ0ssSUFBSSxDQUFDN0UsTUFBTXRELE9BQU8sRUFBRTtZQUNyQixPQUFPO1FBQ1gsT0FDSztZQUNELElBQUlpRCxPQUFPZ0MsT0FBT3BILE1BQU0sSUFBSSxJQUFJaUksT0FBT2IsT0FBT3ZHLEtBQUssQ0FBQyxHQUFHdUcsT0FBT3BILE1BQU0sR0FBRztZQUN2RSxJQUFJeUYsTUFBTWdDLE1BQU0sRUFDWnJDLE9BQU9rRSxtQkFBbUJsRSxNQUFNSyxNQUFNZ0MsTUFBTTtZQUNoRCxPQUFPekosTUFBTWtCLE1BQU0sQ0FBQztnQkFDaEJpRCxTQUFTc0QsTUFBTXRELE9BQU87Z0JBQ3RCL0QsV0FBV3FILE1BQU1pQyxjQUFjO2dCQUMvQkYsU0FBUy9CLE1BQU0rQixPQUFPO2dCQUN0QjZDLGFBQWFuSCxZQUFZaUQsRUFBRSxDQUFDO29CQUFFdEI7b0JBQU1PO29CQUFNaEg7Z0JBQVU7Z0JBQ3BEMkssUUFBUTtnQkFDUnBELFdBQVdkLFFBQVEsRUFBRSxtQkFBbUIsTUFBSyxTQUFTO2dCQUN0RHlGLGdCQUFnQjtZQUNwQjtRQUNKO0lBQ0o7QUFDSjtBQUNBaEcsYUFBYXhCLEtBQUssR0FBRyxXQUFXLEdBQUUsSUFBSXdCLGFBQWEyRCxNQUFNQTtBQUN6RDs7Ozs7OztBQU9BLEdBQ0EsTUFBTXNDLGdCQUFnQjtJQUNsQjtRQUFFQyxLQUFLO1FBQVNDLEtBQUtqRTtRQUFNRSxnQkFBZ0I7SUFBSztJQUNoRDtRQUFFOEQsS0FBSztRQUFTRSxLQUFLO1FBQWVELEtBQUtoRTtRQUFNQyxnQkFBZ0I7SUFBSztJQUNwRTtRQUFFaUUsT0FBTztRQUFnQkYsS0FBS2hFO1FBQU1DLGdCQUFnQjtJQUFLO0lBQ3pEO1FBQUU4RCxLQUFLO1FBQVNDLEtBQUt6RDtRQUFlTixnQkFBZ0I7SUFBSztJQUN6RDtRQUFFOEQsS0FBSztRQUFTRSxLQUFLO1FBQWVELEtBQUt4RDtRQUFlUCxnQkFBZ0I7SUFBSztDQUNoRjtBQUVELFNBQVNrRSxVQUFVQyxHQUFHLEVBQUVDLEVBQUU7SUFDdEIsT0FBT2hPLDhEQUFlQSxDQUFDdUgsTUFBTSxDQUFDd0csSUFBSXZKLE1BQU0sQ0FBQ1EsR0FBRyxDQUFDZ0osS0FBS0QsSUFBSUUsU0FBUztBQUNuRTtBQUNBLFNBQVNDLE9BQU9oTixLQUFLLEVBQUVJLFNBQVM7SUFDNUIsT0FBT0osTUFBTWtCLE1BQU0sQ0FBQztRQUFFZDtRQUFXa00sZ0JBQWdCO1FBQU0zRSxXQUFXO0lBQVM7QUFDL0U7QUFDQSxTQUFTc0YsUUFBUSxFQUFFak4sS0FBSyxFQUFFZSxRQUFRLEVBQUUsRUFBRW1NLEdBQUc7SUFDckMsSUFBSTlNLFlBQVl3TSxVQUFVNU0sTUFBTUksU0FBUyxFQUFFOE07SUFDM0MsSUFBSTlNLFVBQVVnTCxFQUFFLENBQUNwTCxNQUFNSSxTQUFTLEVBQUUsT0FDOUIsT0FBTztJQUNYVyxTQUFTaU0sT0FBT2hOLE9BQU9JO0lBQ3ZCLE9BQU87QUFDWDtBQUNBLFNBQVMrTSxTQUFTL0ksS0FBSyxFQUFFZ0osT0FBTztJQUM1QixPQUFPdE8sOERBQWVBLENBQUN1TyxNQUFNLENBQUNELFVBQVVoSixNQUFNL0IsRUFBRSxHQUFHK0IsTUFBTTlELElBQUk7QUFDakU7QUFDQSxTQUFTZ04sYUFBYWhGLElBQUksRUFBRThFLE9BQU87SUFDL0IsT0FBT0gsUUFBUTNFLE1BQU1sRSxDQUFBQSxRQUFTQSxNQUFNVSxLQUFLLEdBQUd3RCxLQUFLaUYsVUFBVSxDQUFDbkosT0FBT2dKLFdBQVdELFNBQVMvSSxPQUFPZ0o7QUFDbEc7QUFDQSxTQUFTSSxZQUFZbEYsSUFBSTtJQUNyQixPQUFPQSxLQUFLbUYsZUFBZSxDQUFDbkYsS0FBS3RJLEtBQUssQ0FBQ0ksU0FBUyxDQUFDQyxJQUFJLENBQUNxTixJQUFJLEtBQUtyTyx1REFBU0EsQ0FBQ3NPLEdBQUc7QUFDaEY7QUFDQTs7O0FBR0EsR0FDQSxNQUFNQyxpQkFBaUJ0RixDQUFBQSxPQUFRZ0YsYUFBYWhGLE1BQU0sQ0FBQ2tGLFlBQVlsRjtBQUMvRDs7QUFFQSxHQUNBLE1BQU11RixrQkFBa0J2RixDQUFBQSxPQUFRZ0YsYUFBYWhGLE1BQU1rRixZQUFZbEY7QUFDL0Q7O0FBRUEsR0FDQSxNQUFNd0Ysb0JBQW9CeEYsQ0FBQUEsT0FBUWdGLGFBQWFoRixNQUFNO0FBQ3JEOztBQUVBLEdBQ0EsTUFBTXlGLHFCQUFxQnpGLENBQUFBLE9BQVFnRixhQUFhaEYsTUFBTTtBQUN0RCxTQUFTMEYsY0FBY2hPLEtBQUssRUFBRW9FLEtBQUssRUFBRWdKLE9BQU87SUFDeEMsSUFBSXZMLE1BQU11QyxNQUFNc0osSUFBSSxFQUFFek4sT0FBT0QsTUFBTUUsR0FBRyxDQUFDQyxNQUFNLENBQUMwQjtJQUM5QyxJQUFJQSxPQUFRdUwsQ0FBQUEsVUFBVW5OLEtBQUtvQyxFQUFFLEdBQUdwQyxLQUFLSyxJQUFJLEdBQ3JDdUIsTUFBTXVMLFVBQVV0SCxLQUFLRSxHQUFHLENBQUNoRyxNQUFNRSxHQUFHLENBQUM4QixNQUFNLEVBQUUvQixLQUFLb0MsRUFBRSxHQUFHLEtBQUt5RCxLQUFLQyxHQUFHLENBQUMsR0FBRzlGLEtBQUtLLElBQUksR0FBRztTQUVsRnVCLE1BQU01QixLQUFLSyxJQUFJLEdBQUdyQixtRUFBZ0JBLENBQUNnQixLQUFLMkQsSUFBSSxFQUFFL0IsTUFBTTVCLEtBQUtLLElBQUksRUFBRThNO0lBQ25FLE9BQU90Tyw4REFBZUEsQ0FBQ3VPLE1BQU0sQ0FBQ3hMLEtBQUt1TCxVQUFVLENBQUMsSUFBSTtBQUN0RDtBQUNBLFNBQVNhLGtCQUFrQmxPLE1BQU0sRUFBRXFOLE9BQU87SUFDdEMsT0FBT0gsUUFBUWxOLFFBQVFxRSxDQUFBQSxRQUFTQSxNQUFNVSxLQUFLLEdBQUdrSixjQUFjak8sT0FBT0MsS0FBSyxFQUFFb0UsT0FBT2dKLFdBQVdELFNBQVMvSSxPQUFPZ0o7QUFDaEg7QUFDQTs7O0FBR0EsR0FDQSxNQUFNYywyQkFBMkJuTyxDQUFBQSxTQUFVa08sa0JBQWtCbE8sUUFBUTtBQUNyRTs7O0FBR0EsR0FDQSxNQUFNb08sNEJBQTRCcE8sQ0FBQUEsU0FBVWtPLGtCQUFrQmxPLFFBQVE7QUFDdEUsU0FBU3FPLGNBQWM5RixJQUFJLEVBQUU4RSxPQUFPO0lBQ2hDLE9BQU9ILFFBQVEzRSxNQUFNbEUsQ0FBQUEsUUFBU0EsTUFBTVUsS0FBSyxHQUFHd0QsS0FBSytGLFdBQVcsQ0FBQ2pLLE9BQU9nSixXQUFXRCxTQUFTL0ksT0FBT2dKO0FBQ25HO0FBQ0E7OztBQUdBLEdBQ0EsTUFBTWtCLGtCQUFrQmhHLENBQUFBLE9BQVE4RixjQUFjOUYsTUFBTSxDQUFDa0YsWUFBWWxGO0FBQ2pFOztBQUVBLEdBQ0EsTUFBTWlHLG1CQUFtQmpHLENBQUFBLE9BQVE4RixjQUFjOUYsTUFBTWtGLFlBQVlsRjtBQUNqRTs7QUFFQSxHQUNBLE1BQU1rRyxxQkFBcUJsRyxDQUFBQSxPQUFROEYsY0FBYzlGLE1BQU07QUFDdkQ7O0FBRUEsR0FDQSxNQUFNbUcsc0JBQXNCbkcsQ0FBQUEsT0FBUThGLGNBQWM5RixNQUFNO0FBQ3hELFNBQVNvRyxhQUFhcEcsSUFBSSxFQUFFekcsR0FBRyxFQUFFNEksS0FBSztJQUNsQyxJQUFJa0UsYUFBYXJHLEtBQUt0SSxLQUFLLENBQUM0TyxlQUFlLENBQUMvTTtJQUM1QyxJQUFJZ04sTUFBTUYsV0FBV2xFLFFBQVFxRSxVQUFVRCxPQUFPMVAsMkRBQVlBLENBQUM0UCxLQUFLO0lBQ2hFLE9BQU8sQ0FBQ0M7UUFDSixJQUFJQyxVQUFVTixXQUFXSztRQUN6QixJQUFJQyxXQUFXOVAsMkRBQVlBLENBQUM0UCxLQUFLLEVBQzdCLE9BQU9ELFdBQVdHLFdBQVdKO1FBQ2pDQyxVQUFVO1FBQ1YsT0FBTztJQUNYO0FBQ0o7QUFDQTs7O0FBR0EsR0FDQSxNQUFNSSx3QkFBd0I1RyxDQUFBQTtJQUMxQixPQUFPMkUsUUFBUTNFLE1BQU1sRSxDQUFBQSxRQUFTQSxNQUFNVSxLQUFLLEdBQ25Dd0QsS0FBS2lGLFVBQVUsQ0FBQ25KLE9BQU8sTUFBTXFHLENBQUFBLFFBQVNpRSxhQUFhcEcsTUFBTWxFLE1BQU1zSixJQUFJLEVBQUVqRCxVQUNyRTBDLFNBQVMvSSxPQUFPO0FBQzFCO0FBQ0EsTUFBTStLLFlBQVksT0FBT0MsUUFBUSxlQUFlQSxLQUFLQyxTQUFTLEdBQzFELFdBQVcsR0FBRSxJQUFLRCxLQUFLQyxTQUFTLENBQUVoRixXQUFXO0lBQUVpRixhQUFhO0FBQU8sS0FBSztBQUM1RSxTQUFTQyxjQUFjakgsSUFBSSxFQUFFbEUsS0FBSyxFQUFFZ0osT0FBTztJQUN2QyxJQUFJdUIsYUFBYXJHLEtBQUt0SSxLQUFLLENBQUM0TyxlQUFlLENBQUN4SyxNQUFNOUQsSUFBSTtJQUN0RCxJQUFJdU8sTUFBTTFQLDJEQUFZQSxDQUFDNFAsS0FBSyxFQUFFbE4sTUFBTXVDLE1BQU05RCxJQUFJLEVBQUVrUCxRQUFRO0lBQ3hELElBQUl4SSxPQUFPLE9BQU95SSxXQUFXLE9BQU9DLFdBQVc7SUFDL0MsSUFBSUMsT0FBTyxDQUFDWDtRQUNSLElBQUloSSxNQUNBLE9BQU87UUFDWG5GLE9BQU91TCxVQUFVNEIsS0FBS2hOLE1BQU0sR0FBRyxDQUFDZ04sS0FBS2hOLE1BQU07UUFDM0MsSUFBSWlOLFVBQVVOLFdBQVdLLE9BQU9ZO1FBQ2hDLElBQUlYLFdBQVc5UCwyREFBWUEsQ0FBQzBRLElBQUksSUFBSWIsS0FBS2MsVUFBVSxDQUFDLEtBQUssT0FBTyxRQUFRMU0sSUFBSSxDQUFDNEwsT0FDekVDLFVBQVUsQ0FBQyxHQUFHLG1DQUFtQztRQUNyRCxJQUFJSixPQUFPMVAsMkRBQVlBLENBQUM0UCxLQUFLLEVBQ3pCRixNQUFNSTtRQUNWLElBQUlKLE9BQU9JLFNBQ1AsT0FBTztRQUNYLElBQUlKLE9BQU8xUCwyREFBWUEsQ0FBQzBRLElBQUksRUFBRTtZQUMxQixJQUFJYixLQUFLZSxXQUFXLE1BQU1mLE1BQU07Z0JBQzVCLElBQUksQ0FBQzVCLFdBQVdxQyxVQUNaLE9BQU87Z0JBQ1hDLFdBQVc7WUFDZixPQUNLLElBQUlBLFVBQVU7Z0JBQ2YsSUFBSXRDLFNBQ0EsT0FBTztnQkFDWHBHLE9BQU87WUFDWCxPQUNLO2dCQUNELElBQUl5SSxZQUFZckMsV0FBV3VCLFdBQVdpQixRQUFRdEgsS0FBS3RJLEtBQUssQ0FBQ3VDLFFBQVEsQ0FBQ1YsS0FBS0EsTUFBTSxPQUFPMUMsMkRBQVlBLENBQUMwUSxJQUFJLElBQ2pHRCxNQUFNRyxXQUFXLE1BQU1ILE9BQ3ZCLE9BQU87Z0JBQ1hILFdBQVc7WUFDZjtRQUNKO1FBQ0FEO1FBQ0EsT0FBTztJQUNYO0lBQ0EsSUFBSVEsTUFBTTFILEtBQUtpRixVQUFVLENBQUNuSixPQUFPZ0osU0FBUzNDLENBQUFBO1FBQ3RDa0YsS0FBS2xGO1FBQ0wsT0FBT2tGO0lBQ1g7SUFDQSxJQUFJUixhQUFhTixPQUFPMVAsMkRBQVlBLENBQUMwUSxJQUFJLElBQUlHLElBQUkxUCxJQUFJLElBQUk4RCxNQUFNOUQsSUFBSSxHQUFHa1AsUUFBU3BDLENBQUFBLFVBQVUsSUFBSSxDQUFDLElBQUk7UUFDOUYsSUFBSTlNLE9BQU93RixLQUFLRSxHQUFHLENBQUM1QixNQUFNc0osSUFBSSxFQUFFc0MsSUFBSXRDLElBQUksR0FBR3JMLEtBQUt5RCxLQUFLQyxHQUFHLENBQUMzQixNQUFNc0osSUFBSSxFQUFFc0MsSUFBSXRDLElBQUk7UUFDN0UsSUFBSXVDLFVBQVUzSCxLQUFLdEksS0FBSyxDQUFDdUMsUUFBUSxDQUFDakMsTUFBTStCO1FBQ3hDLElBQUk0TixRQUFRak8sTUFBTSxHQUFHLEtBQUssa0JBQWtCb0IsSUFBSSxDQUFDNk0sVUFBVTtZQUN2RCxJQUFJQyxXQUFXQyxNQUFNN1AsSUFBSSxDQUFDNk8sVUFBVWlCLE9BQU8sQ0FBQ0g7WUFDNUMsSUFBSUMsU0FBU2xPLE1BQU0sR0FBRyxHQUFHO2dCQUNyQixJQUFJb0wsU0FDQSxPQUFPdE8sOERBQWVBLENBQUN1TyxNQUFNLENBQUNqSixNQUFNc0osSUFBSSxHQUFHd0MsUUFBUSxDQUFDLEVBQUUsQ0FBQ0csS0FBSyxFQUFFLENBQUM7Z0JBQ25FLE9BQU92Uiw4REFBZUEsQ0FBQ3VPLE1BQU0sQ0FBQzJDLElBQUl0QyxJQUFJLEdBQUd3QyxRQUFRLENBQUNBLFNBQVNsTyxNQUFNLEdBQUcsRUFBRSxDQUFDcU8sS0FBSyxFQUFFO1lBQ2xGO1FBQ0o7SUFDSjtJQUNBLE9BQU9MO0FBQ1g7QUFDQSxTQUFTTSxnQkFBZ0JoSSxJQUFJLEVBQUU4RSxPQUFPO0lBQ2xDLE9BQU9ILFFBQVEzRSxNQUFNbEUsQ0FBQUEsUUFBU0EsTUFBTVUsS0FBSyxHQUFHeUssY0FBY2pILE1BQU1sRSxPQUFPZ0osV0FBV0QsU0FBUy9JLE9BQU9nSjtBQUN0RztBQUNBOztBQUVBLEdBQ0EsTUFBTW1ELHVCQUF1QmpJLENBQUFBLE9BQVFnSSxnQkFBZ0JoSSxNQUFNO0FBQzNEOztBQUVBLEdBQ0EsTUFBTWtJLHdCQUF3QmxJLENBQUFBLE9BQVFnSSxnQkFBZ0JoSSxNQUFNO0FBQzVELFNBQVNtSSxnQkFBZ0J6USxLQUFLLEVBQUUwUSxJQUFJLEVBQUVDLFdBQVc7SUFDN0MsSUFBSUQsS0FBS0UsSUFBSSxDQUFDQyxJQUFJLENBQUNGLGNBQ2YsT0FBTztJQUNYLElBQUlHLE1BQU1KLEtBQUtyTyxFQUFFLEdBQUdxTyxLQUFLcFEsSUFBSTtJQUM3QixPQUFPd1EsT0FBUUEsQ0FBQUEsTUFBTSxLQUFLLFlBQVkxTixJQUFJLENBQUNwRCxNQUFNdUMsUUFBUSxDQUFDbU8sS0FBS3BRLElBQUksRUFBRW9RLEtBQUtyTyxFQUFFLEVBQUMsS0FBTXFPLEtBQUtLLFVBQVU7QUFDdEc7QUFDQSxTQUFTQyxhQUFhaFIsS0FBSyxFQUFFeUssS0FBSyxFQUFFMkMsT0FBTztJQUN2QyxJQUFJdkwsTUFBTW5DLGdFQUFVQSxDQUFDTSxPQUFPaVIsWUFBWSxDQUFDeEcsTUFBTWlELElBQUk7SUFDbkQsSUFBSWlELGNBQWN2RCxVQUFVdk4sbURBQVFBLENBQUNxUixRQUFRLEdBQUdyUixtREFBUUEsQ0FBQ3NSLFFBQVE7SUFDakUsb0VBQW9FO0lBQ3BFLGNBQWM7SUFDZCxJQUFLLElBQUlDLEtBQUszRyxNQUFNaUQsSUFBSSxHQUFJO1FBQ3hCLElBQUlzQixPQUFPNUIsVUFBVXZMLElBQUl3UCxVQUFVLENBQUNELE1BQU12UCxJQUFJeVAsV0FBVyxDQUFDRjtRQUMxRCxJQUFJLENBQUNwQyxNQUNEO1FBQ0osSUFBSXlCLGdCQUFnQnpRLE9BQU9nUCxNQUFNMkIsY0FDN0I5TyxNQUFNbU47YUFFTm9DLEtBQUtoRSxVQUFVNEIsS0FBSzNNLEVBQUUsR0FBRzJNLEtBQUsxTyxJQUFJO0lBQzFDO0lBQ0EsSUFBSWlSLFVBQVUxUCxJQUFJK08sSUFBSSxDQUFDQyxJQUFJLENBQUNGLGNBQWNhLE9BQU9DO0lBQ2pELElBQUlGLFdBQVlDLENBQUFBLFFBQVFwRSxVQUFVM04sbUVBQWFBLENBQUNPLE9BQU82QixJQUFJdkIsSUFBSSxFQUFFLEtBQUtiLG1FQUFhQSxDQUFDTyxPQUFPNkIsSUFBSVEsRUFBRSxFQUFFLENBQUMsRUFBQyxLQUFNbVAsTUFBTUUsT0FBTyxFQUNwSEQsU0FBU3JFLFVBQVVvRSxNQUFNeEIsR0FBRyxDQUFDM04sRUFBRSxHQUFHbVAsTUFBTXhCLEdBQUcsQ0FBQzFQLElBQUk7U0FFaERtUixTQUFTckUsVUFBVXZMLElBQUlRLEVBQUUsR0FBR1IsSUFBSXZCLElBQUk7SUFDeEMsT0FBT3hCLDhEQUFlQSxDQUFDdU8sTUFBTSxDQUFDb0UsUUFBUXJFLFVBQVUsQ0FBQyxJQUFJO0FBQ3pEO0FBQ0E7O0FBRUEsR0FDQSxNQUFNdUUsbUJBQW1CckosQ0FBQUEsT0FBUTJFLFFBQVEzRSxNQUFNbEUsQ0FBQUEsUUFBUzRNLGFBQWExSSxLQUFLdEksS0FBSyxFQUFFb0UsT0FBTyxDQUFDb0osWUFBWWxGO0FBQ3JHOztBQUVBLEdBQ0EsTUFBTXNKLG9CQUFvQnRKLENBQUFBLE9BQVEyRSxRQUFRM0UsTUFBTWxFLENBQUFBLFFBQVM0TSxhQUFhMUksS0FBS3RJLEtBQUssRUFBRW9FLE9BQU9vSixZQUFZbEY7QUFDckcsU0FBU3VKLGFBQWF2SixJQUFJLEVBQUU4RSxPQUFPO0lBQy9CLE9BQU9ILFFBQVEzRSxNQUFNbEUsQ0FBQUE7UUFDakIsSUFBSSxDQUFDQSxNQUFNVSxLQUFLLEVBQ1osT0FBT3FJLFNBQVMvSSxPQUFPZ0o7UUFDM0IsSUFBSTBFLFFBQVF4SixLQUFLeUosY0FBYyxDQUFDM04sT0FBT2dKO1FBQ3ZDLE9BQU8wRSxNQUFNcEUsSUFBSSxJQUFJdEosTUFBTXNKLElBQUksR0FBR29FLFFBQVF4SixLQUFLMEosa0JBQWtCLENBQUM1TixPQUFPZ0o7SUFDN0U7QUFDSjtBQUNBOztBQUVBLEdBQ0EsTUFBTTZFLGVBQWUzSixDQUFBQSxPQUFRdUosYUFBYXZKLE1BQU07QUFDaEQ7O0FBRUEsR0FDQSxNQUFNNEosaUJBQWlCNUosQ0FBQUEsT0FBUXVKLGFBQWF2SixNQUFNO0FBQ2xELFNBQVM2SixTQUFTN0osSUFBSTtJQUNsQixJQUFJOEosYUFBYTlKLEtBQUsrSixTQUFTLENBQUNDLFlBQVksR0FBR2hLLEtBQUsrSixTQUFTLENBQUNFLFlBQVksR0FBRztJQUM3RSxJQUFJQyxZQUFZLEdBQUdDLGVBQWUsR0FBR0M7SUFDckMsSUFBSU4sWUFBWTtRQUNaLEtBQUssSUFBSU8sVUFBVXJLLEtBQUt0SSxLQUFLLENBQUN1RyxLQUFLLENBQUNuSCx3REFBVUEsQ0FBQ3dULGFBQWEsRUFBRztZQUMzRCxJQUFJQyxVQUFVRixPQUFPcks7WUFDckIsSUFBSXVLLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRQyxHQUFHLEVBQzdETixZQUFZMU0sS0FBS0MsR0FBRyxDQUFDOE0sWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFDLEdBQUcsRUFBRU47WUFDeEYsSUFBSUssWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFFLE1BQU0sRUFDaEVOLGVBQWUzTSxLQUFLQyxHQUFHLENBQUM4TSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUUUsTUFBTSxFQUFFTjtRQUNsRztRQUNBQyxTQUFTcEssS0FBSytKLFNBQVMsQ0FBQ0MsWUFBWSxHQUFHRSxZQUFZQztJQUN2RCxPQUNLO1FBQ0RDLFNBQVMsQ0FBQ3BLLEtBQUswSyxHQUFHLENBQUNDLGFBQWEsQ0FBQ0MsV0FBVyxJQUFJQyxNQUFLLEVBQUdDLFdBQVc7SUFDdkU7SUFDQSxPQUFPO1FBQUVaO1FBQVdDO1FBQWNMO1FBQzlCTSxRQUFRNU0sS0FBS0MsR0FBRyxDQUFDdUMsS0FBSytLLGlCQUFpQixFQUFFWCxTQUFTO0lBQUc7QUFDN0Q7QUFDQSxTQUFTWSxhQUFhaEwsSUFBSSxFQUFFOEUsT0FBTztJQUMvQixJQUFJbUcsT0FBT3BCLFNBQVM3SjtJQUNwQixJQUFJLEVBQUV0SSxLQUFLLEVBQUUsR0FBR3NJLE1BQU1sSSxZQUFZd00sVUFBVTVNLE1BQU1JLFNBQVMsRUFBRWdFLENBQUFBO1FBQ3pELE9BQU9BLE1BQU1VLEtBQUssR0FBR3dELEtBQUt5SixjQUFjLENBQUMzTixPQUFPZ0osU0FBU21HLEtBQUtiLE1BQU0sSUFDOUR2RixTQUFTL0ksT0FBT2dKO0lBQzFCO0lBQ0EsSUFBSWhOLFVBQVVnTCxFQUFFLENBQUNwTCxNQUFNSSxTQUFTLEdBQzVCLE9BQU87SUFDWCxJQUFJb1Q7SUFDSixJQUFJRCxLQUFLbkIsVUFBVSxFQUFFO1FBQ2pCLElBQUlxQixXQUFXbkwsS0FBS29MLFdBQVcsQ0FBQzFULE1BQU1JLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDcU4sSUFBSTtRQUN6RCxJQUFJaUcsYUFBYXJMLEtBQUsrSixTQUFTLENBQUN1QixxQkFBcUI7UUFDckQsSUFBSUMsWUFBWUYsV0FBV2IsR0FBRyxHQUFHUyxLQUFLZixTQUFTLEVBQUVzQixlQUFlSCxXQUFXWixNQUFNLEdBQUdRLEtBQUtkLFlBQVk7UUFDckcsSUFBSWdCLFlBQVlBLFNBQVNYLEdBQUcsR0FBR2UsYUFBYUosU0FBU1YsTUFBTSxHQUFHZSxjQUMxRE4sU0FBU3BVLHdEQUFVQSxDQUFDa04sY0FBYyxDQUFDbE0sVUFBVUMsSUFBSSxDQUFDcU4sSUFBSSxFQUFFO1lBQUVxRyxHQUFHO1lBQVNDLFNBQVNQLFNBQVNYLEdBQUcsR0FBR2U7UUFBVTtJQUNoSDtJQUNBdkwsS0FBS3ZILFFBQVEsQ0FBQ2lNLE9BQU9oTixPQUFPSSxZQUFZO1FBQUVvSixTQUFTZ0s7SUFBTztJQUMxRCxPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU1TLGVBQWUzTCxDQUFBQSxPQUFRZ0wsYUFBYWhMLE1BQU07QUFDaEQ7O0FBRUEsR0FDQSxNQUFNNEwsaUJBQWlCNUwsQ0FBQUEsT0FBUWdMLGFBQWFoTCxNQUFNO0FBQ2xELFNBQVM2TCxtQkFBbUI3TCxJQUFJLEVBQUVtQyxLQUFLLEVBQUUyQyxPQUFPO0lBQzVDLElBQUluTixPQUFPcUksS0FBSzhMLFdBQVcsQ0FBQzNKLE1BQU1pRCxJQUFJLEdBQUdvRSxRQUFReEosS0FBSzBKLGtCQUFrQixDQUFDdkgsT0FBTzJDO0lBQ2hGLElBQUkwRSxNQUFNcEUsSUFBSSxJQUFJakQsTUFBTWlELElBQUksSUFBSW9FLE1BQU1wRSxJQUFJLElBQUtOLENBQUFBLFVBQVVuTixLQUFLb0MsRUFBRSxHQUFHcEMsS0FBS0ssSUFBSSxHQUN4RXdSLFFBQVF4SixLQUFLMEosa0JBQWtCLENBQUN2SCxPQUFPMkMsU0FBUztJQUNwRCxJQUFJLENBQUNBLFdBQVcwRSxNQUFNcEUsSUFBSSxJQUFJek4sS0FBS0ssSUFBSSxJQUFJTCxLQUFLK0IsTUFBTSxFQUFFO1FBQ3BELElBQUlxUyxRQUFRLE9BQU8zUixJQUFJLENBQUM0RixLQUFLdEksS0FBSyxDQUFDdUMsUUFBUSxDQUFDdEMsS0FBS0ssSUFBSSxFQUFFd0YsS0FBS0UsR0FBRyxDQUFDL0YsS0FBS0ssSUFBSSxHQUFHLEtBQUtMLEtBQUtvQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUNMLE1BQU07UUFDckcsSUFBSXFTLFNBQVM1SixNQUFNaUQsSUFBSSxJQUFJek4sS0FBS0ssSUFBSSxHQUFHK1QsT0FDbkN2QyxRQUFRaFQsOERBQWVBLENBQUN1TyxNQUFNLENBQUNwTixLQUFLSyxJQUFJLEdBQUcrVDtJQUNuRDtJQUNBLE9BQU92QztBQUNYO0FBQ0E7OztBQUdBLEdBQ0EsTUFBTXdDLDRCQUE0QmhNLENBQUFBLE9BQVEyRSxRQUFRM0UsTUFBTWxFLENBQUFBLFFBQVMrUCxtQkFBbUI3TCxNQUFNbEUsT0FBTztBQUNqRzs7Ozs7QUFLQSxHQUNBLE1BQU1tUSw2QkFBNkJqTSxDQUFBQSxPQUFRMkUsUUFBUTNFLE1BQU1sRSxDQUFBQSxRQUFTK1AsbUJBQW1CN0wsTUFBTWxFLE9BQU87QUFDbEc7O0FBRUEsR0FDQSxNQUFNb1EseUJBQXlCbE0sQ0FBQUEsT0FBUTJFLFFBQVEzRSxNQUFNbEUsQ0FBQUEsUUFBUytQLG1CQUFtQjdMLE1BQU1sRSxPQUFPLENBQUNvSixZQUFZbEY7QUFDM0c7O0FBRUEsR0FDQSxNQUFNbU0sMEJBQTBCbk0sQ0FBQUEsT0FBUTJFLFFBQVEzRSxNQUFNbEUsQ0FBQUEsUUFBUytQLG1CQUFtQjdMLE1BQU1sRSxPQUFPb0osWUFBWWxGO0FBQzNHOztBQUVBLEdBQ0EsTUFBTW9NLGtCQUFrQnBNLENBQUFBLE9BQVEyRSxRQUFRM0UsTUFBTWxFLENBQUFBLFFBQVN0Riw4REFBZUEsQ0FBQ3VPLE1BQU0sQ0FBQy9FLEtBQUs4TCxXQUFXLENBQUNoUSxNQUFNc0osSUFBSSxFQUFFcE4sSUFBSSxFQUFFO0FBQ2pIOztBQUVBLEdBQ0EsTUFBTXFVLGdCQUFnQnJNLENBQUFBLE9BQVEyRSxRQUFRM0UsTUFBTWxFLENBQUFBLFFBQVN0Riw4REFBZUEsQ0FBQ3VPLE1BQU0sQ0FBQy9FLEtBQUs4TCxXQUFXLENBQUNoUSxNQUFNc0osSUFBSSxFQUFFckwsRUFBRSxFQUFFLENBQUM7QUFDOUcsU0FBU3VTLGtCQUFrQjVVLEtBQUssRUFBRWUsUUFBUSxFQUFFOFQsTUFBTTtJQUM5QyxJQUFJQyxRQUFRLE9BQU8xVSxZQUFZd00sVUFBVTVNLE1BQU1JLFNBQVMsRUFBRWdFLENBQUFBO1FBQ3RELElBQUkyUSxXQUFXdFYsbUVBQWFBLENBQUNPLE9BQU9vRSxNQUFNc0osSUFBSSxFQUFFLENBQUMsTUFDMUNqTyxtRUFBYUEsQ0FBQ08sT0FBT29FLE1BQU1zSixJQUFJLEVBQUUsTUFDaEN0SixNQUFNc0osSUFBSSxHQUFHLEtBQUtqTyxtRUFBYUEsQ0FBQ08sT0FBT29FLE1BQU1zSixJQUFJLEdBQUcsR0FBRyxNQUN2RHRKLE1BQU1zSixJQUFJLEdBQUcxTixNQUFNRSxHQUFHLENBQUM4QixNQUFNLElBQUl2QyxtRUFBYUEsQ0FBQ08sT0FBT29FLE1BQU1zSixJQUFJLEdBQUcsR0FBRyxDQUFDO1FBQy9FLElBQUksQ0FBQ3FILFlBQVksQ0FBQ0EsU0FBUy9FLEdBQUcsRUFDMUIsT0FBTzVMO1FBQ1gwUSxRQUFRO1FBQ1IsSUFBSXBILE9BQU9xSCxTQUFTdEssS0FBSyxDQUFDbkssSUFBSSxJQUFJOEQsTUFBTXNKLElBQUksR0FBR3FILFNBQVMvRSxHQUFHLENBQUMzTixFQUFFLEdBQUcwUyxTQUFTL0UsR0FBRyxDQUFDMVAsSUFBSTtRQUNsRixPQUFPdVUsU0FBUy9WLDhEQUFlQSxDQUFDc0YsS0FBSyxDQUFDQSxNQUFNNFEsTUFBTSxFQUFFdEgsUUFBUTVPLDhEQUFlQSxDQUFDdU8sTUFBTSxDQUFDSztJQUN2RjtJQUNBLElBQUksQ0FBQ29ILE9BQ0QsT0FBTztJQUNYL1QsU0FBU2lNLE9BQU9oTixPQUFPSTtJQUN2QixPQUFPO0FBQ1g7QUFDQTs7O0FBR0EsR0FDQSxNQUFNNlUsd0JBQXdCLENBQUMsRUFBRWpWLEtBQUssRUFBRWUsUUFBUSxFQUFFLEdBQUs2VCxrQkFBa0I1VSxPQUFPZSxVQUFVO0FBQzFGOzs7QUFHQSxHQUNBLE1BQU1tVSx3QkFBd0IsQ0FBQyxFQUFFbFYsS0FBSyxFQUFFZSxRQUFRLEVBQUUsR0FBSzZULGtCQUFrQjVVLE9BQU9lLFVBQVU7QUFDMUYsU0FBU29VLFVBQVVwVixNQUFNLEVBQUVtTixHQUFHO0lBQzFCLElBQUk5TSxZQUFZd00sVUFBVTdNLE9BQU9DLEtBQUssQ0FBQ0ksU0FBUyxFQUFFZ0UsQ0FBQUE7UUFDOUMsSUFBSXNKLE9BQU9SLElBQUk5STtRQUNmLE9BQU90Riw4REFBZUEsQ0FBQ3NGLEtBQUssQ0FBQ0EsTUFBTTRRLE1BQU0sRUFBRXRILEtBQUtBLElBQUksRUFBRUEsS0FBSzBILFVBQVUsRUFBRTFILEtBQUsySCxTQUFTLElBQUloTDtJQUM3RjtJQUNBLElBQUlqSyxVQUFVZ0wsRUFBRSxDQUFDckwsT0FBT0MsS0FBSyxDQUFDSSxTQUFTLEdBQ25DLE9BQU87SUFDWEwsT0FBT2dCLFFBQVEsQ0FBQ2lNLE9BQU9qTixPQUFPQyxLQUFLLEVBQUVJO0lBQ3JDLE9BQU87QUFDWDtBQUNBLFNBQVNrVixhQUFhaE4sSUFBSSxFQUFFOEUsT0FBTztJQUMvQixPQUFPK0gsVUFBVTdNLE1BQU1sRSxDQUFBQSxRQUFTa0UsS0FBS2lGLFVBQVUsQ0FBQ25KLE9BQU9nSjtBQUMzRDtBQUNBOzs7QUFHQSxHQUNBLE1BQU1tSSxpQkFBaUJqTixDQUFBQSxPQUFRZ04sYUFBYWhOLE1BQU0sQ0FBQ2tGLFlBQVlsRjtBQUMvRDs7QUFFQSxHQUNBLE1BQU1rTixrQkFBa0JsTixDQUFBQSxPQUFRZ04sYUFBYWhOLE1BQU1rRixZQUFZbEY7QUFDL0Q7O0FBRUEsR0FDQSxNQUFNbU4sb0JBQW9Cbk4sQ0FBQUEsT0FBUWdOLGFBQWFoTixNQUFNO0FBQ3JEOztBQUVBLEdBQ0EsTUFBTW9OLHFCQUFxQnBOLENBQUFBLE9BQVFnTixhQUFhaE4sTUFBTTtBQUN0RDs7O0FBR0EsR0FDQSxNQUFNcU4sMkJBQTJCNVYsQ0FBQUEsU0FBVW9WLFVBQVVwVixRQUFRcUUsQ0FBQUEsUUFBUzRKLGNBQWNqTyxPQUFPQyxLQUFLLEVBQUVvRSxPQUFPO0FBQ3pHOzs7QUFHQSxHQUNBLE1BQU13Uiw0QkFBNEI3VixDQUFBQSxTQUFVb1YsVUFBVXBWLFFBQVFxRSxDQUFBQSxRQUFTNEosY0FBY2pPLE9BQU9DLEtBQUssRUFBRW9FLE9BQU87QUFDMUcsU0FBU3lSLGNBQWN2TixJQUFJLEVBQUU4RSxPQUFPO0lBQ2hDLE9BQU8rSCxVQUFVN00sTUFBTWxFLENBQUFBLFFBQVNrRSxLQUFLK0YsV0FBVyxDQUFDakssT0FBT2dKO0FBQzVEO0FBQ0E7OztBQUdBLEdBQ0EsTUFBTTBJLGtCQUFrQnhOLENBQUFBLE9BQVF1TixjQUFjdk4sTUFBTSxDQUFDa0YsWUFBWWxGO0FBQ2pFOztBQUVBLEdBQ0EsTUFBTXlOLG1CQUFtQnpOLENBQUFBLE9BQVF1TixjQUFjdk4sTUFBTWtGLFlBQVlsRjtBQUNqRTs7QUFFQSxHQUNBLE1BQU0wTixxQkFBcUIxTixDQUFBQSxPQUFRdU4sY0FBY3ZOLE1BQU07QUFDdkQ7O0FBRUEsR0FDQSxNQUFNMk4sc0JBQXNCM04sQ0FBQUEsT0FBUXVOLGNBQWN2TixNQUFNO0FBQ3hEOzs7QUFHQSxHQUNBLE1BQU00Tix3QkFBd0I1TixDQUFBQTtJQUMxQixPQUFPNk0sVUFBVTdNLE1BQU1sRSxDQUFBQSxRQUFTa0UsS0FBS2lGLFVBQVUsQ0FBQ25KLE9BQU8sTUFBTXFHLENBQUFBLFFBQVNpRSxhQUFhcEcsTUFBTWxFLE1BQU1zSixJQUFJLEVBQUVqRDtBQUN6RztBQUNBLFNBQVMwTCxnQkFBZ0I3TixJQUFJLEVBQUU4RSxPQUFPO0lBQ2xDLE9BQU8rSCxVQUFVN00sTUFBTWxFLENBQUFBLFFBQVNtTCxjQUFjakgsTUFBTWxFLE9BQU9nSjtBQUMvRDtBQUNBOztBQUVBLEdBQ0EsTUFBTWdKLHVCQUF1QjlOLENBQUFBLE9BQVE2TixnQkFBZ0I3TixNQUFNO0FBQzNEOztBQUVBLEdBQ0EsTUFBTStOLHdCQUF3Qi9OLENBQUFBLE9BQVE2TixnQkFBZ0I3TixNQUFNO0FBQzVEOztBQUVBLEdBQ0EsTUFBTWdPLG1CQUFtQmhPLENBQUFBLE9BQVE2TSxVQUFVN00sTUFBTWxFLENBQUFBLFFBQVM0TSxhQUFhMUksS0FBS3RJLEtBQUssRUFBRW9FLE9BQU8sQ0FBQ29KLFlBQVlsRjtBQUN2Rzs7QUFFQSxHQUNBLE1BQU1pTyxvQkFBb0JqTyxDQUFBQSxPQUFRNk0sVUFBVTdNLE1BQU1sRSxDQUFBQSxRQUFTNE0sYUFBYTFJLEtBQUt0SSxLQUFLLEVBQUVvRSxPQUFPb0osWUFBWWxGO0FBQ3ZHLFNBQVNrTyxhQUFhbE8sSUFBSSxFQUFFOEUsT0FBTztJQUMvQixPQUFPK0gsVUFBVTdNLE1BQU1sRSxDQUFBQSxRQUFTa0UsS0FBS3lKLGNBQWMsQ0FBQzNOLE9BQU9nSjtBQUMvRDtBQUNBOztBQUVBLEdBQ0EsTUFBTXFKLGVBQWVuTyxDQUFBQSxPQUFRa08sYUFBYWxPLE1BQU07QUFDaEQ7O0FBRUEsR0FDQSxNQUFNb08saUJBQWlCcE8sQ0FBQUEsT0FBUWtPLGFBQWFsTyxNQUFNO0FBQ2xELFNBQVNxTyxhQUFhck8sSUFBSSxFQUFFOEUsT0FBTztJQUMvQixPQUFPK0gsVUFBVTdNLE1BQU1sRSxDQUFBQSxRQUFTa0UsS0FBS3lKLGNBQWMsQ0FBQzNOLE9BQU9nSixTQUFTK0UsU0FBUzdKLE1BQU1vSyxNQUFNO0FBQzdGO0FBQ0E7O0FBRUEsR0FDQSxNQUFNa0UsZUFBZXRPLENBQUFBLE9BQVFxTyxhQUFhck8sTUFBTTtBQUNoRDs7QUFFQSxHQUNBLE1BQU11TyxpQkFBaUJ2TyxDQUFBQSxPQUFRcU8sYUFBYXJPLE1BQU07QUFDbEQ7O0FBRUEsR0FDQSxNQUFNd08sNEJBQTRCeE8sQ0FBQUEsT0FBUTZNLFVBQVU3TSxNQUFNbEUsQ0FBQUEsUUFBUytQLG1CQUFtQjdMLE1BQU1sRSxPQUFPO0FBQ25HOztBQUVBLEdBQ0EsTUFBTTJTLDZCQUE2QnpPLENBQUFBLE9BQVE2TSxVQUFVN00sTUFBTWxFLENBQUFBLFFBQVMrUCxtQkFBbUI3TCxNQUFNbEUsT0FBTztBQUNwRzs7QUFFQSxHQUNBLE1BQU00Uyx5QkFBeUIxTyxDQUFBQSxPQUFRNk0sVUFBVTdNLE1BQU1sRSxDQUFBQSxRQUFTK1AsbUJBQW1CN0wsTUFBTWxFLE9BQU8sQ0FBQ29KLFlBQVlsRjtBQUM3Rzs7QUFFQSxHQUNBLE1BQU0yTywwQkFBMEIzTyxDQUFBQSxPQUFRNk0sVUFBVTdNLE1BQU1sRSxDQUFBQSxRQUFTK1AsbUJBQW1CN0wsTUFBTWxFLE9BQU9vSixZQUFZbEY7QUFDN0c7O0FBRUEsR0FDQSxNQUFNNE8sa0JBQWtCNU8sQ0FBQUEsT0FBUTZNLFVBQVU3TSxNQUFNbEUsQ0FBQUEsUUFBU3RGLDhEQUFlQSxDQUFDdU8sTUFBTSxDQUFDL0UsS0FBSzhMLFdBQVcsQ0FBQ2hRLE1BQU1zSixJQUFJLEVBQUVwTixJQUFJO0FBQ2pIOztBQUVBLEdBQ0EsTUFBTTZXLGdCQUFnQjdPLENBQUFBLE9BQVE2TSxVQUFVN00sTUFBTWxFLENBQUFBLFFBQVN0Riw4REFBZUEsQ0FBQ3VPLE1BQU0sQ0FBQy9FLEtBQUs4TCxXQUFXLENBQUNoUSxNQUFNc0osSUFBSSxFQUFFckwsRUFBRTtBQUM3Rzs7QUFFQSxHQUNBLE1BQU0rVSxpQkFBaUIsQ0FBQyxFQUFFcFgsS0FBSyxFQUFFZSxRQUFRLEVBQUU7SUFDdkNBLFNBQVNpTSxPQUFPaE4sT0FBTztRQUFFZ1YsUUFBUTtJQUFFO0lBQ25DLE9BQU87QUFDWDtBQUNBOztBQUVBLEdBQ0EsTUFBTXFDLGVBQWUsQ0FBQyxFQUFFclgsS0FBSyxFQUFFZSxRQUFRLEVBQUU7SUFDckNBLFNBQVNpTSxPQUFPaE4sT0FBTztRQUFFZ1YsUUFBUWhWLE1BQU1FLEdBQUcsQ0FBQzhCLE1BQU07SUFBQztJQUNsRCxPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU1zVixpQkFBaUIsQ0FBQyxFQUFFdFgsS0FBSyxFQUFFZSxRQUFRLEVBQUU7SUFDdkNBLFNBQVNpTSxPQUFPaE4sT0FBTztRQUFFZ1YsUUFBUWhWLE1BQU1JLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDMlUsTUFBTTtRQUFFdEgsTUFBTTtJQUFFO0lBQ3RFLE9BQU87QUFDWDtBQUNBOztBQUVBLEdBQ0EsTUFBTTZKLGVBQWUsQ0FBQyxFQUFFdlgsS0FBSyxFQUFFZSxRQUFRLEVBQUU7SUFDckNBLFNBQVNpTSxPQUFPaE4sT0FBTztRQUFFZ1YsUUFBUWhWLE1BQU1JLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDMlUsTUFBTTtRQUFFdEgsTUFBTTFOLE1BQU1FLEdBQUcsQ0FBQzhCLE1BQU07SUFBQztJQUNyRixPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU13VixZQUFZLENBQUMsRUFBRXhYLEtBQUssRUFBRWUsUUFBUSxFQUFFO0lBQ2xDQSxTQUFTZixNQUFNa0IsTUFBTSxDQUFDO1FBQUVkLFdBQVc7WUFBRTRVLFFBQVE7WUFBR3RILE1BQU0xTixNQUFNRSxHQUFHLENBQUM4QixNQUFNO1FBQUM7UUFBRzJGLFdBQVc7SUFBUztJQUM5RixPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU04UCxhQUFhLENBQUMsRUFBRXpYLEtBQUssRUFBRWUsUUFBUSxFQUFFO0lBQ25DLElBQUl1QyxTQUFTb1UsbUJBQW1CMVgsT0FBTzhELEdBQUcsQ0FBQyxDQUFDLEVBQUV4RCxJQUFJLEVBQUUrQixFQUFFLEVBQUUsR0FBS3ZELDhEQUFlQSxDQUFDc0YsS0FBSyxDQUFDOUQsTUFBTXdGLEtBQUtFLEdBQUcsQ0FBQzNELEtBQUssR0FBR3JDLE1BQU1FLEdBQUcsQ0FBQzhCLE1BQU07SUFDMUhqQixTQUFTZixNQUFNa0IsTUFBTSxDQUFDO1FBQUVkLFdBQVd0Qiw4REFBZUEsQ0FBQ3VILE1BQU0sQ0FBQy9DO1FBQVNxRSxXQUFXO0lBQVM7SUFDdkYsT0FBTztBQUNYO0FBQ0E7Ozs7O0FBS0EsR0FDQSxNQUFNZ1EscUJBQXFCLENBQUMsRUFBRTNYLEtBQUssRUFBRWUsUUFBUSxFQUFFO0lBQzNDLElBQUlYLFlBQVl3TSxVQUFVNU0sTUFBTUksU0FBUyxFQUFFZ0UsQ0FBQUE7UUFDdkMsSUFBSXdULE9BQU9sWSxnRUFBVUEsQ0FBQ00sUUFBUTZYLFFBQVFELEtBQUtFLFlBQVksQ0FBQzFULE1BQU05RCxJQUFJLEVBQUU7UUFDcEUsSUFBSThELE1BQU1VLEtBQUssRUFBRTtZQUNiLElBQUlpVCxjQUFjSCxLQUFLRSxZQUFZLENBQUMxVCxNQUFNOUQsSUFBSSxFQUFFLENBQUM7WUFDakQsSUFBSXlYLFlBQVlySCxJQUFJLENBQUNwUSxJQUFJLElBQUl1WCxNQUFNbkgsSUFBSSxDQUFDcFEsSUFBSSxJQUFJeVgsWUFBWXJILElBQUksQ0FBQ3JPLEVBQUUsSUFBSXdWLE1BQU1uSCxJQUFJLENBQUNyTyxFQUFFLEVBQ2hGd1YsUUFBUUU7UUFDaEI7UUFDQSxJQUFLLElBQUlDLE1BQU1ILE9BQU9HLEtBQUtBLE1BQU1BLElBQUloSixJQUFJLENBQUU7WUFDdkMsSUFBSSxFQUFFMEIsSUFBSSxFQUFFLEdBQUdzSDtZQUNmLElBQUksQ0FBQyxLQUFNMVgsSUFBSSxHQUFHOEQsTUFBTTlELElBQUksSUFBSW9RLEtBQUtyTyxFQUFFLElBQUkrQixNQUFNL0IsRUFBRSxJQUM5Q3FPLEtBQUtyTyxFQUFFLEdBQUcrQixNQUFNL0IsRUFBRSxJQUFJcU8sS0FBS3BRLElBQUksSUFBSThELE1BQU05RCxJQUFJLEtBQzlDMFgsSUFBSWhKLElBQUksRUFDUixPQUFPbFEsOERBQWVBLENBQUNzRixLQUFLLENBQUNzTSxLQUFLck8sRUFBRSxFQUFFcU8sS0FBS3BRLElBQUk7UUFDdkQ7UUFDQSxPQUFPOEQ7SUFDWDtJQUNBLElBQUloRSxVQUFVZ0wsRUFBRSxDQUFDcEwsTUFBTUksU0FBUyxHQUM1QixPQUFPO0lBQ1hXLFNBQVNpTSxPQUFPaE4sT0FBT0k7SUFDdkIsT0FBTztBQUNYO0FBQ0E7Ozs7QUFJQSxHQUNBLE1BQU02WCxvQkFBb0IsQ0FBQyxFQUFFalksS0FBSyxFQUFFZSxRQUFRLEVBQUU7SUFDMUMsSUFBSWlYLE1BQU1oWSxNQUFNSSxTQUFTLEVBQUVBLFlBQVk7SUFDdkMsSUFBSTRYLElBQUkxVSxNQUFNLENBQUN0QixNQUFNLEdBQUcsR0FDcEI1QixZQUFZdEIsOERBQWVBLENBQUN1SCxNQUFNLENBQUM7UUFBQzJSLElBQUkzWCxJQUFJO0tBQUM7U0FDNUMsSUFBSSxDQUFDMlgsSUFBSTNYLElBQUksQ0FBQ3lFLEtBQUssRUFDcEIxRSxZQUFZdEIsOERBQWVBLENBQUN1SCxNQUFNLENBQUM7UUFBQ3ZILDhEQUFlQSxDQUFDdU8sTUFBTSxDQUFDMkssSUFBSTNYLElBQUksQ0FBQ3FOLElBQUk7S0FBRTtJQUM5RSxJQUFJLENBQUN0TixXQUNELE9BQU87SUFDWFcsU0FBU2lNLE9BQU9oTixPQUFPSTtJQUN2QixPQUFPO0FBQ1g7QUFDQSxTQUFTOFgsU0FBU25ZLE1BQU0sRUFBRStNLEVBQUU7SUFDeEIsSUFBSS9NLE9BQU9DLEtBQUssQ0FBQ2dCLFFBQVEsRUFDckIsT0FBTztJQUNYLElBQUl5RyxRQUFRLG9CQUFvQixFQUFFekgsS0FBSyxFQUFFLEdBQUdEO0lBQzVDLElBQUlvRSxVQUFVbkUsTUFBTW1ZLGFBQWEsQ0FBQy9ULENBQUFBO1FBQzlCLElBQUksRUFBRTlELElBQUksRUFBRStCLEVBQUUsRUFBRSxHQUFHK0I7UUFDbkIsSUFBSTlELFFBQVErQixJQUFJO1lBQ1osSUFBSStWLFVBQVV0TCxHQUFHMUk7WUFDakIsSUFBSWdVLFVBQVU5WCxNQUFNO2dCQUNoQm1ILFFBQVE7Z0JBQ1IyUSxVQUFVQyxXQUFXdFksUUFBUXFZLFNBQVM7WUFDMUMsT0FDSyxJQUFJQSxVQUFVOVgsTUFBTTtnQkFDckJtSCxRQUFRO2dCQUNSMlEsVUFBVUMsV0FBV3RZLFFBQVFxWSxTQUFTO1lBQzFDO1lBQ0E5WCxPQUFPd0YsS0FBS0UsR0FBRyxDQUFDMUYsTUFBTThYO1lBQ3RCL1YsS0FBS3lELEtBQUtDLEdBQUcsQ0FBQzFELElBQUkrVjtRQUN0QixPQUNLO1lBQ0Q5WCxPQUFPK1gsV0FBV3RZLFFBQVFPLE1BQU07WUFDaEMrQixLQUFLZ1csV0FBV3RZLFFBQVFzQyxJQUFJO1FBQ2hDO1FBQ0EsT0FBTy9CLFFBQVErQixLQUFLO1lBQUUrQjtRQUFNLElBQUk7WUFBRUQsU0FBUztnQkFBRTdEO2dCQUFNK0I7WUFBRztZQUFHK0IsT0FBT3RGLDhEQUFlQSxDQUFDdU8sTUFBTSxDQUFDL00sTUFBTUEsT0FBTzhELE1BQU1zSixJQUFJLEdBQUcsQ0FBQyxJQUFJO1FBQUc7SUFDN0g7SUFDQSxJQUFJdkosUUFBUUEsT0FBTyxDQUFDVyxLQUFLLEVBQ3JCLE9BQU87SUFDWC9FLE9BQU9nQixRQUFRLENBQUNmLE1BQU1rQixNQUFNLENBQUNpRCxTQUFTO1FBQ2xDbUksZ0JBQWdCO1FBQ2hCM0UsV0FBV0Y7UUFDWCtCLFNBQVMvQixTQUFTLHFCQUFxQnJJLHdEQUFVQSxDQUFDa1osUUFBUSxDQUFDblEsRUFBRSxDQUFDbkksTUFBTXVZLE1BQU0sQ0FBQyx3QkFBd0JsTztJQUN2RztJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVNnTyxXQUFXdFksTUFBTSxFQUFFOEIsR0FBRyxFQUFFdUwsT0FBTztJQUNwQyxJQUFJck4sa0JBQWtCWCx3REFBVUEsRUFDNUIsS0FBSyxJQUFJa0UsVUFBVXZELE9BQU9DLEtBQUssQ0FBQ3VHLEtBQUssQ0FBQ25ILHdEQUFVQSxDQUFDb1osWUFBWSxFQUFFMVUsR0FBRyxDQUFDakQsQ0FBQUEsSUFBS0EsRUFBRWQsU0FDdEV1RCxPQUFPbVYsT0FBTyxDQUFDNVcsS0FBS0EsS0FBSyxDQUFDdkIsTUFBTStCO1FBQzVCLElBQUkvQixPQUFPdUIsT0FBT1EsS0FBS1IsS0FDbkJBLE1BQU11TCxVQUFVL0ssS0FBSy9CO0lBQzdCO0lBQ1IsT0FBT3VCO0FBQ1g7QUFDQSxNQUFNNlcsZUFBZSxDQUFDM1ksUUFBUXFOLFNBQVN1TCxlQUFpQlQsU0FBU25ZLFFBQVFxRSxDQUFBQTtRQUNyRSxJQUFJdkMsTUFBTXVDLE1BQU05RCxJQUFJLEVBQUUsRUFBRU4sS0FBSyxFQUFFLEdBQUdELFFBQVFFLE9BQU9ELE1BQU1FLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDMEIsTUFBTThKLFFBQVFpTjtRQUNoRixJQUFJRCxnQkFBZ0IsQ0FBQ3ZMLFdBQVd2TCxNQUFNNUIsS0FBS0ssSUFBSSxJQUFJdUIsTUFBTTVCLEtBQUtLLElBQUksR0FBRyxPQUNqRSxDQUFDLFNBQVM4QyxJQUFJLENBQUN1SSxTQUFTMUwsS0FBSzJELElBQUksQ0FBQ2YsS0FBSyxDQUFDLEdBQUdoQixNQUFNNUIsS0FBS0ssSUFBSSxJQUFJO1lBQzlELElBQUlxTCxNQUFNLENBQUNBLE9BQU8zSixNQUFNLEdBQUcsRUFBRSxJQUFJLEtBQzdCLE9BQU9ILE1BQU07WUFDakIsSUFBSWdYLE1BQU0zWiw4REFBV0EsQ0FBQ3lNLFFBQVEzTCxNQUFNOFksT0FBTyxHQUFHQyxPQUFPRixNQUFNbFosbUVBQWFBLENBQUNLLFVBQVVMLG1FQUFhQSxDQUFDSztZQUNqRyxJQUFLLElBQUlrRSxJQUFJLEdBQUdBLElBQUk2VSxRQUFRcE4sTUFBTSxDQUFDQSxPQUFPM0osTUFBTSxHQUFHLElBQUlrQyxFQUFFLElBQUksS0FBS0EsSUFDOURyQztZQUNKK1csWUFBWS9XO1FBQ2hCLE9BQ0s7WUFDRCtXLFlBQVkzWixtRUFBZ0JBLENBQUNnQixLQUFLMkQsSUFBSSxFQUFFL0IsTUFBTTVCLEtBQUtLLElBQUksRUFBRThNLFNBQVNBLFdBQVduTixLQUFLSyxJQUFJO1lBQ3RGLElBQUlzWSxhQUFhL1csT0FBTzVCLEtBQUsrWSxNQUFNLElBQUs1TCxDQUFBQSxVQUFVcE4sTUFBTUUsR0FBRyxDQUFDdUUsS0FBSyxHQUFHLElBQ2hFbVUsYUFBYXhMLFVBQVUsSUFBSSxDQUFDO2lCQUMzQixJQUFJLENBQUNBLFdBQVcsa0JBQWtCaEssSUFBSSxDQUFDbkQsS0FBSzJELElBQUksQ0FBQ2YsS0FBSyxDQUFDK1YsWUFBWTNZLEtBQUtLLElBQUksRUFBRXVCLE1BQU01QixLQUFLSyxJQUFJLElBQzlGc1ksWUFBWTNaLG1FQUFnQkEsQ0FBQ2dCLEtBQUsyRCxJQUFJLEVBQUVnVixZQUFZM1ksS0FBS0ssSUFBSSxFQUFFLE9BQU8sU0FBU0wsS0FBS0ssSUFBSTtRQUNoRztRQUNBLE9BQU9zWTtJQUNYO0FBQ0E7OztBQUdBLEdBQ0EsTUFBTUsscUJBQXFCM1EsQ0FBQUEsT0FBUW9RLGFBQWFwUSxNQUFNLE9BQU87QUFDN0Q7Ozs7QUFJQSxHQUNBLE1BQU00USwyQkFBMkI1USxDQUFBQSxPQUFRb1EsYUFBYXBRLE1BQU0sT0FBTztBQUNuRTs7QUFFQSxHQUNBLE1BQU02USxvQkFBb0I3USxDQUFBQSxPQUFRb1EsYUFBYXBRLE1BQU0sTUFBTTtBQUMzRCxNQUFNOFEsZ0JBQWdCLENBQUNyWixRQUFRcU4sVUFBWThLLFNBQVNuWSxRQUFRcUUsQ0FBQUE7UUFDeEQsSUFBSXZDLE1BQU11QyxNQUFNc0osSUFBSSxFQUFFLEVBQUUxTixLQUFLLEVBQUUsR0FBR0QsUUFBUUUsT0FBT0QsTUFBTUUsR0FBRyxDQUFDQyxNQUFNLENBQUMwQjtRQUNsRSxJQUFJOE0sYUFBYTNPLE1BQU00TyxlQUFlLENBQUMvTTtRQUN2QyxJQUFLLElBQUlnTixNQUFNLE9BQVE7WUFDbkIsSUFBSWhOLE9BQVF1TCxDQUFBQSxVQUFVbk4sS0FBS29DLEVBQUUsR0FBR3BDLEtBQUtLLElBQUksR0FBRztnQkFDeEMsSUFBSXVCLE9BQU91QyxNQUFNc0osSUFBSSxJQUFJek4sS0FBSytZLE1BQU0sSUFBSzVMLENBQUFBLFVBQVVwTixNQUFNRSxHQUFHLENBQUN1RSxLQUFLLEdBQUcsSUFDakU1QyxPQUFPdUwsVUFBVSxJQUFJLENBQUM7Z0JBQzFCO1lBQ0o7WUFDQSxJQUFJNEIsT0FBTy9QLG1FQUFnQkEsQ0FBQ2dCLEtBQUsyRCxJQUFJLEVBQUUvQixNQUFNNUIsS0FBS0ssSUFBSSxFQUFFOE0sV0FBV25OLEtBQUtLLElBQUk7WUFDNUUsSUFBSStZLFdBQVdwWixLQUFLMkQsSUFBSSxDQUFDZixLQUFLLENBQUNpRCxLQUFLRSxHQUFHLENBQUNuRSxLQUFLbU4sUUFBUS9PLEtBQUtLLElBQUksRUFBRXdGLEtBQUtDLEdBQUcsQ0FBQ2xFLEtBQUttTixRQUFRL08sS0FBS0ssSUFBSTtZQUMvRixJQUFJMk8sVUFBVU4sV0FBVzBLO1lBQ3pCLElBQUl4SyxPQUFPLFFBQVFJLFdBQVdKLEtBQzFCO1lBQ0osSUFBSXdLLFlBQVksT0FBT3hYLE9BQU91QyxNQUFNc0osSUFBSSxFQUNwQ21CLE1BQU1JO1lBQ1ZwTixNQUFNbU47UUFDVjtRQUNBLE9BQU9uTjtJQUNYO0FBQ0E7Ozs7QUFJQSxHQUNBLE1BQU15WCxzQkFBc0J2WixDQUFBQSxTQUFVcVosY0FBY3JaLFFBQVE7QUFDNUQ7O0FBRUEsR0FDQSxNQUFNd1oscUJBQXFCeFosQ0FBQUEsU0FBVXFaLGNBQWNyWixRQUFRO0FBQzNEOzs7O0FBSUEsR0FDQSxNQUFNeVosa0JBQWtCbFIsQ0FBQUEsT0FBUTRQLFNBQVM1UCxNQUFNbEUsQ0FBQUE7UUFDM0MsSUFBSXFWLFVBQVVuUixLQUFLOEwsV0FBVyxDQUFDaFEsTUFBTXNKLElBQUksRUFBRXJMLEVBQUU7UUFDN0MsT0FBTytCLE1BQU1zSixJQUFJLEdBQUcrTCxVQUFVQSxVQUFVM1QsS0FBS0UsR0FBRyxDQUFDc0MsS0FBS3RJLEtBQUssQ0FBQ0UsR0FBRyxDQUFDOEIsTUFBTSxFQUFFb0MsTUFBTXNKLElBQUksR0FBRztJQUN6RjtBQUNBOzs7O0FBSUEsR0FDQSxNQUFNZ00sb0JBQW9CcFIsQ0FBQUEsT0FBUTRQLFNBQVM1UCxNQUFNbEUsQ0FBQUE7UUFDN0MsSUFBSXVWLFlBQVlyUixLQUFLOEwsV0FBVyxDQUFDaFEsTUFBTXNKLElBQUksRUFBRXBOLElBQUk7UUFDakQsT0FBTzhELE1BQU1zSixJQUFJLEdBQUdpTSxZQUFZQSxZQUFZN1QsS0FBS0MsR0FBRyxDQUFDLEdBQUczQixNQUFNc0osSUFBSSxHQUFHO0lBQ3pFO0FBQ0E7OztBQUdBLEdBQ0EsTUFBTWtNLDZCQUE2QnRSLENBQUFBLE9BQVE0UCxTQUFTNVAsTUFBTWxFLENBQUFBO1FBQ3RELElBQUl1VixZQUFZclIsS0FBSzBKLGtCQUFrQixDQUFDNU4sT0FBTyxPQUFPc0osSUFBSTtRQUMxRCxPQUFPdEosTUFBTXNKLElBQUksR0FBR2lNLFlBQVlBLFlBQVk3VCxLQUFLQyxHQUFHLENBQUMsR0FBRzNCLE1BQU1zSixJQUFJLEdBQUc7SUFDekU7QUFDQTs7O0FBR0EsR0FDQSxNQUFNbU0sNEJBQTRCdlIsQ0FBQUEsT0FBUTRQLFNBQVM1UCxNQUFNbEUsQ0FBQUE7UUFDckQsSUFBSXVWLFlBQVlyUixLQUFLMEosa0JBQWtCLENBQUM1TixPQUFPLE1BQU1zSixJQUFJO1FBQ3pELE9BQU90SixNQUFNc0osSUFBSSxHQUFHaU0sWUFBWUEsWUFBWTdULEtBQUtFLEdBQUcsQ0FBQ3NDLEtBQUt0SSxLQUFLLENBQUNFLEdBQUcsQ0FBQzhCLE1BQU0sRUFBRW9DLE1BQU1zSixJQUFJLEdBQUc7SUFDN0Y7QUFDQTs7O0FBR0EsR0FDQSxNQUFNb00sMkJBQTJCLENBQUMsRUFBRTlaLEtBQUssRUFBRWUsUUFBUSxFQUFFO0lBQ2pELElBQUlmLE1BQU1nQixRQUFRLEVBQ2QsT0FBTztJQUNYLElBQUltRCxVQUFVLEVBQUU7SUFDaEIsSUFBSyxJQUFJdEMsTUFBTSxHQUFHa1ksT0FBTyxJQUFJQyxPQUFPaGEsTUFBTUUsR0FBRyxDQUFDOFosSUFBSSxLQUFNO1FBQ3BEQSxLQUFLaEwsSUFBSTtRQUNULElBQUlnTCxLQUFLQyxTQUFTLElBQUlELEtBQUtoVCxJQUFJLEVBQUU7WUFDN0IsSUFBSWtULFdBQVdILEtBQUtJLE1BQU0sQ0FBQztZQUMzQixJQUFJRCxXQUFXLENBQUMsR0FDWi9WLFFBQVFSLElBQUksQ0FBQztnQkFBRXJELE1BQU11QixNQUFPa1ksQ0FBQUEsS0FBSy9YLE1BQU0sR0FBR2tZLFFBQU87Z0JBQUk3WCxJQUFJUjtZQUFJO1lBQ2pFLElBQUltWSxLQUFLaFQsSUFBSSxFQUNUO1lBQ0orUyxPQUFPO1FBQ1gsT0FDSztZQUNEQSxPQUFPQyxLQUFLbFMsS0FBSztRQUNyQjtRQUNBakcsT0FBT21ZLEtBQUtsUyxLQUFLLENBQUM5RixNQUFNO0lBQzVCO0lBQ0EsSUFBSSxDQUFDbUMsUUFBUW5DLE1BQU0sRUFDZixPQUFPO0lBQ1hqQixTQUFTZixNQUFNa0IsTUFBTSxDQUFDO1FBQUVpRDtRQUFTd0QsV0FBVztJQUFTO0lBQ3JELE9BQU87QUFDWDtBQUNBOzs7QUFHQSxHQUNBLE1BQU15UyxZQUFZLENBQUMsRUFBRXBhLEtBQUssRUFBRWUsUUFBUSxFQUFFO0lBQ2xDLElBQUlmLE1BQU1nQixRQUFRLEVBQ2QsT0FBTztJQUNYLElBQUltRCxVQUFVbkUsTUFBTW1ZLGFBQWEsQ0FBQy9ULENBQUFBO1FBQzlCLE9BQU87WUFBRUQsU0FBUztnQkFBRTdELE1BQU04RCxNQUFNOUQsSUFBSTtnQkFBRStCLElBQUkrQixNQUFNL0IsRUFBRTtnQkFBRWdDLFFBQVFyRixtREFBSUEsQ0FBQ21KLEVBQUUsQ0FBQztvQkFBQztvQkFBSTtpQkFBRztZQUFFO1lBQzFFL0QsT0FBT3RGLDhEQUFlQSxDQUFDdU8sTUFBTSxDQUFDakosTUFBTTlELElBQUk7UUFBRTtJQUNsRDtJQUNBUyxTQUFTZixNQUFNa0IsTUFBTSxDQUFDaUQsU0FBUztRQUFFbUksZ0JBQWdCO1FBQU0zRSxXQUFXO0lBQVE7SUFDMUUsT0FBTztBQUNYO0FBQ0E7O0FBRUEsR0FDQSxNQUFNMFMsaUJBQWlCLENBQUMsRUFBRXJhLEtBQUssRUFBRWUsUUFBUSxFQUFFO0lBQ3ZDLElBQUlmLE1BQU1nQixRQUFRLEVBQ2QsT0FBTztJQUNYLElBQUltRCxVQUFVbkUsTUFBTW1ZLGFBQWEsQ0FBQy9ULENBQUFBO1FBQzlCLElBQUksQ0FBQ0EsTUFBTVUsS0FBSyxJQUFJVixNQUFNOUQsSUFBSSxJQUFJLEtBQUs4RCxNQUFNOUQsSUFBSSxJQUFJTixNQUFNRSxHQUFHLENBQUM4QixNQUFNLEVBQ2pFLE9BQU87WUFBRW9DO1FBQU07UUFDbkIsSUFBSXZDLE1BQU11QyxNQUFNOUQsSUFBSSxFQUFFTCxPQUFPRCxNQUFNRSxHQUFHLENBQUNDLE1BQU0sQ0FBQzBCO1FBQzlDLElBQUl2QixPQUFPdUIsT0FBTzVCLEtBQUtLLElBQUksR0FBR3VCLE1BQU0sSUFBSTVDLG1FQUFnQkEsQ0FBQ2dCLEtBQUsyRCxJQUFJLEVBQUUvQixNQUFNNUIsS0FBS0ssSUFBSSxFQUFFLFNBQVNMLEtBQUtLLElBQUk7UUFDdkcsSUFBSStCLEtBQUtSLE9BQU81QixLQUFLb0MsRUFBRSxHQUFHUixNQUFNLElBQUk1QyxtRUFBZ0JBLENBQUNnQixLQUFLMkQsSUFBSSxFQUFFL0IsTUFBTTVCLEtBQUtLLElBQUksRUFBRSxRQUFRTCxLQUFLSyxJQUFJO1FBQ2xHLE9BQU87WUFBRTZELFNBQVM7Z0JBQUU3RDtnQkFBTStCO2dCQUFJZ0MsUUFBUXJFLE1BQU1FLEdBQUcsQ0FBQzJDLEtBQUssQ0FBQ2hCLEtBQUtRLElBQUlpWSxNQUFNLENBQUN0YSxNQUFNRSxHQUFHLENBQUMyQyxLQUFLLENBQUN2QyxNQUFNdUI7WUFBTTtZQUM5RnVDLE9BQU90Riw4REFBZUEsQ0FBQ3VPLE1BQU0sQ0FBQ2hMO1FBQUk7SUFDMUM7SUFDQSxJQUFJOEIsUUFBUUEsT0FBTyxDQUFDVyxLQUFLLEVBQ3JCLE9BQU87SUFDWC9ELFNBQVNmLE1BQU1rQixNQUFNLENBQUNpRCxTQUFTO1FBQUVtSSxnQkFBZ0I7UUFBTTNFLFdBQVc7SUFBaUI7SUFDbkYsT0FBTztBQUNYO0FBQ0EsU0FBUytQLG1CQUFtQjFYLEtBQUs7SUFDN0IsSUFBSXVhLFNBQVMsRUFBRSxFQUFFQyxPQUFPLENBQUM7SUFDekIsS0FBSyxJQUFJcFcsU0FBU3BFLE1BQU1JLFNBQVMsQ0FBQ2tELE1BQU0sQ0FBRTtRQUN0QyxJQUFJbVgsWUFBWXphLE1BQU1FLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDaUUsTUFBTTlELElBQUksR0FBR29hLFVBQVUxYSxNQUFNRSxHQUFHLENBQUNDLE1BQU0sQ0FBQ2lFLE1BQU0vQixFQUFFO1FBQ2pGLElBQUksQ0FBQytCLE1BQU1VLEtBQUssSUFBSVYsTUFBTS9CLEVBQUUsSUFBSXFZLFFBQVFwYSxJQUFJLEVBQ3hDb2EsVUFBVTFhLE1BQU1FLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDaUUsTUFBTS9CLEVBQUUsR0FBRztRQUMxQyxJQUFJbVksUUFBUUMsVUFBVXpCLE1BQU0sRUFBRTtZQUMxQixJQUFJZSxPQUFPUSxNQUFNLENBQUNBLE9BQU92WSxNQUFNLEdBQUcsRUFBRTtZQUNwQytYLEtBQUsxWCxFQUFFLEdBQUdxWSxRQUFRclksRUFBRTtZQUNwQjBYLEtBQUt6VyxNQUFNLENBQUNLLElBQUksQ0FBQ1M7UUFDckIsT0FDSztZQUNEbVcsT0FBTzVXLElBQUksQ0FBQztnQkFBRXJELE1BQU1tYSxVQUFVbmEsSUFBSTtnQkFBRStCLElBQUlxWSxRQUFRclksRUFBRTtnQkFBRWlCLFFBQVE7b0JBQUNjO2lCQUFNO1lBQUM7UUFDeEU7UUFDQW9XLE9BQU9FLFFBQVExQixNQUFNLEdBQUc7SUFDNUI7SUFDQSxPQUFPdUI7QUFDWDtBQUNBLFNBQVNJLFNBQVMzYSxLQUFLLEVBQUVlLFFBQVEsRUFBRXFNLE9BQU87SUFDdEMsSUFBSXBOLE1BQU1nQixRQUFRLEVBQ2QsT0FBTztJQUNYLElBQUltRCxVQUFVLEVBQUUsRUFBRWIsU0FBUyxFQUFFO0lBQzdCLEtBQUssSUFBSTVDLFNBQVNnWCxtQkFBbUIxWCxPQUFRO1FBQ3pDLElBQUlvTixVQUFVMU0sTUFBTTJCLEVBQUUsSUFBSXJDLE1BQU1FLEdBQUcsQ0FBQzhCLE1BQU0sR0FBR3RCLE1BQU1KLElBQUksSUFBSSxHQUN2RDtRQUNKLElBQUlzYSxXQUFXNWEsTUFBTUUsR0FBRyxDQUFDQyxNQUFNLENBQUNpTixVQUFVMU0sTUFBTTJCLEVBQUUsR0FBRyxJQUFJM0IsTUFBTUosSUFBSSxHQUFHO1FBQ3RFLElBQUl1YSxPQUFPRCxTQUFTNVksTUFBTSxHQUFHO1FBQzdCLElBQUlvTCxTQUFTO1lBQ1RqSixRQUFRUixJQUFJLENBQUM7Z0JBQUVyRCxNQUFNSSxNQUFNMkIsRUFBRTtnQkFBRUEsSUFBSXVZLFNBQVN2WSxFQUFFO1lBQUMsR0FBRztnQkFBRS9CLE1BQU1JLE1BQU1KLElBQUk7Z0JBQUUrRCxRQUFRdVcsU0FBU2hYLElBQUksR0FBRzVELE1BQU1pYSxTQUFTO1lBQUM7WUFDOUcsS0FBSyxJQUFJMVcsS0FBSzdDLE1BQU00QyxNQUFNLENBQ3RCQSxPQUFPSyxJQUFJLENBQUM3RSw4REFBZUEsQ0FBQ3NGLEtBQUssQ0FBQzBCLEtBQUtFLEdBQUcsQ0FBQ2hHLE1BQU1FLEdBQUcsQ0FBQzhCLE1BQU0sRUFBRXVCLEVBQUV5UixNQUFNLEdBQUc2RixPQUFPL1UsS0FBS0UsR0FBRyxDQUFDaEcsTUFBTUUsR0FBRyxDQUFDOEIsTUFBTSxFQUFFdUIsRUFBRW1LLElBQUksR0FBR21OO1FBQzNILE9BQ0s7WUFDRDFXLFFBQVFSLElBQUksQ0FBQztnQkFBRXJELE1BQU1zYSxTQUFTdGEsSUFBSTtnQkFBRStCLElBQUkzQixNQUFNSixJQUFJO1lBQUMsR0FBRztnQkFBRUEsTUFBTUksTUFBTTJCLEVBQUU7Z0JBQUVnQyxRQUFRckUsTUFBTWlhLFNBQVMsR0FBR1csU0FBU2hYLElBQUk7WUFBQztZQUNoSCxLQUFLLElBQUlMLEtBQUs3QyxNQUFNNEMsTUFBTSxDQUN0QkEsT0FBT0ssSUFBSSxDQUFDN0UsOERBQWVBLENBQUNzRixLQUFLLENBQUNiLEVBQUV5UixNQUFNLEdBQUc2RixNQUFNdFgsRUFBRW1LLElBQUksR0FBR21OO1FBQ3BFO0lBQ0o7SUFDQSxJQUFJLENBQUMxVyxRQUFRbkMsTUFBTSxFQUNmLE9BQU87SUFDWGpCLFNBQVNmLE1BQU1rQixNQUFNLENBQUM7UUFDbEJpRDtRQUNBbUksZ0JBQWdCO1FBQ2hCbE0sV0FBV3RCLDhEQUFlQSxDQUFDdUgsTUFBTSxDQUFDL0MsUUFBUXRELE1BQU1JLFNBQVMsQ0FBQzJNLFNBQVM7UUFDbkVwRixXQUFXO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU1tVCxhQUFhLENBQUMsRUFBRTlhLEtBQUssRUFBRWUsUUFBUSxFQUFFLEdBQUs0WixTQUFTM2EsT0FBT2UsVUFBVTtBQUN0RTs7QUFFQSxHQUNBLE1BQU1nYSxlQUFlLENBQUMsRUFBRS9hLEtBQUssRUFBRWUsUUFBUSxFQUFFLEdBQUs0WixTQUFTM2EsT0FBT2UsVUFBVTtBQUN4RSxTQUFTaWEsU0FBU2hiLEtBQUssRUFBRWUsUUFBUSxFQUFFcU0sT0FBTztJQUN0QyxJQUFJcE4sTUFBTWdCLFFBQVEsRUFDZCxPQUFPO0lBQ1gsSUFBSW1ELFVBQVUsRUFBRTtJQUNoQixLQUFLLElBQUl6RCxTQUFTZ1gsbUJBQW1CMVgsT0FBUTtRQUN6QyxJQUFJb04sU0FDQWpKLFFBQVFSLElBQUksQ0FBQztZQUFFckQsTUFBTUksTUFBTUosSUFBSTtZQUFFK0QsUUFBUXJFLE1BQU1FLEdBQUcsQ0FBQzJDLEtBQUssQ0FBQ25DLE1BQU1KLElBQUksRUFBRUksTUFBTTJCLEVBQUUsSUFBSXJDLE1BQU1pYSxTQUFTO1FBQUM7YUFFakc5VixRQUFRUixJQUFJLENBQUM7WUFBRXJELE1BQU1JLE1BQU0yQixFQUFFO1lBQUVnQyxRQUFRckUsTUFBTWlhLFNBQVMsR0FBR2phLE1BQU1FLEdBQUcsQ0FBQzJDLEtBQUssQ0FBQ25DLE1BQU1KLElBQUksRUFBRUksTUFBTTJCLEVBQUU7UUFBRTtJQUN2RztJQUNBdEIsU0FBU2YsTUFBTWtCLE1BQU0sQ0FBQztRQUFFaUQ7UUFBU21JLGdCQUFnQjtRQUFNM0UsV0FBVztJQUFpQjtJQUNuRixPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU1zVCxhQUFhLENBQUMsRUFBRWpiLEtBQUssRUFBRWUsUUFBUSxFQUFFLEdBQUtpYSxTQUFTaGIsT0FBT2UsVUFBVTtBQUN0RTs7QUFFQSxHQUNBLE1BQU1tYSxlQUFlLENBQUMsRUFBRWxiLEtBQUssRUFBRWUsUUFBUSxFQUFFLEdBQUtpYSxTQUFTaGIsT0FBT2UsVUFBVTtBQUN4RTs7QUFFQSxHQUNBLE1BQU1vYSxhQUFhN1MsQ0FBQUE7SUFDZixJQUFJQSxLQUFLdEksS0FBSyxDQUFDZ0IsUUFBUSxFQUNuQixPQUFPO0lBQ1gsSUFBSSxFQUFFaEIsS0FBSyxFQUFFLEdBQUdzSSxNQUFNbkUsVUFBVW5FLE1BQU1tRSxPQUFPLENBQUN1VCxtQkFBbUIxWCxPQUFPOEQsR0FBRyxDQUFDLENBQUMsRUFBRXhELElBQUksRUFBRStCLEVBQUUsRUFBRTtRQUNyRixJQUFJL0IsT0FBTyxHQUNQQTthQUNDLElBQUkrQixLQUFLckMsTUFBTUUsR0FBRyxDQUFDOEIsTUFBTSxFQUMxQks7UUFDSixPQUFPO1lBQUUvQjtZQUFNK0I7UUFBRztJQUN0QjtJQUNBLElBQUlqQyxZQUFZd00sVUFBVTVNLE1BQU1JLFNBQVMsRUFBRWdFLENBQUFBO1FBQ3ZDLElBQUlnWCxPQUFPL1E7UUFDWCxJQUFJL0IsS0FBSytTLFlBQVksRUFBRTtZQUNuQixJQUFJM2EsUUFBUTRILEtBQUs4TCxXQUFXLENBQUNoUSxNQUFNc0osSUFBSSxHQUFHN0wsTUFBTXlHLEtBQUtvTCxXQUFXLENBQUN0UCxNQUFNc0osSUFBSSxFQUFFdEosTUFBTWtYLEtBQUssSUFBSTtZQUM1RixJQUFJelosS0FDQXVaLE9BQU8sTUFBT3JJLE1BQU0sR0FBR3pLLEtBQUtpVCxXQUFXLEdBQUkxWixJQUFJa1IsTUFBTSxHQUFHekssS0FBSytLLGlCQUFpQixHQUFHO1FBQ3pGO1FBQ0EsT0FBTy9LLEtBQUt5SixjQUFjLENBQUMzTixPQUFPLE1BQU1nWDtJQUM1QyxHQUFHdFgsR0FBRyxDQUFDSztJQUNQbUUsS0FBS3ZILFFBQVEsQ0FBQztRQUFFb0Q7UUFBUy9EO1FBQVdrTSxnQkFBZ0I7UUFBTTNFLFdBQVc7SUFBYztJQUNuRixPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU02VCxnQkFBZ0IsQ0FBQyxFQUFFeGIsS0FBSyxFQUFFZSxRQUFRLEVBQUU7SUFDdENBLFNBQVNmLE1BQU1rQixNQUFNLENBQUNsQixNQUFNeWIsZ0JBQWdCLENBQUN6YixNQUFNaWEsU0FBUyxHQUFHO1FBQUUzTixnQkFBZ0I7UUFBTTNFLFdBQVc7SUFBUTtJQUMxRyxPQUFPO0FBQ1g7QUFDQTs7O0FBR0EsR0FDQSxNQUFNK1QsMEJBQTBCLENBQUMsRUFBRTFiLEtBQUssRUFBRWUsUUFBUSxFQUFFO0lBQ2hEQSxTQUFTZixNQUFNa0IsTUFBTSxDQUFDbEIsTUFBTW1ZLGFBQWEsQ0FBQy9ULENBQUFBO1FBQ3RDLElBQUlTLFNBQVMsT0FBT25DLElBQUksQ0FBQzFDLE1BQU1FLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDaUUsTUFBTTlELElBQUksRUFBRXNELElBQUksQ0FBQyxDQUFDLEVBQUU7UUFDOUQsT0FBTztZQUNITyxTQUFTO2dCQUFFN0QsTUFBTThELE1BQU05RCxJQUFJO2dCQUFFK0IsSUFBSStCLE1BQU0vQixFQUFFO2dCQUFFZ0MsUUFBUXJFLE1BQU1pYSxTQUFTLEdBQUdwVjtZQUFPO1lBQzVFVCxPQUFPdEYsOERBQWVBLENBQUN1TyxNQUFNLENBQUNqSixNQUFNOUQsSUFBSSxHQUFHdUUsT0FBTzdDLE1BQU0sR0FBRztRQUMvRDtJQUNKLElBQUk7UUFBRXNLLGdCQUFnQjtRQUFNM0UsV0FBVztJQUFRO0lBQy9DLE9BQU87QUFDWDtBQUNBLFNBQVNnVSxrQkFBa0IzYixLQUFLLEVBQUU2QixHQUFHO0lBQ2pDLElBQUksaUJBQWlCdUIsSUFBSSxDQUFDcEQsTUFBTXVDLFFBQVEsQ0FBQ1YsTUFBTSxHQUFHQSxNQUFNLEtBQ3BELE9BQU87UUFBRXZCLE1BQU11QjtRQUFLUSxJQUFJUjtJQUFJO0lBQ2hDLElBQUkrWixVQUFVbGMsZ0VBQVVBLENBQUNNLE9BQU9pUixZQUFZLENBQUNwUDtJQUM3QyxJQUFJOEosU0FBU2lRLFFBQVF0SyxXQUFXLENBQUN6UCxNQUFNZ0ksUUFBUStSLFFBQVF2SyxVQUFVLENBQUN4UCxNQUFNcVA7SUFDeEUsSUFBSXZGLFVBQVU5QixTQUFTOEIsT0FBT3RKLEVBQUUsSUFBSVIsT0FBT2dJLE1BQU12SixJQUFJLElBQUl1QixPQUNwRHFQLENBQUFBLFdBQVd2RixPQUFPaUYsSUFBSSxDQUFDQyxJQUFJLENBQUNoUixtREFBUUEsQ0FBQ3FSLFFBQVEsTUFBTUEsU0FBUzJLLE9BQU8sQ0FBQ2hTLE1BQU1pUyxJQUFJLElBQUksQ0FBQyxLQUNwRjliLE1BQU1FLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDd0wsT0FBT3RKLEVBQUUsRUFBRS9CLElBQUksSUFBSU4sTUFBTUUsR0FBRyxDQUFDQyxNQUFNLENBQUMwSixNQUFNdkosSUFBSSxFQUFFQSxJQUFJLElBQ3JFLENBQUMsS0FBSzhDLElBQUksQ0FBQ3BELE1BQU11QyxRQUFRLENBQUNvSixPQUFPdEosRUFBRSxFQUFFd0gsTUFBTXZKLElBQUksSUFDL0MsT0FBTztRQUFFQSxNQUFNcUwsT0FBT3RKLEVBQUU7UUFBRUEsSUFBSXdILE1BQU12SixJQUFJO0lBQUM7SUFDN0MsT0FBTztBQUNYO0FBQ0E7Ozs7OztBQU1BLEdBQ0EsTUFBTXliLHlCQUF5QixXQUFXLEdBQUVDLGlCQUFpQjtBQUM3RDs7QUFFQSxHQUNBLE1BQU1DLGtCQUFrQixXQUFXLEdBQUVELGlCQUFpQjtBQUN0RCxTQUFTQSxpQkFBaUJFLEtBQUs7SUFDM0IsT0FBTyxDQUFDLEVBQUVsYyxLQUFLLEVBQUVlLFFBQVEsRUFBRTtRQUN2QixJQUFJZixNQUFNZ0IsUUFBUSxFQUNkLE9BQU87UUFDWCxJQUFJbUQsVUFBVW5FLE1BQU1tWSxhQUFhLENBQUMvVCxDQUFBQTtZQUM5QixJQUFJLEVBQUU5RCxJQUFJLEVBQUUrQixFQUFFLEVBQUUsR0FBRytCLE9BQU9uRSxPQUFPRCxNQUFNRSxHQUFHLENBQUNDLE1BQU0sQ0FBQ0c7WUFDbEQsSUFBSTZiLFVBQVUsQ0FBQ0QsU0FBUzViLFFBQVErQixNQUFNc1osa0JBQWtCM2IsT0FBT007WUFDL0QsSUFBSTRiLE9BQ0E1YixPQUFPK0IsS0FBSyxDQUFDQSxNQUFNcEMsS0FBS29DLEVBQUUsR0FBR3BDLE9BQU9ELE1BQU1FLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDa0MsR0FBRSxFQUFHQSxFQUFFO1lBQ2hFLElBQUkrWixLQUFLLElBQUk5YywrREFBYUEsQ0FBQ1UsT0FBTztnQkFBRXFjLGVBQWUvYjtnQkFBTWdjLHFCQUFxQixDQUFDLENBQUNIO1lBQVE7WUFDeEYsSUFBSXRYLFNBQVN0RixvRUFBY0EsQ0FBQzZjLElBQUk5YjtZQUNoQyxJQUFJdUUsVUFBVSxNQUNWQSxTQUFTM0YsOERBQVdBLENBQUMsT0FBT3dELElBQUksQ0FBQzFDLE1BQU1FLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDRyxNQUFNc0QsSUFBSSxDQUFDLENBQUMsRUFBRSxFQUFFNUQsTUFBTThZLE9BQU87WUFDbkYsTUFBT3pXLEtBQUtwQyxLQUFLb0MsRUFBRSxJQUFJLEtBQUtlLElBQUksQ0FBQ25ELEtBQUsyRCxJQUFJLENBQUN2QixLQUFLcEMsS0FBS0ssSUFBSSxDQUFDLEVBQ3REK0I7WUFDSixJQUFJOFosU0FDQyxHQUFFN2IsSUFBSSxFQUFFK0IsRUFBRSxFQUFFLEdBQUc4WixPQUFNO2lCQUNyQixJQUFJN2IsT0FBT0wsS0FBS0ssSUFBSSxJQUFJQSxPQUFPTCxLQUFLSyxJQUFJLEdBQUcsT0FBTyxDQUFDLEtBQUs4QyxJQUFJLENBQUNuRCxLQUFLMkQsSUFBSSxDQUFDZixLQUFLLENBQUMsR0FBR3ZDLFFBQ2pGQSxPQUFPTCxLQUFLSyxJQUFJO1lBQ3BCLElBQUkrRCxTQUFTO2dCQUFDO2dCQUFJN0Usa0VBQVlBLENBQUNRLE9BQU82RTthQUFRO1lBQzlDLElBQUlzWCxTQUNBOVgsT0FBT1YsSUFBSSxDQUFDbkUsa0VBQVlBLENBQUNRLE9BQU9vYyxHQUFHRyxVQUFVLENBQUN0YyxLQUFLSyxJQUFJLEVBQUUsQ0FBQztZQUM5RCxPQUFPO2dCQUFFNkQsU0FBUztvQkFBRTdEO29CQUFNK0I7b0JBQUlnQyxRQUFRckYsbURBQUlBLENBQUNtSixFQUFFLENBQUM5RDtnQkFBUTtnQkFDbERELE9BQU90Riw4REFBZUEsQ0FBQ3VPLE1BQU0sQ0FBQy9NLE9BQU8sSUFBSStELE1BQU0sQ0FBQyxFQUFFLENBQUNyQyxNQUFNO1lBQUU7UUFDbkU7UUFDQWpCLFNBQVNmLE1BQU1rQixNQUFNLENBQUNpRCxTQUFTO1lBQUVtSSxnQkFBZ0I7WUFBTTNFLFdBQVc7UUFBUTtRQUMxRSxPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVM2VSxxQkFBcUJ4YyxLQUFLLEVBQUVhLENBQUM7SUFDbEMsSUFBSTRiLFNBQVMsQ0FBQztJQUNkLE9BQU96YyxNQUFNbVksYUFBYSxDQUFDL1QsQ0FBQUE7UUFDdkIsSUFBSUQsVUFBVSxFQUFFO1FBQ2hCLElBQUssSUFBSXRDLE1BQU11QyxNQUFNOUQsSUFBSSxFQUFFdUIsT0FBT3VDLE1BQU0vQixFQUFFLEVBQUc7WUFDekMsSUFBSXBDLE9BQU9ELE1BQU1FLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDMEI7WUFDNUIsSUFBSTVCLEtBQUsrWSxNQUFNLEdBQUd5RCxVQUFXclksQ0FBQUEsTUFBTVUsS0FBSyxJQUFJVixNQUFNL0IsRUFBRSxHQUFHcEMsS0FBS0ssSUFBSSxHQUFHO2dCQUMvRE8sRUFBRVosTUFBTWtFLFNBQVNDO2dCQUNqQnFZLFNBQVN4YyxLQUFLK1ksTUFBTTtZQUN4QjtZQUNBblgsTUFBTTVCLEtBQUtvQyxFQUFFLEdBQUc7UUFDcEI7UUFDQSxJQUFJNEMsWUFBWWpGLE1BQU1tRSxPQUFPLENBQUNBO1FBQzlCLE9BQU87WUFBRUE7WUFDTEMsT0FBT3RGLDhEQUFlQSxDQUFDc0YsS0FBSyxDQUFDYSxVQUFVeVgsTUFBTSxDQUFDdFksTUFBTTRRLE1BQU0sRUFBRSxJQUFJL1AsVUFBVXlYLE1BQU0sQ0FBQ3RZLE1BQU1zSixJQUFJLEVBQUU7UUFBSTtJQUN6RztBQUNKO0FBQ0E7Ozs7QUFJQSxHQUNBLE1BQU1pUCxrQkFBa0IsQ0FBQyxFQUFFM2MsS0FBSyxFQUFFZSxRQUFRLEVBQUU7SUFDeEMsSUFBSWYsTUFBTWdCLFFBQVEsRUFDZCxPQUFPO0lBQ1gsSUFBSTRiLFVBQVVDLE9BQU94VyxNQUFNLENBQUM7SUFDNUIsSUFBSXVWLFVBQVUsSUFBSXRjLCtEQUFhQSxDQUFDVSxPQUFPO1FBQUU4YyxxQkFBcUJyUyxDQUFBQTtZQUN0RCxJQUFJcUssUUFBUThILE9BQU8sQ0FBQ25TLE1BQU07WUFDMUIsT0FBT3FLLFNBQVMsT0FBTyxDQUFDLElBQUlBO1FBQ2hDO0lBQUU7SUFDTixJQUFJM1EsVUFBVXFZLHFCQUFxQnhjLE9BQU8sQ0FBQ0MsTUFBTWtFLFNBQVNDO1FBQ3RELElBQUlTLFNBQVN0RixvRUFBY0EsQ0FBQ3FjLFNBQVMzYixLQUFLSyxJQUFJO1FBQzlDLElBQUl1RSxVQUFVLE1BQ1Y7UUFDSixJQUFJLENBQUMsS0FBS3pCLElBQUksQ0FBQ25ELEtBQUsyRCxJQUFJLEdBQ3BCaUIsU0FBUztRQUNiLElBQUltVCxNQUFNLE9BQU90VixJQUFJLENBQUN6QyxLQUFLMkQsSUFBSSxDQUFDLENBQUMsRUFBRTtRQUNuQyxJQUFJbVosT0FBT3ZkLGtFQUFZQSxDQUFDUSxPQUFPNkU7UUFDL0IsSUFBSW1ULE9BQU8rRSxRQUFRM1ksTUFBTTlELElBQUksR0FBR0wsS0FBS0ssSUFBSSxHQUFHMFgsSUFBSWhXLE1BQU0sRUFBRTtZQUNwRDRhLE9BQU8sQ0FBQzNjLEtBQUtLLElBQUksQ0FBQyxHQUFHdUU7WUFDckJWLFFBQVFSLElBQUksQ0FBQztnQkFBRXJELE1BQU1MLEtBQUtLLElBQUk7Z0JBQUUrQixJQUFJcEMsS0FBS0ssSUFBSSxHQUFHMFgsSUFBSWhXLE1BQU07Z0JBQUVxQyxRQUFRMFk7WUFBSztRQUM3RTtJQUNKO0lBQ0EsSUFBSSxDQUFDNVksUUFBUUEsT0FBTyxDQUFDVyxLQUFLLEVBQ3RCL0QsU0FBU2YsTUFBTWtCLE1BQU0sQ0FBQ2lELFNBQVM7UUFBRXdELFdBQVc7SUFBUztJQUN6RCxPQUFPO0FBQ1g7QUFDQTs7O0FBR0EsR0FDQSxNQUFNcVYsYUFBYSxDQUFDLEVBQUVoZCxLQUFLLEVBQUVlLFFBQVEsRUFBRTtJQUNuQyxJQUFJZixNQUFNZ0IsUUFBUSxFQUNkLE9BQU87SUFDWEQsU0FBU2YsTUFBTWtCLE1BQU0sQ0FBQ3NiLHFCQUFxQnhjLE9BQU8sQ0FBQ0MsTUFBTWtFO1FBQ3JEQSxRQUFRUixJQUFJLENBQUM7WUFBRXJELE1BQU1MLEtBQUtLLElBQUk7WUFBRStELFFBQVFyRSxNQUFNdUcsS0FBSyxDQUFDM0csNERBQVVBO1FBQUU7SUFDcEUsSUFBSTtRQUFFK0gsV0FBVztJQUFlO0lBQ2hDLE9BQU87QUFDWDtBQUNBOzs7QUFHQSxHQUNBLE1BQU1zVixhQUFhLENBQUMsRUFBRWpkLEtBQUssRUFBRWUsUUFBUSxFQUFFO0lBQ25DLElBQUlmLE1BQU1nQixRQUFRLEVBQ2QsT0FBTztJQUNYRCxTQUFTZixNQUFNa0IsTUFBTSxDQUFDc2IscUJBQXFCeGMsT0FBTyxDQUFDQyxNQUFNa0U7UUFDckQsSUFBSWtRLFFBQVEsT0FBTzNSLElBQUksQ0FBQ3pDLEtBQUsyRCxJQUFJLENBQUMsQ0FBQyxFQUFFO1FBQ3JDLElBQUksQ0FBQ3lRLE9BQ0Q7UUFDSixJQUFJd0UsTUFBTTNaLDhEQUFXQSxDQUFDbVYsT0FBT3JVLE1BQU04WSxPQUFPLEdBQUdvRSxPQUFPO1FBQ3BELElBQUk3WSxTQUFTN0Usa0VBQVlBLENBQUNRLE9BQU84RixLQUFLQyxHQUFHLENBQUMsR0FBRzhTLE1BQU1sWixtRUFBYUEsQ0FBQ0s7UUFDakUsTUFBT2tkLE9BQU83SSxNQUFNclMsTUFBTSxJQUFJa2IsT0FBTzdZLE9BQU9yQyxNQUFNLElBQUlxUyxNQUFNdkUsVUFBVSxDQUFDb04sU0FBUzdZLE9BQU95TCxVQUFVLENBQUNvTixNQUM5RkE7UUFDSi9ZLFFBQVFSLElBQUksQ0FBQztZQUFFckQsTUFBTUwsS0FBS0ssSUFBSSxHQUFHNGM7WUFBTTdhLElBQUlwQyxLQUFLSyxJQUFJLEdBQUcrVCxNQUFNclMsTUFBTTtZQUFFcUMsUUFBUUEsT0FBT3hCLEtBQUssQ0FBQ3FhO1FBQU07SUFDcEcsSUFBSTtRQUFFdlYsV0FBVztJQUFnQjtJQUNqQyxPQUFPO0FBQ1g7QUFDQTs7Ozs7O0FBTUEsR0FDQSxNQUFNd1YscUJBQXFCN1UsQ0FBQUE7SUFDdkJBLEtBQUs4VSxlQUFlO0lBQ3BCLE9BQU87QUFDWDtBQUNBOzs7O0FBSUEsR0FDQSxNQUFNQyw2QkFBNkIvVSxDQUFBQTtJQUMvQkEsS0FBSzhVLGVBQWUsQ0FBQztJQUNyQixPQUFPO0FBQ1g7QUFDQTs7OztBQUlBLEdBQ0EsTUFBTUUsWUFBWSxDQUFDLEVBQUV0ZCxLQUFLLEVBQUVlLFFBQVEsRUFBRTtJQUNsQyxJQUFJZixNQUFNSSxTQUFTLENBQUNrRCxNQUFNLENBQUNnQixJQUFJLENBQUNmLENBQUFBLElBQUssQ0FBQ0EsRUFBRXVCLEtBQUssR0FDekMsT0FBT2tZLFdBQVc7UUFBRWhkO1FBQU9lO0lBQVM7SUFDeENBLFNBQVNmLE1BQU1rQixNQUFNLENBQUNsQixNQUFNeWIsZ0JBQWdCLENBQUMsTUFBTztRQUFFblAsZ0JBQWdCO1FBQU0zRSxXQUFXO0lBQVE7SUFDL0YsT0FBTztBQUNYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQSxHQUNBLE1BQU00VixtQkFBbUI7SUFDckI7UUFBRS9RLEtBQUs7UUFBVUMsS0FBS21CO1FBQWdCNFAsT0FBT2pJO1FBQWdCN00sZ0JBQWdCO0lBQUs7SUFDbEY7UUFBRThELEtBQUs7UUFBVUMsS0FBS29CO1FBQWlCMlAsT0FBT2hJO0lBQWdCO0lBQzlEO1FBQUVoSixLQUFLO1FBQVVDLEtBQUt3RjtRQUFjdUwsT0FBTy9HO0lBQWE7SUFDeEQ7UUFBRWpLLEtBQUs7UUFBVUMsS0FBS3lGO1FBQWdCc0wsT0FBTzlHO0lBQWU7SUFDNUQ7UUFBRWxLLEtBQUs7UUFBVUMsS0FBS2lJO1FBQWlCOEksT0FBT3RHO0lBQWdCO0lBQzlEO1FBQUUxSyxLQUFLO1FBQVVDLEtBQUtrSTtRQUFlNkksT0FBT3JHO0lBQWM7SUFDMUQ7UUFBRTNLLEtBQUs7UUFBVUMsS0FBSzBNO0lBQWtCO0lBQ3hDO1FBQUUzTSxLQUFLO1FBQVVDLEtBQUt3TTtJQUFtQjtJQUN6QztRQUFFek0sS0FBSztRQUFVQyxLQUFLK007SUFBZ0I7SUFDdEM7UUFBRWhOLEtBQUs7UUFBY0MsS0FBSzZNO0lBQW9CO0lBQzlDO1FBQUU5TSxLQUFLO1FBQVVDLEtBQUsyTjtJQUFVO0lBQ2hDO1FBQUU1TixLQUFLO1FBQVVDLEtBQUs0TjtJQUFlO0lBQ3JDO1FBQUU3TixLQUFLO1FBQVVDLEtBQUt5SDtJQUFlO0NBQ3hDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NBLEdBQ0EsTUFBTXVKLGlCQUFpQixXQUFXLEdBQUU7SUFDaEM7UUFBRWpSLEtBQUs7UUFBYUMsS0FBS21CO1FBQWdCNFAsT0FBT2pJO1FBQWdCN00sZ0JBQWdCO0lBQUs7SUFDckY7UUFBRThELEtBQUs7UUFBaUJFLEtBQUs7UUFBaUJELEtBQUs2QjtRQUFpQmtQLE9BQU8xSDtRQUFpQnBOLGdCQUFnQjtJQUFLO0lBQ2pIO1FBQUVnRSxLQUFLO1FBQWlCRCxLQUFLK0g7UUFBd0JnSixPQUFPeEc7UUFBd0J0TyxnQkFBZ0I7SUFBSztJQUN6RztRQUFFOEQsS0FBSztRQUFjQyxLQUFLb0I7UUFBaUIyUCxPQUFPaEk7UUFBaUI5TSxnQkFBZ0I7SUFBSztJQUN4RjtRQUFFOEQsS0FBSztRQUFrQkUsS0FBSztRQUFrQkQsS0FBSzhCO1FBQWtCaVAsT0FBT3pIO1FBQWtCck4sZ0JBQWdCO0lBQUs7SUFDckg7UUFBRWdFLEtBQUs7UUFBa0JELEtBQUtnSTtRQUF5QitJLE9BQU92RztRQUF5QnZPLGdCQUFnQjtJQUFLO0lBQzVHO1FBQUU4RCxLQUFLO1FBQVdDLEtBQUt3RjtRQUFjdUwsT0FBTy9HO1FBQWMvTixnQkFBZ0I7SUFBSztJQUMvRTtRQUFFZ0UsS0FBSztRQUFlRCxLQUFLMks7UUFBZ0JvRyxPQUFPbEc7SUFBZTtJQUNqRTtRQUFFNUssS0FBSztRQUFnQkQsS0FBS3dIO1FBQWN1SixPQUFPNUc7SUFBYTtJQUM5RDtRQUFFcEssS0FBSztRQUFhQyxLQUFLeUY7UUFBZ0JzTCxPQUFPOUc7UUFBZ0JoTyxnQkFBZ0I7SUFBSztJQUNyRjtRQUFFZ0UsS0FBSztRQUFpQkQsS0FBSzRLO1FBQWNtRyxPQUFPakc7SUFBYTtJQUMvRDtRQUFFN0ssS0FBSztRQUFrQkQsS0FBS3lIO1FBQWdCc0osT0FBTzNHO0lBQWU7SUFDcEU7UUFBRXJLLEtBQUs7UUFBVUMsS0FBS3dIO1FBQWN1SixPQUFPNUc7SUFBYTtJQUN4RDtRQUFFcEssS0FBSztRQUFZQyxLQUFLeUg7UUFBZ0JzSixPQUFPM0c7SUFBZTtJQUM5RDtRQUFFckssS0FBSztRQUFRQyxLQUFLOEg7UUFBNEJpSixPQUFPekc7UUFBNEJyTyxnQkFBZ0I7SUFBSztJQUN4RztRQUFFOEQsS0FBSztRQUFZQyxLQUFLMks7UUFBZ0JvRyxPQUFPbEc7SUFBZTtJQUM5RDtRQUFFOUssS0FBSztRQUFPQyxLQUFLNkg7UUFBMkJrSixPQUFPMUc7UUFBMkJwTyxnQkFBZ0I7SUFBSztJQUNyRztRQUFFOEQsS0FBSztRQUFXQyxLQUFLNEs7UUFBY21HLE9BQU9qRztJQUFhO0lBQ3pEO1FBQUUvSyxLQUFLO1FBQVNDLEtBQUtzUDtRQUF3QnlCLE9BQU96QjtJQUF1QjtJQUMzRTtRQUFFdlAsS0FBSztRQUFTQyxLQUFLK0s7SUFBVTtJQUMvQjtRQUFFaEwsS0FBSztRQUFhQyxLQUFLd007UUFBb0J1RSxPQUFPdkU7SUFBbUI7SUFDdkU7UUFBRXpNLEtBQUs7UUFBVUMsS0FBSzBNO0lBQWtCO0lBQ3hDO1FBQUUzTSxLQUFLO1FBQWlCRSxLQUFLO1FBQWlCRCxLQUFLNk07SUFBb0I7SUFDdkU7UUFBRTlNLEtBQUs7UUFBY0UsS0FBSztRQUFjRCxLQUFLOE07SUFBbUI7SUFDaEU7UUFBRTdNLEtBQUs7UUFBaUJELEtBQUttTjtJQUEyQjtJQUN4RDtRQUFFbE4sS0FBSztRQUFjRCxLQUFLb047SUFBMEI7Q0FDdkQsQ0FBQ3pQLE1BQU0sQ0FBQyxXQUFXLEdBQUVtVCxpQkFBaUJ6WixHQUFHLENBQUNvQyxDQUFBQSxJQUFNO1FBQUV3RyxLQUFLeEcsRUFBRXNHLEdBQUc7UUFBRUMsS0FBS3ZHLEVBQUV1RyxHQUFHO1FBQUUrUSxPQUFPdFgsRUFBRXNYLEtBQUs7SUFBQztBQUMxRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQSxHQUNBLE1BQU1FLGdCQUFnQixXQUFXLEdBQUU7SUFDL0I7UUFBRWxSLEtBQUs7UUFBaUJFLEtBQUs7UUFBa0JELEtBQUtrRjtRQUFrQjZMLE9BQU9sSDtJQUFpQjtJQUM5RjtRQUFFOUosS0FBSztRQUFrQkUsS0FBSztRQUFtQkQsS0FBS21GO1FBQW1CNEwsT0FBT2pIO0lBQWtCO0lBQ2xHO1FBQUUvSixLQUFLO1FBQWVDLEtBQUtxTztJQUFXO0lBQ3RDO1FBQUV0TyxLQUFLO1FBQXFCQyxLQUFLd087SUFBVztJQUM1QztRQUFFek8sS0FBSztRQUFpQkMsS0FBS3NPO0lBQWE7SUFDMUM7UUFBRXZPLEtBQUs7UUFBdUJDLEtBQUt5TztJQUFhO0lBQ2hEO1FBQUUxTyxLQUFLO1FBQVVDLEtBQUt3TDtJQUFrQjtJQUN4QztRQUFFekwsS0FBSztRQUFhQyxLQUFLd1A7SUFBZ0I7SUFDekM7UUFBRXpQLEtBQUs7UUFBU0UsS0FBSztRQUFVRCxLQUFLZ0w7SUFBVztJQUMvQztRQUFFakwsS0FBSztRQUFTQyxLQUFLa0w7UUFBb0JqUCxnQkFBZ0I7SUFBSztJQUM5RDtRQUFFOEQsS0FBSztRQUFTQyxLQUFLd1E7SUFBVztJQUNoQztRQUFFelEsS0FBSztRQUFTQyxLQUFLdVE7SUFBVztJQUNoQztRQUFFeFEsS0FBSztRQUFjQyxLQUFLa1E7SUFBZ0I7SUFDMUM7UUFBRW5RLEtBQUs7UUFBZUMsS0FBSzBPO0lBQVc7SUFDdEM7UUFBRTNPLEtBQUs7UUFBZ0JDLEtBQUt3STtJQUFzQjtJQUNsRDtRQUFFekksS0FBSztRQUFTQyxLQUFLM007SUFBYztJQUNuQztRQUFFME0sS0FBSztRQUFTQyxLQUFLbkw7SUFBbUI7SUFDeEM7UUFBRWtMLEtBQUs7UUFBVUUsS0FBSztRQUFlRCxLQUFLMFE7SUFBbUI7Q0FDaEUsQ0FBQy9TLE1BQU0sQ0FBQ3FUO0FBQ1Q7Ozs7O0FBS0EsR0FDQSxNQUFNRSxnQkFBZ0I7SUFBRW5SLEtBQUs7SUFBT0MsS0FBS3VRO0lBQVlRLE9BQU9QO0FBQVc7QUFFdTVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja25pY2hlLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2NvbW1hbmRzL2Rpc3QvaW5kZXguanM/YmYyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbm5vdGF0aW9uLCBGYWNldCwgY29tYmluZUNvbmZpZywgU3RhdGVGaWVsZCwgVHJhbnNhY3Rpb24sIENoYW5nZVNldCwgQ2hhbmdlRGVzYywgRWRpdG9yU2VsZWN0aW9uLCBTdGF0ZUVmZmVjdCwgVGV4dCwgZmluZENsdXN0ZXJCcmVhaywgY291bnRDb2x1bW4sIENoYXJDYXRlZ29yeSB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IEVkaXRvclZpZXcsIERpcmVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgSW5kZW50Q29udGV4dCwgZ2V0SW5kZW50YXRpb24sIGluZGVudFN0cmluZywgbWF0Y2hCcmFja2V0cywgc3ludGF4VHJlZSwgZ2V0SW5kZW50VW5pdCwgaW5kZW50VW5pdCB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IE5vZGVQcm9wIH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5cbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBXaWxsIHVzZSBsaW5lIGNvbW1lbnRzXG5pZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxsaW5nIGJhY2sgdG8gYmxvY2sgY29tbWVudHMuXG4qL1xuY29uc3QgdG9nZ2xlQ29tbWVudCA9IHRhcmdldCA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHRhcmdldCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoc3RhdGUuc2VsZWN0aW9uLm1haW4uZnJvbSksIGNvbmZpZyA9IGdldENvbmZpZyh0YXJnZXQuc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgcmV0dXJuIGNvbmZpZy5saW5lID8gdG9nZ2xlTGluZUNvbW1lbnQodGFyZ2V0KSA6IGNvbmZpZy5ibG9jayA/IHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSh0YXJnZXQpIDogZmFsc2U7XG59O1xuZnVuY3Rpb24gY29tbWFuZChmLCBvcHRpb24pIHtcbiAgICByZXR1cm4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdHIgPSBmKG9wdGlvbiwgc3RhdGUpO1xuICAgICAgICBpZiAoIXRyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUodHIpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGxpbmUgY29tbWVudHMuXG5UaGUgbGluZSBjb21tZW50IHN5bnRheCBpcyB0YWtlbiBmcm9tIHRoZVxuW2Bjb21tZW50VG9rZW5zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5Db21tZW50VG9rZW5zKSBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLlxuKi9cbmNvbnN0IHRvZ2dsZUxpbmVDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlTGluZUNvbW1lbnQsIDAgLyogQ29tbWVudE9wdGlvbi5Ub2dnbGUgKi8pO1xuLyoqXG5Db21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGxpbmVDb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlTGluZUNvbW1lbnQsIDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovKTtcbi8qKlxuVW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBsaW5lIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGxpbmVVbmNvbW1lbnQgPSAvKkBfX1BVUkVfXyovY29tbWFuZChjaGFuZ2VMaW5lQ29tbWVudCwgMiAvKiBDb21tZW50T3B0aW9uLlVuY29tbWVudCAqLyk7XG4vKipcbkNvbW1lbnQgb3IgdW5jb21tZW50IHRoZSBjdXJyZW50IHNlbGVjdGlvbiB1c2luZyBibG9jayBjb21tZW50cy5cblRoZSBibG9jayBjb21tZW50IHN5bnRheCBpcyB0YWtlbiBmcm9tIHRoZVxuW2Bjb21tZW50VG9rZW5zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5Db21tZW50VG9rZW5zKSBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpLlxuKi9cbmNvbnN0IHRvZ2dsZUJsb2NrQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUJsb2NrQ29tbWVudCwgMCAvKiBDb21tZW50T3B0aW9uLlRvZ2dsZSAqLyk7XG4vKipcbkNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGJsb2NrQ29tbWVudCA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKGNoYW5nZUJsb2NrQ29tbWVudCwgMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8pO1xuLyoqXG5VbmNvbW1lbnQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IGJsb2NrVW5jb21tZW50ID0gLypAX19QVVJFX18qL2NvbW1hbmQoY2hhbmdlQmxvY2tDb21tZW50LCAyIC8qIENvbW1lbnRPcHRpb24uVW5jb21tZW50ICovKTtcbi8qKlxuQ29tbWVudCBvciB1bmNvbW1lbnQgdGhlIGxpbmVzIGFyb3VuZCB0aGUgY3VycmVudCBzZWxlY3Rpb24gdXNpbmdcbmJsb2NrIGNvbW1lbnRzLlxuKi9cbmNvbnN0IHRvZ2dsZUJsb2NrQ29tbWVudEJ5TGluZSA9IC8qQF9fUFVSRV9fKi9jb21tYW5kKChvLCBzKSA9PiBjaGFuZ2VCbG9ja0NvbW1lbnQobywgcywgc2VsZWN0ZWRMaW5lUmFuZ2VzKHMpKSwgMCAvKiBDb21tZW50T3B0aW9uLlRvZ2dsZSAqLyk7XG5mdW5jdGlvbiBnZXRDb25maWcoc3RhdGUsIHBvcykge1xuICAgIGxldCBkYXRhID0gc3RhdGUubGFuZ3VhZ2VEYXRhQXQoXCJjb21tZW50VG9rZW5zXCIsIHBvcyk7XG4gICAgcmV0dXJuIGRhdGEubGVuZ3RoID8gZGF0YVswXSA6IHt9O1xufVxuY29uc3QgU2VhcmNoTWFyZ2luID0gNTA7XG4vKipcbkRldGVybWluZXMgaWYgdGhlIGdpdmVuIHJhbmdlIGlzIGJsb2NrLWNvbW1lbnRlZCBpbiB0aGUgZ2l2ZW5cbnN0YXRlLlxuKi9cbmZ1bmN0aW9uIGZpbmRCbG9ja0NvbW1lbnQoc3RhdGUsIHsgb3BlbiwgY2xvc2UgfSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdGV4dEJlZm9yZSA9IHN0YXRlLnNsaWNlRG9jKGZyb20gLSBTZWFyY2hNYXJnaW4sIGZyb20pO1xuICAgIGxldCB0ZXh0QWZ0ZXIgPSBzdGF0ZS5zbGljZURvYyh0bywgdG8gKyBTZWFyY2hNYXJnaW4pO1xuICAgIGxldCBzcGFjZUJlZm9yZSA9IC9cXHMqJC8uZXhlYyh0ZXh0QmVmb3JlKVswXS5sZW5ndGgsIHNwYWNlQWZ0ZXIgPSAvXlxccyovLmV4ZWModGV4dEFmdGVyKVswXS5sZW5ndGg7XG4gICAgbGV0IGJlZm9yZU9mZiA9IHRleHRCZWZvcmUubGVuZ3RoIC0gc3BhY2VCZWZvcmU7XG4gICAgaWYgKHRleHRCZWZvcmUuc2xpY2UoYmVmb3JlT2ZmIC0gb3Blbi5sZW5ndGgsIGJlZm9yZU9mZikgPT0gb3BlbiAmJlxuICAgICAgICB0ZXh0QWZ0ZXIuc2xpY2Uoc3BhY2VBZnRlciwgc3BhY2VBZnRlciArIGNsb3NlLmxlbmd0aCkgPT0gY2xvc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgb3BlbjogeyBwb3M6IGZyb20gLSBzcGFjZUJlZm9yZSwgbWFyZ2luOiBzcGFjZUJlZm9yZSAmJiAxIH0sXG4gICAgICAgICAgICBjbG9zZTogeyBwb3M6IHRvICsgc3BhY2VBZnRlciwgbWFyZ2luOiBzcGFjZUFmdGVyICYmIDEgfSB9O1xuICAgIH1cbiAgICBsZXQgc3RhcnRUZXh0LCBlbmRUZXh0O1xuICAgIGlmICh0byAtIGZyb20gPD0gMiAqIFNlYXJjaE1hcmdpbikge1xuICAgICAgICBzdGFydFRleHQgPSBlbmRUZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhcnRUZXh0ID0gc3RhdGUuc2xpY2VEb2MoZnJvbSwgZnJvbSArIFNlYXJjaE1hcmdpbik7XG4gICAgICAgIGVuZFRleHQgPSBzdGF0ZS5zbGljZURvYyh0byAtIFNlYXJjaE1hcmdpbiwgdG8pO1xuICAgIH1cbiAgICBsZXQgc3RhcnRTcGFjZSA9IC9eXFxzKi8uZXhlYyhzdGFydFRleHQpWzBdLmxlbmd0aCwgZW5kU3BhY2UgPSAvXFxzKiQvLmV4ZWMoZW5kVGV4dClbMF0ubGVuZ3RoO1xuICAgIGxldCBlbmRPZmYgPSBlbmRUZXh0Lmxlbmd0aCAtIGVuZFNwYWNlIC0gY2xvc2UubGVuZ3RoO1xuICAgIGlmIChzdGFydFRleHQuc2xpY2Uoc3RhcnRTcGFjZSwgc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoKSA9PSBvcGVuICYmXG4gICAgICAgIGVuZFRleHQuc2xpY2UoZW5kT2ZmLCBlbmRPZmYgKyBjbG9zZS5sZW5ndGgpID09IGNsb3NlKSB7XG4gICAgICAgIHJldHVybiB7IG9wZW46IHsgcG9zOiBmcm9tICsgc3RhcnRTcGFjZSArIG9wZW4ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIG1hcmdpbjogL1xccy8udGVzdChzdGFydFRleHQuY2hhckF0KHN0YXJ0U3BhY2UgKyBvcGVuLmxlbmd0aCkpID8gMSA6IDAgfSxcbiAgICAgICAgICAgIGNsb3NlOiB7IHBvczogdG8gLSBlbmRTcGFjZSAtIGNsb3NlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXJnaW46IC9cXHMvLnRlc3QoZW5kVGV4dC5jaGFyQXQoZW5kT2ZmIC0gMSkpID8gMSA6IDAgfSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdGVkTGluZVJhbmdlcyhzdGF0ZSkge1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCByIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IGZyb21MaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyLmZyb20pO1xuICAgICAgICBsZXQgdG9MaW5lID0gci50byA8PSBmcm9tTGluZS50byA/IGZyb21MaW5lIDogc3RhdGUuZG9jLmxpbmVBdChyLnRvKTtcbiAgICAgICAgaWYgKHRvTGluZS5mcm9tID4gZnJvbUxpbmUuZnJvbSAmJiB0b0xpbmUuZnJvbSA9PSByLnRvKVxuICAgICAgICAgICAgdG9MaW5lID0gci50byA9PSBmcm9tTGluZS50byArIDEgPyBmcm9tTGluZSA6IHN0YXRlLmRvYy5saW5lQXQoci50byAtIDEpO1xuICAgICAgICBsZXQgbGFzdCA9IHJhbmdlcy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA+PSAwICYmIHJhbmdlc1tsYXN0XS50byA+IGZyb21MaW5lLmZyb20pXG4gICAgICAgICAgICByYW5nZXNbbGFzdF0udG8gPSB0b0xpbmUudG87XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogZnJvbUxpbmUuZnJvbSArIC9eXFxzKi8uZXhlYyhmcm9tTGluZS50ZXh0KVswXS5sZW5ndGgsIHRvOiB0b0xpbmUudG8gfSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG59XG4vLyBQZXJmb3JtcyB0b2dnbGUsIGNvbW1lbnQgYW5kIHVuY29tbWVudCBvZiBibG9jayBjb21tZW50cyBpblxuLy8gbGFuZ3VhZ2VzIHRoYXQgc3VwcG9ydCB0aGVtLlxuZnVuY3Rpb24gY2hhbmdlQmxvY2tDb21tZW50KG9wdGlvbiwgc3RhdGUsIHJhbmdlcyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICBsZXQgdG9rZW5zID0gcmFuZ2VzLm1hcChyID0+IGdldENvbmZpZyhzdGF0ZSwgci5mcm9tKS5ibG9jayk7XG4gICAgaWYgKCF0b2tlbnMuZXZlcnkoYyA9PiBjKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGNvbW1lbnRzID0gcmFuZ2VzLm1hcCgociwgaSkgPT4gZmluZEJsb2NrQ29tbWVudChzdGF0ZSwgdG9rZW5zW2ldLCByLmZyb20sIHIudG8pKTtcbiAgICBpZiAob3B0aW9uICE9IDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8gJiYgIWNvbW1lbnRzLmV2ZXJ5KGMgPT4gYykpIHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogc3RhdGUuY2hhbmdlcyhyYW5nZXMubWFwKChyYW5nZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb21tZW50c1tpXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbeyBmcm9tOiByYW5nZS5mcm9tLCBpbnNlcnQ6IHRva2Vuc1tpXS5vcGVuICsgXCIgXCIgfSwgeyBmcm9tOiByYW5nZS50bywgaW5zZXJ0OiBcIiBcIiArIHRva2Vuc1tpXS5jbG9zZSB9XTtcbiAgICAgICAgICAgIH0pKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb24gIT0gMSAvKiBDb21tZW50T3B0aW9uLkNvbW1lbnQgKi8gJiYgY29tbWVudHMuc29tZShjID0+IGMpKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjb21tZW50OyBpIDwgY29tbWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tbWVudCA9IGNvbW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gdG9rZW5zW2ldLCB7IG9wZW4sIGNsb3NlIH0gPSBjb21tZW50O1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IG9wZW4ucG9zIC0gdG9rZW4ub3Blbi5sZW5ndGgsIHRvOiBvcGVuLnBvcyArIG9wZW4ubWFyZ2luIH0sIHsgZnJvbTogY2xvc2UucG9zIC0gY2xvc2UubWFyZ2luLCB0bzogY2xvc2UucG9zICsgdG9rZW4uY2xvc2UubGVuZ3RoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gUGVyZm9ybXMgdG9nZ2xlLCBjb21tZW50IGFuZCB1bmNvbW1lbnQgb2YgbGluZSBjb21tZW50cy5cbmZ1bmN0aW9uIGNoYW5nZUxpbmVDb21tZW50KG9wdGlvbiwgc3RhdGUsIHJhbmdlcyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsZXQgcHJldkxpbmUgPSAtMTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBzdGFydEkgPSBsaW5lcy5sZW5ndGgsIG1pbkluZGVudCA9IDFlOTtcbiAgICAgICAgbGV0IHRva2VuID0gZ2V0Q29uZmlnKHN0YXRlLCBmcm9tKS5saW5lO1xuICAgICAgICBpZiAoIXRva2VuKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IGZyb207IHBvcyA8PSB0bzspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGxpbmUuZnJvbSA+IHByZXZMaW5lICYmIChmcm9tID09IHRvIHx8IHRvID4gbGluZS5mcm9tKSkge1xuICAgICAgICAgICAgICAgIHByZXZMaW5lID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSAvXlxccyovLmV4ZWMobGluZS50ZXh0KVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGVtcHR5ID0gaW5kZW50ID09IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBjb21tZW50ID0gbGluZS50ZXh0LnNsaWNlKGluZGVudCwgaW5kZW50ICsgdG9rZW4ubGVuZ3RoKSA9PSB0b2tlbiA/IGluZGVudCA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChpbmRlbnQgPCBsaW5lLnRleHQubGVuZ3RoICYmIGluZGVudCA8IG1pbkluZGVudClcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZW50ID0gaW5kZW50O1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goeyBsaW5lLCBjb21tZW50LCB0b2tlbiwgaW5kZW50LCBlbXB0eSwgc2luZ2xlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW5JbmRlbnQgPCAxZTkpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzW2ldLmluZGVudCA8IGxpbmVzW2ldLmxpbmUudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzW2ldLmluZGVudCA9IG1pbkluZGVudDtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PSBzdGFydEkgKyAxKVxuICAgICAgICAgICAgbGluZXNbc3RhcnRJXS5zaW5nbGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0aW9uICE9IDIgLyogQ29tbWVudE9wdGlvbi5VbmNvbW1lbnQgKi8gJiYgbGluZXMuc29tZShsID0+IGwuY29tbWVudCA8IDAgJiYgKCFsLmVtcHR5IHx8IGwuc2luZ2xlKSkpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeyBsaW5lLCB0b2tlbiwgaW5kZW50LCBlbXB0eSwgc2luZ2xlIH0gb2YgbGluZXMpXG4gICAgICAgICAgICBpZiAoc2luZ2xlIHx8ICFlbXB0eSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20gKyBpbmRlbnQsIGluc2VydDogdG9rZW4gKyBcIiBcIiB9KTtcbiAgICAgICAgbGV0IGNoYW5nZVNldCA9IHN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IGNoYW5nZVNldCwgc2VsZWN0aW9uOiBzdGF0ZS5zZWxlY3Rpb24ubWFwKGNoYW5nZVNldCwgMSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9uICE9IDEgLyogQ29tbWVudE9wdGlvbi5Db21tZW50ICovICYmIGxpbmVzLnNvbWUobCA9PiBsLmNvbW1lbnQgPj0gMCkpIHtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeyBsaW5lLCBjb21tZW50LCB0b2tlbiB9IG9mIGxpbmVzKVxuICAgICAgICAgICAgaWYgKGNvbW1lbnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gbGluZS5mcm9tICsgY29tbWVudCwgdG8gPSBmcm9tICsgdG9rZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLnRleHRbdG8gLSBsaW5lLmZyb21dID09IFwiIFwiKVxuICAgICAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBmcm9tSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5UcmFuc2FjdGlvbiBhbm5vdGF0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IHRoYXQgdHJhbnNhY3Rpb24gZnJvbVxuYmVpbmcgY29tYmluZWQgd2l0aCBvdGhlciB0cmFuc2FjdGlvbnMgaW4gdGhlIHVuZG8gaGlzdG9yeS4gR2l2ZW5cbmBcImJlZm9yZVwiYCwgaXQnbGwgcHJldmVudCBtZXJnaW5nIHdpdGggcHJldmlvdXMgdHJhbnNhY3Rpb25zLiBXaXRoXG5gXCJhZnRlclwiYCwgc3Vic2VxdWVudCB0cmFuc2FjdGlvbnMgd29uJ3QgYmUgY29tYmluZWQgd2l0aCB0aGlzXG5vbmUuIFdpdGggYFwiZnVsbFwiYCwgdGhlIHRyYW5zYWN0aW9uIGlzIGlzb2xhdGVkIG9uIGJvdGggc2lkZXMuXG4qL1xuY29uc3QgaXNvbGF0ZUhpc3RvcnkgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuVGhpcyBmYWNldCBwcm92aWRlcyBhIHdheSB0byByZWdpc3RlciBmdW5jdGlvbnMgdGhhdCwgZ2l2ZW4gYVxudHJhbnNhY3Rpb24sIHByb3ZpZGUgYSBzZXQgb2YgZWZmZWN0cyB0aGF0IHRoZSBoaXN0b3J5IHNob3VsZFxuc3RvcmUgd2hlbiBpbnZlcnRpbmcgdGhlIHRyYW5zYWN0aW9uLiBUaGlzIGNhbiBiZSB1c2VkIHRvXG5pbnRlZ3JhdGUgc29tZSBraW5kcyBvZiBlZmZlY3RzIGluIHRoZSBoaXN0b3J5LCBzbyB0aGF0IHRoZXkgY2FuXG5iZSB1bmRvbmUgKGFuZCByZWRvbmUgYWdhaW4pLlxuKi9cbmNvbnN0IGludmVydGVkRWZmZWN0cyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGhpc3RvcnlDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgbWluRGVwdGg6IDEwMCxcbiAgICAgICAgICAgIG5ld0dyb3VwRGVsYXk6IDUwMCxcbiAgICAgICAgICAgIGpvaW5Ub0V2ZW50OiAoX3QsIGlzQWRqYWNlbnQpID0+IGlzQWRqYWNlbnQsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1pbkRlcHRoOiBNYXRoLm1heCxcbiAgICAgICAgICAgIG5ld0dyb3VwRGVsYXk6IE1hdGgubWluLFxuICAgICAgICAgICAgam9pblRvRXZlbnQ6IChhLCBiKSA9PiAodHIsIGFkaikgPT4gYSh0ciwgYWRqKSB8fCBiKHRyLCBhZGopXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuY29uc3QgaGlzdG9yeUZpZWxkXyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gSGlzdG9yeVN0YXRlLmVtcHR5O1xuICAgIH0sXG4gICAgdXBkYXRlKHN0YXRlLCB0cikge1xuICAgICAgICBsZXQgY29uZmlnID0gdHIuc3RhdGUuZmFjZXQoaGlzdG9yeUNvbmZpZyk7XG4gICAgICAgIGxldCBmcm9tSGlzdCA9IHRyLmFubm90YXRpb24oZnJvbUhpc3RvcnkpO1xuICAgICAgICBpZiAoZnJvbUhpc3QpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSGlzdEV2ZW50LmZyb21UcmFuc2FjdGlvbih0ciwgZnJvbUhpc3Quc2VsZWN0aW9uKSwgZnJvbSA9IGZyb21IaXN0LnNpZGU7XG4gICAgICAgICAgICBsZXQgb3RoZXIgPSBmcm9tID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gc3RhdGUudW5kb25lIDogc3RhdGUuZG9uZTtcbiAgICAgICAgICAgIGlmIChpdGVtKVxuICAgICAgICAgICAgICAgIG90aGVyID0gdXBkYXRlQnJhbmNoKG90aGVyLCBvdGhlci5sZW5ndGgsIGNvbmZpZy5taW5EZXB0aCwgaXRlbSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3RoZXIgPSBhZGRTZWxlY3Rpb24ob3RoZXIsIHRyLnN0YXJ0U3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGZyb20gPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBmcm9tSGlzdC5yZXN0IDogb3RoZXIsIGZyb20gPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBvdGhlciA6IGZyb21IaXN0LnJlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpc29sYXRlID0gdHIuYW5ub3RhdGlvbihpc29sYXRlSGlzdG9yeSk7XG4gICAgICAgIGlmIChpc29sYXRlID09IFwiZnVsbFwiIHx8IGlzb2xhdGUgPT0gXCJiZWZvcmVcIilcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuaXNvbGF0ZSgpO1xuICAgICAgICBpZiAodHIuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi5hZGRUb0hpc3RvcnkpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiAhdHIuY2hhbmdlcy5lbXB0eSA/IHN0YXRlLmFkZE1hcHBpbmcodHIuY2hhbmdlcy5kZXNjKSA6IHN0YXRlO1xuICAgICAgICBsZXQgZXZlbnQgPSBIaXN0RXZlbnQuZnJvbVRyYW5zYWN0aW9uKHRyKTtcbiAgICAgICAgbGV0IHRpbWUgPSB0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnRpbWUpLCB1c2VyRXZlbnQgPSB0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnVzZXJFdmVudCk7XG4gICAgICAgIGlmIChldmVudClcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuYWRkQ2hhbmdlcyhldmVudCwgdGltZSwgdXNlckV2ZW50LCBjb25maWcsIHRyKTtcbiAgICAgICAgZWxzZSBpZiAodHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5hZGRTZWxlY3Rpb24odHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24sIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLm5ld0dyb3VwRGVsYXkpO1xuICAgICAgICBpZiAoaXNvbGF0ZSA9PSBcImZ1bGxcIiB8fCBpc29sYXRlID09IFwiYWZ0ZXJcIilcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuaXNvbGF0ZSgpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICB0b0pTT04odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdmFsdWUuZG9uZS5tYXAoZSA9PiBlLnRvSlNPTigpKSwgdW5kb25lOiB2YWx1ZS51bmRvbmUubWFwKGUgPT4gZS50b0pTT04oKSkgfTtcbiAgICB9LFxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoanNvbi5kb25lLm1hcChIaXN0RXZlbnQuZnJvbUpTT04pLCBqc29uLnVuZG9uZS5tYXAoSGlzdEV2ZW50LmZyb21KU09OKSk7XG4gICAgfVxufSk7XG4vKipcbkNyZWF0ZSBhIGhpc3RvcnkgZXh0ZW5zaW9uIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4qL1xuZnVuY3Rpb24gaGlzdG9yeShjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGhpc3RvcnlGaWVsZF8sXG4gICAgICAgIGhpc3RvcnlDb25maWcub2YoY29uZmlnKSxcbiAgICAgICAgRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICAgICAgICAgIGJlZm9yZWlucHV0KGUsIHZpZXcpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29tbWFuZCA9IGUuaW5wdXRUeXBlID09IFwiaGlzdG9yeVVuZG9cIiA/IHVuZG8gOiBlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlSZWRvXCIgPyByZWRvIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbW1hbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgXTtcbn1cbi8qKlxuVGhlIHN0YXRlIGZpZWxkIHVzZWQgdG8gc3RvcmUgdGhlIGhpc3RvcnkgZGF0YS4gU2hvdWxkIHByb2JhYmx5XG5vbmx5IGJlIHVzZWQgd2hlbiB5b3Ugd2FudCB0b1xuW3NlcmlhbGl6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIG9yXG5bZGVzZXJpYWxpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeZnJvbUpTT04pIHN0YXRlIG9iamVjdHMgaW4gYSB3YXlcbnRoYXQgcHJlc2VydmVzIGhpc3RvcnkuXG4qL1xuY29uc3QgaGlzdG9yeUZpZWxkID0gaGlzdG9yeUZpZWxkXztcbmZ1bmN0aW9uIGNtZChzaWRlLCBzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHsgc3RhdGUsIGRpc3BhdGNoIH0pIHtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gJiYgc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBoaXN0b3J5U3RhdGUgPSBzdGF0ZS5maWVsZChoaXN0b3J5RmllbGRfLCBmYWxzZSk7XG4gICAgICAgIGlmICghaGlzdG9yeVN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdHIgPSBoaXN0b3J5U3RhdGUucG9wKHNpZGUsIHN0YXRlLCBzZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXRyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblVuZG8gYSBzaW5nbGUgZ3JvdXAgb2YgaGlzdG9yeSBldmVudHMuIFJldHVybnMgZmFsc2UgaWYgbm8gZ3JvdXBcbndhcyBhdmFpbGFibGUuXG4qL1xuY29uc3QgdW5kbyA9IC8qQF9fUFVSRV9fKi9jbWQoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8sIGZhbHNlKTtcbi8qKlxuUmVkbyBhIGdyb3VwIG9mIGhpc3RvcnkgZXZlbnRzLiBSZXR1cm5zIGZhbHNlIGlmIG5vIGdyb3VwIHdhc1xuYXZhaWxhYmxlLlxuKi9cbmNvbnN0IHJlZG8gPSAvKkBfX1BVUkVfXyovY21kKDEgLyogQnJhbmNoTmFtZS5VbmRvbmUgKi8sIGZhbHNlKTtcbi8qKlxuVW5kbyBhIGNoYW5nZSBvciBzZWxlY3Rpb24gY2hhbmdlLlxuKi9cbmNvbnN0IHVuZG9TZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovY21kKDAgLyogQnJhbmNoTmFtZS5Eb25lICovLCB0cnVlKTtcbi8qKlxuUmVkbyBhIGNoYW5nZSBvciBzZWxlY3Rpb24gY2hhbmdlLlxuKi9cbmNvbnN0IHJlZG9TZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovY21kKDEgLyogQnJhbmNoTmFtZS5VbmRvbmUgKi8sIHRydWUpO1xuZnVuY3Rpb24gZGVwdGgoc2lkZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgbGV0IGhpc3RTdGF0ZSA9IHN0YXRlLmZpZWxkKGhpc3RvcnlGaWVsZF8sIGZhbHNlKTtcbiAgICAgICAgaWYgKCFoaXN0U3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGJyYW5jaCA9IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBoaXN0U3RhdGUuZG9uZSA6IGhpc3RTdGF0ZS51bmRvbmU7XG4gICAgICAgIHJldHVybiBicmFuY2gubGVuZ3RoIC0gKGJyYW5jaC5sZW5ndGggJiYgIWJyYW5jaFswXS5jaGFuZ2VzID8gMSA6IDApO1xuICAgIH07XG59XG4vKipcblRoZSBhbW91bnQgb2YgdW5kb2FibGUgY2hhbmdlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5jb25zdCB1bmRvRGVwdGggPSAvKkBfX1BVUkVfXyovZGVwdGgoMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8pO1xuLyoqXG5UaGUgYW1vdW50IG9mIHJlZG9hYmxlIGNoYW5nZSBldmVudHMgYXZhaWxhYmxlIGluIGEgZ2l2ZW4gc3RhdGUuXG4qL1xuY29uc3QgcmVkb0RlcHRoID0gLypAX19QVVJFX18qL2RlcHRoKDEgLyogQnJhbmNoTmFtZS5VbmRvbmUgKi8pO1xuLy8gSGlzdG9yeSBldmVudHMgc3RvcmUgZ3JvdXBzIG9mIGNoYW5nZXMgb3IgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmVcbi8vIHVuZG9uZS9yZWRvbmUgdG9nZXRoZXIuXG5jbGFzcyBIaXN0RXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBjaGFuZ2VzIGluIHRoaXMgZXZlbnQuIE5vcm1hbCBldmVudHMgaG9sZCBhdCBsZWFzdCBvbmVcbiAgICAvLyBjaGFuZ2Ugb3IgZWZmZWN0LiBCdXQgaXQgbWF5IGJlIG5lY2Vzc2FyeSB0byBzdG9yZSBzZWxlY3Rpb25cbiAgICAvLyBldmVudHMgYmVmb3JlIHRoZSBmaXJzdCBjaGFuZ2UsIGluIHdoaWNoIGNhc2UgYSBzcGVjaWFsIHR5cGUgb2ZcbiAgICAvLyBpbnN0YW5jZSBpcyBjcmVhdGVkIHdoaWNoIGRvZXNuJ3QgaG9sZCBhbnkgY2hhbmdlcywgd2l0aFxuICAgIC8vIGNoYW5nZXMgPT0gc3RhcnRTZWxlY3Rpb24gPT0gdW5kZWZpbmVkXG4gICAgY2hhbmdlcywgXG4gICAgLy8gVGhlIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXZlbnRcbiAgICBlZmZlY3RzLCBcbiAgICAvLyBBY2N1bXVsYXRlZCBtYXBwaW5nIChmcm9tIGFkZFRvSGlzdG9yeT09ZmFsc2UpIHRoYXQgc2hvdWxkIGJlXG4gICAgLy8gYXBwbGllZCB0byBldmVudHMgYmVsb3cgdGhpcyBvbmUuXG4gICAgbWFwcGVkLCBcbiAgICAvLyBUaGUgc2VsZWN0aW9uIGJlZm9yZSB0aGlzIGV2ZW50XG4gICAgc3RhcnRTZWxlY3Rpb24sIFxuICAgIC8vIFN0b3JlcyBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciB0aGlzIGV2ZW50LCB0byBiZSB1c2VkIGZvclxuICAgIC8vIHNlbGVjdGlvbiB1bmRvL3JlZG8uXG4gICAgc2VsZWN0aW9uc0FmdGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IGVmZmVjdHM7XG4gICAgICAgIHRoaXMubWFwcGVkID0gbWFwcGVkO1xuICAgICAgICB0aGlzLnN0YXJ0U2VsZWN0aW9uID0gc3RhcnRTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uc0FmdGVyID0gc2VsZWN0aW9uc0FmdGVyO1xuICAgIH1cbiAgICBzZXRTZWxBZnRlcihhZnRlcikge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh0aGlzLmNoYW5nZXMsIHRoaXMuZWZmZWN0cywgdGhpcy5tYXBwZWQsIHRoaXMuc3RhcnRTZWxlY3Rpb24sIGFmdGVyKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXM6IChfYSA9IHRoaXMuY2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSlNPTigpLFxuICAgICAgICAgICAgbWFwcGVkOiAoX2IgPSB0aGlzLm1hcHBlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvSlNPTigpLFxuICAgICAgICAgICAgc3RhcnRTZWxlY3Rpb246IChfYyA9IHRoaXMuc3RhcnRTZWxlY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b0pTT04oKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbnNBZnRlcjogdGhpcy5zZWxlY3Rpb25zQWZ0ZXIubWFwKHMgPT4gcy50b0pTT04oKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQoanNvbi5jaGFuZ2VzICYmIENoYW5nZVNldC5mcm9tSlNPTihqc29uLmNoYW5nZXMpLCBbXSwganNvbi5tYXBwZWQgJiYgQ2hhbmdlRGVzYy5mcm9tSlNPTihqc29uLm1hcHBlZCksIGpzb24uc3RhcnRTZWxlY3Rpb24gJiYgRWRpdG9yU2VsZWN0aW9uLmZyb21KU09OKGpzb24uc3RhcnRTZWxlY3Rpb24pLCBqc29uLnNlbGVjdGlvbnNBZnRlci5tYXAoRWRpdG9yU2VsZWN0aW9uLmZyb21KU09OKSk7XG4gICAgfVxuICAgIC8vIFRoaXMgZG9lcyBub3QgY2hlY2sgYGFkZFRvSGlzdG9yeWAgYW5kIHN1Y2gsIGl0IGFzc3VtZXMgdGhlXG4gICAgLy8gdHJhbnNhY3Rpb24gbmVlZHMgdG8gYmUgY29udmVydGVkIHRvIGFuIGl0ZW0uIFJldHVybnMgbnVsbCB3aGVuXG4gICAgLy8gdGhlcmUgYXJlIG5vIGNoYW5nZXMgb3IgZWZmZWN0cyBpbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgc3RhdGljIGZyb21UcmFuc2FjdGlvbih0ciwgc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBlZmZlY3RzID0gbm9uZTtcbiAgICAgICAgZm9yIChsZXQgaW52ZXJ0IG9mIHRyLnN0YXJ0U3RhdGUuZmFjZXQoaW52ZXJ0ZWRFZmZlY3RzKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGludmVydCh0cik7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBlZmZlY3RzID0gZWZmZWN0cy5jb25jYXQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVmZmVjdHMubGVuZ3RoICYmIHRyLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodHIuY2hhbmdlcy5pbnZlcnQodHIuc3RhcnRTdGF0ZS5kb2MpLCBlZmZlY3RzLCB1bmRlZmluZWQsIHNlbGVjdGlvbiB8fCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbiwgbm9uZSk7XG4gICAgfVxuICAgIHN0YXRpYyBzZWxlY3Rpb24oc2VsZWN0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RFdmVudCh1bmRlZmluZWQsIG5vbmUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBzZWxlY3Rpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVCcmFuY2goYnJhbmNoLCB0bywgbWF4TGVuLCBuZXdFdmVudCkge1xuICAgIGxldCBzdGFydCA9IHRvICsgMSA+IG1heExlbiArIDIwID8gdG8gLSBtYXhMZW4gLSAxIDogMDtcbiAgICBsZXQgbmV3QnJhbmNoID0gYnJhbmNoLnNsaWNlKHN0YXJ0LCB0byk7XG4gICAgbmV3QnJhbmNoLnB1c2gobmV3RXZlbnQpO1xuICAgIHJldHVybiBuZXdCcmFuY2g7XG59XG5mdW5jdGlvbiBpc0FkamFjZW50KGEsIGIpIHtcbiAgICBsZXQgcmFuZ2VzID0gW10sIGlzQWRqYWNlbnQgPSBmYWxzZTtcbiAgICBhLml0ZXJDaGFuZ2VkUmFuZ2VzKChmLCB0KSA9PiByYW5nZXMucHVzaChmLCB0KSk7XG4gICAgYi5pdGVyQ2hhbmdlZFJhbmdlcygoX2YsIF90LCBmLCB0KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzW2krK10sIHRvID0gcmFuZ2VzW2krK107XG4gICAgICAgICAgICBpZiAodCA+PSBmcm9tICYmIGYgPD0gdG8pXG4gICAgICAgICAgICAgICAgaXNBZGphY2VudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXNBZGphY2VudDtcbn1cbmZ1bmN0aW9uIGVxU2VsZWN0aW9uU2hhcGUoYSwgYikge1xuICAgIHJldHVybiBhLnJhbmdlcy5sZW5ndGggPT0gYi5yYW5nZXMubGVuZ3RoICYmXG4gICAgICAgIGEucmFuZ2VzLmZpbHRlcigociwgaSkgPT4gci5lbXB0eSAhPSBiLnJhbmdlc1tpXS5lbXB0eSkubGVuZ3RoID09PSAwO1xufVxuZnVuY3Rpb24gY29uYyhhLCBiKSB7XG4gICAgcmV0dXJuICFhLmxlbmd0aCA/IGIgOiAhYi5sZW5ndGggPyBhIDogYS5jb25jYXQoYik7XG59XG5jb25zdCBub25lID0gW107XG5jb25zdCBNYXhTZWxlY3Rpb25zUGVyRXZlbnQgPSAyMDA7XG5mdW5jdGlvbiBhZGRTZWxlY3Rpb24oYnJhbmNoLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoIWJyYW5jaC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtIaXN0RXZlbnQuc2VsZWN0aW9uKFtzZWxlY3Rpb25dKV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbGFzdEV2ZW50ID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXTtcbiAgICAgICAgbGV0IHNlbHMgPSBsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLnNsaWNlKE1hdGgubWF4KDAsIGxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gTWF4U2VsZWN0aW9uc1BlckV2ZW50KSk7XG4gICAgICAgIGlmIChzZWxzLmxlbmd0aCAmJiBzZWxzW3NlbHMubGVuZ3RoIC0gMV0uZXEoc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgICAgIHNlbHMucHVzaChzZWxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gdXBkYXRlQnJhbmNoKGJyYW5jaCwgYnJhbmNoLmxlbmd0aCAtIDEsIDFlOSwgbGFzdEV2ZW50LnNldFNlbEFmdGVyKHNlbHMpKTtcbiAgICB9XG59XG4vLyBBc3N1bWVzIHRoZSB0b3AgaXRlbSBoYXMgb25lIG9yIG1vcmUgc2VsZWN0aW9uQWZ0ZXIgdmFsdWVzXG5mdW5jdGlvbiBwb3BTZWxlY3Rpb24oYnJhbmNoKSB7XG4gICAgbGV0IGxhc3QgPSBicmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdO1xuICAgIGxldCBuZXdCcmFuY2ggPSBicmFuY2guc2xpY2UoKTtcbiAgICBuZXdCcmFuY2hbYnJhbmNoLmxlbmd0aCAtIDFdID0gbGFzdC5zZXRTZWxBZnRlcihsYXN0LnNlbGVjdGlvbnNBZnRlci5zbGljZSgwLCBsYXN0LnNlbGVjdGlvbnNBZnRlci5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIG5ld0JyYW5jaDtcbn1cbi8vIEFkZCBhIG1hcHBpbmcgdG8gdGhlIHRvcCBldmVudCBpbiB0aGUgZ2l2ZW4gYnJhbmNoLiBJZiB0aGlzIG1hcHNcbi8vIGF3YXkgYWxsIHRoZSBjaGFuZ2VzIGFuZCBlZmZlY3RzIGluIHRoYXQgaXRlbSwgZHJvcCBpdCBhbmRcbi8vIHByb3BhZ2F0ZSB0aGUgbWFwcGluZyB0byB0aGUgbmV4dCBpdGVtLlxuZnVuY3Rpb24gYWRkTWFwcGluZ1RvQnJhbmNoKGJyYW5jaCwgbWFwcGluZykge1xuICAgIGlmICghYnJhbmNoLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICBsZXQgbGVuZ3RoID0gYnJhbmNoLmxlbmd0aCwgc2VsZWN0aW9ucyA9IG5vbmU7XG4gICAgd2hpbGUgKGxlbmd0aCkge1xuICAgICAgICBsZXQgZXZlbnQgPSBtYXBFdmVudChicmFuY2hbbGVuZ3RoIC0gMV0sIG1hcHBpbmcsIHNlbGVjdGlvbnMpO1xuICAgICAgICBpZiAoZXZlbnQuY2hhbmdlcyAmJiAhZXZlbnQuY2hhbmdlcy5lbXB0eSB8fCBldmVudC5lZmZlY3RzLmxlbmd0aCkgeyAvLyBFdmVudCBzdXJ2aXZlZCBtYXBwaW5nXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gYnJhbmNoLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICAgICAgICByZXN1bHRbbGVuZ3RoIC0gMV0gPSBldmVudDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIERyb3AgdGhpcyBldmVudCwgc2luY2UgdGhlcmUncyBubyBjaGFuZ2VzIG9yIGVmZmVjdHMgbGVmdFxuICAgICAgICAgICAgbWFwcGluZyA9IGV2ZW50Lm1hcHBlZDtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgc2VsZWN0aW9ucyA9IGV2ZW50LnNlbGVjdGlvbnNBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0aW9ucy5sZW5ndGggPyBbSGlzdEV2ZW50LnNlbGVjdGlvbihzZWxlY3Rpb25zKV0gOiBub25lO1xufVxuZnVuY3Rpb24gbWFwRXZlbnQoZXZlbnQsIG1hcHBpbmcsIGV4dHJhU2VsZWN0aW9ucykge1xuICAgIGxldCBzZWxlY3Rpb25zID0gY29uYyhldmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoID8gZXZlbnQuc2VsZWN0aW9uc0FmdGVyLm1hcChzID0+IHMubWFwKG1hcHBpbmcpKSA6IG5vbmUsIGV4dHJhU2VsZWN0aW9ucyk7XG4gICAgLy8gQ2hhbmdlLWxlc3MgZXZlbnRzIGRvbid0IHN0b3JlIG1hcHBpbmdzICh0aGV5IGFyZSBhbHdheXMgdGhlIGxhc3QgZXZlbnQgaW4gYSBicmFuY2gpXG4gICAgaWYgKCFldmVudC5jaGFuZ2VzKVxuICAgICAgICByZXR1cm4gSGlzdEV2ZW50LnNlbGVjdGlvbihzZWxlY3Rpb25zKTtcbiAgICBsZXQgbWFwcGVkQ2hhbmdlcyA9IGV2ZW50LmNoYW5nZXMubWFwKG1hcHBpbmcpLCBiZWZvcmUgPSBtYXBwaW5nLm1hcERlc2MoZXZlbnQuY2hhbmdlcywgdHJ1ZSk7XG4gICAgbGV0IGZ1bGxNYXBwaW5nID0gZXZlbnQubWFwcGVkID8gZXZlbnQubWFwcGVkLmNvbXBvc2VEZXNjKGJlZm9yZSkgOiBiZWZvcmU7XG4gICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQobWFwcGVkQ2hhbmdlcywgU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhldmVudC5lZmZlY3RzLCBtYXBwaW5nKSwgZnVsbE1hcHBpbmcsIGV2ZW50LnN0YXJ0U2VsZWN0aW9uLm1hcChiZWZvcmUpLCBzZWxlY3Rpb25zKTtcbn1cbmNvbnN0IGpvaW5hYmxlVXNlckV2ZW50ID0gL14oaW5wdXRcXC50eXBlfGRlbGV0ZSkoJHxcXC4pLztcbmNsYXNzIEhpc3RvcnlTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZG9uZSwgdW5kb25lLCBwcmV2VGltZSA9IDAsIHByZXZVc2VyRXZlbnQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5kb25lID0gZG9uZTtcbiAgICAgICAgdGhpcy51bmRvbmUgPSB1bmRvbmU7XG4gICAgICAgIHRoaXMucHJldlRpbWUgPSBwcmV2VGltZTtcbiAgICAgICAgdGhpcy5wcmV2VXNlckV2ZW50ID0gcHJldlVzZXJFdmVudDtcbiAgICB9XG4gICAgaXNvbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldlRpbWUgPyBuZXcgSGlzdG9yeVN0YXRlKHRoaXMuZG9uZSwgdGhpcy51bmRvbmUpIDogdGhpcztcbiAgICB9XG4gICAgYWRkQ2hhbmdlcyhldmVudCwgdGltZSwgdXNlckV2ZW50LCBjb25maWcsIHRyKSB7XG4gICAgICAgIGxldCBkb25lID0gdGhpcy5kb25lLCBsYXN0RXZlbnQgPSBkb25lW2RvbmUubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0RXZlbnQgJiYgbGFzdEV2ZW50LmNoYW5nZXMgJiYgIWxhc3RFdmVudC5jaGFuZ2VzLmVtcHR5ICYmIGV2ZW50LmNoYW5nZXMgJiZcbiAgICAgICAgICAgICghdXNlckV2ZW50IHx8IGpvaW5hYmxlVXNlckV2ZW50LnRlc3QodXNlckV2ZW50KSkgJiZcbiAgICAgICAgICAgICgoIWxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgdGltZSAtIHRoaXMucHJldlRpbWUgPCBjb25maWcubmV3R3JvdXBEZWxheSAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5qb2luVG9FdmVudCh0ciwgaXNBZGphY2VudChsYXN0RXZlbnQuY2hhbmdlcywgZXZlbnQuY2hhbmdlcykpKSB8fFxuICAgICAgICAgICAgICAgIC8vIEZvciBjb21wb3NlIChidXQgbm90IGNvbXBvc2Uuc3RhcnQpIGV2ZW50cywgYWx3YXlzIGpvaW4gd2l0aCBwcmV2aW91cyBldmVudFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudCA9PSBcImlucHV0LnR5cGUuY29tcG9zZVwiKSkge1xuICAgICAgICAgICAgZG9uZSA9IHVwZGF0ZUJyYW5jaChkb25lLCBkb25lLmxlbmd0aCAtIDEsIGNvbmZpZy5taW5EZXB0aCwgbmV3IEhpc3RFdmVudChldmVudC5jaGFuZ2VzLmNvbXBvc2UobGFzdEV2ZW50LmNoYW5nZXMpLCBjb25jKFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoZXZlbnQuZWZmZWN0cywgbGFzdEV2ZW50LmNoYW5nZXMpLCBsYXN0RXZlbnQuZWZmZWN0cyksIGxhc3RFdmVudC5tYXBwZWQsIGxhc3RFdmVudC5zdGFydFNlbGVjdGlvbiwgbm9uZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG9uZSA9IHVwZGF0ZUJyYW5jaChkb25lLCBkb25lLmxlbmd0aCwgY29uZmlnLm1pbkRlcHRoLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoZG9uZSwgbm9uZSwgdGltZSwgdXNlckV2ZW50KTtcbiAgICB9XG4gICAgYWRkU2VsZWN0aW9uKHNlbGVjdGlvbiwgdGltZSwgdXNlckV2ZW50LCBuZXdHcm91cERlbGF5KSB7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5kb25lLmxlbmd0aCA/IHRoaXMuZG9uZVt0aGlzLmRvbmUubGVuZ3RoIC0gMV0uc2VsZWN0aW9uc0FmdGVyIDogbm9uZTtcbiAgICAgICAgaWYgKGxhc3QubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGltZSAtIHRoaXMucHJldlRpbWUgPCBuZXdHcm91cERlbGF5ICYmXG4gICAgICAgICAgICB1c2VyRXZlbnQgPT0gdGhpcy5wcmV2VXNlckV2ZW50ICYmIHVzZXJFdmVudCAmJiAvXnNlbGVjdCgkfFxcLikvLnRlc3QodXNlckV2ZW50KSAmJlxuICAgICAgICAgICAgZXFTZWxlY3Rpb25TaGFwZShsYXN0W2xhc3QubGVuZ3RoIC0gMV0sIHNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoYWRkU2VsZWN0aW9uKHRoaXMuZG9uZSwgc2VsZWN0aW9uKSwgdGhpcy51bmRvbmUsIHRpbWUsIHVzZXJFdmVudCk7XG4gICAgfVxuICAgIGFkZE1hcHBpbmcobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShhZGRNYXBwaW5nVG9CcmFuY2godGhpcy5kb25lLCBtYXBwaW5nKSwgYWRkTWFwcGluZ1RvQnJhbmNoKHRoaXMudW5kb25lLCBtYXBwaW5nKSwgdGhpcy5wcmV2VGltZSwgdGhpcy5wcmV2VXNlckV2ZW50KTtcbiAgICB9XG4gICAgcG9wKHNpZGUsIHN0YXRlLCBvbmx5U2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBicmFuY2ggPSBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gdGhpcy5kb25lIDogdGhpcy51bmRvbmU7XG4gICAgICAgIGlmIChicmFuY2gubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGV2ZW50ID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXSwgc2VsZWN0aW9uID0gZXZlbnQuc2VsZWN0aW9uc0FmdGVyWzBdIHx8IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKG9ubHlTZWxlY3Rpb24gJiYgZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBldmVudC5zZWxlY3Rpb25zQWZ0ZXJbZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBmcm9tSGlzdG9yeS5vZih7IHNpZGUsIHJlc3Q6IHBvcFNlbGVjdGlvbihicmFuY2gpLCBzZWxlY3Rpb24gfSksXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBzaWRlID09IDAgLyogQnJhbmNoTmFtZS5Eb25lICovID8gXCJzZWxlY3QudW5kb1wiIDogXCJzZWxlY3QucmVkb1wiLFxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZXZlbnQuY2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzdCA9IGJyYW5jaC5sZW5ndGggPT0gMSA/IG5vbmUgOiBicmFuY2guc2xpY2UoMCwgYnJhbmNoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgaWYgKGV2ZW50Lm1hcHBlZClcbiAgICAgICAgICAgICAgICByZXN0ID0gYWRkTWFwcGluZ1RvQnJhbmNoKHJlc3QsIGV2ZW50Lm1hcHBlZCk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiBldmVudC5jaGFuZ2VzLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZXZlbnQuc3RhcnRTZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgZWZmZWN0czogZXZlbnQuZWZmZWN0cyxcbiAgICAgICAgICAgICAgICBhbm5vdGF0aW9uczogZnJvbUhpc3Rvcnkub2YoeyBzaWRlLCByZXN0LCBzZWxlY3Rpb24gfSksXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IHNpZGUgPT0gMCAvKiBCcmFuY2hOYW1lLkRvbmUgKi8gPyBcInVuZG9cIiA6IFwicmVkb1wiLFxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkhpc3RvcnlTdGF0ZS5lbXB0eSA9IC8qQF9fUFVSRV9fKi9uZXcgSGlzdG9yeVN0YXRlKG5vbmUsIG5vbmUpO1xuLyoqXG5EZWZhdWx0IGtleSBiaW5kaW5ncyBmb3IgdGhlIHVuZG8gaGlzdG9yeS5cblxuLSBNb2QtejogW2B1bmRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy51bmRvKS5cbi0gTW9kLXkgKE1vZC1TaGlmdC16IG9uIG1hY09TKSArIEN0cmwtU2hpZnQteiBvbiBMaW51eDogW2ByZWRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5yZWRvKS5cbi0gTW9kLXU6IFtgdW5kb1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudW5kb1NlbGVjdGlvbikuXG4tIEFsdC11IChNb2QtU2hpZnQtdSBvbiBtYWNPUyk6IFtgcmVkb1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMucmVkb1NlbGVjdGlvbikuXG4qL1xuY29uc3QgaGlzdG9yeUtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtelwiLCBydW46IHVuZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLXlcIiwgbWFjOiBcIk1vZC1TaGlmdC16XCIsIHJ1bjogcmVkbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGxpbnV4OiBcIkN0cmwtU2hpZnQtelwiLCBydW46IHJlZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLXVcIiwgcnVuOiB1bmRvU2VsZWN0aW9uLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIkFsdC11XCIsIG1hYzogXCJNb2QtU2hpZnQtdVwiLCBydW46IHJlZG9TZWxlY3Rpb24sIHByZXZlbnREZWZhdWx0OiB0cnVlIH1cbl07XG5cbmZ1bmN0aW9uIHVwZGF0ZVNlbChzZWwsIGJ5KSB7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsLnJhbmdlcy5tYXAoYnkpLCBzZWwubWFpbkluZGV4KTtcbn1cbmZ1bmN0aW9uIHNldFNlbChzdGF0ZSwgc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbiwgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJzZWxlY3RcIiB9KTtcbn1cbmZ1bmN0aW9uIG1vdmVTZWwoeyBzdGF0ZSwgZGlzcGF0Y2ggfSwgaG93KSB7XG4gICAgbGV0IHNlbGVjdGlvbiA9IHVwZGF0ZVNlbChzdGF0ZS5zZWxlY3Rpb24sIGhvdyk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24sIHRydWUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IHJhbmdlLnRvIDogcmFuZ2UuZnJvbSk7XG59XG5mdW5jdGlvbiBjdXJzb3JCeUNoYXIodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG5mdW5jdGlvbiBsdHJBdEN1cnNvcih2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXcudGV4dERpcmVjdGlvbkF0KHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkgPT0gRGlyZWN0aW9uLkxUUjtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQgKHdoaWNoIGlzIGJhY2t3YXJkIGluXG5sZWZ0LXRvLXJpZ2h0IHRleHQsIGZvcndhcmQgaW4gcmlnaHQtdG8tbGVmdCB0ZXh0KS5cbiovXG5jb25zdCBjdXJzb3JDaGFyTGVmdCA9IHZpZXcgPT4gY3Vyc29yQnlDaGFyKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBjdXJzb3JDaGFyUmlnaHQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGZvcndhcmQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckZvcndhcmQgPSB2aWV3ID0+IGN1cnNvckJ5Q2hhcih2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQuXG4qL1xuY29uc3QgY3Vyc29yQ2hhckJhY2t3YXJkID0gdmlldyA9PiBjdXJzb3JCeUNoYXIodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gYnlDaGFyTG9naWNhbChzdGF0ZSwgcmFuZ2UsIGZvcndhcmQpIHtcbiAgICBsZXQgcG9zID0gcmFuZ2UuaGVhZCwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICBpZiAocG9zID09IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpXG4gICAgICAgIHBvcyA9IGZvcndhcmQgPyBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCBsaW5lLnRvICsgMSkgOiBNYXRoLm1heCgwLCBsaW5lLmZyb20gLSAxKTtcbiAgICBlbHNlXG4gICAgICAgIHBvcyA9IGxpbmUuZnJvbSArIGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQpO1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHBvcywgZm9yd2FyZCA/IC0xIDogMSk7XG59XG5mdW5jdGlvbiBtb3ZlQnlDaGFyTG9naWNhbCh0YXJnZXQsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh0YXJnZXQsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gYnlDaGFyTG9naWNhbCh0YXJnZXQuc3RhdGUsIHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgY2hhcmFjdGVyIGZvcndhcmQsIGluIGxvZ2ljYWxcbihub24tdGV4dC1kaXJlY3Rpb24tYXdhcmUpIHN0cmluZyBpbmRleCBvcmRlci5cbiovXG5jb25zdCBjdXJzb3JDaGFyRm9yd2FyZExvZ2ljYWwgPSB0YXJnZXQgPT4gbW92ZUJ5Q2hhckxvZ2ljYWwodGFyZ2V0LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQsIGluIGxvZ2ljYWwgc3RyaW5nIGluZGV4XG5vcmRlci5cbiovXG5jb25zdCBjdXJzb3JDaGFyQmFja3dhcmRMb2dpY2FsID0gdGFyZ2V0ID0+IG1vdmVCeUNoYXJMb2dpY2FsKHRhcmdldCwgZmFsc2UpO1xuZnVuY3Rpb24gY3Vyc29yQnlHcm91cCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIG1vdmVTZWwodmlldywgcmFuZ2UgPT4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVCeUdyb3VwKHJhbmdlLCBmb3J3YXJkKSA6IHJhbmdlRW5kKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbGVmdCBhY3Jvc3Mgb25lIGdyb3VwIG9mIHdvcmQgb3Jcbm5vbi13b3JkIChidXQgYWxzbyBub24tc3BhY2UpIGNoYXJhY3RlcnMuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBMZWZ0ID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwUmlnaHQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgbHRyQXRDdXJzb3IodmlldykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIGZvcndhcmQuXG4qL1xuY29uc3QgY3Vyc29yR3JvdXBGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeUdyb3VwKHZpZXcsIHRydWUpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvckdyb3VwQmFja3dhcmQgPSB2aWV3ID0+IGN1cnNvckJ5R3JvdXAodmlldywgZmFsc2UpO1xuZnVuY3Rpb24gdG9Hcm91cFN0YXJ0KHZpZXcsIHBvcywgc3RhcnQpIHtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHZpZXcuc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgbGV0IGNhdCA9IGNhdGVnb3JpemUoc3RhcnQpLCBpbml0aWFsID0gY2F0ICE9IENoYXJDYXRlZ29yeS5TcGFjZTtcbiAgICByZXR1cm4gKG5leHQpID0+IHtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpO1xuICAgICAgICBpZiAobmV4dENhdCAhPSBDaGFyQ2F0ZWdvcnkuU3BhY2UpXG4gICAgICAgICAgICByZXR1cm4gaW5pdGlhbCAmJiBuZXh0Q2F0ID09IGNhdDtcbiAgICAgICAgaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5Nb3ZlIHRoZSBjdXJzb3Igb25lIGdyb3VwIGZvcndhcmQgaW4gdGhlIGRlZmF1bHQgV2luZG93cyBzdHlsZSxcbndoZXJlIGl0IG1vdmVzIHRvIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBncm91cC5cbiovXG5jb25zdCBjdXJzb3JHcm91cEZvcndhcmRXaW4gPSB2aWV3ID0+IHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiByYW5nZS5lbXB0eVxuICAgICAgICA/IHZpZXcubW92ZUJ5Q2hhcihyYW5nZSwgdHJ1ZSwgc3RhcnQgPT4gdG9Hcm91cFN0YXJ0KHZpZXcsIHJhbmdlLmhlYWQsIHN0YXJ0KSlcbiAgICAgICAgOiByYW5nZUVuZChyYW5nZSwgdHJ1ZSkpO1xufTtcbmNvbnN0IHNlZ21lbnRlciA9IHR5cGVvZiBJbnRsICE9IFwidW5kZWZpbmVkXCIgJiYgSW50bC5TZWdtZW50ZXIgP1xuICAgIC8qQF9fUFVSRV9fKi9uZXcgKEludGwuU2VnbWVudGVyKSh1bmRlZmluZWQsIHsgZ3JhbnVsYXJpdHk6IFwid29yZFwiIH0pIDogbnVsbDtcbmZ1bmN0aW9uIG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpIHtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHZpZXcuc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmZyb20pO1xuICAgIGxldCBjYXQgPSBDaGFyQ2F0ZWdvcnkuU3BhY2UsIHBvcyA9IHJhbmdlLmZyb20sIHN0ZXBzID0gMDtcbiAgICBsZXQgZG9uZSA9IGZhbHNlLCBzYXdVcHBlciA9IGZhbHNlLCBzYXdMb3dlciA9IGZhbHNlO1xuICAgIGxldCBzdGVwID0gKG5leHQpID0+IHtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvcyArPSBmb3J3YXJkID8gbmV4dC5sZW5ndGggOiAtbmV4dC5sZW5ndGg7XG4gICAgICAgIGxldCBuZXh0Q2F0ID0gY2F0ZWdvcml6ZShuZXh0KSwgYWhlYWQ7XG4gICAgICAgIGlmIChuZXh0Q2F0ID09IENoYXJDYXRlZ29yeS5Xb3JkICYmIG5leHQuY2hhckNvZGVBdCgwKSA8IDEyOCAmJiAvW1xcV19dLy50ZXN0KG5leHQpKVxuICAgICAgICAgICAgbmV4dENhdCA9IC0xOyAvLyBUcmVhdCB3b3JkIHB1bmN0dWF0aW9uIHNwZWNpYWxseVxuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIGlmIChjYXQgIT0gbmV4dENhdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGNhdCA9PSBDaGFyQ2F0ZWdvcnkuV29yZCkge1xuICAgICAgICAgICAgaWYgKG5leHQudG9Mb3dlckNhc2UoKSA9PSBuZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3J3YXJkICYmIHNhd1VwcGVyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2F3TG93ZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2F3TG93ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhd1VwcGVyICYmIGZvcndhcmQgJiYgY2F0ZWdvcml6ZShhaGVhZCA9IHZpZXcuc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyAxKSkgPT0gQ2hhckNhdGVnb3J5LldvcmQgJiZcbiAgICAgICAgICAgICAgICAgICAgYWhlYWQudG9Mb3dlckNhc2UoKSA9PSBhaGVhZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHNhd1VwcGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGVwcysrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIGxldCBlbmQgPSB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQsIHN0YXJ0ID0+IHtcbiAgICAgICAgc3RlcChzdGFydCk7XG4gICAgICAgIHJldHVybiBzdGVwO1xuICAgIH0pO1xuICAgIGlmIChzZWdtZW50ZXIgJiYgY2F0ID09IENoYXJDYXRlZ29yeS5Xb3JkICYmIGVuZC5mcm9tID09IHJhbmdlLmZyb20gKyBzdGVwcyAqIChmb3J3YXJkID8gMSA6IC0xKSkge1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKHJhbmdlLmhlYWQsIGVuZC5oZWFkKSwgdG8gPSBNYXRoLm1heChyYW5nZS5oZWFkLCBlbmQuaGVhZCk7XG4gICAgICAgIGxldCBza2lwcGVkID0gdmlldy5zdGF0ZS5zbGljZURvYyhmcm9tLCB0byk7XG4gICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDEgJiYgL1tcXHU0RTAwLVxcdWZmZmZdLy50ZXN0KHNraXBwZWQpKSB7XG4gICAgICAgICAgICBsZXQgc2VnbWVudHMgPSBBcnJheS5mcm9tKHNlZ21lbnRlci5zZWdtZW50KHNraXBwZWQpKTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmhlYWQgKyBzZWdtZW50c1sxXS5pbmRleCwgLTEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGVuZC5oZWFkICsgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmQ7XG59XG5mdW5jdGlvbiBjdXJzb3JCeVN1YndvcmQodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IHJhbmdlLmVtcHR5ID8gbW92ZUJ5U3Vid29yZCh2aWV3LCByYW5nZSwgZm9yd2FyZCkgOiByYW5nZUVuZChyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBmb3J3YXJkLlxuKi9cbmNvbnN0IGN1cnNvclN1YndvcmRGb3J3YXJkID0gdmlldyA9PiBjdXJzb3JCeVN1YndvcmQodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgZ3JvdXAgb3IgY2FtZWwtY2FzZSBzdWJ3b3JkIGJhY2t3YXJkLlxuKi9cbmNvbnN0IGN1cnNvclN1YndvcmRCYWNrd2FyZCA9IHZpZXcgPT4gY3Vyc29yQnlTdWJ3b3JkKHZpZXcsIGZhbHNlKTtcbmZ1bmN0aW9uIGludGVyZXN0aW5nTm9kZShzdGF0ZSwgbm9kZSwgYnJhY2tldFByb3ApIHtcbiAgICBpZiAobm9kZS50eXBlLnByb3AoYnJhY2tldFByb3ApKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgbGVuID0gbm9kZS50byAtIG5vZGUuZnJvbTtcbiAgICByZXR1cm4gbGVuICYmIChsZW4gPiAyIHx8IC9bXlxccywuOzpdLy50ZXN0KHN0YXRlLnNsaWNlRG9jKG5vZGUuZnJvbSwgbm9kZS50bykpKSB8fCBub2RlLmZpcnN0Q2hpbGQ7XG59XG5mdW5jdGlvbiBtb3ZlQnlTeW50YXgoc3RhdGUsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgbGV0IHBvcyA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihzdGFydC5oZWFkKTtcbiAgICBsZXQgYnJhY2tldFByb3AgPSBmb3J3YXJkID8gTm9kZVByb3AuY2xvc2VkQnkgOiBOb2RlUHJvcC5vcGVuZWRCeTtcbiAgICAvLyBTY2FuIGZvcndhcmQgdGhyb3VnaCBjaGlsZCBub2RlcyB0byBzZWUgaWYgdGhlcmUncyBhbiBpbnRlcmVzdGluZ1xuICAgIC8vIG5vZGUgYWhlYWQuXG4gICAgZm9yIChsZXQgYXQgPSBzdGFydC5oZWFkOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBmb3J3YXJkID8gcG9zLmNoaWxkQWZ0ZXIoYXQpIDogcG9zLmNoaWxkQmVmb3JlKGF0KTtcbiAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChpbnRlcmVzdGluZ05vZGUoc3RhdGUsIG5leHQsIGJyYWNrZXRQcm9wKSlcbiAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGF0ID0gZm9yd2FyZCA/IG5leHQudG8gOiBuZXh0LmZyb207XG4gICAgfVxuICAgIGxldCBicmFja2V0ID0gcG9zLnR5cGUucHJvcChicmFja2V0UHJvcCksIG1hdGNoLCBuZXdQb3M7XG4gICAgaWYgKGJyYWNrZXQgJiYgKG1hdGNoID0gZm9yd2FyZCA/IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy5mcm9tLCAxKSA6IG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcy50bywgLTEpKSAmJiBtYXRjaC5tYXRjaGVkKVxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gbWF0Y2guZW5kLnRvIDogbWF0Y2guZW5kLmZyb207XG4gICAgZWxzZVxuICAgICAgICBuZXdQb3MgPSBmb3J3YXJkID8gcG9zLnRvIDogcG9zLmZyb207XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV3UG9zLCBmb3J3YXJkID8gLTEgOiAxKTtcbn1cbi8qKlxuTW92ZSB0aGUgY3Vyc29yIG92ZXIgdGhlIG5leHQgc3ludGFjdGljIGVsZW1lbnQgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4TGVmdCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsICFsdHJBdEN1cnNvcih2aWV3KSkpO1xuLyoqXG5Nb3ZlIHRoZSBjdXJzb3Igb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3QgY3Vyc29yU3ludGF4UmlnaHQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCBsdHJBdEN1cnNvcih2aWV3KSkpO1xuZnVuY3Rpb24gY3Vyc29yQnlMaW5lKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiB7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgICAgICBsZXQgbW92ZWQgPSB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkKTtcbiAgICAgICAgcmV0dXJuIG1vdmVkLmhlYWQgIT0gcmFuZ2UuaGVhZCA/IG1vdmVkIDogdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgdXAuXG4qL1xuY29uc3QgY3Vyc29yTGluZVVwID0gdmlldyA9PiBjdXJzb3JCeUxpbmUodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gb25lIGxpbmUgZG93bi5cbiovXG5jb25zdCBjdXJzb3JMaW5lRG93biA9IHZpZXcgPT4gY3Vyc29yQnlMaW5lKHZpZXcsIHRydWUpO1xuZnVuY3Rpb24gcGFnZUluZm8odmlldykge1xuICAgIGxldCBzZWxmU2Nyb2xsID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0IDwgdmlldy5zY3JvbGxET00uc2Nyb2xsSGVpZ2h0IC0gMjtcbiAgICBsZXQgbWFyZ2luVG9wID0gMCwgbWFyZ2luQm90dG9tID0gMCwgaGVpZ2h0O1xuICAgIGlmIChzZWxmU2Nyb2xsKSB7XG4gICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucykpIHtcbiAgICAgICAgICAgIGxldCBtYXJnaW5zID0gc291cmNlKHZpZXcpO1xuICAgICAgICAgICAgaWYgKG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy50b3ApXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wID0gTWF0aC5tYXgobWFyZ2lucyA9PT0gbnVsbCB8fCBtYXJnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXJnaW5zLnRvcCwgbWFyZ2luVG9wKTtcbiAgICAgICAgICAgIGlmIChtYXJnaW5zID09PSBudWxsIHx8IG1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcmdpbnMuYm90dG9tKVxuICAgICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9IE1hdGgubWF4KG1hcmdpbnMgPT09IG51bGwgfHwgbWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFyZ2lucy5ib3R0b20sIG1hcmdpbkJvdHRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaGVpZ2h0ID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0IC0gbWFyZ2luVG9wIC0gbWFyZ2luQm90dG9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGVpZ2h0ID0gKHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93KS5pbm5lckhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWFyZ2luVG9wLCBtYXJnaW5Cb3R0b20sIHNlbGZTY3JvbGwsXG4gICAgICAgIGhlaWdodDogTWF0aC5tYXgodmlldy5kZWZhdWx0TGluZUhlaWdodCwgaGVpZ2h0IC0gNSkgfTtcbn1cbmZ1bmN0aW9uIGN1cnNvckJ5UGFnZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgbGV0IHBhZ2UgPSBwYWdlSW5mbyh2aWV3KTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICByZXR1cm4gcmFuZ2UuZW1wdHkgPyB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCBwYWdlLmhlaWdodClcbiAgICAgICAgICAgIDogcmFuZ2VFbmQocmFuZ2UsIGZvcndhcmQpO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3Q7XG4gICAgaWYgKHBhZ2Uuc2VsZlNjcm9sbCkge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBsZXQgc2Nyb2xsUmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gc2Nyb2xsUmVjdC50b3AgKyBwYWdlLm1hcmdpblRvcCwgc2Nyb2xsQm90dG9tID0gc2Nyb2xsUmVjdC5ib3R0b20gLSBwYWdlLm1hcmdpbkJvdHRvbTtcbiAgICAgICAgaWYgKHN0YXJ0UG9zICYmIHN0YXJ0UG9zLnRvcCA+IHNjcm9sbFRvcCAmJiBzdGFydFBvcy5ib3R0b20gPCBzY3JvbGxCb3R0b20pXG4gICAgICAgICAgICBlZmZlY3QgPSBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHNlbGVjdGlvbi5tYWluLmhlYWQsIHsgeTogXCJzdGFydFwiLCB5TWFyZ2luOiBzdGFydFBvcy50b3AgLSBzY3JvbGxUb3AgfSk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pLCB7IGVmZmVjdHM6IGVmZmVjdCB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIHVwLlxuKi9cbmNvbnN0IGN1cnNvclBhZ2VVcCA9IHZpZXcgPT4gY3Vyc29yQnlQYWdlKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBwYWdlIGRvd24uXG4qL1xuY29uc3QgY3Vyc29yUGFnZURvd24gPSB2aWV3ID0+IGN1cnNvckJ5UGFnZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCBzdGFydCwgZm9yd2FyZCkge1xuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChzdGFydC5oZWFkKSwgbW92ZWQgPSB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCk7XG4gICAgaWYgKG1vdmVkLmhlYWQgPT0gc3RhcnQuaGVhZCAmJiBtb3ZlZC5oZWFkICE9IChmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSkpXG4gICAgICAgIG1vdmVkID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkoc3RhcnQsIGZvcndhcmQsIGZhbHNlKTtcbiAgICBpZiAoIWZvcndhcmQgJiYgbW92ZWQuaGVhZCA9PSBsaW5lLmZyb20gJiYgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHNwYWNlID0gL15cXHMqLy5leGVjKHZpZXcuc3RhdGUuc2xpY2VEb2MobGluZS5mcm9tLCBNYXRoLm1pbihsaW5lLmZyb20gKyAxMDAsIGxpbmUudG8pKSlbMF0ubGVuZ3RoO1xuICAgICAgICBpZiAoc3BhY2UgJiYgc3RhcnQuaGVhZCAhPSBsaW5lLmZyb20gKyBzcGFjZSlcbiAgICAgICAgICAgIG1vdmVkID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLmZyb20gKyBzcGFjZSk7XG4gICAgfVxuICAgIHJldHVybiBtb3ZlZDtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBuZXh0IGxpbmUgd3JhcCBwb2ludCwgb3IgdG8gdGhlIGVuZCBvZlxudGhlIGxpbmUgaWYgdGhlcmUgaXNuJ3Qgb25lIGxlZnQgb24gdGhpcyBsaW5lLlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byBwcmV2aW91cyBsaW5lIHdyYXAgcG9pbnQsIG9yIGZhaWxpbmcgdGhhdCB0b1xudGhlIHN0YXJ0IG9mIHRoZSBsaW5lLiBJZiB0aGUgbGluZSBpcyBpbmRlbnRlZCwgYW5kIHRoZSBjdXJzb3Jcbmlzbid0IGFscmVhZHkgYXQgdGhlIGVuZCBvZiB0aGUgaW5kZW50YXRpb24sIHRoaXMgd2lsbCBtb3ZlIHRvIHRoZVxuZW5kIG9mIHRoZSBpbmRlbnRhdGlvbiBpbnN0ZWFkIG9mIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlMaW5lQm91bmRhcnkodmlldywgcmFuZ2UsIGZhbHNlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgbGluZSB3cmFwIHBvaW50IHRvIHRoZSBsZWZ0LlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeUxlZnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5TGluZUJvdW5kYXJ5KHZpZXcsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIG9uZSBsaW5lIHdyYXAgcG9pbnQgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IGN1cnNvckxpbmVCb3VuZGFyeVJpZ2h0ID0gdmlldyA9PiBtb3ZlU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiovXG5jb25zdCBjdXJzb3JMaW5lU3RhcnQgPSB2aWV3ID0+IG1vdmVTZWwodmlldywgcmFuZ2UgPT4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLmhlYWQpLmZyb20sIDEpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3QgY3Vyc29yTGluZUVuZCA9IHZpZXcgPT4gbW92ZVNlbCh2aWV3LCByYW5nZSA9PiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG8sIC0xKSk7XG5mdW5jdGlvbiB0b01hdGNoaW5nQnJhY2tldChzdGF0ZSwgZGlzcGF0Y2gsIGV4dGVuZCkge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlLCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCBtYXRjaGluZyA9IG1hdGNoQnJhY2tldHMoc3RhdGUsIHJhbmdlLmhlYWQsIC0xKVxuICAgICAgICAgICAgfHwgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCwgMSlcbiAgICAgICAgICAgIHx8IChyYW5nZS5oZWFkID4gMCAmJiBtYXRjaEJyYWNrZXRzKHN0YXRlLCByYW5nZS5oZWFkIC0gMSwgMSkpXG4gICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA8IHN0YXRlLmRvYy5sZW5ndGggJiYgbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcmFuZ2UuaGVhZCArIDEsIC0xKSk7XG4gICAgICAgIGlmICghbWF0Y2hpbmcgfHwgIW1hdGNoaW5nLmVuZClcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBsZXQgaGVhZCA9IG1hdGNoaW5nLnN0YXJ0LmZyb20gPT0gcmFuZ2UuaGVhZCA/IG1hdGNoaW5nLmVuZC50byA6IG1hdGNoaW5nLmVuZC5mcm9tO1xuICAgICAgICByZXR1cm4gZXh0ZW5kID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZCkgOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGhlYWQpO1xuICAgIH0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGJyYWNrZXQgbWF0Y2hpbmcgdGhlIG9uZSBpdCBpcyBjdXJyZW50bHlcbm9uLCBpZiBhbnkuXG4qL1xuY29uc3QgY3Vyc29yTWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgZmFsc2UpO1xuLyoqXG5FeHRlbmQgdGhlIHNlbGVjdGlvbiB0byB0aGUgYnJhY2tldCBtYXRjaGluZyB0aGUgb25lIHRoZSBzZWxlY3Rpb25cbmhlYWQgaXMgY3VycmVudGx5IG9uLCBpZiBhbnkuXG4qL1xuY29uc3Qgc2VsZWN0TWF0Y2hpbmdCcmFja2V0ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHRvTWF0Y2hpbmdCcmFja2V0KHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG5mdW5jdGlvbiBleHRlbmRTZWwodGFyZ2V0LCBob3cpIHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHRhcmdldC5zdGF0ZS5zZWxlY3Rpb24sIHJhbmdlID0+IHtcbiAgICAgICAgbGV0IGhlYWQgPSBob3cocmFuZ2UpO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHJhbmdlLmFuY2hvciwgaGVhZC5oZWFkLCBoZWFkLmdvYWxDb2x1bW4sIGhlYWQuYmlkaUxldmVsIHx8IHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGlvbi5lcSh0YXJnZXQuc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRhcmdldC5kaXNwYXRjaChzZXRTZWwodGFyZ2V0LnN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdEJ5Q2hhcih2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUNoYXIocmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciB0byB0aGUgbGVmdCwgd2hpbGUgbGVhdmluZ1xudGhlIGFuY2hvciBpbiBwbGFjZS5cbiovXG5jb25zdCBzZWxlY3RDaGFyTGVmdCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0LlxuKi9cbmNvbnN0IHNlbGVjdENoYXJSaWdodCA9IHZpZXcgPT4gc2VsZWN0QnlDaGFyKHZpZXcsIGx0ckF0Q3Vyc29yKHZpZXcpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGNoYXJhY3RlciBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQuXG4qL1xuY29uc3Qgc2VsZWN0Q2hhckJhY2t3YXJkID0gdmlldyA9PiBzZWxlY3RCeUNoYXIodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgY2hhcmFjdGVyIGZvcndhcmQgYnkgbG9naWNhbFxuKG5vbi1kaXJlY3Rpb24gYXdhcmUpIHN0cmluZyBpbmRleCBvcmRlci5cbiovXG5jb25zdCBzZWxlY3RDaGFyRm9yd2FyZExvZ2ljYWwgPSB0YXJnZXQgPT4gZXh0ZW5kU2VsKHRhcmdldCwgcmFuZ2UgPT4gYnlDaGFyTG9naWNhbCh0YXJnZXQuc3RhdGUsIHJhbmdlLCB0cnVlKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBjaGFyYWN0ZXIgYmFja3dhcmQgYnkgbG9naWNhbCBzdHJpbmdcbmluZGV4IG9yZGVyLlxuKi9cbmNvbnN0IHNlbGVjdENoYXJCYWNrd2FyZExvZ2ljYWwgPSB0YXJnZXQgPT4gZXh0ZW5kU2VsKHRhcmdldCwgcmFuZ2UgPT4gYnlDaGFyTG9naWNhbCh0YXJnZXQuc3RhdGUsIHJhbmdlLCBmYWxzZSkpO1xuZnVuY3Rpb24gc2VsZWN0QnlHcm91cCh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVCeUdyb3VwKHJhbmdlLCBmb3J3YXJkKSk7XG59XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBbZ3JvdXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yR3JvdXBMZWZ0KSB0b1xudGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBMZWZ0ID0gdmlldyA9PiBzZWxlY3RCeUdyb3VwKHZpZXcsICFsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0R3JvdXBSaWdodCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCBsdHJBdEN1cnNvcih2aWV3KSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwRm9yd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlHcm91cCh2aWV3LCB0cnVlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwQmFja3dhcmQgPSB2aWV3ID0+IHNlbGVjdEJ5R3JvdXAodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgZ3JvdXAgZm9yd2FyZCBpbiB0aGUgZGVmYXVsdCBXaW5kb3dzXG5zdHlsZSwgc2tpcHBpbmcgdG8gdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IGdyb3VwLlxuKi9cbmNvbnN0IHNlbGVjdEdyb3VwRm9yd2FyZFdpbiA9IHZpZXcgPT4ge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlQnlDaGFyKHJhbmdlLCB0cnVlLCBzdGFydCA9PiB0b0dyb3VwU3RhcnQodmlldywgcmFuZ2UuaGVhZCwgc3RhcnQpKSk7XG59O1xuZnVuY3Rpb24gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeVN1YndvcmQodmlldywgcmFuZ2UsIGZvcndhcmQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGdyb3VwIG9yIGNhbWVsLWNhc2Ugc3Vid29yZCBmb3J3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdFN1YndvcmRGb3J3YXJkID0gdmlldyA9PiBzZWxlY3RCeVN1YndvcmQodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBncm91cCBvciBzdWJ3b3JkIGJhY2t3YXJkLlxuKi9cbmNvbnN0IHNlbGVjdFN1YndvcmRCYWNrd2FyZCA9IHZpZXcgPT4gc2VsZWN0QnlTdWJ3b3JkKHZpZXcsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgbGVmdC5cbiovXG5jb25zdCBzZWxlY3RTeW50YXhMZWZ0ID0gdmlldyA9PiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gbW92ZUJ5U3ludGF4KHZpZXcuc3RhdGUsIHJhbmdlLCAhbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb3ZlciB0aGUgbmV4dCBzeW50YWN0aWMgZWxlbWVudCB0byB0aGUgcmlnaHQuXG4qL1xuY29uc3Qgc2VsZWN0U3ludGF4UmlnaHQgPSB2aWV3ID0+IGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiBtb3ZlQnlTeW50YXgodmlldy5zdGF0ZSwgcmFuZ2UsIGx0ckF0Q3Vyc29yKHZpZXcpKSk7XG5mdW5jdGlvbiBzZWxlY3RCeUxpbmUodmlldywgZm9yd2FyZCkge1xuICAgIHJldHVybiBleHRlbmRTZWwodmlldywgcmFuZ2UgPT4gdmlldy5tb3ZlVmVydGljYWxseShyYW5nZSwgZm9yd2FyZCkpO1xufVxuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgbGluZSB1cC5cbiovXG5jb25zdCBzZWxlY3RMaW5lVXAgPSB2aWV3ID0+IHNlbGVjdEJ5TGluZSh2aWV3LCBmYWxzZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGRvd24uXG4qL1xuY29uc3Qgc2VsZWN0TGluZURvd24gPSB2aWV3ID0+IHNlbGVjdEJ5TGluZSh2aWV3LCB0cnVlKTtcbmZ1bmN0aW9uIHNlbGVjdEJ5UGFnZSh2aWV3LCBmb3J3YXJkKSB7XG4gICAgcmV0dXJuIGV4dGVuZFNlbCh2aWV3LCByYW5nZSA9PiB2aWV3Lm1vdmVWZXJ0aWNhbGx5KHJhbmdlLCBmb3J3YXJkLCBwYWdlSW5mbyh2aWV3KS5oZWlnaHQpKTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIHBhZ2UgdXAuXG4qL1xuY29uc3Qgc2VsZWN0UGFnZVVwID0gdmlldyA9PiBzZWxlY3RCeVBhZ2UodmlldywgZmFsc2UpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCBvbmUgcGFnZSBkb3duLlxuKi9cbmNvbnN0IHNlbGVjdFBhZ2VEb3duID0gdmlldyA9PiBzZWxlY3RCeVBhZ2UodmlldywgdHJ1ZSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBuZXh0IGxpbmUgYm91bmRhcnkuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5Rm9yd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgdHJ1ZSkpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgcHJldmlvdXMgbGluZSBib3VuZGFyeS5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgZmFsc2UpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgb25lIGxpbmUgYm91bmRhcnkgdG8gdGhlIGxlZnQuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgIWx0ckF0Q3Vyc29yKHZpZXcpKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIG9uZSBsaW5lIGJvdW5kYXJ5IHRvIHRoZSByaWdodC5cbiovXG5jb25zdCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IG1vdmVCeUxpbmVCb3VuZGFyeSh2aWV3LCByYW5nZSwgbHRyQXRDdXJzb3IodmlldykpKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIGhlYWQgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lLlxuKi9cbmNvbnN0IHNlbGVjdExpbmVTdGFydCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS5mcm9tKSk7XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4qL1xuY29uc3Qgc2VsZWN0TGluZUVuZCA9IHZpZXcgPT4gZXh0ZW5kU2VsKHZpZXcsIHJhbmdlID0+IEVkaXRvclNlbGVjdGlvbi5jdXJzb3Iodmlldy5saW5lQmxvY2tBdChyYW5nZS5oZWFkKS50bykpO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBjdXJzb3JEb2NTdGFydCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCB7IGFuY2hvcjogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3QgY3Vyc29yRG9jRW5kID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHsgYW5jaG9yOiBzdGF0ZS5kb2MubGVuZ3RoIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiBoZWFkIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0RG9jU3RhcnQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogMCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gaGVhZCB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3REb2NFbmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHNldFNlbChzdGF0ZSwgeyBhbmNob3I6IHN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciwgaGVhZDogc3RhdGUuZG9jLmxlbmd0aCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIGVudGlyZSBkb2N1bWVudC5cbiovXG5jb25zdCBzZWxlY3RBbGwgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7IHNlbGVjdGlvbjogeyBhbmNob3I6IDAsIGhlYWQ6IHN0YXRlLmRvYy5sZW5ndGggfSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkV4cGFuZCB0aGUgc2VsZWN0aW9uIHRvIGNvdmVyIGVudGlyZSBsaW5lcy5cbiovXG5jb25zdCBzZWxlY3RMaW5lID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgcmFuZ2VzID0gc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKS5tYXAoKHsgZnJvbSwgdG8gfSkgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIE1hdGgubWluKHRvICsgMSwgc3RhdGUuZG9jLmxlbmd0aCkpKTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzKSwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgbmV4dCBzeW50YWN0aWMgY29uc3RydWN0IHRoYXQgaXMgbGFyZ2VyIHRoYW4gdGhlXG5zZWxlY3Rpb24uIE5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSB3b3JrIGluc29mYXIgYXMgdGhlIGxhbmd1YWdlXG5bcHJvdmlkZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2UpIHlvdSB1c2UgYnVpbGRzIHVwIGEgZnVsbFxuc3ludGF4IHRyZWUuXG4qL1xuY29uc3Qgc2VsZWN0UGFyZW50U3ludGF4ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgc2VsZWN0aW9uID0gdXBkYXRlU2VsKHN0YXRlLnNlbGVjdGlvbiwgcmFuZ2UgPT4ge1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLCBzdGFjayA9IHRyZWUucmVzb2x2ZVN0YWNrKHJhbmdlLmZyb20sIDEpO1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBzdGFja0JlZm9yZSA9IHRyZWUucmVzb2x2ZVN0YWNrKHJhbmdlLmZyb20sIC0xKTtcbiAgICAgICAgICAgIGlmIChzdGFja0JlZm9yZS5ub2RlLmZyb20gPj0gc3RhY2subm9kZS5mcm9tICYmIHN0YWNrQmVmb3JlLm5vZGUudG8gPD0gc3RhY2subm9kZS50bylcbiAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrQmVmb3JlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHN0YWNrOyBjdXI7IGN1ciA9IGN1ci5uZXh0KSB7XG4gICAgICAgICAgICBsZXQgeyBub2RlIH0gPSBjdXI7XG4gICAgICAgICAgICBpZiAoKChub2RlLmZyb20gPCByYW5nZS5mcm9tICYmIG5vZGUudG8gPj0gcmFuZ2UudG8pIHx8XG4gICAgICAgICAgICAgICAgKG5vZGUudG8gPiByYW5nZS50byAmJiBub2RlLmZyb20gPD0gcmFuZ2UuZnJvbSkpICYmXG4gICAgICAgICAgICAgICAgY3VyLm5leHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShub2RlLnRvLCBub2RlLmZyb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9KTtcbiAgICBpZiAoc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzZXRTZWwoc3RhdGUsIHNlbGVjdGlvbikpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuU2ltcGxpZnkgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBXaGVuIG11bHRpcGxlIHJhbmdlcyBhcmUgc2VsZWN0ZWQsXG5yZWR1Y2UgaXQgdG8gaXRzIG1haW4gcmFuZ2UuIE90aGVyd2lzZSwgaWYgdGhlIHNlbGVjdGlvbiBpc1xubm9uLWVtcHR5LCBjb252ZXJ0IGl0IHRvIGEgY3Vyc29yIHNlbGVjdGlvbi5cbiovXG5jb25zdCBzaW1wbGlmeVNlbGVjdGlvbiA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IGN1ciA9IHN0YXRlLnNlbGVjdGlvbiwgc2VsZWN0aW9uID0gbnVsbDtcbiAgICBpZiAoY3VyLnJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtjdXIubWFpbl0pO1xuICAgIGVsc2UgaWYgKCFjdXIubWFpbi5lbXB0eSlcbiAgICAgICAgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihjdXIubWFpbi5oZWFkKV0pO1xuICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc2V0U2VsKHN0YXRlLCBzZWxlY3Rpb24pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBkZWxldGVCeSh0YXJnZXQsIGJ5KSB7XG4gICAgaWYgKHRhcmdldC5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBldmVudCA9IFwiZGVsZXRlLnNlbGVjdGlvblwiLCB7IHN0YXRlIH0gPSB0YXJnZXQ7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlO1xuICAgICAgICBpZiAoZnJvbSA9PSB0bykge1xuICAgICAgICAgICAgbGV0IHRvd2FyZHMgPSBieShyYW5nZSk7XG4gICAgICAgICAgICBpZiAodG93YXJkcyA8IGZyb20pIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IFwiZGVsZXRlLmJhY2t3YXJkXCI7XG4gICAgICAgICAgICAgICAgdG93YXJkcyA9IHNraXBBdG9taWModGFyZ2V0LCB0b3dhcmRzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b3dhcmRzID4gZnJvbSkge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gXCJkZWxldGUuZm9yd2FyZFwiO1xuICAgICAgICAgICAgICAgIHRvd2FyZHMgPSBza2lwQXRvbWljKHRhcmdldCwgdG93YXJkcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tID0gTWF0aC5taW4oZnJvbSwgdG93YXJkcyk7XG4gICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCB0b3dhcmRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBza2lwQXRvbWljKHRhcmdldCwgZnJvbSwgZmFsc2UpO1xuICAgICAgICAgICAgdG8gPSBza2lwQXRvbWljKHRhcmdldCwgdG8sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tID09IHRvID8geyByYW5nZSB9IDogeyBjaGFuZ2VzOiB7IGZyb20sIHRvIH0sIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20sIGZyb20gPCByYW5nZS5oZWFkID8gLTEgOiAxKSB9O1xuICAgIH0pO1xuICAgIGlmIChjaGFuZ2VzLmNoYW5nZXMuZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0YXJnZXQuZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIHVzZXJFdmVudDogZXZlbnQsXG4gICAgICAgIGVmZmVjdHM6IGV2ZW50ID09IFwiZGVsZXRlLnNlbGVjdGlvblwiID8gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihzdGF0ZS5waHJhc2UoXCJTZWxlY3Rpb24gZGVsZXRlZFwiKSkgOiB1bmRlZmluZWRcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBza2lwQXRvbWljKHRhcmdldCwgcG9zLCBmb3J3YXJkKSB7XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEVkaXRvclZpZXcpXG4gICAgICAgIGZvciAobGV0IHJhbmdlcyBvZiB0YXJnZXQuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5hdG9taWNSYW5nZXMpLm1hcChmID0+IGYodGFyZ2V0KSkpXG4gICAgICAgICAgICByYW5nZXMuYmV0d2Vlbihwb3MsIHBvcywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGZvcndhcmQgPyB0byA6IGZyb207XG4gICAgICAgICAgICB9KTtcbiAgICByZXR1cm4gcG9zO1xufVxuY29uc3QgZGVsZXRlQnlDaGFyID0gKHRhcmdldCwgZm9yd2FyZCwgYnlJbmRlbnRVbml0KSA9PiBkZWxldGVCeSh0YXJnZXQsIHJhbmdlID0+IHtcbiAgICBsZXQgcG9zID0gcmFuZ2UuZnJvbSwgeyBzdGF0ZSB9ID0gdGFyZ2V0LCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBiZWZvcmUsIHRhcmdldFBvcztcbiAgICBpZiAoYnlJbmRlbnRVbml0ICYmICFmb3J3YXJkICYmIHBvcyA+IGxpbmUuZnJvbSAmJiBwb3MgPCBsaW5lLmZyb20gKyAyMDAgJiZcbiAgICAgICAgIS9bXiBcXHRdLy50ZXN0KGJlZm9yZSA9IGxpbmUudGV4dC5zbGljZSgwLCBwb3MgLSBsaW5lLmZyb20pKSkge1xuICAgICAgICBpZiAoYmVmb3JlW2JlZm9yZS5sZW5ndGggLSAxXSA9PSBcIlxcdFwiKVxuICAgICAgICAgICAgcmV0dXJuIHBvcyAtIDE7XG4gICAgICAgIGxldCBjb2wgPSBjb3VudENvbHVtbihiZWZvcmUsIHN0YXRlLnRhYlNpemUpLCBkcm9wID0gY29sICUgZ2V0SW5kZW50VW5pdChzdGF0ZSkgfHwgZ2V0SW5kZW50VW5pdChzdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJvcCAmJiBiZWZvcmVbYmVmb3JlLmxlbmd0aCAtIDEgLSBpXSA9PSBcIiBcIjsgaSsrKVxuICAgICAgICAgICAgcG9zLS07XG4gICAgICAgIHRhcmdldFBvcyA9IHBvcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldFBvcyA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIGZvcndhcmQsIGZvcndhcmQpICsgbGluZS5mcm9tO1xuICAgICAgICBpZiAodGFyZ2V0UG9zID09IHBvcyAmJiBsaW5lLm51bWJlciAhPSAoZm9yd2FyZCA/IHN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgdGFyZ2V0UG9zICs9IGZvcndhcmQgPyAxIDogLTE7XG4gICAgICAgIGVsc2UgaWYgKCFmb3J3YXJkICYmIC9bXFx1ZmUwMC1cXHVmZTBmXS8udGVzdChsaW5lLnRleHQuc2xpY2UodGFyZ2V0UG9zIC0gbGluZS5mcm9tLCBwb3MgLSBsaW5lLmZyb20pKSlcbiAgICAgICAgICAgIHRhcmdldFBvcyA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCB0YXJnZXRQb3MgLSBsaW5lLmZyb20sIGZhbHNlLCBmYWxzZSkgKyBsaW5lLmZyb207XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRQb3M7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIG9yLCBmb3IgY3Vyc29yIHNlbGVjdGlvbnMsIHRoZSBjaGFyYWN0ZXIgb3JcbmluZGVudGF0aW9uIHVuaXQgYmVmb3JlIHRoZSBjdXJzb3IuXG4qL1xuY29uc3QgZGVsZXRlQ2hhckJhY2t3YXJkID0gdmlldyA9PiBkZWxldGVCeUNoYXIodmlldywgZmFsc2UsIHRydWUpO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiBvciB0aGUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgY3Vyc29yLiBEb2VzIG5vdFxuaW1wbGVtZW50IGFueSBleHRlbmRlZCBiZWhhdmlvciBsaWtlIGRlbGV0aW5nIHdob2xlIGluZGVudGF0aW9uXG51bml0cyBpbiBvbmUgZ28uXG4qL1xuY29uc3QgZGVsZXRlQ2hhckJhY2t3YXJkU3RyaWN0ID0gdmlldyA9PiBkZWxldGVCeUNoYXIodmlldywgZmFsc2UsIGZhbHNlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgdGhlIGNoYXJhY3RlciBhZnRlciB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUNoYXJGb3J3YXJkID0gdmlldyA9PiBkZWxldGVCeUNoYXIodmlldywgdHJ1ZSwgZmFsc2UpO1xuY29uc3QgZGVsZXRlQnlHcm91cCA9ICh0YXJnZXQsIGZvcndhcmQpID0+IGRlbGV0ZUJ5KHRhcmdldCwgcmFuZ2UgPT4ge1xuICAgIGxldCBwb3MgPSByYW5nZS5oZWFkLCB7IHN0YXRlIH0gPSB0YXJnZXQsIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgbGV0IGNhdGVnb3JpemUgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBmb3IgKGxldCBjYXQgPSBudWxsOzspIHtcbiAgICAgICAgaWYgKHBvcyA9PSAoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICBpZiAocG9zID09IHJhbmdlLmhlYWQgJiYgbGluZS5udW1iZXIgIT0gKGZvcndhcmQgPyBzdGF0ZS5kb2MubGluZXMgOiAxKSlcbiAgICAgICAgICAgICAgICBwb3MgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHBvcyAtIGxpbmUuZnJvbSwgZm9yd2FyZCkgKyBsaW5lLmZyb207XG4gICAgICAgIGxldCBuZXh0Q2hhciA9IGxpbmUudGV4dC5zbGljZShNYXRoLm1pbihwb3MsIG5leHQpIC0gbGluZS5mcm9tLCBNYXRoLm1heChwb3MsIG5leHQpIC0gbGluZS5mcm9tKTtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHRDaGFyKTtcbiAgICAgICAgaWYgKGNhdCAhPSBudWxsICYmIG5leHRDYXQgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0Q2hhciAhPSBcIiBcIiB8fCBwb3MgIT0gcmFuZ2UuaGVhZClcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHBvcyA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59KTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgYmFja3dhcmQgdW50aWwgdGhlIGVuZCBvZiB0aGUgbmV4dFxuW2dyb3VwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlQnlHcm91cCksIG9ubHkgc2tpcHBpbmcgZ3JvdXBzIG9mXG53aGl0ZXNwYWNlIHdoZW4gdGhleSBjb25zaXN0IG9mIGEgc2luZ2xlIHNwYWNlLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwQmFja3dhcmQgPSB0YXJnZXQgPT4gZGVsZXRlQnlHcm91cCh0YXJnZXQsIGZhbHNlKTtcbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24gb3IgZm9yd2FyZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBuZXh0IGdyb3VwLlxuKi9cbmNvbnN0IGRlbGV0ZUdyb3VwRm9yd2FyZCA9IHRhcmdldCA9PiBkZWxldGVCeUdyb3VwKHRhcmdldCwgdHJ1ZSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBlbmQgb2YgdGhlIGxpbmUuIElmIHRoZSBjdXJzb3IgaXMgZGlyZWN0bHkgYXQgdGhlIGVuZCBvZiB0aGVcbmxpbmUsIGRlbGV0ZSB0aGUgbGluZSBicmVhayBhZnRlciBpdC5cbiovXG5jb25zdCBkZWxldGVUb0xpbmVFbmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHJhbmdlID0+IHtcbiAgICBsZXQgbGluZUVuZCA9IHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkudG87XG4gICAgcmV0dXJuIHJhbmdlLmhlYWQgPCBsaW5lRW5kID8gbGluZUVuZCA6IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxlbmd0aCwgcmFuZ2UuaGVhZCArIDEpO1xufSk7XG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBvciwgaWYgaXQgaXMgYSBjdXJzb3Igc2VsZWN0aW9uLCBkZWxldGUgdG9cbnRoZSBzdGFydCBvZiB0aGUgbGluZS4gSWYgdGhlIGN1cnNvciBpcyBkaXJlY3RseSBhdCB0aGUgc3RhcnQgb2YgdGhlXG5saW5lLCBkZWxldGUgdGhlIGxpbmUgYnJlYWsgYmVmb3JlIGl0LlxuKi9cbmNvbnN0IGRlbGV0ZVRvTGluZVN0YXJ0ID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCByYW5nZSA9PiB7XG4gICAgbGV0IGxpbmVTdGFydCA9IHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCkuZnJvbTtcbiAgICByZXR1cm4gcmFuZ2UuaGVhZCA+IGxpbmVTdGFydCA/IGxpbmVTdGFydCA6IE1hdGgubWF4KDAsIHJhbmdlLmhlYWQgLSAxKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgc3RhcnQgb2YgdGhlIGxpbmUgb3IgdGhlIG5leHQgbGluZSB3cmFwIGJlZm9yZSB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUxpbmVCb3VuZGFyeUJhY2t3YXJkID0gdmlldyA9PiBkZWxldGVCeSh2aWV3LCByYW5nZSA9PiB7XG4gICAgbGV0IGxpbmVTdGFydCA9IHZpZXcubW92ZVRvTGluZUJvdW5kYXJ5KHJhbmdlLCBmYWxzZSkuaGVhZDtcbiAgICByZXR1cm4gcmFuZ2UuaGVhZCA+IGxpbmVTdGFydCA/IGxpbmVTdGFydCA6IE1hdGgubWF4KDAsIHJhbmdlLmhlYWQgLSAxKTtcbn0pO1xuLyoqXG5EZWxldGUgdGhlIHNlbGVjdGlvbiwgb3IsIGlmIGl0IGlzIGEgY3Vyc29yIHNlbGVjdGlvbiwgZGVsZXRlIHRvXG50aGUgZW5kIG9mIHRoZSBsaW5lIG9yIHRoZSBuZXh0IGxpbmUgd3JhcCBhZnRlciB0aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGRlbGV0ZUxpbmVCb3VuZGFyeUZvcndhcmQgPSB2aWV3ID0+IGRlbGV0ZUJ5KHZpZXcsIHJhbmdlID0+IHtcbiAgICBsZXQgbGluZVN0YXJ0ID0gdmlldy5tb3ZlVG9MaW5lQm91bmRhcnkocmFuZ2UsIHRydWUpLmhlYWQ7XG4gICAgcmV0dXJuIHJhbmdlLmhlYWQgPCBsaW5lU3RhcnQgPyBsaW5lU3RhcnQgOiBNYXRoLm1pbih2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIHJhbmdlLmhlYWQgKyAxKTtcbn0pO1xuLyoqXG5EZWxldGUgYWxsIHdoaXRlc3BhY2UgZGlyZWN0bHkgYmVmb3JlIGEgbGluZSBlbmQgZnJvbSB0aGVcbmRvY3VtZW50LlxuKi9cbmNvbnN0IGRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSAwLCBwcmV2ID0gXCJcIiwgaXRlciA9IHN0YXRlLmRvYy5pdGVyKCk7Oykge1xuICAgICAgICBpdGVyLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZXIubGluZUJyZWFrIHx8IGl0ZXIuZG9uZSkge1xuICAgICAgICAgICAgbGV0IHRyYWlsaW5nID0gcHJldi5zZWFyY2goL1xccyskLyk7XG4gICAgICAgICAgICBpZiAodHJhaWxpbmcgPiAtMSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBwb3MgLSAocHJldi5sZW5ndGggLSB0cmFpbGluZyksIHRvOiBwb3MgfSk7XG4gICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcHJldiA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmV2ID0gaXRlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gaXRlci52YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBjaGFuZ2VzLCB1c2VyRXZlbnQ6IFwiZGVsZXRlXCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSBlYWNoIHNlbGVjdGlvbiByYW5nZSB3aXRoIGEgbGluZSBicmVhaywgbGVhdmluZyB0aGUgY3Vyc29yXG5vbiB0aGUgbGluZSBiZWZvcmUgdGhlIGJyZWFrLlxuKi9cbmNvbnN0IHNwbGl0TGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogVGV4dC5vZihbXCJcIiwgXCJcIl0pIH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tKSB9O1xuICAgIH0pO1xuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZShjaGFuZ2VzLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5GbGlwIHRoZSBjaGFyYWN0ZXJzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGN1cnNvcihzKS5cbiovXG5jb25zdCB0cmFuc3Bvc2VDaGFycyA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSB8fCByYW5nZS5mcm9tID09IDAgfHwgcmFuZ2UuZnJvbSA9PSBzdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgbGV0IHBvcyA9IHJhbmdlLmZyb20sIGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCBmcm9tID0gcG9zID09IGxpbmUuZnJvbSA/IHBvcyAtIDEgOiBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgcG9zIC0gbGluZS5mcm9tLCBmYWxzZSkgKyBsaW5lLmZyb207XG4gICAgICAgIGxldCB0byA9IHBvcyA9PSBsaW5lLnRvID8gcG9zICsgMSA6IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBwb3MgLSBsaW5lLmZyb20sIHRydWUpICsgbGluZS5mcm9tO1xuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb20sIHRvLCBpbnNlcnQ6IHN0YXRlLmRvYy5zbGljZShwb3MsIHRvKS5hcHBlbmQoc3RhdGUuZG9jLnNsaWNlKGZyb20sIHBvcykpIH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih0bykgfTtcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlcy5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJtb3ZlLmNoYXJhY3RlclwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVCbG9ja3Moc3RhdGUpIHtcbiAgICBsZXQgYmxvY2tzID0gW10sIHVwdG8gPSAtMTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgIGxldCBzdGFydExpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLCBlbmRMaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS50byk7XG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkgJiYgcmFuZ2UudG8gPT0gZW5kTGluZS5mcm9tKVxuICAgICAgICAgICAgZW5kTGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8gLSAxKTtcbiAgICAgICAgaWYgKHVwdG8gPj0gc3RhcnRMaW5lLm51bWJlcikge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBibG9ja3NbYmxvY2tzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcHJldi50byA9IGVuZExpbmUudG87XG4gICAgICAgICAgICBwcmV2LnJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKHsgZnJvbTogc3RhcnRMaW5lLmZyb20sIHRvOiBlbmRMaW5lLnRvLCByYW5nZXM6IFtyYW5nZV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXB0byA9IGVuZExpbmUubnVtYmVyICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2Nrcztcbn1cbmZ1bmN0aW9uIG1vdmVMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZm9yd2FyZCkge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW10sIHJhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IGJsb2NrIG9mIHNlbGVjdGVkTGluZUJsb2NrcyhzdGF0ZSkpIHtcbiAgICAgICAgaWYgKGZvcndhcmQgPyBibG9jay50byA9PSBzdGF0ZS5kb2MubGVuZ3RoIDogYmxvY2suZnJvbSA9PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBuZXh0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZm9yd2FyZCA/IGJsb2NrLnRvICsgMSA6IGJsb2NrLmZyb20gLSAxKTtcbiAgICAgICAgbGV0IHNpemUgPSBuZXh0TGluZS5sZW5ndGggKyAxO1xuICAgICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2sudG8sIHRvOiBuZXh0TGluZS50byB9LCB7IGZyb206IGJsb2NrLmZyb20sIGluc2VydDogbmV4dExpbmUudGV4dCArIHN0YXRlLmxpbmVCcmVhayB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IHIgb2YgYmxvY2sucmFuZ2VzKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCByLmFuY2hvciArIHNpemUpLCBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCByLmhlYWQgKyBzaXplKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbmV4dExpbmUuZnJvbSwgdG86IGJsb2NrLmZyb20gfSwgeyBmcm9tOiBibG9jay50bywgaW5zZXJ0OiBzdGF0ZS5saW5lQnJlYWsgKyBuZXh0TGluZS50ZXh0IH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgciBvZiBibG9jay5yYW5nZXMpXG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuYW5jaG9yIC0gc2l6ZSwgci5oZWFkIC0gc2l6ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghY2hhbmdlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc3RhdGUuc2VsZWN0aW9uLm1haW5JbmRleCksXG4gICAgICAgIHVzZXJFdmVudDogXCJtb3ZlLmxpbmVcIlxuICAgIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuTW92ZSB0aGUgc2VsZWN0ZWQgbGluZXMgdXAgb25lIGxpbmUuXG4qL1xuY29uc3QgbW92ZUxpbmVVcCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBtb3ZlTGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0ZWQgbGluZXMgZG93biBvbmUgbGluZS5cbiovXG5jb25zdCBtb3ZlTGluZURvd24gPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4gbW92ZUxpbmUoc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbmZ1bmN0aW9uIGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgZm9yd2FyZCkge1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgYmxvY2sgb2Ygc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKSkge1xuICAgICAgICBpZiAoZm9yd2FyZClcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGJsb2NrLmZyb20sIGluc2VydDogc3RhdGUuZG9jLnNsaWNlKGJsb2NrLmZyb20sIGJsb2NrLnRvKSArIHN0YXRlLmxpbmVCcmVhayB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogYmxvY2sudG8sIGluc2VydDogc3RhdGUubGluZUJyZWFrICsgc3RhdGUuZG9jLnNsaWNlKGJsb2NrLmZyb20sIGJsb2NrLnRvKSB9KTtcbiAgICB9XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHsgY2hhbmdlcywgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudDogXCJpbnB1dC5jb3B5bGluZVwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29weSBvZiB0aGUgc2VsZWN0ZWQgbGluZXMuIEtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgdG9wIGNvcHkuXG4qL1xuY29uc3QgY29weUxpbmVVcCA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiBjb3B5TGluZShzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlKTtcbi8qKlxuQ3JlYXRlIGEgY29weSBvZiB0aGUgc2VsZWN0ZWQgbGluZXMuIEtlZXAgdGhlIHNlbGVjdGlvbiBpbiB0aGUgYm90dG9tIGNvcHkuXG4qL1xuY29uc3QgY29weUxpbmVEb3duID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IGNvcHlMaW5lKHN0YXRlLCBkaXNwYXRjaCwgdHJ1ZSk7XG4vKipcbkRlbGV0ZSBzZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCBkZWxldGVMaW5lID0gdmlldyA9PiB7XG4gICAgaWYgKHZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZXMoc2VsZWN0ZWRMaW5lQmxvY2tzKHN0YXRlKS5tYXAoKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBmcm9tLS07XG4gICAgICAgIGVsc2UgaWYgKHRvIDwgc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHRvKys7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvIH07XG4gICAgfSkpO1xuICAgIGxldCBzZWxlY3Rpb24gPSB1cGRhdGVTZWwoc3RhdGUuc2VsZWN0aW9uLCByYW5nZSA9PiB7XG4gICAgICAgIGxldCBkaXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodmlldy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIGxldCBibG9jayA9IHZpZXcubGluZUJsb2NrQXQocmFuZ2UuaGVhZCksIHBvcyA9IHZpZXcuY29vcmRzQXRQb3MocmFuZ2UuaGVhZCwgcmFuZ2UuYXNzb2MgfHwgMSk7XG4gICAgICAgICAgICBpZiAocG9zKVxuICAgICAgICAgICAgICAgIGRpc3QgPSAoYmxvY2suYm90dG9tICsgdmlldy5kb2N1bWVudFRvcCkgLSBwb3MuYm90dG9tICsgdmlldy5kZWZhdWx0TGluZUhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXcubW92ZVZlcnRpY2FsbHkocmFuZ2UsIHRydWUsIGRpc3QpO1xuICAgIH0pLm1hcChjaGFuZ2VzKTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgY2hhbmdlcywgc2VsZWN0aW9uLCBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImRlbGV0ZS5saW5lXCIgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUuXG4qL1xuY29uc3QgaW5zZXJ0TmV3bGluZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKHN0YXRlLnJlcGxhY2VTZWxlY3Rpb24oc3RhdGUubGluZUJyZWFrKSwgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSB0aGUgc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGFuZCB0aGUgc2FtZSBhbW91bnQgb2ZcbmluZGVudGF0aW9uIGFzIHRoZSBsaW5lIGFib3ZlLlxuKi9cbmNvbnN0IGluc2VydE5ld2xpbmVLZWVwSW5kZW50ID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgIGxldCBpbmRlbnQgPSAvXlxccyovLmV4ZWMoc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKS50ZXh0KVswXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IHN0YXRlLmxpbmVCcmVhayArIGluZGVudCB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGluZGVudC5sZW5ndGggKyAxKVxuICAgICAgICB9O1xuICAgIH0pLCB7IHNjcm9sbEludG9WaWV3OiB0cnVlLCB1c2VyRXZlbnQ6IFwiaW5wdXRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gaXNCZXR3ZWVuQnJhY2tldHMoc3RhdGUsIHBvcykge1xuICAgIGlmICgvXFwoXFwpfFxcW1xcXXxcXHtcXH0vLnRlc3Qoc3RhdGUuc2xpY2VEb2MocG9zIC0gMSwgcG9zICsgMSkpKVxuICAgICAgICByZXR1cm4geyBmcm9tOiBwb3MsIHRvOiBwb3MgfTtcbiAgICBsZXQgY29udGV4dCA9IHN5bnRheFRyZWUoc3RhdGUpLnJlc29sdmVJbm5lcihwb3MpO1xuICAgIGxldCBiZWZvcmUgPSBjb250ZXh0LmNoaWxkQmVmb3JlKHBvcyksIGFmdGVyID0gY29udGV4dC5jaGlsZEFmdGVyKHBvcyksIGNsb3NlZEJ5O1xuICAgIGlmIChiZWZvcmUgJiYgYWZ0ZXIgJiYgYmVmb3JlLnRvIDw9IHBvcyAmJiBhZnRlci5mcm9tID49IHBvcyAmJlxuICAgICAgICAoY2xvc2VkQnkgPSBiZWZvcmUudHlwZS5wcm9wKE5vZGVQcm9wLmNsb3NlZEJ5KSkgJiYgY2xvc2VkQnkuaW5kZXhPZihhZnRlci5uYW1lKSA+IC0xICYmXG4gICAgICAgIHN0YXRlLmRvYy5saW5lQXQoYmVmb3JlLnRvKS5mcm9tID09IHN0YXRlLmRvYy5saW5lQXQoYWZ0ZXIuZnJvbSkuZnJvbSAmJlxuICAgICAgICAhL1xcUy8udGVzdChzdGF0ZS5zbGljZURvYyhiZWZvcmUudG8sIGFmdGVyLmZyb20pKSlcbiAgICAgICAgcmV0dXJuIHsgZnJvbTogYmVmb3JlLnRvLCB0bzogYWZ0ZXIuZnJvbSB9O1xuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5SZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUgYW5kIGluZGVudCB0aGUgbmV3bHkgY3JlYXRlZFxubGluZShzKS4gSWYgdGhlIGN1cnJlbnQgbGluZSBjb25zaXN0cyBvbmx5IG9mIHdoaXRlc3BhY2UsIHRoaXNcbndpbGwgYWxzbyBkZWxldGUgdGhhdCB3aGl0ZXNwYWNlLiBXaGVuIHRoZSBjdXJzb3IgaXMgYmV0d2VlblxubWF0Y2hpbmcgYnJhY2tldHMsIGFuIGFkZGl0aW9uYWwgbmV3bGluZSB3aWxsIGJlIGluc2VydGVkIGFmdGVyXG50aGUgY3Vyc29yLlxuKi9cbmNvbnN0IGluc2VydE5ld2xpbmVBbmRJbmRlbnQgPSAvKkBfX1BVUkVfXyovbmV3bGluZUFuZEluZGVudChmYWxzZSk7XG4vKipcbkNyZWF0ZSBhIGJsYW5rLCBpbmRlbnRlZCBsaW5lIGJlbG93IHRoZSBjdXJyZW50IGxpbmUuXG4qL1xuY29uc3QgaW5zZXJ0QmxhbmtMaW5lID0gLypAX19QVVJFX18qL25ld2xpbmVBbmRJbmRlbnQodHJ1ZSk7XG5mdW5jdGlvbiBuZXdsaW5lQW5kSW5kZW50KGF0RW9mKSB7XG4gICAgcmV0dXJuICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZSwgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZnJvbSk7XG4gICAgICAgICAgICBsZXQgZXhwbG9kZSA9ICFhdEVvZiAmJiBmcm9tID09IHRvICYmIGlzQmV0d2VlbkJyYWNrZXRzKHN0YXRlLCBmcm9tKTtcbiAgICAgICAgICAgIGlmIChhdEVvZilcbiAgICAgICAgICAgICAgICBmcm9tID0gdG8gPSAodG8gPD0gbGluZS50byA/IGxpbmUgOiBzdGF0ZS5kb2MubGluZUF0KHRvKSkudG87XG4gICAgICAgICAgICBsZXQgY3ggPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBzaW11bGF0ZUJyZWFrOiBmcm9tLCBzaW11bGF0ZURvdWJsZUJyZWFrOiAhIWV4cGxvZGUgfSk7XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY3gsIGZyb20pO1xuICAgICAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGluZGVudCA9IGNvdW50Q29sdW1uKC9eXFxzKi8uZXhlYyhzdGF0ZS5kb2MubGluZUF0KGZyb20pLnRleHQpWzBdLCBzdGF0ZS50YWJTaXplKTtcbiAgICAgICAgICAgIHdoaWxlICh0byA8IGxpbmUudG8gJiYgL1xccy8udGVzdChsaW5lLnRleHRbdG8gLSBsaW5lLmZyb21dKSlcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgaWYgKGV4cGxvZGUpXG4gICAgICAgICAgICAgICAgKHsgZnJvbSwgdG8gfSA9IGV4cGxvZGUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbSA+IGxpbmUuZnJvbSAmJiBmcm9tIDwgbGluZS5mcm9tICsgMTAwICYmICEvXFxTLy50ZXN0KGxpbmUudGV4dC5zbGljZSgwLCBmcm9tKSkpXG4gICAgICAgICAgICAgICAgZnJvbSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBbXCJcIiwgaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpXTtcbiAgICAgICAgICAgIGlmIChleHBsb2RlKVxuICAgICAgICAgICAgICAgIGluc2VydC5wdXNoKGluZGVudFN0cmluZyhzdGF0ZSwgY3gubGluZUluZGVudChsaW5lLmZyb20sIC0xKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tLCB0bywgaW5zZXJ0OiBUZXh0Lm9mKGluc2VydCkgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmcm9tICsgMSArIGluc2VydFsxXS5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgICAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlcywgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIGYpIHtcbiAgICBsZXQgYXRMaW5lID0gLTE7XG4gICAgcmV0dXJuIHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSByYW5nZS5mcm9tOyBwb3MgPD0gcmFuZ2UudG87KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChsaW5lLm51bWJlciA+IGF0TGluZSAmJiAocmFuZ2UuZW1wdHkgfHwgcmFuZ2UudG8gPiBsaW5lLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgZihsaW5lLCBjaGFuZ2VzLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgYXRMaW5lID0gbGluZS5udW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hhbmdlU2V0ID0gc3RhdGUuY2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIHsgY2hhbmdlcyxcbiAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoY2hhbmdlU2V0Lm1hcFBvcyhyYW5nZS5hbmNob3IsIDEpLCBjaGFuZ2VTZXQubWFwUG9zKHJhbmdlLmhlYWQsIDEpKSB9O1xuICAgIH0pO1xufVxuLyoqXG5BdXRvLWluZGVudCB0aGUgc2VsZWN0ZWQgbGluZXMuIFRoaXMgdXNlcyB0aGUgW2luZGVudGF0aW9uIHNlcnZpY2VcbmZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpIGFzIHNvdXJjZSBmb3IgYXV0by1pbmRlbnRcbmluZm9ybWF0aW9uLlxuKi9cbmNvbnN0IGluZGVudFNlbGVjdGlvbiA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHVwZGF0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoc3RhdGUsIHsgb3ZlcnJpZGVJbmRlbnRhdGlvbjogc3RhcnQgPT4ge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gdXBkYXRlZFtzdGFydF07XG4gICAgICAgICAgICByZXR1cm4gZm91bmQgPT0gbnVsbCA/IC0xIDogZm91bmQ7XG4gICAgICAgIH0gfSk7XG4gICAgbGV0IGNoYW5nZXMgPSBjaGFuZ2VCeVNlbGVjdGVkTGluZShzdGF0ZSwgKGxpbmUsIGNoYW5nZXMsIHJhbmdlKSA9PiB7XG4gICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBsaW5lLmZyb20pO1xuICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghL1xcUy8udGVzdChsaW5lLnRleHQpKVxuICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgaWYgKGN1ciAhPSBub3JtIHx8IHJhbmdlLmZyb20gPCBsaW5lLmZyb20gKyBjdXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB1cGRhdGVkW2xpbmUuZnJvbV0gPSBpbmRlbnQ7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWNoYW5nZXMuY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZXMsIHsgdXNlckV2ZW50OiBcImluZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkFkZCBhIFt1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIG9mIGluZGVudGF0aW9uIHRvIGFsbCBzZWxlY3RlZFxubGluZXMuXG4qL1xuY29uc3QgaW5kZW50TW9yZSA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKHN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGlzcGF0Y2goc3RhdGUudXBkYXRlKGNoYW5nZUJ5U2VsZWN0ZWRMaW5lKHN0YXRlLCAobGluZSwgY2hhbmdlcykgPT4ge1xuICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydDogc3RhdGUuZmFjZXQoaW5kZW50VW5pdCkgfSk7XG4gICAgfSksIHsgdXNlckV2ZW50OiBcImlucHV0LmluZGVudFwiIH0pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblJlbW92ZSBhIFt1bml0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIG9mIGluZGVudGF0aW9uIGZyb20gYWxsXG5zZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCBpbmRlbnRMZXNzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoY2hhbmdlQnlTZWxlY3RlZExpbmUoc3RhdGUsIChsaW5lLCBjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGxldCBzcGFjZSA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBpZiAoIXNwYWNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY29sID0gY291bnRDb2x1bW4oc3BhY2UsIHN0YXRlLnRhYlNpemUpLCBrZWVwID0gMDtcbiAgICAgICAgbGV0IGluc2VydCA9IGluZGVudFN0cmluZyhzdGF0ZSwgTWF0aC5tYXgoMCwgY29sIC0gZ2V0SW5kZW50VW5pdChzdGF0ZSkpKTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBzcGFjZS5sZW5ndGggJiYga2VlcCA8IGluc2VydC5sZW5ndGggJiYgc3BhY2UuY2hhckNvZGVBdChrZWVwKSA9PSBpbnNlcnQuY2hhckNvZGVBdChrZWVwKSlcbiAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tICsga2VlcCwgdG86IGxpbmUuZnJvbSArIHNwYWNlLmxlbmd0aCwgaW5zZXJ0OiBpbnNlcnQuc2xpY2Uoa2VlcCkgfSk7XG4gICAgfSksIHsgdXNlckV2ZW50OiBcImRlbGV0ZS5kZWRlbnRcIiB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5FbmFibGVzIG9yIGRpc2FibGVzXG5bdGFiLWZvY3VzIG1vZGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnNldFRhYkZvY3VzTW9kZSkuIFdoaWxlIG9uLCB0aGlzXG5wcmV2ZW50cyB0aGUgZWRpdG9yJ3Mga2V5IGJpbmRpbmdzIGZyb20gY2FwdHVyaW5nIFRhYiBvclxuU2hpZnQtVGFiLCBtYWtpbmcgaXQgcG9zc2libGUgZm9yIHRoZSB1c2VyIHRvIG1vdmUgZm9jdXMgb3V0IG9mXG50aGUgZWRpdG9yIHdpdGggdGhlIGtleWJvYXJkLlxuKi9cbmNvbnN0IHRvZ2dsZVRhYkZvY3VzTW9kZSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuc2V0VGFiRm9jdXNNb2RlKCk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5UZW1wb3JhcmlseSBlbmFibGVzIFt0YWItZm9jdXNcbm1vZGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnNldFRhYkZvY3VzTW9kZSkgZm9yIHR3byBzZWNvbmRzIG9yIHVudGlsXG5hbm90aGVyIGtleSBpcyBwcmVzc2VkLlxuKi9cbmNvbnN0IHRlbXBvcmFyaWx5U2V0VGFiRm9jdXNNb2RlID0gdmlldyA9PiB7XG4gICAgdmlldy5zZXRUYWJGb2N1c01vZGUoMjAwMCk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JbnNlcnQgYSB0YWIgY2hhcmFjdGVyIGF0IHRoZSBjdXJzb3Igb3IsIGlmIHNvbWV0aGluZyBpcyBzZWxlY3RlZCxcbnVzZSBbYGluZGVudE1vcmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudE1vcmUpIHRvIGluZGVudCB0aGUgZW50aXJlXG5zZWxlY3Rpb24uXG4qL1xuY29uc3QgaW5zZXJ0VGFiID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gIXIuZW1wdHkpKVxuICAgICAgICByZXR1cm4gaW5kZW50TW9yZSh7IHN0YXRlLCBkaXNwYXRjaCB9KTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoc3RhdGUucmVwbGFjZVNlbGVjdGlvbihcIlxcdFwiKSwgeyBzY3JvbGxJbnRvVmlldzogdHJ1ZSwgdXNlckV2ZW50OiBcImlucHV0XCIgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQXJyYXkgb2Yga2V5IGJpbmRpbmdzIGNvbnRhaW5pbmcgdGhlIEVtYWNzLXN0eWxlIGJpbmRpbmdzIHRoYXQgYXJlXG5hdmFpbGFibGUgb24gbWFjT1MgYnkgZGVmYXVsdC5cblxuIC0gQ3RybC1iOiBbYGN1cnNvckNoYXJMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JDaGFyTGVmdCkgKFtgc2VsZWN0Q2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJMZWZ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1mOiBbYGN1cnNvckNoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhclJpZ2h0KSAoW2BzZWxlY3RDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJSaWdodCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtcDogW2BjdXJzb3JMaW5lVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVVcCkgKFtgc2VsZWN0TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lVXApIHdpdGggU2hpZnQpXG4gLSBDdHJsLW46IFtgY3Vyc29yTGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVEb3duKSAoW2BzZWxlY3RMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZURvd24pIHdpdGggU2hpZnQpXG4gLSBDdHJsLWE6IFtgY3Vyc29yTGluZVN0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lU3RhcnQpIChbYHNlbGVjdExpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVN0YXJ0KSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1lOiBbYGN1cnNvckxpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckxpbmVFbmQpIChbYHNlbGVjdExpbmVFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVFbmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLWQ6IFtgZGVsZXRlQ2hhckZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJGb3J3YXJkKVxuIC0gQ3RybC1oOiBbYGRlbGV0ZUNoYXJCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlQ2hhckJhY2t3YXJkKVxuIC0gQ3RybC1rOiBbYGRlbGV0ZVRvTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlVG9MaW5lRW5kKVxuIC0gQ3RybC1BbHQtaDogW2BkZWxldGVHcm91cEJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEJhY2t3YXJkKVxuIC0gQ3RybC1vOiBbYHNwbGl0TGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRMaW5lKVxuIC0gQ3RybC10OiBbYHRyYW5zcG9zZUNoYXJzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy50cmFuc3Bvc2VDaGFycylcbiAtIEN0cmwtdjogW2BjdXJzb3JQYWdlRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZURvd24pXG4gLSBBbHQtdjogW2BjdXJzb3JQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VVcClcbiovXG5jb25zdCBlbWFjc1N0eWxlS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkN0cmwtYlwiLCBydW46IGN1cnNvckNoYXJMZWZ0LCBzaGlmdDogc2VsZWN0Q2hhckxlZnQsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1mXCIsIHJ1bjogY3Vyc29yQ2hhclJpZ2h0LCBzaGlmdDogc2VsZWN0Q2hhclJpZ2h0IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1wXCIsIHJ1bjogY3Vyc29yTGluZVVwLCBzaGlmdDogc2VsZWN0TGluZVVwIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1uXCIsIHJ1bjogY3Vyc29yTGluZURvd24sIHNoaWZ0OiBzZWxlY3RMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIkN0cmwtYVwiLCBydW46IGN1cnNvckxpbmVTdGFydCwgc2hpZnQ6IHNlbGVjdExpbmVTdGFydCB9LFxuICAgIHsga2V5OiBcIkN0cmwtZVwiLCBydW46IGN1cnNvckxpbmVFbmQsIHNoaWZ0OiBzZWxlY3RMaW5lRW5kIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1kXCIsIHJ1bjogZGVsZXRlQ2hhckZvcndhcmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWhcIiwgcnVuOiBkZWxldGVDaGFyQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJDdHJsLWtcIiwgcnVuOiBkZWxldGVUb0xpbmVFbmQgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1oXCIsIHJ1bjogZGVsZXRlR3JvdXBCYWNrd2FyZCB9LFxuICAgIHsga2V5OiBcIkN0cmwtb1wiLCBydW46IHNwbGl0TGluZSB9LFxuICAgIHsga2V5OiBcIkN0cmwtdFwiLCBydW46IHRyYW5zcG9zZUNoYXJzIH0sXG4gICAgeyBrZXk6IFwiQ3RybC12XCIsIHJ1bjogY3Vyc29yUGFnZURvd24gfSxcbl07XG4vKipcbkFuIGFycmF5IG9mIGtleSBiaW5kaW5ncyBjbG9zZWx5IHN0aWNraW5nIHRvIHBsYXRmb3JtLXN0YW5kYXJkIG9yXG53aWRlbHkgdXNlZCBiaW5kaW5ncy4gKFRoaXMgaW5jbHVkZXMgdGhlIGJpbmRpbmdzIGZyb21cbltgZW1hY3NTdHlsZUtleW1hcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZW1hY3NTdHlsZUtleW1hcCksIHdpdGggdGhlaXIgYGtleWBcbnByb3BlcnR5IGNoYW5nZWQgdG8gYG1hY2AuKVxuXG4gLSBBcnJvd0xlZnQ6IFtgY3Vyc29yQ2hhckxlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckNoYXJMZWZ0KSAoW2BzZWxlY3RDaGFyTGVmdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0Q2hhckxlZnQpIHdpdGggU2hpZnQpXG4gLSBBcnJvd1JpZ2h0OiBbYGN1cnNvckNoYXJSaWdodGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yQ2hhclJpZ2h0KSAoW2BzZWxlY3RDaGFyUmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdENoYXJSaWdodCkgd2l0aCBTaGlmdClcbiAtIEN0cmwtQXJyb3dMZWZ0IChBbHQtQXJyb3dMZWZ0IG9uIG1hY09TKTogW2BjdXJzb3JHcm91cExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckdyb3VwTGVmdCkgKFtgc2VsZWN0R3JvdXBMZWZ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RHcm91cExlZnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93UmlnaHQgKEFsdC1BcnJvd1JpZ2h0IG9uIG1hY09TKTogW2BjdXJzb3JHcm91cFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JHcm91cFJpZ2h0KSAoW2BzZWxlY3RHcm91cFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RHcm91cFJpZ2h0KSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93TGVmdCAob24gbWFjT1MpOiBbYGN1cnNvckxpbmVTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZVN0YXJ0KSAoW2BzZWxlY3RMaW5lU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVTdGFydCkgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd1JpZ2h0IChvbiBtYWNPUyk6IFtgY3Vyc29yTGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUVuZCkgKFtgc2VsZWN0TGluZUVuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZUVuZCkgd2l0aCBTaGlmdClcbiAtIEFycm93VXA6IFtgY3Vyc29yTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lVXApIChbYHNlbGVjdExpbmVVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0TGluZVVwKSB3aXRoIFNoaWZ0KVxuIC0gQXJyb3dEb3duOiBbYGN1cnNvckxpbmVEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lRG93bikgKFtgc2VsZWN0TGluZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdExpbmVEb3duKSB3aXRoIFNoaWZ0KVxuIC0gQ21kLUFycm93VXAgKG9uIG1hY09TKTogW2BjdXJzb3JEb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jU3RhcnQpIChbYHNlbGVjdERvY1N0YXJ0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NTdGFydCkgd2l0aCBTaGlmdClcbiAtIENtZC1BcnJvd0Rvd24gKG9uIG1hY09TKTogW2BjdXJzb3JEb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY0VuZCkgKFtgc2VsZWN0RG9jRW5kYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3REb2NFbmQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93VXAgKG9uIG1hY09TKTogW2BjdXJzb3JQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclBhZ2VVcCkgKFtgc2VsZWN0UGFnZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RQYWdlVXApIHdpdGggU2hpZnQpXG4gLSBDdHJsLUFycm93RG93biAob24gbWFjT1MpOiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bikgKFtgc2VsZWN0UGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VEb3duKSB3aXRoIFNoaWZ0KVxuIC0gUGFnZVVwOiBbYGN1cnNvclBhZ2VVcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yUGFnZVVwKSAoW2BzZWxlY3RQYWdlVXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VVcCkgd2l0aCBTaGlmdClcbiAtIFBhZ2VEb3duOiBbYGN1cnNvclBhZ2VEb3duYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JQYWdlRG93bikgKFtgc2VsZWN0UGFnZURvd25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhZ2VEb3duKSB3aXRoIFNoaWZ0KVxuIC0gSG9tZTogW2BjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yTGluZUJvdW5kYXJ5QmFja3dhcmQpIChbYHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lQm91bmRhcnlCYWNrd2FyZCkgd2l0aCBTaGlmdClcbiAtIEVuZDogW2BjdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JMaW5lQm91bmRhcnlGb3J3YXJkKSAoW2BzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkKSB3aXRoIFNoaWZ0KVxuIC0gQ3RybC1Ib21lIChDbWQtSG9tZSBvbiBtYWNPUyk6IFtgY3Vyc29yRG9jU3RhcnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvckRvY1N0YXJ0KSAoW2BzZWxlY3REb2NTdGFydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuc2VsZWN0RG9jU3RhcnQpIHdpdGggU2hpZnQpXG4gLSBDdHJsLUVuZCAoQ21kLUhvbWUgb24gbWFjT1MpOiBbYGN1cnNvckRvY0VuZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY3Vyc29yRG9jRW5kKSAoW2BzZWxlY3REb2NFbmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdERvY0VuZCkgd2l0aCBTaGlmdClcbiAtIEVudGVyIGFuZCBTaGlmdC1FbnRlcjogW2BpbnNlcnROZXdsaW5lQW5kSW5kZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbnNlcnROZXdsaW5lQW5kSW5kZW50KVxuIC0gQ3RybC1hIChDbWQtYSBvbiBtYWNPUyk6IFtgc2VsZWN0QWxsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RBbGwpXG4gLSBCYWNrc3BhY2U6IFtgZGVsZXRlQ2hhckJhY2t3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVDaGFyQmFja3dhcmQpXG4gLSBEZWxldGU6IFtgZGVsZXRlQ2hhckZvcndhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUNoYXJGb3J3YXJkKVxuIC0gQ3RybC1CYWNrc3BhY2UgKEFsdC1CYWNrc3BhY2Ugb24gbWFjT1MpOiBbYGRlbGV0ZUdyb3VwQmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUdyb3VwQmFja3dhcmQpXG4gLSBDdHJsLURlbGV0ZSAoQWx0LURlbGV0ZSBvbiBtYWNPUyk6IFtgZGVsZXRlR3JvdXBGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVHcm91cEZvcndhcmQpXG4gLSBDbWQtQmFja3NwYWNlIChtYWNPUyk6IFtgZGVsZXRlTGluZUJvdW5kYXJ5QmFja3dhcmRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmRlbGV0ZUxpbmVCb3VuZGFyeUJhY2t3YXJkKS5cbiAtIENtZC1EZWxldGUgKG1hY09TKTogW2BkZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5kZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkKS5cbiovXG5jb25zdCBzdGFuZGFyZEtleW1hcCA9IC8qQF9fUFVSRV9fKi9bXG4gICAgeyBrZXk6IFwiQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yQ2hhckxlZnQsIHNoaWZ0OiBzZWxlY3RDaGFyTGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtQXJyb3dMZWZ0XCIsIG1hYzogXCJBbHQtQXJyb3dMZWZ0XCIsIHJ1bjogY3Vyc29yR3JvdXBMZWZ0LCBzaGlmdDogc2VsZWN0R3JvdXBMZWZ0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd0xlZnRcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlMZWZ0LCBzaGlmdDogc2VsZWN0TGluZUJvdW5kYXJ5TGVmdCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJBcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yQ2hhclJpZ2h0LCBzaGlmdDogc2VsZWN0Q2hhclJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1BcnJvd1JpZ2h0XCIsIG1hYzogXCJBbHQtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvckdyb3VwUmlnaHQsIHNoaWZ0OiBzZWxlY3RHcm91cFJpZ2h0LCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd1JpZ2h0XCIsIHJ1bjogY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJBcnJvd1VwXCIsIHJ1bjogY3Vyc29yTGluZVVwLCBzaGlmdDogc2VsZWN0TGluZVVwLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsgbWFjOiBcIkNtZC1BcnJvd1VwXCIsIHJ1bjogY3Vyc29yRG9jU3RhcnQsIHNoaWZ0OiBzZWxlY3REb2NTdGFydCB9LFxuICAgIHsgbWFjOiBcIkN0cmwtQXJyb3dVcFwiLCBydW46IGN1cnNvclBhZ2VVcCwgc2hpZnQ6IHNlbGVjdFBhZ2VVcCB9LFxuICAgIHsga2V5OiBcIkFycm93RG93blwiLCBydW46IGN1cnNvckxpbmVEb3duLCBzaGlmdDogc2VsZWN0TGluZURvd24sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBtYWM6IFwiQ21kLUFycm93RG93blwiLCBydW46IGN1cnNvckRvY0VuZCwgc2hpZnQ6IHNlbGVjdERvY0VuZCB9LFxuICAgIHsgbWFjOiBcIkN0cmwtQXJyb3dEb3duXCIsIHJ1bjogY3Vyc29yUGFnZURvd24sIHNoaWZ0OiBzZWxlY3RQYWdlRG93biB9LFxuICAgIHsga2V5OiBcIlBhZ2VVcFwiLCBydW46IGN1cnNvclBhZ2VVcCwgc2hpZnQ6IHNlbGVjdFBhZ2VVcCB9LFxuICAgIHsga2V5OiBcIlBhZ2VEb3duXCIsIHJ1bjogY3Vyc29yUGFnZURvd24sIHNoaWZ0OiBzZWxlY3RQYWdlRG93biB9LFxuICAgIHsga2V5OiBcIkhvbWVcIiwgcnVuOiBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCwgc2hpZnQ6IHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1Ib21lXCIsIHJ1bjogY3Vyc29yRG9jU3RhcnQsIHNoaWZ0OiBzZWxlY3REb2NTdGFydCB9LFxuICAgIHsga2V5OiBcIkVuZFwiLCBydW46IGN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQsIHNoaWZ0OiBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1FbmRcIiwgcnVuOiBjdXJzb3JEb2NFbmQsIHNoaWZ0OiBzZWxlY3REb2NFbmQgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBydW46IGluc2VydE5ld2xpbmVBbmRJbmRlbnQsIHNoaWZ0OiBpbnNlcnROZXdsaW5lQW5kSW5kZW50IH0sXG4gICAgeyBrZXk6IFwiTW9kLWFcIiwgcnVuOiBzZWxlY3RBbGwgfSxcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVDaGFyQmFja3dhcmQsIHNoaWZ0OiBkZWxldGVDaGFyQmFja3dhcmQgfSxcbiAgICB7IGtleTogXCJEZWxldGVcIiwgcnVuOiBkZWxldGVDaGFyRm9yd2FyZCB9LFxuICAgIHsga2V5OiBcIk1vZC1CYWNrc3BhY2VcIiwgbWFjOiBcIkFsdC1CYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVHcm91cEJhY2t3YXJkIH0sXG4gICAgeyBrZXk6IFwiTW9kLURlbGV0ZVwiLCBtYWM6IFwiQWx0LURlbGV0ZVwiLCBydW46IGRlbGV0ZUdyb3VwRm9yd2FyZCB9LFxuICAgIHsgbWFjOiBcIk1vZC1CYWNrc3BhY2VcIiwgcnVuOiBkZWxldGVMaW5lQm91bmRhcnlCYWNrd2FyZCB9LFxuICAgIHsgbWFjOiBcIk1vZC1EZWxldGVcIiwgcnVuOiBkZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkIH1cbl0uY29uY2F0KC8qQF9fUFVSRV9fKi9lbWFjc1N0eWxlS2V5bWFwLm1hcChiID0+ICh7IG1hYzogYi5rZXksIHJ1bjogYi5ydW4sIHNoaWZ0OiBiLnNoaWZ0IH0pKSk7XG4vKipcblRoZSBkZWZhdWx0IGtleW1hcC4gSW5jbHVkZXMgYWxsIGJpbmRpbmdzIGZyb21cbltgc3RhbmRhcmRLZXltYXBgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnN0YW5kYXJkS2V5bWFwKSBwbHVzIHRoZSBmb2xsb3dpbmc6XG5cbi0gQWx0LUFycm93TGVmdCAoQ3RybC1BcnJvd0xlZnQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmN1cnNvclN5bnRheExlZnQpIChbYHNlbGVjdFN5bnRheExlZnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheExlZnQpIHdpdGggU2hpZnQpXG4tIEFsdC1BcnJvd1JpZ2h0IChDdHJsLUFycm93UmlnaHQgb24gbWFjT1MpOiBbYGN1cnNvclN5bnRheFJpZ2h0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JTeW50YXhSaWdodCkgKFtgc2VsZWN0U3ludGF4UmlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFN5bnRheFJpZ2h0KSB3aXRoIFNoaWZ0KVxuLSBBbHQtQXJyb3dVcDogW2Btb3ZlTGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5tb3ZlTGluZVVwKVxuLSBBbHQtQXJyb3dEb3duOiBbYG1vdmVMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMubW92ZUxpbmVEb3duKVxuLSBTaGlmdC1BbHQtQXJyb3dVcDogW2Bjb3B5TGluZVVwYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jb3B5TGluZVVwKVxuLSBTaGlmdC1BbHQtQXJyb3dEb3duOiBbYGNvcHlMaW5lRG93bmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuY29weUxpbmVEb3duKVxuLSBFc2NhcGU6IFtgc2ltcGxpZnlTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNpbXBsaWZ5U2VsZWN0aW9uKVxuLSBDdHJsLUVudGVyIChDbWQtRW50ZXIgb24gbWFjT1MpOiBbYGluc2VydEJsYW5rTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5zZXJ0QmxhbmtMaW5lKVxuLSBBbHQtbCAoQ3RybC1sIG9uIG1hY09TKTogW2BzZWxlY3RMaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5zZWxlY3RMaW5lKVxuLSBDdHJsLWkgKENtZC1pIG9uIG1hY09TKTogW2BzZWxlY3RQYXJlbnRTeW50YXhgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnNlbGVjdFBhcmVudFN5bnRheClcbi0gQ3RybC1bIChDbWQtWyBvbiBtYWNPUyk6IFtgaW5kZW50TGVzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TGVzcylcbi0gQ3RybC1dIChDbWQtXSBvbiBtYWNPUyk6IFtgaW5kZW50TW9yZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuaW5kZW50TW9yZSlcbi0gQ3RybC1BbHQtXFxcXCAoQ21kLUFsdC1cXFxcIG9uIG1hY09TKTogW2BpbmRlbnRTZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudFNlbGVjdGlvbilcbi0gU2hpZnQtQ3RybC1rIChTaGlmdC1DbWQtayBvbiBtYWNPUyk6IFtgZGVsZXRlTGluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuZGVsZXRlTGluZSlcbi0gU2hpZnQtQ3RybC1cXFxcIChTaGlmdC1DbWQtXFxcXCBvbiBtYWNPUyk6IFtgY3Vyc29yTWF0Y2hpbmdCcmFja2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5jdXJzb3JNYXRjaGluZ0JyYWNrZXQpXG4tIEN0cmwtLyAoQ21kLS8gb24gbWFjT1MpOiBbYHRvZ2dsZUNvbW1lbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRvZ2dsZUNvbW1lbnQpLlxuLSBTaGlmdC1BbHQtYTogW2B0b2dnbGVCbG9ja0NvbW1lbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLnRvZ2dsZUJsb2NrQ29tbWVudCkuXG4tIEN0cmwtbSAoQWx0LVNoaWZ0LW0gb24gbWFjT1MpOiBbYHRvZ2dsZVRhYkZvY3VzTW9kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMudG9nZ2xlVGFiRm9jdXNNb2RlKS5cbiovXG5jb25zdCBkZWZhdWx0S2V5bWFwID0gLypAX19QVVJFX18qL1tcbiAgICB7IGtleTogXCJBbHQtQXJyb3dMZWZ0XCIsIG1hYzogXCJDdHJsLUFycm93TGVmdFwiLCBydW46IGN1cnNvclN5bnRheExlZnQsIHNoaWZ0OiBzZWxlY3RTeW50YXhMZWZ0IH0sXG4gICAgeyBrZXk6IFwiQWx0LUFycm93UmlnaHRcIiwgbWFjOiBcIkN0cmwtQXJyb3dSaWdodFwiLCBydW46IGN1cnNvclN5bnRheFJpZ2h0LCBzaGlmdDogc2VsZWN0U3ludGF4UmlnaHQgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dVcFwiLCBydW46IG1vdmVMaW5lVXAgfSxcbiAgICB7IGtleTogXCJTaGlmdC1BbHQtQXJyb3dVcFwiLCBydW46IGNvcHlMaW5lVXAgfSxcbiAgICB7IGtleTogXCJBbHQtQXJyb3dEb3duXCIsIHJ1bjogbW92ZUxpbmVEb3duIH0sXG4gICAgeyBrZXk6IFwiU2hpZnQtQWx0LUFycm93RG93blwiLCBydW46IGNvcHlMaW5lRG93biB9LFxuICAgIHsga2V5OiBcIkVzY2FwZVwiLCBydW46IHNpbXBsaWZ5U2VsZWN0aW9uIH0sXG4gICAgeyBrZXk6IFwiTW9kLUVudGVyXCIsIHJ1bjogaW5zZXJ0QmxhbmtMaW5lIH0sXG4gICAgeyBrZXk6IFwiQWx0LWxcIiwgbWFjOiBcIkN0cmwtbFwiLCBydW46IHNlbGVjdExpbmUgfSxcbiAgICB7IGtleTogXCJNb2QtaVwiLCBydW46IHNlbGVjdFBhcmVudFN5bnRheCwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtW1wiLCBydW46IGluZGVudExlc3MgfSxcbiAgICB7IGtleTogXCJNb2QtXVwiLCBydW46IGluZGVudE1vcmUgfSxcbiAgICB7IGtleTogXCJNb2QtQWx0LVxcXFxcIiwgcnVuOiBpbmRlbnRTZWxlY3Rpb24gfSxcbiAgICB7IGtleTogXCJTaGlmdC1Nb2Qta1wiLCBydW46IGRlbGV0ZUxpbmUgfSxcbiAgICB7IGtleTogXCJTaGlmdC1Nb2QtXFxcXFwiLCBydW46IGN1cnNvck1hdGNoaW5nQnJhY2tldCB9LFxuICAgIHsga2V5OiBcIk1vZC0vXCIsIHJ1bjogdG9nZ2xlQ29tbWVudCB9LFxuICAgIHsga2V5OiBcIkFsdC1BXCIsIHJ1bjogdG9nZ2xlQmxvY2tDb21tZW50IH0sXG4gICAgeyBrZXk6IFwiQ3RybC1tXCIsIG1hYzogXCJTaGlmdC1BbHQtbVwiLCBydW46IHRvZ2dsZVRhYkZvY3VzTW9kZSB9LFxuXS5jb25jYXQoc3RhbmRhcmRLZXltYXApO1xuLyoqXG5BIGJpbmRpbmcgdGhhdCBiaW5kcyBUYWIgdG8gW2BpbmRlbnRNb3JlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNjb21tYW5kcy5pbmRlbnRNb3JlKSBhbmRcblNoaWZ0LVRhYiB0byBbYGluZGVudExlc3NgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLmluZGVudExlc3MpLlxuUGxlYXNlIHNlZSB0aGUgW1RhYiBleGFtcGxlXSguLi8uLi9leGFtcGxlcy90YWIvKSBiZWZvcmUgdXNpbmdcbnRoaXMuXG4qL1xuY29uc3QgaW5kZW50V2l0aFRhYiA9IHsga2V5OiBcIlRhYlwiLCBydW46IGluZGVudE1vcmUsIHNoaWZ0OiBpbmRlbnRMZXNzIH07XG5cbmV4cG9ydCB7IGJsb2NrQ29tbWVudCwgYmxvY2tVbmNvbW1lbnQsIGNvcHlMaW5lRG93biwgY29weUxpbmVVcCwgY3Vyc29yQ2hhckJhY2t3YXJkLCBjdXJzb3JDaGFyQmFja3dhcmRMb2dpY2FsLCBjdXJzb3JDaGFyRm9yd2FyZCwgY3Vyc29yQ2hhckZvcndhcmRMb2dpY2FsLCBjdXJzb3JDaGFyTGVmdCwgY3Vyc29yQ2hhclJpZ2h0LCBjdXJzb3JEb2NFbmQsIGN1cnNvckRvY1N0YXJ0LCBjdXJzb3JHcm91cEJhY2t3YXJkLCBjdXJzb3JHcm91cEZvcndhcmQsIGN1cnNvckdyb3VwRm9yd2FyZFdpbiwgY3Vyc29yR3JvdXBMZWZ0LCBjdXJzb3JHcm91cFJpZ2h0LCBjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCwgY3Vyc29yTGluZUJvdW5kYXJ5Rm9yd2FyZCwgY3Vyc29yTGluZUJvdW5kYXJ5TGVmdCwgY3Vyc29yTGluZUJvdW5kYXJ5UmlnaHQsIGN1cnNvckxpbmVEb3duLCBjdXJzb3JMaW5lRW5kLCBjdXJzb3JMaW5lU3RhcnQsIGN1cnNvckxpbmVVcCwgY3Vyc29yTWF0Y2hpbmdCcmFja2V0LCBjdXJzb3JQYWdlRG93biwgY3Vyc29yUGFnZVVwLCBjdXJzb3JTdWJ3b3JkQmFja3dhcmQsIGN1cnNvclN1YndvcmRGb3J3YXJkLCBjdXJzb3JTeW50YXhMZWZ0LCBjdXJzb3JTeW50YXhSaWdodCwgZGVmYXVsdEtleW1hcCwgZGVsZXRlQ2hhckJhY2t3YXJkLCBkZWxldGVDaGFyQmFja3dhcmRTdHJpY3QsIGRlbGV0ZUNoYXJGb3J3YXJkLCBkZWxldGVHcm91cEJhY2t3YXJkLCBkZWxldGVHcm91cEZvcndhcmQsIGRlbGV0ZUxpbmUsIGRlbGV0ZUxpbmVCb3VuZGFyeUJhY2t3YXJkLCBkZWxldGVMaW5lQm91bmRhcnlGb3J3YXJkLCBkZWxldGVUb0xpbmVFbmQsIGRlbGV0ZVRvTGluZVN0YXJ0LCBkZWxldGVUcmFpbGluZ1doaXRlc3BhY2UsIGVtYWNzU3R5bGVLZXltYXAsIGhpc3RvcnksIGhpc3RvcnlGaWVsZCwgaGlzdG9yeUtleW1hcCwgaW5kZW50TGVzcywgaW5kZW50TW9yZSwgaW5kZW50U2VsZWN0aW9uLCBpbmRlbnRXaXRoVGFiLCBpbnNlcnRCbGFua0xpbmUsIGluc2VydE5ld2xpbmUsIGluc2VydE5ld2xpbmVBbmRJbmRlbnQsIGluc2VydE5ld2xpbmVLZWVwSW5kZW50LCBpbnNlcnRUYWIsIGludmVydGVkRWZmZWN0cywgaXNvbGF0ZUhpc3RvcnksIGxpbmVDb21tZW50LCBsaW5lVW5jb21tZW50LCBtb3ZlTGluZURvd24sIG1vdmVMaW5lVXAsIHJlZG8sIHJlZG9EZXB0aCwgcmVkb1NlbGVjdGlvbiwgc2VsZWN0QWxsLCBzZWxlY3RDaGFyQmFja3dhcmQsIHNlbGVjdENoYXJCYWNrd2FyZExvZ2ljYWwsIHNlbGVjdENoYXJGb3J3YXJkLCBzZWxlY3RDaGFyRm9yd2FyZExvZ2ljYWwsIHNlbGVjdENoYXJMZWZ0LCBzZWxlY3RDaGFyUmlnaHQsIHNlbGVjdERvY0VuZCwgc2VsZWN0RG9jU3RhcnQsIHNlbGVjdEdyb3VwQmFja3dhcmQsIHNlbGVjdEdyb3VwRm9yd2FyZCwgc2VsZWN0R3JvdXBGb3J3YXJkV2luLCBzZWxlY3RHcm91cExlZnQsIHNlbGVjdEdyb3VwUmlnaHQsIHNlbGVjdExpbmUsIHNlbGVjdExpbmVCb3VuZGFyeUJhY2t3YXJkLCBzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkLCBzZWxlY3RMaW5lQm91bmRhcnlMZWZ0LCBzZWxlY3RMaW5lQm91bmRhcnlSaWdodCwgc2VsZWN0TGluZURvd24sIHNlbGVjdExpbmVFbmQsIHNlbGVjdExpbmVTdGFydCwgc2VsZWN0TGluZVVwLCBzZWxlY3RNYXRjaGluZ0JyYWNrZXQsIHNlbGVjdFBhZ2VEb3duLCBzZWxlY3RQYWdlVXAsIHNlbGVjdFBhcmVudFN5bnRheCwgc2VsZWN0U3Vid29yZEJhY2t3YXJkLCBzZWxlY3RTdWJ3b3JkRm9yd2FyZCwgc2VsZWN0U3ludGF4TGVmdCwgc2VsZWN0U3ludGF4UmlnaHQsIHNpbXBsaWZ5U2VsZWN0aW9uLCBzcGxpdExpbmUsIHN0YW5kYXJkS2V5bWFwLCB0ZW1wb3JhcmlseVNldFRhYkZvY3VzTW9kZSwgdG9nZ2xlQmxvY2tDb21tZW50LCB0b2dnbGVCbG9ja0NvbW1lbnRCeUxpbmUsIHRvZ2dsZUNvbW1lbnQsIHRvZ2dsZUxpbmVDb21tZW50LCB0b2dnbGVUYWJGb2N1c01vZGUsIHRyYW5zcG9zZUNoYXJzLCB1bmRvLCB1bmRvRGVwdGgsIHVuZG9TZWxlY3Rpb24gfTtcbiJdLCJuYW1lcyI6WyJBbm5vdGF0aW9uIiwiRmFjZXQiLCJjb21iaW5lQ29uZmlnIiwiU3RhdGVGaWVsZCIsIlRyYW5zYWN0aW9uIiwiQ2hhbmdlU2V0IiwiQ2hhbmdlRGVzYyIsIkVkaXRvclNlbGVjdGlvbiIsIlN0YXRlRWZmZWN0IiwiVGV4dCIsImZpbmRDbHVzdGVyQnJlYWsiLCJjb3VudENvbHVtbiIsIkNoYXJDYXRlZ29yeSIsIkVkaXRvclZpZXciLCJEaXJlY3Rpb24iLCJJbmRlbnRDb250ZXh0IiwiZ2V0SW5kZW50YXRpb24iLCJpbmRlbnRTdHJpbmciLCJtYXRjaEJyYWNrZXRzIiwic3ludGF4VHJlZSIsImdldEluZGVudFVuaXQiLCJpbmRlbnRVbml0IiwiTm9kZVByb3AiLCJ0b2dnbGVDb21tZW50IiwidGFyZ2V0Iiwic3RhdGUiLCJsaW5lIiwiZG9jIiwibGluZUF0Iiwic2VsZWN0aW9uIiwibWFpbiIsImZyb20iLCJjb25maWciLCJnZXRDb25maWciLCJ0b2dnbGVMaW5lQ29tbWVudCIsImJsb2NrIiwidG9nZ2xlQmxvY2tDb21tZW50QnlMaW5lIiwiY29tbWFuZCIsImYiLCJvcHRpb24iLCJkaXNwYXRjaCIsInJlYWRPbmx5IiwidHIiLCJ1cGRhdGUiLCJjaGFuZ2VMaW5lQ29tbWVudCIsImxpbmVDb21tZW50IiwibGluZVVuY29tbWVudCIsInRvZ2dsZUJsb2NrQ29tbWVudCIsImNoYW5nZUJsb2NrQ29tbWVudCIsImJsb2NrQ29tbWVudCIsImJsb2NrVW5jb21tZW50IiwibyIsInMiLCJzZWxlY3RlZExpbmVSYW5nZXMiLCJwb3MiLCJkYXRhIiwibGFuZ3VhZ2VEYXRhQXQiLCJsZW5ndGgiLCJTZWFyY2hNYXJnaW4iLCJmaW5kQmxvY2tDb21tZW50Iiwib3BlbiIsImNsb3NlIiwidG8iLCJ0ZXh0QmVmb3JlIiwic2xpY2VEb2MiLCJ0ZXh0QWZ0ZXIiLCJzcGFjZUJlZm9yZSIsImV4ZWMiLCJzcGFjZUFmdGVyIiwiYmVmb3JlT2ZmIiwic2xpY2UiLCJtYXJnaW4iLCJzdGFydFRleHQiLCJlbmRUZXh0Iiwic3RhcnRTcGFjZSIsImVuZFNwYWNlIiwiZW5kT2ZmIiwidGVzdCIsImNoYXJBdCIsInJhbmdlcyIsInIiLCJmcm9tTGluZSIsInRvTGluZSIsImxhc3QiLCJwdXNoIiwidGV4dCIsInRva2VucyIsIm1hcCIsImV2ZXJ5IiwiYyIsImNvbW1lbnRzIiwiaSIsImNoYW5nZXMiLCJyYW5nZSIsImluc2VydCIsInNvbWUiLCJjb21tZW50IiwidG9rZW4iLCJsaW5lcyIsInByZXZMaW5lIiwic3RhcnRJIiwibWluSW5kZW50IiwiaW5kZW50IiwiZW1wdHkiLCJzaW5nbGUiLCJsIiwiY2hhbmdlU2V0IiwiZnJvbUhpc3RvcnkiLCJkZWZpbmUiLCJpc29sYXRlSGlzdG9yeSIsImludmVydGVkRWZmZWN0cyIsImhpc3RvcnlDb25maWciLCJjb21iaW5lIiwiY29uZmlncyIsIm1pbkRlcHRoIiwibmV3R3JvdXBEZWxheSIsImpvaW5Ub0V2ZW50IiwiX3QiLCJpc0FkamFjZW50IiwiTWF0aCIsIm1heCIsIm1pbiIsImEiLCJiIiwiYWRqIiwiaGlzdG9yeUZpZWxkXyIsImNyZWF0ZSIsIkhpc3RvcnlTdGF0ZSIsImZhY2V0IiwiZnJvbUhpc3QiLCJhbm5vdGF0aW9uIiwiaXRlbSIsIkhpc3RFdmVudCIsImZyb21UcmFuc2FjdGlvbiIsInNpZGUiLCJvdGhlciIsInVuZG9uZSIsImRvbmUiLCJ1cGRhdGVCcmFuY2giLCJhZGRTZWxlY3Rpb24iLCJzdGFydFN0YXRlIiwicmVzdCIsImlzb2xhdGUiLCJhZGRUb0hpc3RvcnkiLCJhZGRNYXBwaW5nIiwiZGVzYyIsImV2ZW50IiwidGltZSIsInVzZXJFdmVudCIsImFkZENoYW5nZXMiLCJ0b0pTT04iLCJ2YWx1ZSIsImUiLCJmcm9tSlNPTiIsImpzb24iLCJoaXN0b3J5Iiwib2YiLCJkb21FdmVudEhhbmRsZXJzIiwiYmVmb3JlaW5wdXQiLCJ2aWV3IiwiaW5wdXRUeXBlIiwidW5kbyIsInJlZG8iLCJwcmV2ZW50RGVmYXVsdCIsImhpc3RvcnlGaWVsZCIsImNtZCIsImhpc3RvcnlTdGF0ZSIsImZpZWxkIiwicG9wIiwidW5kb1NlbGVjdGlvbiIsInJlZG9TZWxlY3Rpb24iLCJkZXB0aCIsImhpc3RTdGF0ZSIsImJyYW5jaCIsInVuZG9EZXB0aCIsInJlZG9EZXB0aCIsImNvbnN0cnVjdG9yIiwiZWZmZWN0cyIsIm1hcHBlZCIsInN0YXJ0U2VsZWN0aW9uIiwic2VsZWN0aW9uc0FmdGVyIiwic2V0U2VsQWZ0ZXIiLCJhZnRlciIsIl9hIiwiX2IiLCJfYyIsIm5vbmUiLCJpbnZlcnQiLCJyZXN1bHQiLCJjb25jYXQiLCJ1bmRlZmluZWQiLCJzZWxlY3Rpb25zIiwibWF4TGVuIiwibmV3RXZlbnQiLCJzdGFydCIsIm5ld0JyYW5jaCIsIml0ZXJDaGFuZ2VkUmFuZ2VzIiwidCIsIl9mIiwiZXFTZWxlY3Rpb25TaGFwZSIsImZpbHRlciIsImNvbmMiLCJNYXhTZWxlY3Rpb25zUGVyRXZlbnQiLCJsYXN0RXZlbnQiLCJzZWxzIiwiZXEiLCJwb3BTZWxlY3Rpb24iLCJhZGRNYXBwaW5nVG9CcmFuY2giLCJtYXBwaW5nIiwibWFwRXZlbnQiLCJleHRyYVNlbGVjdGlvbnMiLCJtYXBwZWRDaGFuZ2VzIiwiYmVmb3JlIiwibWFwRGVzYyIsImZ1bGxNYXBwaW5nIiwiY29tcG9zZURlc2MiLCJtYXBFZmZlY3RzIiwiam9pbmFibGVVc2VyRXZlbnQiLCJwcmV2VGltZSIsInByZXZVc2VyRXZlbnQiLCJjb21wb3NlIiwib25seVNlbGVjdGlvbiIsImFubm90YXRpb25zIiwic2Nyb2xsSW50b1ZpZXciLCJoaXN0b3J5S2V5bWFwIiwia2V5IiwicnVuIiwibWFjIiwibGludXgiLCJ1cGRhdGVTZWwiLCJzZWwiLCJieSIsIm1haW5JbmRleCIsInNldFNlbCIsIm1vdmVTZWwiLCJob3ciLCJyYW5nZUVuZCIsImZvcndhcmQiLCJjdXJzb3IiLCJjdXJzb3JCeUNoYXIiLCJtb3ZlQnlDaGFyIiwibHRyQXRDdXJzb3IiLCJ0ZXh0RGlyZWN0aW9uQXQiLCJoZWFkIiwiTFRSIiwiY3Vyc29yQ2hhckxlZnQiLCJjdXJzb3JDaGFyUmlnaHQiLCJjdXJzb3JDaGFyRm9yd2FyZCIsImN1cnNvckNoYXJCYWNrd2FyZCIsImJ5Q2hhckxvZ2ljYWwiLCJtb3ZlQnlDaGFyTG9naWNhbCIsImN1cnNvckNoYXJGb3J3YXJkTG9naWNhbCIsImN1cnNvckNoYXJCYWNrd2FyZExvZ2ljYWwiLCJjdXJzb3JCeUdyb3VwIiwibW92ZUJ5R3JvdXAiLCJjdXJzb3JHcm91cExlZnQiLCJjdXJzb3JHcm91cFJpZ2h0IiwiY3Vyc29yR3JvdXBGb3J3YXJkIiwiY3Vyc29yR3JvdXBCYWNrd2FyZCIsInRvR3JvdXBTdGFydCIsImNhdGVnb3JpemUiLCJjaGFyQ2F0ZWdvcml6ZXIiLCJjYXQiLCJpbml0aWFsIiwiU3BhY2UiLCJuZXh0IiwibmV4dENhdCIsImN1cnNvckdyb3VwRm9yd2FyZFdpbiIsInNlZ21lbnRlciIsIkludGwiLCJTZWdtZW50ZXIiLCJncmFudWxhcml0eSIsIm1vdmVCeVN1YndvcmQiLCJzdGVwcyIsInNhd1VwcGVyIiwic2F3TG93ZXIiLCJzdGVwIiwiYWhlYWQiLCJXb3JkIiwiY2hhckNvZGVBdCIsInRvTG93ZXJDYXNlIiwiZW5kIiwic2tpcHBlZCIsInNlZ21lbnRzIiwiQXJyYXkiLCJzZWdtZW50IiwiaW5kZXgiLCJjdXJzb3JCeVN1YndvcmQiLCJjdXJzb3JTdWJ3b3JkRm9yd2FyZCIsImN1cnNvclN1YndvcmRCYWNrd2FyZCIsImludGVyZXN0aW5nTm9kZSIsIm5vZGUiLCJicmFja2V0UHJvcCIsInR5cGUiLCJwcm9wIiwibGVuIiwiZmlyc3RDaGlsZCIsIm1vdmVCeVN5bnRheCIsInJlc29sdmVJbm5lciIsImNsb3NlZEJ5Iiwib3BlbmVkQnkiLCJhdCIsImNoaWxkQWZ0ZXIiLCJjaGlsZEJlZm9yZSIsImJyYWNrZXQiLCJtYXRjaCIsIm5ld1BvcyIsIm1hdGNoZWQiLCJjdXJzb3JTeW50YXhMZWZ0IiwiY3Vyc29yU3ludGF4UmlnaHQiLCJjdXJzb3JCeUxpbmUiLCJtb3ZlZCIsIm1vdmVWZXJ0aWNhbGx5IiwibW92ZVRvTGluZUJvdW5kYXJ5IiwiY3Vyc29yTGluZVVwIiwiY3Vyc29yTGluZURvd24iLCJwYWdlSW5mbyIsInNlbGZTY3JvbGwiLCJzY3JvbGxET00iLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJtYXJnaW5Ub3AiLCJtYXJnaW5Cb3R0b20iLCJoZWlnaHQiLCJzb3VyY2UiLCJzY3JvbGxNYXJnaW5zIiwibWFyZ2lucyIsInRvcCIsImJvdHRvbSIsImRvbSIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImlubmVySGVpZ2h0IiwiZGVmYXVsdExpbmVIZWlnaHQiLCJjdXJzb3JCeVBhZ2UiLCJwYWdlIiwiZWZmZWN0Iiwic3RhcnRQb3MiLCJjb29yZHNBdFBvcyIsInNjcm9sbFJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzY3JvbGxUb3AiLCJzY3JvbGxCb3R0b20iLCJ5IiwieU1hcmdpbiIsImN1cnNvclBhZ2VVcCIsImN1cnNvclBhZ2VEb3duIiwibW92ZUJ5TGluZUJvdW5kYXJ5IiwibGluZUJsb2NrQXQiLCJzcGFjZSIsImN1cnNvckxpbmVCb3VuZGFyeUZvcndhcmQiLCJjdXJzb3JMaW5lQm91bmRhcnlCYWNrd2FyZCIsImN1cnNvckxpbmVCb3VuZGFyeUxlZnQiLCJjdXJzb3JMaW5lQm91bmRhcnlSaWdodCIsImN1cnNvckxpbmVTdGFydCIsImN1cnNvckxpbmVFbmQiLCJ0b01hdGNoaW5nQnJhY2tldCIsImV4dGVuZCIsImZvdW5kIiwibWF0Y2hpbmciLCJhbmNob3IiLCJjdXJzb3JNYXRjaGluZ0JyYWNrZXQiLCJzZWxlY3RNYXRjaGluZ0JyYWNrZXQiLCJleHRlbmRTZWwiLCJnb2FsQ29sdW1uIiwiYmlkaUxldmVsIiwic2VsZWN0QnlDaGFyIiwic2VsZWN0Q2hhckxlZnQiLCJzZWxlY3RDaGFyUmlnaHQiLCJzZWxlY3RDaGFyRm9yd2FyZCIsInNlbGVjdENoYXJCYWNrd2FyZCIsInNlbGVjdENoYXJGb3J3YXJkTG9naWNhbCIsInNlbGVjdENoYXJCYWNrd2FyZExvZ2ljYWwiLCJzZWxlY3RCeUdyb3VwIiwic2VsZWN0R3JvdXBMZWZ0Iiwic2VsZWN0R3JvdXBSaWdodCIsInNlbGVjdEdyb3VwRm9yd2FyZCIsInNlbGVjdEdyb3VwQmFja3dhcmQiLCJzZWxlY3RHcm91cEZvcndhcmRXaW4iLCJzZWxlY3RCeVN1YndvcmQiLCJzZWxlY3RTdWJ3b3JkRm9yd2FyZCIsInNlbGVjdFN1YndvcmRCYWNrd2FyZCIsInNlbGVjdFN5bnRheExlZnQiLCJzZWxlY3RTeW50YXhSaWdodCIsInNlbGVjdEJ5TGluZSIsInNlbGVjdExpbmVVcCIsInNlbGVjdExpbmVEb3duIiwic2VsZWN0QnlQYWdlIiwic2VsZWN0UGFnZVVwIiwic2VsZWN0UGFnZURvd24iLCJzZWxlY3RMaW5lQm91bmRhcnlGb3J3YXJkIiwic2VsZWN0TGluZUJvdW5kYXJ5QmFja3dhcmQiLCJzZWxlY3RMaW5lQm91bmRhcnlMZWZ0Iiwic2VsZWN0TGluZUJvdW5kYXJ5UmlnaHQiLCJzZWxlY3RMaW5lU3RhcnQiLCJzZWxlY3RMaW5lRW5kIiwiY3Vyc29yRG9jU3RhcnQiLCJjdXJzb3JEb2NFbmQiLCJzZWxlY3REb2NTdGFydCIsInNlbGVjdERvY0VuZCIsInNlbGVjdEFsbCIsInNlbGVjdExpbmUiLCJzZWxlY3RlZExpbmVCbG9ja3MiLCJzZWxlY3RQYXJlbnRTeW50YXgiLCJ0cmVlIiwic3RhY2siLCJyZXNvbHZlU3RhY2siLCJzdGFja0JlZm9yZSIsImN1ciIsInNpbXBsaWZ5U2VsZWN0aW9uIiwiZGVsZXRlQnkiLCJjaGFuZ2VCeVJhbmdlIiwidG93YXJkcyIsInNraXBBdG9taWMiLCJhbm5vdW5jZSIsInBocmFzZSIsImF0b21pY1JhbmdlcyIsImJldHdlZW4iLCJkZWxldGVCeUNoYXIiLCJieUluZGVudFVuaXQiLCJ0YXJnZXRQb3MiLCJjb2wiLCJ0YWJTaXplIiwiZHJvcCIsIm51bWJlciIsImRlbGV0ZUNoYXJCYWNrd2FyZCIsImRlbGV0ZUNoYXJCYWNrd2FyZFN0cmljdCIsImRlbGV0ZUNoYXJGb3J3YXJkIiwiZGVsZXRlQnlHcm91cCIsIm5leHRDaGFyIiwiZGVsZXRlR3JvdXBCYWNrd2FyZCIsImRlbGV0ZUdyb3VwRm9yd2FyZCIsImRlbGV0ZVRvTGluZUVuZCIsImxpbmVFbmQiLCJkZWxldGVUb0xpbmVTdGFydCIsImxpbmVTdGFydCIsImRlbGV0ZUxpbmVCb3VuZGFyeUJhY2t3YXJkIiwiZGVsZXRlTGluZUJvdW5kYXJ5Rm9yd2FyZCIsImRlbGV0ZVRyYWlsaW5nV2hpdGVzcGFjZSIsInByZXYiLCJpdGVyIiwibGluZUJyZWFrIiwidHJhaWxpbmciLCJzZWFyY2giLCJzcGxpdExpbmUiLCJ0cmFuc3Bvc2VDaGFycyIsImFwcGVuZCIsImJsb2NrcyIsInVwdG8iLCJzdGFydExpbmUiLCJlbmRMaW5lIiwibW92ZUxpbmUiLCJuZXh0TGluZSIsInNpemUiLCJtb3ZlTGluZVVwIiwibW92ZUxpbmVEb3duIiwiY29weUxpbmUiLCJjb3B5TGluZVVwIiwiY29weUxpbmVEb3duIiwiZGVsZXRlTGluZSIsImRpc3QiLCJsaW5lV3JhcHBpbmciLCJhc3NvYyIsImRvY3VtZW50VG9wIiwiaW5zZXJ0TmV3bGluZSIsInJlcGxhY2VTZWxlY3Rpb24iLCJpbnNlcnROZXdsaW5lS2VlcEluZGVudCIsImlzQmV0d2VlbkJyYWNrZXRzIiwiY29udGV4dCIsImluZGV4T2YiLCJuYW1lIiwiaW5zZXJ0TmV3bGluZUFuZEluZGVudCIsIm5ld2xpbmVBbmRJbmRlbnQiLCJpbnNlcnRCbGFua0xpbmUiLCJhdEVvZiIsImV4cGxvZGUiLCJjeCIsInNpbXVsYXRlQnJlYWsiLCJzaW11bGF0ZURvdWJsZUJyZWFrIiwibGluZUluZGVudCIsImNoYW5nZUJ5U2VsZWN0ZWRMaW5lIiwiYXRMaW5lIiwibWFwUG9zIiwiaW5kZW50U2VsZWN0aW9uIiwidXBkYXRlZCIsIk9iamVjdCIsIm92ZXJyaWRlSW5kZW50YXRpb24iLCJub3JtIiwiaW5kZW50TW9yZSIsImluZGVudExlc3MiLCJrZWVwIiwidG9nZ2xlVGFiRm9jdXNNb2RlIiwic2V0VGFiRm9jdXNNb2RlIiwidGVtcG9yYXJpbHlTZXRUYWJGb2N1c01vZGUiLCJpbnNlcnRUYWIiLCJlbWFjc1N0eWxlS2V5bWFwIiwic2hpZnQiLCJzdGFuZGFyZEtleW1hcCIsImRlZmF1bHRLZXltYXAiLCJpbmRlbnRXaXRoVGFiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/commands/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/language/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/language/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DocInput: () => (/* binding */ DocInput),\n/* harmony export */   HighlightStyle: () => (/* binding */ HighlightStyle),\n/* harmony export */   IndentContext: () => (/* binding */ IndentContext),\n/* harmony export */   LRLanguage: () => (/* binding */ LRLanguage),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   LanguageDescription: () => (/* binding */ LanguageDescription),\n/* harmony export */   LanguageSupport: () => (/* binding */ LanguageSupport),\n/* harmony export */   ParseContext: () => (/* binding */ ParseContext),\n/* harmony export */   StreamLanguage: () => (/* binding */ StreamLanguage),\n/* harmony export */   StringStream: () => (/* binding */ StringStream),\n/* harmony export */   TreeIndentContext: () => (/* binding */ TreeIndentContext),\n/* harmony export */   bidiIsolates: () => (/* binding */ bidiIsolates),\n/* harmony export */   bracketMatching: () => (/* binding */ bracketMatching),\n/* harmony export */   bracketMatchingHandle: () => (/* binding */ bracketMatchingHandle),\n/* harmony export */   codeFolding: () => (/* binding */ codeFolding),\n/* harmony export */   continuedIndent: () => (/* binding */ continuedIndent),\n/* harmony export */   defaultHighlightStyle: () => (/* binding */ defaultHighlightStyle),\n/* harmony export */   defineLanguageFacet: () => (/* binding */ defineLanguageFacet),\n/* harmony export */   delimitedIndent: () => (/* binding */ delimitedIndent),\n/* harmony export */   ensureSyntaxTree: () => (/* binding */ ensureSyntaxTree),\n/* harmony export */   flatIndent: () => (/* binding */ flatIndent),\n/* harmony export */   foldAll: () => (/* binding */ foldAll),\n/* harmony export */   foldCode: () => (/* binding */ foldCode),\n/* harmony export */   foldEffect: () => (/* binding */ foldEffect),\n/* harmony export */   foldGutter: () => (/* binding */ foldGutter),\n/* harmony export */   foldInside: () => (/* binding */ foldInside),\n/* harmony export */   foldKeymap: () => (/* binding */ foldKeymap),\n/* harmony export */   foldNodeProp: () => (/* binding */ foldNodeProp),\n/* harmony export */   foldService: () => (/* binding */ foldService),\n/* harmony export */   foldState: () => (/* binding */ foldState),\n/* harmony export */   foldable: () => (/* binding */ foldable),\n/* harmony export */   foldedRanges: () => (/* binding */ foldedRanges),\n/* harmony export */   forceParsing: () => (/* binding */ forceParsing),\n/* harmony export */   getIndentUnit: () => (/* binding */ getIndentUnit),\n/* harmony export */   getIndentation: () => (/* binding */ getIndentation),\n/* harmony export */   highlightingFor: () => (/* binding */ highlightingFor),\n/* harmony export */   indentNodeProp: () => (/* binding */ indentNodeProp),\n/* harmony export */   indentOnInput: () => (/* binding */ indentOnInput),\n/* harmony export */   indentRange: () => (/* binding */ indentRange),\n/* harmony export */   indentService: () => (/* binding */ indentService),\n/* harmony export */   indentString: () => (/* binding */ indentString),\n/* harmony export */   indentUnit: () => (/* binding */ indentUnit),\n/* harmony export */   language: () => (/* binding */ language),\n/* harmony export */   languageDataProp: () => (/* binding */ languageDataProp),\n/* harmony export */   matchBrackets: () => (/* binding */ matchBrackets),\n/* harmony export */   sublanguageProp: () => (/* binding */ sublanguageProp),\n/* harmony export */   syntaxHighlighting: () => (/* binding */ syntaxHighlighting),\n/* harmony export */   syntaxParserRunning: () => (/* binding */ syntaxParserRunning),\n/* harmony export */   syntaxTree: () => (/* binding */ syntaxTree),\n/* harmony export */   syntaxTreeAvailable: () => (/* binding */ syntaxTreeAvailable),\n/* harmony export */   toggleFold: () => (/* binding */ toggleFold),\n/* harmony export */   unfoldAll: () => (/* binding */ unfoldAll),\n/* harmony export */   unfoldCode: () => (/* binding */ unfoldCode),\n/* harmony export */   unfoldEffect: () => (/* binding */ unfoldEffect)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"(ssr)/./node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style-mod */ \"(ssr)/./node_modules/style-mod/src/style-mod.js\");\n\n\n\n\n\nvar _a;\n/**\nNode prop stored in a parser's top syntax node to provide the\nfacet that stores language-specific data for that language.\n*/ const languageDataProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nHelper function to define a facet (to be added to the top syntax\nnode(s) for a language via\n[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be\nused to associate language data with the language. You\nprobably only need this when subclassing\n[`Language`](https://codemirror.net/6/docs/ref/#language.Language).\n*/ function defineLanguageFacet(baseData) {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n        combine: baseData ? (values)=>values.concat(baseData) : undefined\n    });\n}\n/**\nSyntax node prop used to register sublanguages. Should be added to\nthe top level node type for the language.\n*/ const sublanguageProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nA language object manages parsing and per-language\n[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is\nmanaged as a [Lezer](https://lezer.codemirror.net) tree. The class\ncan be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)\nsubclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or\nvia the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass\nfor stream parsers.\n*/ class Language {\n    /**\n    Construct a language object. If you need to invoke this\n    directly, first define a data facet with\n    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then\n    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it\n    to the language's outer syntax node.\n    */ constructor(/**\n    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet\n    used for this language.\n    */ data, parser, extraExtensions = [], /**\n    A language name.\n    */ name = \"\"){\n        this.data = data;\n        this.name = name;\n        // Kludge to define EditorState.tree as a debugging helper,\n        // without the EditorState package actually knowing about\n        // languages and lezer trees.\n        if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype.hasOwnProperty(\"tree\")) Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype, \"tree\", {\n            get () {\n                return syntaxTree(this);\n            }\n        });\n        this.parser = parser;\n        this.extension = [\n            language.of(this),\n            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.languageData.of((state, pos, side)=>{\n                let top = topNodeAt(state, pos, side), data = top.type.prop(languageDataProp);\n                if (!data) return [];\n                let base = state.facet(data), sub = top.type.prop(sublanguageProp);\n                if (sub) {\n                    let innerNode = top.resolve(pos - top.from, side);\n                    for (let sublang of sub)if (sublang.test(innerNode, state)) {\n                        let data = state.facet(sublang.facet);\n                        return sublang.type == \"replace\" ? data : data.concat(base);\n                    }\n                }\n                return base;\n            })\n        ].concat(extraExtensions);\n    }\n    /**\n    Query whether this language is active at the given position.\n    */ isActiveAt(state, pos, side = -1) {\n        return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;\n    }\n    /**\n    Find the document regions that were parsed using this language.\n    The returned regions will _include_ any nested languages rooted\n    in this language, when those exist.\n    */ findRegions(state) {\n        let lang = state.facet(language);\n        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [\n            {\n                from: 0,\n                to: state.doc.length\n            }\n        ];\n        if (!lang || !lang.allowsNesting) return [];\n        let result = [];\n        let explore = (tree, from)=>{\n            if (tree.prop(languageDataProp) == this.data) {\n                result.push({\n                    from,\n                    to: from + tree.length\n                });\n                return;\n            }\n            let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n            if (mount) {\n                if (mount.tree.prop(languageDataProp) == this.data) {\n                    if (mount.overlay) for (let r of mount.overlay)result.push({\n                        from: r.from + from,\n                        to: r.to + from\n                    });\n                    else result.push({\n                        from: from,\n                        to: from + tree.length\n                    });\n                    return;\n                } else if (mount.overlay) {\n                    let size = result.length;\n                    explore(mount.tree, mount.overlay[0].from + from);\n                    if (result.length > size) return;\n                }\n            }\n            for(let i = 0; i < tree.children.length; i++){\n                let ch = tree.children[i];\n                if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) explore(ch, tree.positions[i] + from);\n            }\n        };\n        explore(syntaxTree(state), 0);\n        return result;\n    }\n    /**\n    Indicates whether this language allows nested languages. The\n    default implementation returns true.\n    */ get allowsNesting() {\n        return true;\n    }\n}\n/**\n@internal\n*/ Language.setState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\nfunction topNodeAt(state, pos, side) {\n    let topLang = state.facet(language), tree = syntaxTree(state).topNode;\n    if (!topLang || topLang.allowsNesting) {\n        for(let node = tree; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.ExcludeBuffers))if (node.type.isTop) tree = node;\n    }\n    return tree;\n}\n/**\nA subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer\n[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)\nparsers.\n*/ class LRLanguage extends Language {\n    constructor(data, parser, name){\n        super(data, parser, [], name);\n        this.parser = parser;\n    }\n    /**\n    Define a language from a parser.\n    */ static define(spec) {\n        let data = defineLanguageFacet(spec.languageData);\n        return new LRLanguage(data, spec.parser.configure({\n            props: [\n                languageDataProp.add((type)=>type.isTop ? data : undefined)\n            ]\n        }), spec.name);\n    }\n    /**\n    Create a new instance of this language with a reconfigured\n    version of its parser and optionally a new name.\n    */ configure(options, name) {\n        return new LRLanguage(this.data, this.parser.configure(options), name || this.name);\n    }\n    get allowsNesting() {\n        return this.parser.hasWrappers();\n    }\n}\n/**\nGet the syntax tree for a state, which is the current (possibly\nincomplete) parse tree of the active\n[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no\nlanguage available.\n*/ function syntaxTree(state) {\n    let field = state.field(Language.state, false);\n    return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n}\n/**\nTry to get a parse tree that spans at least up to `upto`. The\nmethod will do at most `timeout` milliseconds of work to parse\nup to that point if the tree isn't already available.\n*/ function ensureSyntaxTree(state, upto, timeout = 50) {\n    var _a;\n    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n    if (!parse) return null;\n    let oldVieport = parse.viewport;\n    parse.updateViewport({\n        from: 0,\n        to: upto\n    });\n    let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;\n    parse.updateViewport(oldVieport);\n    return result;\n}\n/**\nQueries whether there is a full syntax tree available up to the\ngiven document position. If there isn't, the background parse\nprocess _might_ still be working and update the tree further, but\nthere is no guarantee of that—the parser will [stop\nworking](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a\ncertain amount of time or has moved beyond the visible viewport.\nAlways returns false if no language has been enabled.\n*/ function syntaxTreeAvailable(state, upto = state.doc.length) {\n    var _a;\n    return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;\n}\n/**\nMove parsing forward, and update the editor state afterwards to\nreflect the new tree. Will work for at most `timeout`\nmilliseconds. Returns true if the parser managed get to the given\nposition in that time.\n*/ function forceParsing(view, upto = view.viewport.to, timeout = 100) {\n    let success = ensureSyntaxTree(view.state, upto, timeout);\n    if (success != syntaxTree(view.state)) view.dispatch({});\n    return !!success;\n}\n/**\nTells you whether the language parser is planning to do more\nparsing work (in a `requestIdleCallback` pseudo-thread) or has\nstopped running, either because it parsed the entire document,\nbecause it spent too much time and was cut off, or because there\nis no language parser enabled.\n*/ function syntaxParserRunning(view) {\n    var _a;\n    return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;\n}\n/**\nLezer-style\n[`Input`](https://lezer.codemirror.net/docs/ref#common.Input)\nobject for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.\n*/ class DocInput {\n    /**\n    Create an input object for the given document.\n    */ constructor(doc){\n        this.doc = doc;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.cursor = doc.iter();\n    }\n    get length() {\n        return this.doc.length;\n    }\n    syncTo(pos) {\n        this.string = this.cursor.next(pos - this.cursorPos).value;\n        this.cursorPos = pos + this.string.length;\n        return this.cursorPos - this.string.length;\n    }\n    chunk(pos) {\n        this.syncTo(pos);\n        return this.string;\n    }\n    get lineChunks() {\n        return true;\n    }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);\n        else return this.string.slice(from - stringStart, to - stringStart);\n    }\n}\nlet currentContext = null;\n/**\nA parse context provided to parsers working on the editor content.\n*/ class ParseContext {\n    constructor(parser, /**\n    The current editor state.\n    */ state, /**\n    Tree fragments that can be reused by incremental re-parses.\n    */ fragments = [], /**\n    @internal\n    */ tree, /**\n    @internal\n    */ treeLen, /**\n    The current editor viewport (or some overapproximation\n    thereof). Intended to be used for opportunistically avoiding\n    work (in which case\n    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)\n    should be called to make sure the parser is restarted when the\n    skipped region becomes visible).\n    */ viewport, /**\n    @internal\n    */ skipped, /**\n    This is where skipping parsers can register a promise that,\n    when resolved, will schedule a new parse. It is cleared when\n    the parse worker picks up the promise. @internal\n    */ scheduleOn){\n        this.parser = parser;\n        this.state = state;\n        this.fragments = fragments;\n        this.tree = tree;\n        this.treeLen = treeLen;\n        this.viewport = viewport;\n        this.skipped = skipped;\n        this.scheduleOn = scheduleOn;\n        this.parse = null;\n        /**\n        @internal\n        */ this.tempSkipped = [];\n    }\n    /**\n    @internal\n    */ static create(parser, state, viewport) {\n        return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty, 0, viewport, [], null);\n    }\n    startParse() {\n        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);\n    }\n    /**\n    @internal\n    */ work(until, upto) {\n        if (upto != null && upto >= this.state.doc.length) upto = undefined;\n        if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {\n            this.takeTree();\n            return true;\n        }\n        return this.withContext(()=>{\n            var _a;\n            if (typeof until == \"number\") {\n                let endTime = Date.now() + until;\n                until = ()=>Date.now() > endTime;\n            }\n            if (!this.parse) this.parse = this.startParse();\n            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);\n            for(;;){\n                let done = this.parse.advance();\n                if (done) {\n                    this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));\n                    this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;\n                    this.tree = done;\n                    this.parse = null;\n                    if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length)) this.parse = this.startParse();\n                    else return true;\n                }\n                if (until()) return false;\n            }\n        });\n    }\n    /**\n    @internal\n    */ takeTree() {\n        let pos, tree;\n        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {\n            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);\n            this.withContext(()=>{\n                while(!(tree = this.parse.advance())){}\n            });\n            this.treeLen = pos;\n            this.tree = tree;\n            this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(this.tree, this.fragments, true));\n            this.parse = null;\n        }\n    }\n    withContext(f) {\n        let prev = currentContext;\n        currentContext = this;\n        try {\n            return f();\n        } finally{\n            currentContext = prev;\n        }\n    }\n    withoutTempSkipped(fragments) {\n        for(let r; r = this.tempSkipped.pop();)fragments = cutFragments(fragments, r.from, r.to);\n        return fragments;\n    }\n    /**\n    @internal\n    */ changes(changes, newState) {\n        let { fragments, tree, treeLen, viewport, skipped } = this;\n        this.takeTree();\n        if (!changes.empty) {\n            let ranges = [];\n            changes.iterChangedRanges((fromA, toA, fromB, toB)=>ranges.push({\n                    fromA,\n                    toA,\n                    fromB,\n                    toB\n                }));\n            fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, ranges);\n            tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n            treeLen = 0;\n            viewport = {\n                from: changes.mapPos(viewport.from, -1),\n                to: changes.mapPos(viewport.to, 1)\n            };\n            if (this.skipped.length) {\n                skipped = [];\n                for (let r of this.skipped){\n                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);\n                    if (from < to) skipped.push({\n                        from,\n                        to\n                    });\n                }\n            }\n        }\n        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);\n    }\n    /**\n    @internal\n    */ updateViewport(viewport) {\n        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;\n        this.viewport = viewport;\n        let startLen = this.skipped.length;\n        for(let i = 0; i < this.skipped.length; i++){\n            let { from, to } = this.skipped[i];\n            if (from < viewport.to && to > viewport.from) {\n                this.fragments = cutFragments(this.fragments, from, to);\n                this.skipped.splice(i--, 1);\n            }\n        }\n        if (this.skipped.length >= startLen) return false;\n        this.reset();\n        return true;\n    }\n    /**\n    @internal\n    */ reset() {\n        if (this.parse) {\n            this.takeTree();\n            this.parse = null;\n        }\n    }\n    /**\n    Notify the parse scheduler that the given region was skipped\n    because it wasn't in view, and the parse should be restarted\n    when it comes into view.\n    */ skipUntilInView(from, to) {\n        this.skipped.push({\n            from,\n            to\n        });\n    }\n    /**\n    Returns a parser intended to be used as placeholder when\n    asynchronously loading a nested parser. It'll skip its input and\n    mark it as not-really-parsed, so that the next update will parse\n    it again.\n    \n    When `until` is given, a reparse will be scheduled when that\n    promise resolves.\n    */ static getSkippingParser(until) {\n        return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                let from = ranges[0].from, to = ranges[ranges.length - 1].to;\n                let parser = {\n                    parsedPos: from,\n                    advance () {\n                        let cx = currentContext;\n                        if (cx) {\n                            for (let r of ranges)cx.tempSkipped.push(r);\n                            if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([\n                                cx.scheduleOn,\n                                until\n                            ]) : until;\n                        }\n                        this.parsedPos = to;\n                        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], to - from);\n                    },\n                    stoppedAt: null,\n                    stopAt () {}\n                };\n                return parser;\n            }\n        };\n    }\n    /**\n    @internal\n    */ isDone(upto) {\n        upto = Math.min(upto, this.state.doc.length);\n        let frags = this.fragments;\n        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;\n    }\n    /**\n    Get the context for the current parse, or `null` if no editor\n    parse is in progress.\n    */ static get() {\n        return currentContext;\n    }\n}\nfunction cutFragments(fragments, from, to) {\n    return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, [\n        {\n            fromA: from,\n            toA: to,\n            fromB: from,\n            toB: to\n        }\n    ]);\n}\nclass LanguageState {\n    constructor(// A mutable parse state that is used to preserve work done during\n    // the lifetime of a state when moving to the next state.\n    context){\n        this.context = context;\n        this.tree = context.tree;\n    }\n    apply(tr) {\n        if (!tr.docChanged && this.tree == this.context.tree) return this;\n        let newCx = this.context.changes(tr.changes, tr.state);\n        // If the previous parse wasn't done, go forward only up to its\n        // end position or the end of the viewport, to avoid slowing down\n        // state updates with parse work beyond the viewport.\n        let upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);\n        if (!newCx.work(20 /* Work.Apply */ , upto)) newCx.takeTree();\n        return new LanguageState(newCx);\n    }\n    static init(state) {\n        let vpTo = Math.min(3000 /* Work.InitViewport */ , state.doc.length);\n        let parseState = ParseContext.create(state.facet(language).parser, state, {\n            from: 0,\n            to: vpTo\n        });\n        if (!parseState.work(20 /* Work.Apply */ , vpTo)) parseState.takeTree();\n        return new LanguageState(parseState);\n    }\n}\nLanguage.state = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create: LanguageState.init,\n    update (value, tr) {\n        for (let e of tr.effects)if (e.is(Language.setState)) return e.value;\n        if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);\n        return value.apply(tr);\n    }\n});\nlet requestIdle = (callback)=>{\n    let timeout = setTimeout(()=>callback(), 500 /* Work.MaxPause */ );\n    return ()=>clearTimeout(timeout);\n};\nif (typeof requestIdleCallback != \"undefined\") requestIdle = (callback)=>{\n    let idle = -1, timeout = setTimeout(()=>{\n        idle = requestIdleCallback(callback, {\n            timeout: 500 /* Work.MaxPause */  - 100 /* Work.MinPause */ \n        });\n    }, 100 /* Work.MinPause */ );\n    return ()=>idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);\n};\nconst isInputPending = typeof navigator != \"undefined\" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? ()=>navigator.scheduling.isInputPending() : null;\nconst parseWorker = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class ParseWorker {\n    constructor(view){\n        this.view = view;\n        this.working = null;\n        this.workScheduled = 0;\n        // End of the current time chunk\n        this.chunkEnd = -1;\n        // Milliseconds of budget left for this chunk\n        this.chunkBudget = -1;\n        this.work = this.work.bind(this);\n        this.scheduleWork();\n    }\n    update(update) {\n        let cx = this.view.state.field(Language.state).context;\n        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();\n        if (update.docChanged || update.selectionSet) {\n            if (this.view.hasFocus) this.chunkBudget += 50 /* Work.ChangeBonus */ ;\n            this.scheduleWork();\n        }\n        this.checkAsyncSchedule(cx);\n    }\n    scheduleWork() {\n        if (this.working) return;\n        let { state } = this.view, field = state.field(Language.state);\n        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work);\n    }\n    work(deadline) {\n        this.working = null;\n        let now = Date.now();\n        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {\n            this.chunkEnd = now + 30000 /* Work.ChunkTime */ ;\n            this.chunkBudget = 3000 /* Work.ChunkBudget */ ;\n        }\n        if (this.chunkBudget <= 0) return; // No more budget\n        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);\n        if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */ )) return;\n        let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Work.Slice */ , deadline && !isInputPending ? Math.max(25 /* Work.MinSlice */ , deadline.timeRemaining() - 5) : 1e9);\n        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;\n        let done = field.context.work(()=>{\n            return isInputPending && isInputPending() || Date.now() > endTime;\n        }, vpTo + (viewportFirst ? 0 : 100000 /* Work.MaxParseAhead */ ));\n        this.chunkBudget -= Date.now() - now;\n        if (done || this.chunkBudget <= 0) {\n            field.context.takeTree();\n            this.view.dispatch({\n                effects: Language.setState.of(new LanguageState(field.context))\n            });\n        }\n        if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();\n        this.checkAsyncSchedule(field.context);\n    }\n    checkAsyncSchedule(cx) {\n        if (cx.scheduleOn) {\n            this.workScheduled++;\n            cx.scheduleOn.then(()=>this.scheduleWork()).catch((err)=>(0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.logException)(this.view.state, err)).then(()=>this.workScheduled--);\n            cx.scheduleOn = null;\n        }\n    }\n    destroy() {\n        if (this.working) this.working();\n    }\n    isWorking() {\n        return !!(this.working || this.workScheduled > 0);\n    }\n}, {\n    eventHandlers: {\n        focus () {\n            this.scheduleWork();\n        }\n    }\n});\n/**\nThe facet used to associate a language with an editor state. Used\nby `Language` object's `extension` property (so you don't need to\nmanually wrap your languages in this). Can be used to access the\ncurrent language on a state.\n*/ const language = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (languages) {\n        return languages.length ? languages[0] : null;\n    },\n    enables: (language)=>[\n            Language.state,\n            parseWorker,\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.contentAttributes.compute([\n                language\n            ], (state)=>{\n                let lang = state.facet(language);\n                return lang && lang.name ? {\n                    \"data-language\": lang.name\n                } : {};\n            })\n        ]\n});\n/**\nThis class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an\noptional set of supporting extensions. Language packages are\nencouraged to export a function that optionally takes a\nconfiguration object and returns a `LanguageSupport` instance, as\nthe main way for client code to use the package.\n*/ class LanguageSupport {\n    /**\n    Create a language support object.\n    */ constructor(/**\n    The language object.\n    */ language, /**\n    An optional set of supporting extensions. When nesting a\n    language in another language, the outer language is encouraged\n    to include the supporting extensions for its inner languages\n    in its own set of support extensions.\n    */ support = []){\n        this.language = language;\n        this.support = support;\n        this.extension = [\n            language,\n            support\n        ];\n    }\n}\n/**\nLanguage descriptions are used to store metadata about languages\nand to dynamically load them. Their main role is finding the\nappropriate language for a filename or dynamically loading nested\nparsers.\n*/ class LanguageDescription {\n    constructor(/**\n    The name of this language.\n    */ name, /**\n    Alternative names for the mode (lowercased, includes `this.name`).\n    */ alias, /**\n    File extensions associated with this language.\n    */ extensions, /**\n    Optional filename pattern that should be associated with this\n    language.\n    */ filename, loadFunc, /**\n    If the language has been loaded, this will hold its value.\n    */ support = undefined){\n        this.name = name;\n        this.alias = alias;\n        this.extensions = extensions;\n        this.filename = filename;\n        this.loadFunc = loadFunc;\n        this.support = support;\n        this.loading = null;\n    }\n    /**\n    Start loading the the language. Will return a promise that\n    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)\n    object when the language successfully loads.\n    */ load() {\n        return this.loading || (this.loading = this.loadFunc().then((support)=>this.support = support, (err)=>{\n            this.loading = null;\n            throw err;\n        }));\n    }\n    /**\n    Create a language description.\n    */ static of(spec) {\n        let { load, support } = spec;\n        if (!load) {\n            if (!support) throw new RangeError(\"Must pass either 'load' or 'support' to LanguageDescription.of\");\n            load = ()=>Promise.resolve(support);\n        }\n        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map((s)=>s.toLowerCase()), spec.extensions || [], spec.filename, load, support);\n    }\n    /**\n    Look for a language in the given array of descriptions that\n    matches the filename. Will first match\n    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,\n    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),\n    and return the first language that matches.\n    */ static matchFilename(descs, filename) {\n        for (let d of descs)if (d.filename && d.filename.test(filename)) return d;\n        let ext = /\\.([^.]+)$/.exec(filename);\n        if (ext) {\n            for (let d of descs)if (d.extensions.indexOf(ext[1]) > -1) return d;\n        }\n        return null;\n    }\n    /**\n    Look for a language whose name or alias matches the the given\n    name (case-insensitively). If `fuzzy` is true, and no direct\n    matchs is found, this'll also search for a language whose name\n    or alias occurs in the string (for names shorter than three\n    characters, only when surrounded by non-word characters).\n    */ static matchLanguageName(descs, name, fuzzy = true) {\n        name = name.toLowerCase();\n        for (let d of descs)if (d.alias.some((a)=>a == name)) return d;\n        if (fuzzy) for (let d of descs)for (let a of d.alias){\n            let found = name.indexOf(a);\n            if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length]))) return d;\n        }\n        return null;\n    }\n}\n/**\nFacet that defines a way to provide a function that computes the\nappropriate indentation depth, as a column number (see\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given\nline. A return value of `null` indicates no indentation can be\ndetermined, and the line should inherit the indentation of the one\nabove it. A return value of `undefined` defers to the next indent\nservice.\n*/ const indentService = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nFacet for overriding the unit by which indentation happens. Should\nbe a string consisting either entirely of the same whitespace\ncharacter. When not set, this defaults to 2 spaces.\n*/ const indentUnit = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>{\n        if (!values.length) return \"  \";\n        let unit = values[0];\n        if (!unit || /\\S/.test(unit) || Array.from(unit).some((e)=>e != unit[0])) throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n        return unit;\n    }\n});\n/**\nReturn the _column width_ of an indent unit in the state.\nDetermined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)\nfacet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that\ncontains tabs.\n*/ function getIndentUnit(state) {\n    let unit = state.facet(indentUnit);\n    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/**\nCreate an indentation string that covers columns 0 to `cols`.\nWill use tabs for as much of the columns as possible when the\n[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains\ntabs.\n*/ function indentString(state, cols) {\n    let result = \"\", ts = state.tabSize, ch = state.facet(indentUnit)[0];\n    if (ch == \"\t\") {\n        while(cols >= ts){\n            result += \"\t\";\n            cols -= ts;\n        }\n        ch = \" \";\n    }\n    for(let i = 0; i < cols; i++)result += ch;\n    return result;\n}\n/**\nGet the indentation, as a column number, at the given position.\nWill first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)\nthat are registered, and if none of those return an indentation,\nthis will check the syntax tree for the [indent node\nprop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a\nnumber when an indentation could be determined, and null\notherwise.\n*/ function getIndentation(context, pos) {\n    if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState) context = new IndentContext(context);\n    for (let service of context.state.facet(indentService)){\n        let result = service(context, pos);\n        if (result !== undefined) return result;\n    }\n    let tree = syntaxTree(context.state);\n    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;\n}\n/**\nCreate a change set that auto-indents all lines touched by the\ngiven document range.\n*/ function indentRange(state, from, to) {\n    let updated = Object.create(null);\n    let context = new IndentContext(state, {\n        overrideIndentation: (start)=>{\n            var _a;\n            return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1;\n        }\n    });\n    let changes = [];\n    for(let pos = from; pos <= to;){\n        let line = state.doc.lineAt(pos);\n        pos = line.to + 1;\n        let indent = getIndentation(context, line.from);\n        if (indent == null) continue;\n        if (!/\\S/.test(line.text)) indent = 0;\n        let cur = /^\\s*/.exec(line.text)[0];\n        let norm = indentString(state, indent);\n        if (cur != norm) {\n            updated[line.from] = indent;\n            changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n    }\n    return state.changes(changes);\n}\n/**\nIndentation contexts are used when calling [indentation\nservices](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities\nuseful in indentation logic, and can selectively override the\nindentation reported for some lines.\n*/ class IndentContext {\n    /**\n    Create an indent context.\n    */ constructor(/**\n    The editor state.\n    */ state, /**\n    @internal\n    */ options = {}){\n        this.state = state;\n        this.options = options;\n        this.unit = getIndentUnit(state);\n    }\n    /**\n    Get a description of the line at the given position, taking\n    [simulated line\n    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    into account. If there is such a break at `pos`, the `bias`\n    argument determines whether the part of the line line before or\n    after the break is used.\n    */ lineAt(pos, bias = 1) {\n        let line = this.state.doc.lineAt(pos);\n        let { simulateBreak, simulateDoubleBreak } = this.options;\n        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {\n            if (simulateDoubleBreak && simulateBreak == pos) return {\n                text: \"\",\n                from: pos\n            };\n            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {\n                text: line.text.slice(simulateBreak - line.from),\n                from: simulateBreak\n            };\n            else return {\n                text: line.text.slice(0, simulateBreak - line.from),\n                from: line.from\n            };\n        }\n        return line;\n    }\n    /**\n    Get the text directly after `pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */ textAfterPos(pos, bias = 1) {\n        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return \"\";\n        let { text, from } = this.lineAt(pos, bias);\n        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));\n    }\n    /**\n    Find the column for the given position.\n    */ column(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let result = this.countColumn(text, pos - from);\n        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;\n        if (override > -1) result += override - this.countColumn(text, text.search(/\\S|$/));\n        return result;\n    }\n    /**\n    Find the column position (taking tabs into account) of the given\n    position in the given string.\n    */ countColumn(line, pos = line.length) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line, this.state.tabSize, pos);\n    }\n    /**\n    Find the indentation column of the line at the given point.\n    */ lineIndent(pos, bias = 1) {\n        let { text, from } = this.lineAt(pos, bias);\n        let override = this.options.overrideIndentation;\n        if (override) {\n            let overriden = override(from);\n            if (overriden > -1) return overriden;\n        }\n        return this.countColumn(text, text.search(/\\S|$/));\n    }\n    /**\n    Returns the [simulated line\n    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n    for this context, if any.\n    */ get simulatedBreak() {\n        return this.options.simulateBreak || null;\n    }\n}\n/**\nA syntax tree node prop used to associate indentation strategies\nwith node types. Such a strategy is a function from an indentation\ncontext to a column number (see also\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null\nindicates that no definitive indentation can be determined.\n*/ const indentNodeProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n// Compute the indentation for a given position from the syntax tree.\nfunction syntaxIndentation(cx, ast, pos) {\n    let stack = ast.resolveStack(pos);\n    let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);\n    if (inner != stack.node) {\n        let add = [];\n        for(let cur = inner; cur && !(cur.from == stack.node.from && cur.type == stack.node.type); cur = cur.parent)add.push(cur);\n        for(let i = add.length - 1; i >= 0; i--)stack = {\n            node: add[i],\n            next: stack\n        };\n    }\n    return indentFor(stack, cx, pos);\n}\nfunction indentFor(stack, cx, pos) {\n    for(let cur = stack; cur; cur = cur.next){\n        let strategy = indentStrategy(cur.node);\n        if (strategy) return strategy(TreeIndentContext.create(cx, pos, cur));\n    }\n    return 0;\n}\nfunction ignoreClosed(cx) {\n    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;\n}\nfunction indentStrategy(tree) {\n    let strategy = tree.type.prop(indentNodeProp);\n    if (strategy) return strategy;\n    let first = tree.firstChild, close;\n    if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy))) {\n        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;\n        return (cx)=>delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n    }\n    return tree.parent == null ? topIndent : null;\n}\nfunction topIndent() {\n    return 0;\n}\n/**\nObjects of this type provide context information and helper\nmethods to indentation functions registered on syntax nodes.\n*/ class TreeIndentContext extends IndentContext {\n    constructor(base, /**\n    The position at which indentation is being computed.\n    */ pos, /**\n    @internal\n    */ context){\n        super(base.state, base.options);\n        this.base = base;\n        this.pos = pos;\n        this.context = context;\n    }\n    /**\n    The syntax tree node to which the indentation strategy\n    applies.\n    */ get node() {\n        return this.context.node;\n    }\n    /**\n    @internal\n    */ static create(base, pos, context) {\n        return new TreeIndentContext(base, pos, context);\n    }\n    /**\n    Get the text directly after `this.pos`, either the entire line\n    or the next 100 characters, whichever is shorter.\n    */ get textAfter() {\n        return this.textAfterPos(this.pos);\n    }\n    /**\n    Get the indentation at the reference line for `this.node`, which\n    is the line on which it starts, unless there is a node that is\n    _not_ a parent of this node covering the start of that line. If\n    so, the line at the start of that node is tried, again skipping\n    on if it is covered by another such node.\n    */ get baseIndent() {\n        return this.baseIndentFor(this.node);\n    }\n    /**\n    Get the indentation for the reference line of the given node\n    (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).\n    */ baseIndentFor(node) {\n        let line = this.state.doc.lineAt(node.from);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for(;;){\n            let atBreak = node.resolve(line.from);\n            while(atBreak.parent && atBreak.parent.from == atBreak.from)atBreak = atBreak.parent;\n            if (isParent(atBreak, node)) break;\n            line = this.state.doc.lineAt(atBreak.from);\n        }\n        return this.lineIndent(line.from);\n    }\n    /**\n    Continue looking for indentations in the node's parent nodes,\n    and return the result of that.\n    */ continue() {\n        return indentFor(this.context.next, this.base, this.pos);\n    }\n}\nfunction isParent(parent, of) {\n    for(let cur = of; cur; cur = cur.parent)if (parent == cur) return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.from), last = tree.lastChild;\n    if (!openToken) return null;\n    let sim = context.options.simulateBreak;\n    let openLine = context.state.doc.lineAt(openToken.from);\n    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n    for(let pos = openToken.to;;){\n        let next = tree.childAfter(pos);\n        if (!next || next == last) return null;\n        if (!next.type.isSkipped) {\n            if (next.from >= lineEnd) return null;\n            let space = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;\n            return {\n                from: openToken.from,\n                to: openToken.to + space\n            };\n        }\n        pos = next.to;\n    }\n}\n/**\nAn indentation strategy for delimited (usually bracketed) nodes.\nWill, by default, indent one unit more than the parent's base\nindent unless the line starts with a closing token. When `align`\nis true and there are non-skipped nodes on the node's opening\nline, the content of the node will be aligned with the end of the\nopening node, like this:\n\n    foo(bar,\n        baz)\n*/ function delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context)=>delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n    let after = context.textAfter, space = after.match(/^\\s*/)[0].length;\n    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n    let aligned = align ? bracketedAligned(context) : null;\n    if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);\n    return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/**\nAn indentation strategy that aligns a node's content to its base\nindentation.\n*/ const flatIndent = (context)=>context.baseIndent;\n/**\nCreates an indentation strategy that, by default, indents\ncontinued lines one unit more than the node's base indentation.\nYou can provide `except` to prevent indentation of lines that\nmatch a pattern (for example `/^else\\b/` in `if`/`else`\nconstructs), and you can change the amount of units used with the\n`units` option.\n*/ function continuedIndent({ except, units = 1 } = {}) {\n    return (context)=>{\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\nconst DontIndentBeyond = 200;\n/**\nEnables reindentation on input. When a language defines an\n`indentOnInput` field in its [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular\nexpression, the line at the cursor will be reindented whenever new\ntext is typed and the input from the start of the line up to the\ncursor matches that regexp.\n\nTo avoid unneccesary reindents, it is recommended to start the\nregexp with `^` (usually followed by `\\s*`), and end it with `$`.\nFor example, `/^\\s*\\}$/` will reindent when a closing brace is\nadded at the start of a line.\n*/ function indentOnInput() {\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.transactionFilter.of((tr)=>{\n        if (!tr.docChanged || !tr.isUserEvent(\"input.type\") && !tr.isUserEvent(\"input.complete\")) return tr;\n        let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n        if (!rules.length) return tr;\n        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);\n        if (head > line.from + DontIndentBeyond) return tr;\n        let lineStart = doc.sliceString(line.from, head);\n        if (!rules.some((r)=>r.test(lineStart))) return tr;\n        let { state } = tr, last = -1, changes = [];\n        for (let { head } of state.selection.ranges){\n            let line = state.doc.lineAt(head);\n            if (line.from == last) continue;\n            last = line.from;\n            let indent = getIndentation(state, line.from);\n            if (indent == null) continue;\n            let cur = /^\\s*/.exec(line.text)[0];\n            let norm = indentString(state, indent);\n            if (cur != norm) changes.push({\n                from: line.from,\n                to: line.from + cur.length,\n                insert: norm\n            });\n        }\n        return changes.length ? [\n            tr,\n            {\n                changes,\n                sequential: true\n            }\n        ] : tr;\n    });\n}\n/**\nA facet that registers a code folding service. When called with\nthe extent of a line, such a function should return a foldable\nrange that starts on that line (but continues beyond it), if one\ncan be found.\n*/ const foldService = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nThis node prop is used to associate folding information with\nsyntax node types. Given a syntax node, it should check whether\nthat tree is foldable and return the range that can be collapsed\nwhen it is.\n*/ const foldNodeProp = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\n[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but\nthe first and the last child of a syntax node. Useful for nodes\nthat start and end with delimiters.\n*/ function foldInside(node) {\n    let first = node.firstChild, last = node.lastChild;\n    return first && first.to < last.from ? {\n        from: first.to,\n        to: last.type.isError ? node.to : last.from\n    } : null;\n}\nfunction syntaxFolding(state, start, end) {\n    let tree = syntaxTree(state);\n    if (tree.length < end) return null;\n    let stack = tree.resolveStack(end, 1);\n    let found = null;\n    for(let iter = stack; iter; iter = iter.next){\n        let cur = iter.node;\n        if (cur.to <= end || cur.from > end) continue;\n        if (found && cur.from < start) break;\n        let prop = cur.type.prop(foldNodeProp);\n        if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {\n            let value = prop(cur, state);\n            if (value && value.from <= end && value.from >= start && value.to > end) found = value;\n        }\n    }\n    return found;\n}\nfunction isUnfinished(node) {\n    let ch = node.lastChild;\n    return ch && ch.to == node.to && ch.type.isError;\n}\n/**\nCheck whether the given line is foldable. First asks any fold\nservices registered through\n[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return\na result, tries to query the [fold node\nprop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end\nof the line.\n*/ function foldable(state, lineStart, lineEnd) {\n    for (let service of state.facet(foldService)){\n        let result = service(state, lineStart, lineEnd);\n        if (result) return result;\n    }\n    return syntaxFolding(state, lineStart, lineEnd);\n}\nfunction mapRange(range, mapping) {\n    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);\n    return from >= to ? undefined : {\n        from,\n        to\n    };\n}\n/**\nState effect that can be attached to a transaction to fold the\ngiven range. (You probably only need this in exceptional\ncircumstances—usually you'll just want to let\n[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold\ngutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)\n*/ const foldEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map: mapRange\n});\n/**\nState effect that unfolds the given range (if it was folded).\n*/ const unfoldEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n    map: mapRange\n});\nfunction selectedLines(view) {\n    let lines = [];\n    for (let { head } of view.state.selection.ranges){\n        if (lines.some((l)=>l.from <= head && l.to >= head)) continue;\n        lines.push(view.lineBlockAt(head));\n    }\n    return lines;\n}\n/**\nThe state field that stores the folded ranges (as a [decoration\nset](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to\n[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and\n[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold\nstate.\n*/ const foldState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    },\n    update (folded, tr) {\n        folded = folded.map(tr.changes);\n        for (let e of tr.effects){\n            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {\n                let { preparePlaceholder } = tr.state.facet(foldConfig);\n                let widget = !preparePlaceholder ? foldWidget : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n                    widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value))\n                });\n                folded = folded.update({\n                    add: [\n                        widget.range(e.value.from, e.value.to)\n                    ]\n                });\n            } else if (e.is(unfoldEffect)) {\n                folded = folded.update({\n                    filter: (from, to)=>e.value.from != from || e.value.to != to,\n                    filterFrom: e.value.from,\n                    filterTo: e.value.to\n                });\n            }\n        }\n        // Clear folded ranges that cover the selection head\n        if (tr.selection) {\n            let onSelection = false, { head } = tr.selection.main;\n            folded.between(head, head, (a, b)=>{\n                if (a < head && b > head) onSelection = true;\n            });\n            if (onSelection) folded = folded.update({\n                filterFrom: head,\n                filterTo: head,\n                filter: (a, b)=>b <= head || a >= head\n            });\n        }\n        return folded;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f),\n    toJSON (folded, state) {\n        let ranges = [];\n        folded.between(0, state.doc.length, (from, to)=>{\n            ranges.push(from, to);\n        });\n        return ranges;\n    },\n    fromJSON (value) {\n        if (!Array.isArray(value) || value.length % 2) throw new RangeError(\"Invalid JSON for fold state\");\n        let ranges = [];\n        for(let i = 0; i < value.length;){\n            let from = value[i++], to = value[i++];\n            if (typeof from != \"number\" || typeof to != \"number\") throw new RangeError(\"Invalid JSON for fold state\");\n            ranges.push(foldWidget.range(from, to));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(ranges, true);\n    }\n});\n/**\nGet a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges\nin the given state.\n*/ function foldedRanges(state) {\n    return state.field(foldState, false) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n}\nfunction findFold(state, from, to) {\n    var _a;\n    let found = null;\n    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to)=>{\n        if (!found || found.from > from) found = {\n            from,\n            to\n        };\n    });\n    return found;\n}\nfunction foldExists(folded, from, to) {\n    let found = false;\n    folded.between(from, from, (a, b)=>{\n        if (a == from && b == to) found = true;\n    });\n    return found;\n}\nfunction maybeEnable(state, other) {\n    return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(codeFolding()));\n}\n/**\nFold the lines that are selected, if possible.\n*/ const foldCode = (view)=>{\n    for (let line of selectedLines(view)){\n        let range = foldable(view.state, line.from, line.to);\n        if (range) {\n            view.dispatch({\n                effects: maybeEnable(view.state, [\n                    foldEffect.of(range),\n                    announceFold(view, range)\n                ])\n            });\n            return true;\n        }\n    }\n    return false;\n};\n/**\nUnfold folded ranges on selected lines.\n*/ const unfoldCode = (view)=>{\n    if (!view.state.field(foldState, false)) return false;\n    let effects = [];\n    for (let line of selectedLines(view)){\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n    }\n    if (effects.length) view.dispatch({\n        effects\n    });\n    return effects.length > 0;\n};\nfunction announceFold(view, range, fold = true) {\n    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\n/**\nFold all top-level foldable ranges. Note that, in most cases,\nfolding information will depend on the [syntax\ntree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work\nreliably when the document hasn't been fully parsed (either\nbecause the editor state was only just initialized, or because the\ndocument is so big that the parser decided not to parse it\nentirely).\n*/ const foldAll = (view)=>{\n    let { state } = view, effects = [];\n    for(let pos = 0; pos < state.doc.length;){\n        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);\n        if (range) effects.push(foldEffect.of(range));\n        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;\n    }\n    if (effects.length) view.dispatch({\n        effects: maybeEnable(view.state, effects)\n    });\n    return !!effects.length;\n};\n/**\nUnfold all folded code.\n*/ const unfoldAll = (view)=>{\n    let field = view.state.field(foldState, false);\n    if (!field || !field.size) return false;\n    let effects = [];\n    field.between(0, view.state.doc.length, (from, to)=>{\n        effects.push(unfoldEffect.of({\n            from,\n            to\n        }));\n    });\n    view.dispatch({\n        effects\n    });\n    return true;\n};\n// Find the foldable region containing the given line, if one exists\nfunction foldableContainer(view, lineBlock) {\n    // Look backwards through line blocks until we find a foldable region that\n    // intersects with the line\n    for(let line = lineBlock;;){\n        let foldableRegion = foldable(view.state, line.from, line.to);\n        if (foldableRegion && foldableRegion.to > lineBlock.from) return foldableRegion;\n        if (!line.from) return null;\n        line = view.lineBlockAt(line.from - 1);\n    }\n}\n/**\nToggle folding at cursors. Unfolds if there is an existing fold\nstarting in that line, tries to find a foldable range around it\notherwise.\n*/ const toggleFold = (view)=>{\n    let effects = [];\n    for (let line of selectedLines(view)){\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) {\n            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n        } else {\n            let foldRange = foldableContainer(view, line);\n            if (foldRange) effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));\n        }\n    }\n    if (effects.length > 0) view.dispatch({\n        effects: maybeEnable(view.state, effects)\n    });\n    return !!effects.length;\n};\n/**\nDefault fold-related key bindings.\n\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).\n*/ const foldKeymap = [\n    {\n        key: \"Ctrl-Shift-[\",\n        mac: \"Cmd-Alt-[\",\n        run: foldCode\n    },\n    {\n        key: \"Ctrl-Shift-]\",\n        mac: \"Cmd-Alt-]\",\n        run: unfoldCode\n    },\n    {\n        key: \"Ctrl-Alt-[\",\n        run: foldAll\n    },\n    {\n        key: \"Ctrl-Alt-]\",\n        run: unfoldAll\n    }\n];\nconst defaultConfig = {\n    placeholderDOM: null,\n    preparePlaceholder: null,\n    placeholderText: \"…\"\n};\nconst foldConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (values) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, defaultConfig);\n    }\n});\n/**\nCreate an extension that configures code folding.\n*/ function codeFolding(config) {\n    let result = [\n        foldState,\n        baseTheme$1\n    ];\n    if (config) result.push(foldConfig.of(config));\n    return result;\n}\nfunction widgetToDOM(view, prepared) {\n    let { state } = view, conf = state.facet(foldConfig);\n    let onclick = (event)=>{\n        let line = view.lineBlockAt(view.posAtDOM(event.target));\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) view.dispatch({\n            effects: unfoldEffect.of(folded)\n        });\n        event.preventDefault();\n    };\n    if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick, prepared);\n    let element = document.createElement(\"span\");\n    element.textContent = conf.placeholderText;\n    element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n    element.title = state.phrase(\"unfold\");\n    element.className = \"cm-foldPlaceholder\";\n    element.onclick = onclick;\n    return element;\n}\nconst foldWidget = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n    widget: /*@__PURE__*/ new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n        toDOM(view) {\n            return widgetToDOM(view, null);\n        }\n    }\n});\nclass PreparedFoldWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n    constructor(value){\n        super();\n        this.value = value;\n    }\n    eq(other) {\n        return this.value == other.value;\n    }\n    toDOM(view) {\n        return widgetToDOM(view, this.value);\n    }\n}\nconst foldGutterDefaults = {\n    openText: \"⌄\",\n    closedText: \"›\",\n    markerDOM: null,\n    domEventHandlers: {},\n    foldingChanged: ()=>false\n};\nclass FoldMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.GutterMarker {\n    constructor(config, open){\n        super();\n        this.config = config;\n        this.open = open;\n    }\n    eq(other) {\n        return this.config == other.config && this.open == other.open;\n    }\n    toDOM(view) {\n        if (this.config.markerDOM) return this.config.markerDOM(this.open);\n        let span = document.createElement(\"span\");\n        span.textContent = this.open ? this.config.openText : this.config.closedText;\n        span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n        return span;\n    }\n}\n/**\nCreate an extension that registers a fold gutter, which shows a\nfold status indicator before foldable lines (which can be clicked\nto fold or unfold the line).\n*/ function foldGutter(config = {}) {\n    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);\n    let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n        constructor(view){\n            this.from = view.viewport.from;\n            this.markers = this.buildMarkers(view);\n        }\n        update(update) {\n            if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update)) this.markers = this.buildMarkers(update.view);\n        }\n        buildMarkers(view) {\n            let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n            for (let line of view.viewportLineBlocks){\n                let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;\n                if (mark) builder.add(line.from, line.from, mark);\n            }\n            return builder.finish();\n        }\n    });\n    let { domEventHandlers } = fullConfig;\n    return [\n        markers,\n        (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.gutter)({\n            class: \"cm-foldGutter\",\n            markers (view) {\n                var _a;\n                return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n            },\n            initialSpacer () {\n                return new FoldMarker(fullConfig, false);\n            },\n            domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), {\n                click: (view, line, event)=>{\n                    if (domEventHandlers.click && domEventHandlers.click(view, line, event)) return true;\n                    let folded = findFold(view.state, line.from, line.to);\n                    if (folded) {\n                        view.dispatch({\n                            effects: unfoldEffect.of(folded)\n                        });\n                        return true;\n                    }\n                    let range = foldable(view.state, line.from, line.to);\n                    if (range) {\n                        view.dispatch({\n                            effects: foldEffect.of(range)\n                        });\n                        return true;\n                    }\n                    return false;\n                }\n            })\n        }),\n        codeFolding()\n    ];\n}\nconst baseTheme$1 = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"#eee\",\n        border: \"1px solid #ddd\",\n        color: \"#888\",\n        borderRadius: \".2em\",\n        margin: \"0 1px\",\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    },\n    \".cm-foldGutter span\": {\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    }\n});\n/**\nA highlight style associates CSS styles with higlighting\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).\n*/ class HighlightStyle {\n    constructor(/**\n    The tag styles used to create this highlight style.\n    */ specs, options){\n        this.specs = specs;\n        let modSpec;\n        function def(spec) {\n            let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule.newName();\n            (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n            return cls;\n        }\n        const all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : undefined;\n        const scopeOpt = options.scope;\n        this.scope = scopeOpt instanceof Language ? (type)=>type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type)=>type == scopeOpt : undefined;\n        this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tagHighlighter)(specs.map((style)=>({\n                tag: style.tag,\n                class: style.class || def(Object.assign({}, style, {\n                    tag: null\n                }))\n            })), {\n            all\n        }).style;\n        this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule(modSpec) : null;\n        this.themeType = options.themeType;\n    }\n    /**\n    Create a highlighter style that associates the given styles to\n    the given tags. The specs must be objects that hold a style tag\n    or array of tags in their `tag` property, and either a single\n    `class` property providing a static CSS class (for highlighter\n    that rely on external styling), or a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n    set of CSS properties (which define the styling for those tags).\n    \n    The CSS rules created for a highlighter will be emitted in the\n    order of the spec's properties. That means that for elements that\n    have multiple tags associated with them, styles defined further\n    down in the list will have a higher CSS precedence than styles\n    defined earlier.\n    */ static define(specs, options) {\n        return new HighlightStyle(specs, options || {});\n    }\n}\nconst highlighterFacet = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst fallbackHighlighter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (values) {\n        return values.length ? [\n            values[0]\n        ] : null;\n    }\n});\nfunction getHighlighters(state) {\n    let main = state.facet(highlighterFacet);\n    return main.length ? main : state.facet(fallbackHighlighter);\n}\n/**\nWrap a highlighter in an editor extension that uses it to apply\nsyntax highlighting to the editor content.\n\nWhen multiple (non-fallback) styles are provided, the styling\napplied is the union of the classes they emit.\n*/ function syntaxHighlighting(highlighter, options) {\n    let ext = [\n        treeHighlighter\n    ], themeType;\n    if (highlighter instanceof HighlightStyle) {\n        if (highlighter.module) ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.styleModule.of(highlighter.module));\n        themeType = highlighter.themeType;\n    }\n    if (options === null || options === void 0 ? void 0 : options.fallback) ext.push(fallbackHighlighter.of(highlighter));\n    else if (themeType) ext.push(highlighterFacet.computeN([\n        _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme\n    ], (state)=>{\n        return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme) == (themeType == \"dark\") ? [\n            highlighter\n        ] : [];\n    }));\n    else ext.push(highlighterFacet.of(highlighter));\n    return ext;\n}\n/**\nReturns the CSS classes (if any) that the highlighters active in\nthe state would assign to the given style\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and\n(optional) language\n[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).\n*/ function highlightingFor(state, tags, scope) {\n    let highlighters = getHighlighters(state);\n    let result = null;\n    if (highlighters) for (let highlighter of highlighters){\n        if (!highlighter.scope || scope && highlighter.scope(scope)) {\n            let cls = highlighter.style(tags);\n            if (cls) result = result ? result + \" \" + cls : cls;\n        }\n    }\n    return result;\n}\nclass TreeHighlighter {\n    constructor(view){\n        this.markCache = Object.create(null);\n        this.tree = syntaxTree(view.state);\n        this.decorations = this.buildDeco(view, getHighlighters(view.state));\n        this.decoratedTo = view.viewport.to;\n    }\n    update(update) {\n        let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);\n        let styleChange = highlighters != getHighlighters(update.startState);\n        let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);\n        if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {\n            this.decorations = this.decorations.map(update.changes);\n            this.decoratedTo = decoratedToMapped;\n        } else if (tree != this.tree || update.viewportChanged || styleChange) {\n            this.tree = tree;\n            this.decorations = this.buildDeco(update.view, highlighters);\n            this.decoratedTo = viewport.to;\n        }\n    }\n    buildDeco(view, highlighters) {\n        if (!highlighters || !this.tree.length) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n        for (let { from, to } of view.visibleRanges){\n            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.highlightTree)(this.tree, highlighters, (from, to, style)=>{\n                builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n                    class: style\n                })));\n            }, from, to);\n        }\n        return builder.finish();\n    }\n}\nconst treeHighlighter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.high(/*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(TreeHighlighter, {\n    decorations: (v)=>v.decorations\n}));\n/**\nA default highlight style (works well with light themes).\n*/ const defaultHighlightStyle = /*@__PURE__*/ HighlightStyle.define([\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n        color: \"#404740\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.link,\n        textDecoration: \"underline\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading,\n        textDecoration: \"underline\",\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.emphasis,\n        fontStyle: \"italic\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strong,\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strikethrough,\n        textDecoration: \"line-through\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n        color: \"#708\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.url,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.contentSeparator,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName\n        ],\n        color: \"#219\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.literal,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.inserted\n        ],\n        color: \"#164\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.deleted\n        ],\n        color: \"#a11\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string)\n        ],\n        color: \"#e40\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n        color: \"#00f\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n        color: \"#30a\"\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.namespace\n        ],\n        color: \"#085\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n        color: \"#167\"\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.macroName\n        ],\n        color: \"#256\"\n    },\n    {\n        tag: /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n        color: \"#00c\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.comment,\n        color: \"#940\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid,\n        color: \"#f00\"\n    }\n]);\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n    \"&.cm-focused .cm-matchingBracket\": {\n        backgroundColor: \"#328c8252\"\n    },\n    \"&.cm-focused .cm-nonmatchingBracket\": {\n        backgroundColor: \"#bb555544\"\n    }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist,\n            renderMatch: defaultRenderMatch\n        });\n    }\n});\nconst matchingMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-matchingBracket\"\n}), nonmatchingMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-nonmatchingBracket\"\n});\nfunction defaultRenderMatch(match) {\n    let decorations = [];\n    let mark = match.matched ? matchingMark : nonmatchingMark;\n    decorations.push(mark.range(match.start.from, match.start.to));\n    if (match.end) decorations.push(mark.range(match.end.from, match.end.to));\n    return decorations;\n}\nconst bracketMatchingState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n    create () {\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    },\n    update (deco, tr) {\n        if (!tr.docChanged && !tr.selection) return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges){\n            if (!range.empty) continue;\n            let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));\n            if (match) decorations = decorations.concat(config.renderMatch(match, tr.state));\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(decorations, true);\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/ function bracketMatching(config = {}) {\n    return [\n        bracketMatchingConfig.of(config),\n        bracketMatchingUnique\n    ];\n}\n/**\nWhen larger syntax nodes, such as HTML tags, are marked as\nopening/closing, it can be a bit messy to treat the whole node as\na matchable bracket. This node prop allows you to define, for such\na node, a ‘handle’—the part of the node that is highlighted, and\nthat the cursor must be on to activate highlighting in the first\nplace.\n*/ const bracketMatchingHandle = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy);\n    if (byProp) return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [\n            brackets[index + dir]\n        ];\n    }\n    return null;\n}\nfunction findHandle(node) {\n    let hasHandle = node.type.prop(bracketMatchingHandle);\n    return hasHandle ? hasHandle(node.node) : node;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/ function matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);\n    for(let cur = node; cur; cur = cur.parent){\n        let matches = matchingNodes(cur.type, dir, brackets);\n        if (matches && cur.from < cur.to) {\n            let handle = findHandle(cur);\n            if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to)) return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);\n        }\n    }\n    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {\n    let parent = token.parent, firstToken = {\n        from: handle.from,\n        to: handle.to\n    };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {\n        if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n            if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n                let endHandle = findHandle(cursor);\n                return {\n                    start: firstToken,\n                    end: endHandle ? {\n                        from: endHandle.from,\n                        to: endHandle.to\n                    } : undefined,\n                    matched: true\n                };\n            } else if (matchingNodes(cursor.type, dir, brackets)) {\n                depth++;\n            } else if (matchingNodes(cursor.type, -dir, brackets)) {\n                if (depth == 0) {\n                    let endHandle = findHandle(cursor);\n                    return {\n                        start: firstToken,\n                        end: endHandle && endHandle.from < endHandle.to ? {\n                            from: endHandle.from,\n                            to: endHandle.to\n                        } : undefined,\n                        matched: false\n                    };\n                }\n                depth--;\n            }\n        }\n    }while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return {\n        start: firstToken,\n        matched: false\n    };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;\n    let startToken = {\n        from: dir < 0 ? pos - 1 : pos,\n        to: dir > 0 ? pos + 1 : pos\n    };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for(let distance = 0; !iter.next().done && distance <= maxScanDistance;){\n        let text = iter.value;\n        if (dir < 0) distance += text.length;\n        let basePos = pos + distance * dir;\n        for(let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir){\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType) continue;\n            if (found % 2 == 0 == dir > 0) {\n                depth++;\n            } else if (depth == 1) {\n                return {\n                    start: startToken,\n                    end: {\n                        from: basePos + pos,\n                        to: basePos + pos + 1\n                    },\n                    matched: found >> 1 == bracket >> 1\n                };\n            } else {\n                depth--;\n            }\n        }\n        if (dir > 0) distance += text.length;\n    }\n    return iter.done ? {\n        start: startToken,\n        matched: false\n    } : null;\n}\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n    if (end == null) {\n        end = string.search(/[^\\s\\u00a0]/);\n        if (end == -1) end = string.length;\n    }\n    let n = startValue;\n    for(let i = startIndex; i < end; i++){\n        if (string.charCodeAt(i) == 9) n += tabSize - n % tabSize;\n        else n++;\n    }\n    return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/ class StringStream {\n    /**\n    Create a stream.\n    */ constructor(/**\n    The line.\n    */ string, tabSize, /**\n    The current indent unit size.\n    */ indentUnit, overrideIndent){\n        this.string = string;\n        this.tabSize = tabSize;\n        this.indentUnit = indentUnit;\n        this.overrideIndent = overrideIndent;\n        /**\n        The current position on the line.\n        */ this.pos = 0;\n        /**\n        The start position of the current token.\n        */ this.start = 0;\n        this.lastColumnPos = 0;\n        this.lastColumnValue = 0;\n    }\n    /**\n    True if we are at the end of the line.\n    */ eol() {\n        return this.pos >= this.string.length;\n    }\n    /**\n    True if we are at the start of the line.\n    */ sol() {\n        return this.pos == 0;\n    }\n    /**\n    Get the next code unit after the current position, or undefined\n    if we're at the end of the line.\n    */ peek() {\n        return this.string.charAt(this.pos) || undefined;\n    }\n    /**\n    Read the next code unit and advance `this.pos`.\n    */ next() {\n        if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n    }\n    /**\n    Match the next character against the given string, regular\n    expression, or predicate. Consume and return it if it matches.\n    */ eat(match) {\n        let ch = this.string.charAt(this.pos);\n        let ok;\n        if (typeof match == \"string\") ok = ch == match;\n        else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n        if (ok) {\n            ++this.pos;\n            return ch;\n        }\n    }\n    /**\n    Continue matching characters that match the given string,\n    regular expression, or predicate function. Return true if any\n    characters were consumed.\n    */ eatWhile(match) {\n        let start = this.pos;\n        while(this.eat(match)){}\n        return this.pos > start;\n    }\n    /**\n    Consume whitespace ahead of `this.pos`. Return true if any was\n    found.\n    */ eatSpace() {\n        let start = this.pos;\n        while(/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))++this.pos;\n        return this.pos > start;\n    }\n    /**\n    Move to the end of the line.\n    */ skipToEnd() {\n        this.pos = this.string.length;\n    }\n    /**\n    Move to directly before the given character, if found on the\n    current line.\n    */ skipTo(ch) {\n        let found = this.string.indexOf(ch, this.pos);\n        if (found > -1) {\n            this.pos = found;\n            return true;\n        }\n    }\n    /**\n    Move back `n` characters.\n    */ backUp(n) {\n        this.pos -= n;\n    }\n    /**\n    Get the column position at `this.pos`.\n    */ column() {\n        if (this.lastColumnPos < this.start) {\n            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n            this.lastColumnPos = this.start;\n        }\n        return this.lastColumnValue;\n    }\n    /**\n    Get the indentation column of the current line.\n    */ indentation() {\n        var _a;\n        return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);\n    }\n    /**\n    Match the input against the given string or regular expression\n    (which should start with a `^`). Return true or the regexp match\n    if it matches.\n    \n    Unless `consume` is set to `false`, this will move `this.pos`\n    past the matched text.\n    \n    When matching a string `caseInsensitive` can be set to true to\n    make the match case-insensitive.\n    */ match(pattern, consume, caseInsensitive) {\n        if (typeof pattern == \"string\") {\n            let cased = (str)=>caseInsensitive ? str.toLowerCase() : str;\n            let substr = this.string.substr(this.pos, pattern.length);\n            if (cased(substr) == cased(pattern)) {\n                if (consume !== false) this.pos += pattern.length;\n                return true;\n            } else return null;\n        } else {\n            let match = this.string.slice(this.pos).match(pattern);\n            if (match && match.index > 0) return null;\n            if (match && consume !== false) this.pos += match[0].length;\n            return match;\n        }\n    }\n    /**\n    Get the current token.\n    */ current() {\n        return this.string.slice(this.start, this.pos);\n    }\n}\nfunction fullParser(spec) {\n    return {\n        name: spec.name || \"\",\n        token: spec.token,\n        blankLine: spec.blankLine || (()=>{}),\n        startState: spec.startState || (()=>true),\n        copyState: spec.copyState || defaultCopyState,\n        indent: spec.indent || (()=>null),\n        languageData: spec.languageData || {},\n        tokenTable: spec.tokenTable || noTokens\n    };\n}\nfunction defaultCopyState(state) {\n    if (typeof state != \"object\") return state;\n    let newState = {};\n    for(let prop in state){\n        let val = state[prop];\n        newState[prop] = val instanceof Array ? val.slice() : val;\n    }\n    return newState;\n}\nconst IndentedFrom = /*@__PURE__*/ new WeakMap();\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror\n5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).\n*/ class StreamLanguage extends Language {\n    constructor(parser){\n        let data = defineLanguageFacet(parser.languageData);\n        let p = fullParser(parser), self;\n        let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n            createParse(input, fragments, ranges) {\n                return new Parse(self, input, fragments, ranges);\n            }\n        };\n        super(data, impl, [], parser.name);\n        this.topNode = docID(data, this);\n        self = this;\n        this.streamParser = p;\n        this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({\n            perNode: true\n        });\n        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n    }\n    /**\n    Define a stream language.\n    */ static define(spec) {\n        return new StreamLanguage(spec);\n    }\n    /**\n    @internal\n    */ getIndent(cx) {\n        let from = undefined;\n        let { overrideIndentation } = cx.options;\n        if (overrideIndentation) {\n            from = IndentedFrom.get(cx.state);\n            if (from != null && from < cx.pos - 1e4) from = undefined;\n        }\n        let start = findState(this, cx.node.tree, cx.node.from, cx.node.from, from !== null && from !== void 0 ? from : cx.pos), statePos, state;\n        if (start) {\n            state = start.state;\n            statePos = start.pos + 1;\n        } else {\n            state = this.streamParser.startState(cx.unit);\n            statePos = cx.node.from;\n        }\n        if (cx.pos - statePos > 10000 /* C.MaxIndentScanDist */ ) return null;\n        while(statePos < cx.pos){\n            let line = cx.state.doc.lineAt(statePos), end = Math.min(cx.pos, line.to);\n            if (line.length) {\n                let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;\n                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);\n                while(stream.pos < end - line.from)readToken(this.streamParser.token, stream, state);\n            } else {\n                this.streamParser.blankLine(state, cx.unit);\n            }\n            if (end == cx.pos) break;\n            statePos = line.to + 1;\n        }\n        let line = cx.lineAt(cx.pos);\n        if (overrideIndentation && from == null) IndentedFrom.set(cx.state, line.from);\n        return this.streamParser.indent(state, /^\\s*(.*)/.exec(line.text)[1], cx);\n    }\n    get allowsNesting() {\n        return false;\n    }\n}\nfunction findState(lang, tree, off, startPos, before) {\n    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n    if (state) return {\n        state: lang.streamParser.copyState(state),\n        pos: off + tree.length\n    };\n    for(let i = tree.children.length - 1; i >= 0; i--){\n        let child = tree.children[i], pos = off + tree.positions[i];\n        let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && pos < before && findState(lang, child, pos, startPos, before);\n        if (found) return found;\n    }\n    return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n    if (inside && from <= 0 && to >= tree.length) return tree;\n    if (!inside && from == 0 && tree.type == lang.topNode) inside = true;\n    for(let i = tree.children.length - 1; i >= 0; i--){\n        let pos = tree.positions[i], child = tree.children[i], inner;\n        if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside))) break;\n            return !inside ? inner : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n        }\n    }\n    return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, endPos, editorState) {\n    for (let f of fragments){\n        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);\n        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;\n        if (found && found.pos <= endPos && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false))) return {\n            state: found.state,\n            tree\n        };\n    }\n    return {\n        state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4),\n        tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty\n    };\n}\nclass Parse {\n    constructor(lang, input, fragments, ranges){\n        this.lang = lang;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.stoppedAt = null;\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.rangeIndex = 0;\n        this.to = ranges[ranges.length - 1].to;\n        let context = ParseContext.get(), from = ranges[0].from;\n        let { state, tree } = findStartInFragments(lang, fragments, from, this.to, context === null || context === void 0 ? void 0 : context.state);\n        this.state = state;\n        this.parsedPos = this.chunkStart = from + tree.length;\n        for(let i = 0; i < tree.children.length; i++){\n            this.chunks.push(tree.children[i]);\n            this.chunkPos.push(tree.positions[i]);\n        }\n        if (context && this.parsedPos < context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */  && ranges.some((r)=>r.from <= context.viewport.from && r.to >= context.viewport.from)) {\n            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n            context.skipUntilInView(this.parsedPos, context.viewport.from);\n            this.parsedPos = context.viewport.from;\n        }\n        this.moveRangeIndex();\n    }\n    advance() {\n        let context = ParseContext.get();\n        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\n        let end = Math.min(parseEnd, this.chunkStart + 2048 /* C.ChunkSize */ );\n        if (context) end = Math.min(end, context.viewport.to);\n        while(this.parsedPos < end)this.parseLine(context);\n        if (this.chunkStart < this.parsedPos) this.finishChunk();\n        if (this.parsedPos >= parseEnd) return this.finish();\n        if (context && this.parsedPos >= context.viewport.to) {\n            context.skipUntilInView(this.parsedPos, parseEnd);\n            return this.finish();\n        }\n        return null;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n    }\n    lineAfter(pos) {\n        let chunk = this.input.chunk(pos);\n        if (!this.input.lineChunks) {\n            let eol = chunk.indexOf(\"\\n\");\n            if (eol > -1) chunk = chunk.slice(0, eol);\n        } else if (chunk == \"\\n\") {\n            chunk = \"\";\n        }\n        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n    }\n    nextLine() {\n        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;\n        for(let index = this.rangeIndex;;){\n            let rangeEnd = this.ranges[index].to;\n            if (rangeEnd >= end) break;\n            line = line.slice(0, rangeEnd - (end - line.length));\n            index++;\n            if (index == this.ranges.length) break;\n            let rangeStart = this.ranges[index].from;\n            let after = this.lineAfter(rangeStart);\n            line += after;\n            end = rangeStart + after.length;\n        }\n        return {\n            line,\n            end\n        };\n    }\n    skipGapsTo(pos, offset, side) {\n        for(;;){\n            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;\n            if (side > 0 ? end > offPos : end >= offPos) break;\n            let start = this.ranges[++this.rangeIndex].from;\n            offset += start - end;\n        }\n        return offset;\n    }\n    moveRangeIndex() {\n        while(this.ranges[this.rangeIndex].to < this.parsedPos)this.rangeIndex++;\n    }\n    emitToken(id, from, to, offset) {\n        let size = 4;\n        if (this.ranges.length > 1) {\n            offset = this.skipGapsTo(from, offset, 1);\n            from += offset;\n            let len0 = this.chunk.length;\n            offset = this.skipGapsTo(to, offset, -1);\n            to += offset;\n            size += this.chunk.length - len0;\n        }\n        let last = this.chunk.length - 4;\n        if (size == 4 && last >= 0 && this.chunk[last] == id && this.chunk[last + 2] == from) this.chunk[last + 2] = to;\n        else this.chunk.push(id, from, to, size);\n        return offset;\n    }\n    parseLine(context) {\n        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;\n        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n        if (stream.eol()) {\n            streamParser.blankLine(this.state, stream.indentUnit);\n        } else {\n            while(!stream.eol()){\n                let token = readToken(streamParser.token, stream, this.state);\n                if (token) offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, offset);\n                if (stream.start > 10000 /* C.MaxLineLength */ ) break;\n            }\n        }\n        this.parsedPos = end;\n        this.moveRangeIndex();\n        if (this.parsedPos < this.to) this.parsedPos++;\n    }\n    finishChunk() {\n        let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n            buffer: this.chunk,\n            start: this.chunkStart,\n            length: this.parsedPos - this.chunkStart,\n            nodeSet,\n            topID: 0,\n            maxBufferLength: 2048 /* C.ChunkSize */ ,\n            reused: this.chunkReused\n        });\n        tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children, tree.positions, tree.length, [\n            [\n                this.lang.stateAfter,\n                this.lang.streamParser.copyState(this.state)\n            ]\n        ]);\n        this.chunks.push(tree);\n        this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n        this.chunk = [];\n        this.chunkReused = undefined;\n        this.chunkStart = this.parsedPos;\n    }\n    finish() {\n        return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n    }\n}\nfunction readToken(token, stream, state) {\n    stream.start = stream.pos;\n    for(let i = 0; i < 10; i++){\n        let result = token(stream, state);\n        if (stream.pos > stream.start) return result;\n    }\n    throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst noTokens = /*@__PURE__*/ Object.create(null);\nconst typeArray = [\n    _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none\n];\nconst nodeSet = /*@__PURE__*/ new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(typeArray);\nconst warned = [];\n// Cache of node types by name and tags\nconst byTag = /*@__PURE__*/ Object.create(null);\nconst defaultTable = /*@__PURE__*/ Object.create(null);\nfor (let [legacyName, name] of [\n    [\n        \"variable\",\n        \"variableName\"\n    ],\n    [\n        \"variable-2\",\n        \"variableName.special\"\n    ],\n    [\n        \"string-2\",\n        \"string.special\"\n    ],\n    [\n        \"def\",\n        \"variableName.definition\"\n    ],\n    [\n        \"tag\",\n        \"tagName\"\n    ],\n    [\n        \"attribute\",\n        \"attributeName\"\n    ],\n    [\n        \"type\",\n        \"typeName\"\n    ],\n    [\n        \"builtin\",\n        \"variableName.standard\"\n    ],\n    [\n        \"qualifier\",\n        \"modifier\"\n    ],\n    [\n        \"error\",\n        \"invalid\"\n    ],\n    [\n        \"header\",\n        \"heading\"\n    ],\n    [\n        \"property\",\n        \"propertyName\"\n    ]\n])defaultTable[legacyName] = /*@__PURE__*/ createTokenType(noTokens, name);\nclass TokenTable {\n    constructor(extra){\n        this.extra = extra;\n        this.table = Object.assign(Object.create(null), defaultTable);\n    }\n    resolve(tag) {\n        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n    }\n}\nconst defaultTokenTable = /*@__PURE__*/ new TokenTable(noTokens);\nfunction warnForPart(part, msg) {\n    if (warned.indexOf(part) > -1) return;\n    warned.push(part);\n    console.warn(msg);\n}\nfunction createTokenType(extra, tagStr) {\n    let tags$1 = [];\n    for (let name of tagStr.split(\" \")){\n        let found = [];\n        for (let part of name.split(\".\")){\n            let value = extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags[part];\n            if (!value) {\n                warnForPart(part, `Unknown highlighting tag ${part}`);\n            } else if (typeof value == \"function\") {\n                if (!found.length) warnForPart(part, `Modifier ${part} used at start of tag`);\n                else found = found.map(value);\n            } else {\n                if (found.length) warnForPart(part, `Tag ${part} used as modifier`);\n                else found = Array.isArray(value) ? value : [\n                    value\n                ];\n            }\n        }\n        for (let tag of found)tags$1.push(tag);\n    }\n    if (!tags$1.length) return 0;\n    let name = tagStr.replace(/ /g, \"_\"), key = name + \" \" + tags$1.map((t)=>t.id);\n    let known = byTag[key];\n    if (known) return known.id;\n    let type = byTag[key] = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n        id: typeArray.length,\n        name,\n        props: [\n            (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n                [name]: tags$1\n            })\n        ]\n    });\n    typeArray.push(type);\n    return type.id;\n}\nfunction docID(data, lang) {\n    let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n        id: typeArray.length,\n        name: \"Document\",\n        props: [\n            languageDataProp.add(()=>data),\n            indentNodeProp.add(()=>(cx)=>lang.getIndent(cx))\n        ],\n        top: true\n    });\n    typeArray.push(type);\n    return type;\n}\nfunction buildForLine(line) {\n    return line.length <= 4096 && /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/.test(line);\n}\nfunction textHasRTL(text) {\n    for(let i = text.iter(); !i.next().done;)if (buildForLine(i.value)) return true;\n    return false;\n}\nfunction changeAddsRTL(change) {\n    let added = false;\n    change.iterChanges((fA, tA, fB, tB, ins)=>{\n        if (!added && textHasRTL(ins)) added = true;\n    });\n    return added;\n}\nconst alwaysIsolate = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\n/**\nMake sure nodes\n[marked](https://lezer.codemirror.net/docs/ref/#common.NodeProp^isolate)\nas isolating for bidirectional text are rendered in a way that\nisolates them from the surrounding text.\n*/ function bidiIsolates(options = {}) {\n    let extensions = [\n        isolateMarks\n    ];\n    if (options.alwaysIsolate) extensions.push(alwaysIsolate.of(true));\n    return extensions;\n}\nconst isolateMarks = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.always = view.state.facet(alwaysIsolate) || view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR || view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);\n        this.hasRTL = !this.always && textHasRTL(view.state.doc);\n        this.tree = syntaxTree(view.state);\n        this.decorations = this.always || this.hasRTL ? buildDeco(view, this.tree, this.always) : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    }\n    update(update) {\n        let always = update.state.facet(alwaysIsolate) || update.view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR || update.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);\n        if (!always && !this.hasRTL && changeAddsRTL(update.changes)) this.hasRTL = true;\n        if (!always && !this.hasRTL) return;\n        let tree = syntaxTree(update.state);\n        if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {\n            this.tree = tree;\n            this.always = always;\n            this.decorations = buildDeco(update.view, tree, always);\n        }\n    }\n}, {\n    provide: (plugin)=>{\n        function access(view) {\n            var _a, _b;\n            return (_b = (_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.decorations) !== null && _b !== void 0 ? _b : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n        }\n        return [\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.outerDecorations.of(access),\n            _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.lowest(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.bidiIsolatedRanges.of(access))\n        ];\n    }\n});\nfunction buildDeco(view, tree, always) {\n    let deco = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n    let ranges = view.visibleRanges;\n    if (!always) ranges = clipRTLLines(ranges, view.state.doc);\n    for (let { from, to } of ranges){\n        tree.iterate({\n            enter: (node)=>{\n                let iso = node.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.isolate);\n                if (iso) deco.add(node.from, node.to, marks[iso]);\n            },\n            from,\n            to\n        });\n    }\n    return deco.finish();\n}\nfunction clipRTLLines(ranges, doc) {\n    let cur = doc.iter(), pos = 0, result = [], last = null;\n    for (let { from, to } of ranges){\n        if (last && last.to > from) {\n            from = last.to;\n            if (from >= to) continue;\n        }\n        if (pos + cur.value.length < from) {\n            cur.next(from - (pos + cur.value.length));\n            pos = from;\n        }\n        for(;;){\n            let start = pos, end = pos + cur.value.length;\n            if (!cur.lineBreak && buildForLine(cur.value)) {\n                if (last && last.to > start - 10) last.to = Math.min(to, end);\n                else result.push(last = {\n                    from: start,\n                    to: Math.min(to, end)\n                });\n            }\n            if (end >= to) break;\n            pos = end;\n            cur.next();\n        }\n    }\n    return result;\n}\nconst marks = {\n    rtl: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"rtl\"\n        },\n        bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.RTL\n    }),\n    ltr: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"ltr\"\n        },\n        bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR\n    }),\n    auto: /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n        class: \"cm-iso\",\n        inclusive: true,\n        attributes: {\n            dir: \"auto\"\n        },\n        bidiIsolate: null\n    })\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRztBQUMyQztBQUNaO0FBQy9DO0FBQzFDO0FBRXhDLElBQUk2QjtBQUNKOzs7QUFHQSxHQUNBLE1BQU1DLG1CQUFtQixXQUFXLEdBQUUsSUFBSTlCLG1EQUFRQTtBQUNsRDs7Ozs7OztBQU9BLEdBQ0EsU0FBUytCLG9CQUFvQkMsUUFBUTtJQUNqQyxPQUFPdkIsb0RBQUtBLENBQUN3QixNQUFNLENBQUM7UUFDaEJDLFNBQVNGLFdBQVdHLENBQUFBLFNBQVVBLE9BQU9DLE1BQU0sQ0FBQ0osWUFBWUs7SUFDNUQ7QUFDSjtBQUNBOzs7QUFHQSxHQUNBLE1BQU1DLGtCQUFrQixXQUFXLEdBQUUsSUFBSXRDLG1EQUFRQTtBQUNqRDs7Ozs7Ozs7QUFRQSxHQUNBLE1BQU11QztJQUNGOzs7Ozs7SUFNQSxHQUNBQyxZQUNBOzs7SUFHQSxHQUNBQyxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsa0JBQWtCLEVBQUUsRUFDbEM7O0lBRUEsR0FDQUMsT0FBTyxFQUFFLENBQUU7UUFDUCxJQUFJLENBQUNILElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNHLElBQUksR0FBR0E7UUFDWiwyREFBMkQ7UUFDM0QseURBQXlEO1FBQ3pELDZCQUE2QjtRQUM3QixJQUFJLENBQUNsQywwREFBV0EsQ0FBQ21DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDLFNBQ3RDQyxPQUFPQyxjQUFjLENBQUN0QywwREFBV0EsQ0FBQ21DLFNBQVMsRUFBRSxRQUFRO1lBQUVJO2dCQUFRLE9BQU9DLFdBQVcsSUFBSTtZQUFHO1FBQUU7UUFDOUYsSUFBSSxDQUFDUixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDUyxTQUFTLEdBQUc7WUFDYkMsU0FBU0MsRUFBRSxDQUFDLElBQUk7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O1FBQUcwSyxhQUFhbnNCLHVEQUFTQSxDQUFDb3NCLEdBQUc7SUFBQztJQUM3SEMsS0FBSyxXQUFXLEdBQUV6c0Isd0RBQVVBLENBQUM4YixJQUFJLENBQUM7UUFBRUUsT0FBTztRQUFVcVEsV0FBVztRQUFNQyxZQUFZO1lBQUV6SyxLQUFLO1FBQU07UUFBRzBLLGFBQWFuc0IsdURBQVNBLENBQUNrckIsR0FBRztJQUFDO0lBQzdIb0IsTUFBTSxXQUFXLEdBQUUxc0Isd0RBQVVBLENBQUM4YixJQUFJLENBQUM7UUFBRUUsT0FBTztRQUFVcVEsV0FBVztRQUFNQyxZQUFZO1lBQUV6SyxLQUFLO1FBQU87UUFBRzBLLGFBQWE7SUFBSztBQUMxSDtBQUV3eUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmljaGUvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGFuZ3VhZ2UvZGlzdC9pbmRleC5qcz9kNzNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGVQcm9wLCBJdGVyTW9kZSwgVHJlZSwgVHJlZUZyYWdtZW50LCBQYXJzZXIsIE5vZGVUeXBlLCBOb2RlU2V0IH0gZnJvbSAnQGxlemVyL2NvbW1vbic7XG5pbXBvcnQgeyBTdGF0ZUVmZmVjdCwgU3RhdGVGaWVsZCwgRmFjZXQsIEVkaXRvclN0YXRlLCBjb3VudENvbHVtbiwgY29tYmluZUNvbmZpZywgUmFuZ2VTZXQsIFJhbmdlU2V0QnVpbGRlciwgUHJlYyB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7IFZpZXdQbHVnaW4sIGxvZ0V4Y2VwdGlvbiwgRWRpdG9yVmlldywgRGVjb3JhdGlvbiwgV2lkZ2V0VHlwZSwgZ3V0dGVyLCBHdXR0ZXJNYXJrZXIsIERpcmVjdGlvbiB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgdGFncywgdGFnSGlnaGxpZ2h0ZXIsIGhpZ2hsaWdodFRyZWUsIHN0eWxlVGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xuXG52YXIgX2E7XG4vKipcbk5vZGUgcHJvcCBzdG9yZWQgaW4gYSBwYXJzZXIncyB0b3Agc3ludGF4IG5vZGUgdG8gcHJvdmlkZSB0aGVcbmZhY2V0IHRoYXQgc3RvcmVzIGxhbmd1YWdlLXNwZWNpZmljIGRhdGEgZm9yIHRoYXQgbGFuZ3VhZ2UuXG4qL1xuY29uc3QgbGFuZ3VhZ2VEYXRhUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuSGVscGVyIGZ1bmN0aW9uIHRvIGRlZmluZSBhIGZhY2V0ICh0byBiZSBhZGRlZCB0byB0aGUgdG9wIHN5bnRheFxubm9kZShzKSBmb3IgYSBsYW5ndWFnZSB2aWFcbltgbGFuZ3VhZ2VEYXRhUHJvcGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkpLCB0aGF0IHdpbGwgYmVcbnVzZWQgdG8gYXNzb2NpYXRlIGxhbmd1YWdlIGRhdGEgd2l0aCB0aGUgbGFuZ3VhZ2UuIFlvdVxucHJvYmFibHkgb25seSBuZWVkIHRoaXMgd2hlbiBzdWJjbGFzc2luZ1xuW2BMYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpLlxuKi9cbmZ1bmN0aW9uIGRlZmluZUxhbmd1YWdlRmFjZXQoYmFzZURhdGEpIHtcbiAgICByZXR1cm4gRmFjZXQuZGVmaW5lKHtcbiAgICAgICAgY29tYmluZTogYmFzZURhdGEgPyB2YWx1ZXMgPT4gdmFsdWVzLmNvbmNhdChiYXNlRGF0YSkgOiB1bmRlZmluZWRcbiAgICB9KTtcbn1cbi8qKlxuU3ludGF4IG5vZGUgcHJvcCB1c2VkIHRvIHJlZ2lzdGVyIHN1Ymxhbmd1YWdlcy4gU2hvdWxkIGJlIGFkZGVkIHRvXG50aGUgdG9wIGxldmVsIG5vZGUgdHlwZSBmb3IgdGhlIGxhbmd1YWdlLlxuKi9cbmNvbnN0IHN1Ymxhbmd1YWdlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuQSBsYW5ndWFnZSBvYmplY3QgbWFuYWdlcyBwYXJzaW5nIGFuZCBwZXItbGFuZ3VhZ2VcblttZXRhZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkuIFBhcnNlIGRhdGEgaXNcbm1hbmFnZWQgYXMgYSBbTGV6ZXJdKGh0dHBzOi8vbGV6ZXIuY29kZW1pcnJvci5uZXQpIHRyZWUuIFRoZSBjbGFzc1xuY2FuIGJlIHVzZWQgZGlyZWN0bHksIHZpYSB0aGUgW2BMUkxhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MUkxhbmd1YWdlKVxuc3ViY2xhc3MgZm9yIFtMZXplcl0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC8pIExSIHBhcnNlcnMsIG9yXG52aWEgdGhlIFtgU3RyZWFtTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlN0cmVhbUxhbmd1YWdlKSBzdWJjbGFzc1xuZm9yIHN0cmVhbSBwYXJzZXJzLlxuKi9cbmNsYXNzIExhbmd1YWdlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBsYW5ndWFnZSBvYmplY3QuIElmIHlvdSBuZWVkIHRvIGludm9rZSB0aGlzXG4gICAgZGlyZWN0bHksIGZpcnN0IGRlZmluZSBhIGRhdGEgZmFjZXQgd2l0aFxuICAgIFtgZGVmaW5lTGFuZ3VhZ2VGYWNldGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZGVmaW5lTGFuZ3VhZ2VGYWNldCksIGFuZCB0aGVuXG4gICAgY29uZmlndXJlIHlvdXIgcGFyc2VyIHRvIFthdHRhY2hdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkgaXRcbiAgICB0byB0aGUgbGFuZ3VhZ2UncyBvdXRlciBzeW50YXggbm9kZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBbbGFuZ3VhZ2UgZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCkgZmFjZXRcbiAgICB1c2VkIGZvciB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgZGF0YSwgcGFyc2VyLCBleHRyYUV4dGVuc2lvbnMgPSBbXSwgXG4gICAgLyoqXG4gICAgQSBsYW5ndWFnZSBuYW1lLlxuICAgICovXG4gICAgbmFtZSA9IFwiXCIpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgLy8gS2x1ZGdlIHRvIGRlZmluZSBFZGl0b3JTdGF0ZS50cmVlIGFzIGEgZGVidWdnaW5nIGhlbHBlcixcbiAgICAgICAgLy8gd2l0aG91dCB0aGUgRWRpdG9yU3RhdGUgcGFja2FnZSBhY3R1YWxseSBrbm93aW5nIGFib3V0XG4gICAgICAgIC8vIGxhbmd1YWdlcyBhbmQgbGV6ZXIgdHJlZXMuXG4gICAgICAgIGlmICghRWRpdG9yU3RhdGUucHJvdG90eXBlLmhhc093blByb3BlcnR5KFwidHJlZVwiKSlcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFZGl0b3JTdGF0ZS5wcm90b3R5cGUsIFwidHJlZVwiLCB7IGdldCgpIHsgcmV0dXJuIHN5bnRheFRyZWUodGhpcyk7IH0gfSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IFtcbiAgICAgICAgICAgIGxhbmd1YWdlLm9mKHRoaXMpLFxuICAgICAgICAgICAgRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhLm9mKChzdGF0ZSwgcG9zLCBzaWRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvcCA9IHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKSwgZGF0YSA9IHRvcC50eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBzdGF0ZS5mYWNldChkYXRhKSwgc3ViID0gdG9wLnR5cGUucHJvcChzdWJsYW5ndWFnZVByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyTm9kZSA9IHRvcC5yZXNvbHZlKHBvcyAtIHRvcC5mcm9tLCBzaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3VibGFuZyBvZiBzdWIpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VibGFuZy50ZXN0KGlubmVyTm9kZSwgc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBzdGF0ZS5mYWNldChzdWJsYW5nLmZhY2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VibGFuZy50eXBlID09IFwicmVwbGFjZVwiID8gZGF0YSA6IGRhdGEuY29uY2F0KGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF0uY29uY2F0KGV4dHJhRXh0ZW5zaW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhpcyBsYW5ndWFnZSBpcyBhY3RpdmUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgaXNBY3RpdmVBdChzdGF0ZSwgcG9zLCBzaWRlID0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRvcE5vZGVBdChzdGF0ZSwgcG9zLCBzaWRlKS50eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gdGhpcy5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBkb2N1bWVudCByZWdpb25zIHRoYXQgd2VyZSBwYXJzZWQgdXNpbmcgdGhpcyBsYW5ndWFnZS5cbiAgICBUaGUgcmV0dXJuZWQgcmVnaW9ucyB3aWxsIF9pbmNsdWRlXyBhbnkgbmVzdGVkIGxhbmd1YWdlcyByb290ZWRcbiAgICBpbiB0aGlzIGxhbmd1YWdlLCB3aGVuIHRob3NlIGV4aXN0LlxuICAgICovXG4gICAgZmluZFJlZ2lvbnMoc3RhdGUpIHtcbiAgICAgICAgbGV0IGxhbmcgPSBzdGF0ZS5mYWNldChsYW5ndWFnZSk7XG4gICAgICAgIGlmICgobGFuZyA9PT0gbnVsbCB8fCBsYW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYW5nLmRhdGEpID09IHRoaXMuZGF0YSlcbiAgICAgICAgICAgIHJldHVybiBbeyBmcm9tOiAwLCB0bzogc3RhdGUuZG9jLmxlbmd0aCB9XTtcbiAgICAgICAgaWYgKCFsYW5nIHx8ICFsYW5nLmFsbG93c05lc3RpbmcpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGV4cGxvcmUgPSAodHJlZSwgZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRyZWUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb20sIHRvOiBmcm9tICsgdHJlZS5sZW5ndGggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1vdW50ID0gdHJlZS5wcm9wKE5vZGVQcm9wLm1vdW50ZWQpO1xuICAgICAgICAgICAgaWYgKG1vdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vdW50LnRyZWUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSB0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdW50Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1vdW50Lm92ZXJsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tOiByLmZyb20gKyBmcm9tLCB0bzogci50byArIGZyb20gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbTogZnJvbSwgdG86IGZyb20gKyB0cmVlLmxlbmd0aCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShtb3VudC50cmVlLCBtb3VudC5vdmVybGF5WzBdLmZyb20gKyBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiBzaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IHRyZWUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9yZShjaCwgdHJlZS5wb3NpdGlvbnNbaV0gKyBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZXhwbG9yZShzeW50YXhUcmVlKHN0YXRlKSwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgbGFuZ3VhZ2UgYWxsb3dzIG5lc3RlZCBsYW5ndWFnZXMuIFRoZVxuICAgIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0cnVlLlxuICAgICovXG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiB0cnVlOyB9XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbkxhbmd1YWdlLnNldFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuZnVuY3Rpb24gdG9wTm9kZUF0KHN0YXRlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgdG9wTGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKSwgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpLnRvcE5vZGU7XG4gICAgaWYgKCF0b3BMYW5nIHx8IHRvcExhbmcuYWxsb3dzTmVzdGluZykge1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdHJlZTsgbm9kZTsgbm9kZSA9IG5vZGUuZW50ZXIocG9zLCBzaWRlLCBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycykpXG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLmlzVG9wKVxuICAgICAgICAgICAgICAgIHRyZWUgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZTtcbn1cbi8qKlxuQSBzdWJjbGFzcyBvZiBbYExhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgZm9yIHVzZSB3aXRoIExlemVyXG5bTFIgcGFyc2Vyc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNsci5MUlBhcnNlcilcbnBhcnNlcnMuXG4qL1xuY2xhc3MgTFJMYW5ndWFnZSBleHRlbmRzIExhbmd1YWdlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwYXJzZXIsIG5hbWUpIHtcbiAgICAgICAgc3VwZXIoZGF0YSwgcGFyc2VyLCBbXSwgbmFtZSk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBsYW5ndWFnZSBmcm9tIGEgcGFyc2VyLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7XG4gICAgICAgIGxldCBkYXRhID0gZGVmaW5lTGFuZ3VhZ2VGYWNldChzcGVjLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZShkYXRhLCBzcGVjLnBhcnNlci5jb25maWd1cmUoe1xuICAgICAgICAgICAgcHJvcHM6IFtsYW5ndWFnZURhdGFQcm9wLmFkZCh0eXBlID0+IHR5cGUuaXNUb3AgPyBkYXRhIDogdW5kZWZpbmVkKV1cbiAgICAgICAgfSksIHNwZWMubmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGxhbmd1YWdlIHdpdGggYSByZWNvbmZpZ3VyZWRcbiAgICB2ZXJzaW9uIG9mIGl0cyBwYXJzZXIgYW5kIG9wdGlvbmFsbHkgYSBuZXcgbmFtZS5cbiAgICAqL1xuICAgIGNvbmZpZ3VyZShvcHRpb25zLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgTFJMYW5ndWFnZSh0aGlzLmRhdGEsIHRoaXMucGFyc2VyLmNvbmZpZ3VyZShvcHRpb25zKSwgbmFtZSB8fCB0aGlzLm5hbWUpO1xuICAgIH1cbiAgICBnZXQgYWxsb3dzTmVzdGluZygpIHsgcmV0dXJuIHRoaXMucGFyc2VyLmhhc1dyYXBwZXJzKCk7IH1cbn1cbi8qKlxuR2V0IHRoZSBzeW50YXggdHJlZSBmb3IgYSBzdGF0ZSwgd2hpY2ggaXMgdGhlIGN1cnJlbnQgKHBvc3NpYmx5XG5pbmNvbXBsZXRlKSBwYXJzZSB0cmVlIG9mIHRoZSBhY3RpdmVcbltsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSksIG9yIHRoZSBlbXB0eSB0cmVlIGlmIHRoZXJlIGlzIG5vXG5sYW5ndWFnZSBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gc3ludGF4VHJlZShzdGF0ZSkge1xuICAgIGxldCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGZpZWxkID8gZmllbGQudHJlZSA6IFRyZWUuZW1wdHk7XG59XG4vKipcblRyeSB0byBnZXQgYSBwYXJzZSB0cmVlIHRoYXQgc3BhbnMgYXQgbGVhc3QgdXAgdG8gYHVwdG9gLiBUaGVcbm1ldGhvZCB3aWxsIGRvIGF0IG1vc3QgYHRpbWVvdXRgIG1pbGxpc2Vjb25kcyBvZiB3b3JrIHRvIHBhcnNlXG51cCB0byB0aGF0IHBvaW50IGlmIHRoZSB0cmVlIGlzbid0IGFscmVhZHkgYXZhaWxhYmxlLlxuKi9cbmZ1bmN0aW9uIGVuc3VyZVN5bnRheFRyZWUoc3RhdGUsIHVwdG8sIHRpbWVvdXQgPSA1MCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgcGFyc2UgPSAoX2EgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGV4dDtcbiAgICBpZiAoIXBhcnNlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgb2xkVmllcG9ydCA9IHBhcnNlLnZpZXdwb3J0O1xuICAgIHBhcnNlLnVwZGF0ZVZpZXdwb3J0KHsgZnJvbTogMCwgdG86IHVwdG8gfSk7XG4gICAgbGV0IHJlc3VsdCA9IHBhcnNlLmlzRG9uZSh1cHRvKSB8fCBwYXJzZS53b3JrKHRpbWVvdXQsIHVwdG8pID8gcGFyc2UudHJlZSA6IG51bGw7XG4gICAgcGFyc2UudXBkYXRlVmlld3BvcnQob2xkVmllcG9ydCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuUXVlcmllcyB3aGV0aGVyIHRoZXJlIGlzIGEgZnVsbCBzeW50YXggdHJlZSBhdmFpbGFibGUgdXAgdG8gdGhlXG5naXZlbiBkb2N1bWVudCBwb3NpdGlvbi4gSWYgdGhlcmUgaXNuJ3QsIHRoZSBiYWNrZ3JvdW5kIHBhcnNlXG5wcm9jZXNzIF9taWdodF8gc3RpbGwgYmUgd29ya2luZyBhbmQgdXBkYXRlIHRoZSB0cmVlIGZ1cnRoZXIsIGJ1dFxudGhlcmUgaXMgbm8gZ3VhcmFudGVlIG9mIHRoYXTigJR0aGUgcGFyc2VyIHdpbGwgW3N0b3BcbndvcmtpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2Uuc3ludGF4UGFyc2VyUnVubmluZykgd2hlbiBpdCBoYXMgc3BlbnQgYVxuY2VydGFpbiBhbW91bnQgb2YgdGltZSBvciBoYXMgbW92ZWQgYmV5b25kIHRoZSB2aXNpYmxlIHZpZXdwb3J0LlxuQWx3YXlzIHJldHVybnMgZmFsc2UgaWYgbm8gbGFuZ3VhZ2UgaGFzIGJlZW4gZW5hYmxlZC5cbiovXG5mdW5jdGlvbiBzeW50YXhUcmVlQXZhaWxhYmxlKHN0YXRlLCB1cHRvID0gc3RhdGUuZG9jLmxlbmd0aCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZXh0LmlzRG9uZSh1cHRvKSkgfHwgZmFsc2U7XG59XG4vKipcbk1vdmUgcGFyc2luZyBmb3J3YXJkLCBhbmQgdXBkYXRlIHRoZSBlZGl0b3Igc3RhdGUgYWZ0ZXJ3YXJkcyB0b1xucmVmbGVjdCB0aGUgbmV3IHRyZWUuIFdpbGwgd29yayBmb3IgYXQgbW9zdCBgdGltZW91dGBcbm1pbGxpc2Vjb25kcy4gUmV0dXJucyB0cnVlIGlmIHRoZSBwYXJzZXIgbWFuYWdlZCBnZXQgdG8gdGhlIGdpdmVuXG5wb3NpdGlvbiBpbiB0aGF0IHRpbWUuXG4qL1xuZnVuY3Rpb24gZm9yY2VQYXJzaW5nKHZpZXcsIHVwdG8gPSB2aWV3LnZpZXdwb3J0LnRvLCB0aW1lb3V0ID0gMTAwKSB7XG4gICAgbGV0IHN1Y2Nlc3MgPSBlbnN1cmVTeW50YXhUcmVlKHZpZXcuc3RhdGUsIHVwdG8sIHRpbWVvdXQpO1xuICAgIGlmIChzdWNjZXNzICE9IHN5bnRheFRyZWUodmlldy5zdGF0ZSkpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe30pO1xuICAgIHJldHVybiAhIXN1Y2Nlc3M7XG59XG4vKipcblRlbGxzIHlvdSB3aGV0aGVyIHRoZSBsYW5ndWFnZSBwYXJzZXIgaXMgcGxhbm5pbmcgdG8gZG8gbW9yZVxucGFyc2luZyB3b3JrIChpbiBhIGByZXF1ZXN0SWRsZUNhbGxiYWNrYCBwc2V1ZG8tdGhyZWFkKSBvciBoYXNcbnN0b3BwZWQgcnVubmluZywgZWl0aGVyIGJlY2F1c2UgaXQgcGFyc2VkIHRoZSBlbnRpcmUgZG9jdW1lbnQsXG5iZWNhdXNlIGl0IHNwZW50IHRvbyBtdWNoIHRpbWUgYW5kIHdhcyBjdXQgb2ZmLCBvciBiZWNhdXNlIHRoZXJlXG5pcyBubyBsYW5ndWFnZSBwYXJzZXIgZW5hYmxlZC5cbiovXG5mdW5jdGlvbiBzeW50YXhQYXJzZXJSdW5uaW5nKHZpZXcpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwYXJzZVdvcmtlcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1dvcmtpbmcoKSkgfHwgZmFsc2U7XG59XG4vKipcbkxlemVyLXN0eWxlXG5bYElucHV0YF0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNjb21tb24uSW5wdXQpXG5vYmplY3QgZm9yIGEgW2BUZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0KSBvYmplY3QuXG4qL1xuY2xhc3MgRG9jSW5wdXQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnB1dCBvYmplY3QgZm9yIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRvYykge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSAwO1xuICAgICAgICB0aGlzLnN0cmluZyA9IFwiXCI7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gZG9jLml0ZXIoKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMuZG9jLmxlbmd0aDsgfVxuICAgIHN5bmNUbyhwb3MpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSB0aGlzLmN1cnNvci5uZXh0KHBvcyAtIHRoaXMuY3Vyc29yUG9zKS52YWx1ZTtcbiAgICAgICAgdGhpcy5jdXJzb3JQb3MgPSBwb3MgKyB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvclBvcyAtIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgY2h1bmsocG9zKSB7XG4gICAgICAgIHRoaXMuc3luY1RvKHBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZztcbiAgICB9XG4gICAgZ2V0IGxpbmVDaHVua3MoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgcmVhZChmcm9tLCB0bykge1xuICAgICAgICBsZXQgc3RyaW5nU3RhcnQgPSB0aGlzLmN1cnNvclBvcyAtIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKGZyb20gPCBzdHJpbmdTdGFydCB8fCB0byA+PSB0aGlzLmN1cnNvclBvcylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0byk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShmcm9tIC0gc3RyaW5nU3RhcnQsIHRvIC0gc3RyaW5nU3RhcnQpO1xuICAgIH1cbn1cbmxldCBjdXJyZW50Q29udGV4dCA9IG51bGw7XG4vKipcbkEgcGFyc2UgY29udGV4dCBwcm92aWRlZCB0byBwYXJzZXJzIHdvcmtpbmcgb24gdGhlIGVkaXRvciBjb250ZW50LlxuKi9cbmNsYXNzIFBhcnNlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLyoqXG4gICAgVHJlZSBmcmFnbWVudHMgdGhhdCBjYW4gYmUgcmV1c2VkIGJ5IGluY3JlbWVudGFsIHJlLXBhcnNlcy5cbiAgICAqL1xuICAgIGZyYWdtZW50cyA9IFtdLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRyZWUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHJlZUxlbiwgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHZpZXdwb3J0IChvciBzb21lIG92ZXJhcHByb3hpbWF0aW9uXG4gICAgdGhlcmVvZikuIEludGVuZGVkIHRvIGJlIHVzZWQgZm9yIG9wcG9ydHVuaXN0aWNhbGx5IGF2b2lkaW5nXG4gICAgd29yayAoaW4gd2hpY2ggY2FzZVxuICAgIFtgc2tpcFVudGlsSW5WaWV3YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5QYXJzZUNvbnRleHQuc2tpcFVudGlsSW5WaWV3KVxuICAgIHNob3VsZCBiZSBjYWxsZWQgdG8gbWFrZSBzdXJlIHRoZSBwYXJzZXIgaXMgcmVzdGFydGVkIHdoZW4gdGhlXG4gICAgc2tpcHBlZCByZWdpb24gYmVjb21lcyB2aXNpYmxlKS5cbiAgICAqL1xuICAgIHZpZXdwb3J0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNraXBwZWQsIFxuICAgIC8qKlxuICAgIFRoaXMgaXMgd2hlcmUgc2tpcHBpbmcgcGFyc2VycyBjYW4gcmVnaXN0ZXIgYSBwcm9taXNlIHRoYXQsXG4gICAgd2hlbiByZXNvbHZlZCwgd2lsbCBzY2hlZHVsZSBhIG5ldyBwYXJzZS4gSXQgaXMgY2xlYXJlZCB3aGVuXG4gICAgdGhlIHBhcnNlIHdvcmtlciBwaWNrcyB1cCB0aGUgcHJvbWlzZS4gQGludGVybmFsXG4gICAgKi9cbiAgICBzY2hlZHVsZU9uKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLnRyZWVMZW4gPSB0cmVlTGVuO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHRoaXMuc2tpcHBlZCA9IHNraXBwZWQ7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVPbiA9IHNjaGVkdWxlT247XG4gICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudGVtcFNraXBwZWQgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHBhcnNlciwgc3RhdGUsIHZpZXdwb3J0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0KHBhcnNlciwgc3RhdGUsIFtdLCBUcmVlLmVtcHR5LCAwLCB2aWV3cG9ydCwgW10sIG51bGwpO1xuICAgIH1cbiAgICBzdGFydFBhcnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZXIuc3RhcnRQYXJzZShuZXcgRG9jSW5wdXQodGhpcy5zdGF0ZS5kb2MpLCB0aGlzLmZyYWdtZW50cyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgd29yayh1bnRpbCwgdXB0bykge1xuICAgICAgICBpZiAodXB0byAhPSBudWxsICYmIHVwdG8gPj0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgdXB0byA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMudHJlZSAhPSBUcmVlLmVtcHR5ICYmIHRoaXMuaXNEb25lKHVwdG8gIT09IG51bGwgJiYgdXB0byAhPT0gdm9pZCAwID8gdXB0byA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdW50aWwgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGxldCBlbmRUaW1lID0gRGF0ZS5ub3coKSArIHVudGlsO1xuICAgICAgICAgICAgICAgIHVudGlsID0gKCkgPT4gRGF0ZS5ub3coKSA+IGVuZFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMuc3RhcnRQYXJzZSgpO1xuICAgICAgICAgICAgaWYgKHVwdG8gIT0gbnVsbCAmJiAodGhpcy5wYXJzZS5zdG9wcGVkQXQgPT0gbnVsbCB8fCB0aGlzLnBhcnNlLnN0b3BwZWRBdCA+IHVwdG8pICYmXG4gICAgICAgICAgICAgICAgdXB0byA8IHRoaXMuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlLnN0b3BBdCh1cHRvKTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMucGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRzID0gdGhpcy53aXRob3V0VGVtcFNraXBwZWQoVHJlZUZyYWdtZW50LmFkZFRyZWUoZG9uZSwgdGhpcy5mcmFnbWVudHMsIHRoaXMucGFyc2Uuc3RvcHBlZEF0ICE9IG51bGwpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlTGVuID0gKF9hID0gdGhpcy5wYXJzZS5zdG9wcGVkQXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlID0gZG9uZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyZWVMZW4gPCAodXB0byAhPT0gbnVsbCAmJiB1cHRvICE9PSB2b2lkIDAgPyB1cHRvIDogdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1bnRpbCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRha2VUcmVlKCkge1xuICAgICAgICBsZXQgcG9zLCB0cmVlO1xuICAgICAgICBpZiAodGhpcy5wYXJzZSAmJiAocG9zID0gdGhpcy5wYXJzZS5wYXJzZWRQb3MpID49IHRoaXMudHJlZUxlbikge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2Uuc3RvcHBlZEF0ID09IG51bGwgfHwgdGhpcy5wYXJzZS5zdG9wcGVkQXQgPiBwb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZS5zdG9wQXQocG9zKTtcbiAgICAgICAgICAgIHRoaXMud2l0aENvbnRleHQoKCkgPT4geyB3aGlsZSAoISh0cmVlID0gdGhpcy5wYXJzZS5hZHZhbmNlKCkpKSB7IH0gfSk7XG4gICAgICAgICAgICB0aGlzLnRyZWVMZW4gPSBwb3M7XG4gICAgICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudHMgPSB0aGlzLndpdGhvdXRUZW1wU2tpcHBlZChUcmVlRnJhZ21lbnQuYWRkVHJlZSh0aGlzLnRyZWUsIHRoaXMuZnJhZ21lbnRzLCB0cnVlKSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aXRoQ29udGV4dChmKSB7XG4gICAgICAgIGxldCBwcmV2ID0gY3VycmVudENvbnRleHQ7XG4gICAgICAgIGN1cnJlbnRDb250ZXh0ID0gdGhpcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IHByZXY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2l0aG91dFRlbXBTa2lwcGVkKGZyYWdtZW50cykge1xuICAgICAgICBmb3IgKGxldCByOyByID0gdGhpcy50ZW1wU2tpcHBlZC5wb3AoKTspXG4gICAgICAgICAgICBmcmFnbWVudHMgPSBjdXRGcmFnbWVudHMoZnJhZ21lbnRzLCByLmZyb20sIHIudG8pO1xuICAgICAgICByZXR1cm4gZnJhZ21lbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoYW5nZXMoY2hhbmdlcywgbmV3U3RhdGUpIHtcbiAgICAgICAgbGV0IHsgZnJhZ21lbnRzLCB0cmVlLCB0cmVlTGVuLCB2aWV3cG9ydCwgc2tpcHBlZCB9ID0gdGhpcztcbiAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICBpZiAoIWNoYW5nZXMuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpID0+IHJhbmdlcy5wdXNoKHsgZnJvbUEsIHRvQSwgZnJvbUIsIHRvQiB9KSk7XG4gICAgICAgICAgICBmcmFnbWVudHMgPSBUcmVlRnJhZ21lbnQuYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgcmFuZ2VzKTtcbiAgICAgICAgICAgIHRyZWUgPSBUcmVlLmVtcHR5O1xuICAgICAgICAgICAgdHJlZUxlbiA9IDA7XG4gICAgICAgICAgICB2aWV3cG9ydCA9IHsgZnJvbTogY2hhbmdlcy5tYXBQb3Modmlld3BvcnQuZnJvbSwgLTEpLCB0bzogY2hhbmdlcy5tYXBQb3Modmlld3BvcnQudG8sIDEpIH07XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwcGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIHRoaXMuc2tpcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IGNoYW5nZXMubWFwUG9zKHIuZnJvbSwgMSksIHRvID0gY2hhbmdlcy5tYXBQb3Moci50bywgLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZC5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VDb250ZXh0KHRoaXMucGFyc2VyLCBuZXdTdGF0ZSwgZnJhZ21lbnRzLCB0cmVlLCB0cmVlTGVuLCB2aWV3cG9ydCwgc2tpcHBlZCwgdGhpcy5zY2hlZHVsZU9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1cGRhdGVWaWV3cG9ydCh2aWV3cG9ydCkge1xuICAgICAgICBpZiAodGhpcy52aWV3cG9ydC5mcm9tID09IHZpZXdwb3J0LmZyb20gJiYgdGhpcy52aWV3cG9ydC50byA9PSB2aWV3cG9ydC50bylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICBsZXQgc3RhcnRMZW4gPSB0aGlzLnNraXBwZWQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2tpcHBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMuc2tpcHBlZFtpXTtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgdmlld3BvcnQudG8gJiYgdG8gPiB2aWV3cG9ydC5mcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBjdXRGcmFnbWVudHModGhpcy5mcmFnbWVudHMsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBwZWQuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2tpcHBlZC5sZW5ndGggPj0gc3RhcnRMZW4pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBOb3RpZnkgdGhlIHBhcnNlIHNjaGVkdWxlciB0aGF0IHRoZSBnaXZlbiByZWdpb24gd2FzIHNraXBwZWRcbiAgICBiZWNhdXNlIGl0IHdhc24ndCBpbiB2aWV3LCBhbmQgdGhlIHBhcnNlIHNob3VsZCBiZSByZXN0YXJ0ZWRcbiAgICB3aGVuIGl0IGNvbWVzIGludG8gdmlldy5cbiAgICAqL1xuICAgIHNraXBVbnRpbEluVmlldyhmcm9tLCB0bykge1xuICAgICAgICB0aGlzLnNraXBwZWQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgcGFyc2VyIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgcGxhY2Vob2xkZXIgd2hlblxuICAgIGFzeW5jaHJvbm91c2x5IGxvYWRpbmcgYSBuZXN0ZWQgcGFyc2VyLiBJdCdsbCBza2lwIGl0cyBpbnB1dCBhbmRcbiAgICBtYXJrIGl0IGFzIG5vdC1yZWFsbHktcGFyc2VkLCBzbyB0aGF0IHRoZSBuZXh0IHVwZGF0ZSB3aWxsIHBhcnNlXG4gICAgaXQgYWdhaW4uXG4gICAgXG4gICAgV2hlbiBgdW50aWxgIGlzIGdpdmVuLCBhIHJlcGFyc2Ugd2lsbCBiZSBzY2hlZHVsZWQgd2hlbiB0aGF0XG4gICAgcHJvbWlzZSByZXNvbHZlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBnZXRTa2lwcGluZ1BhcnNlcih1bnRpbCkge1xuICAgICAgICByZXR1cm4gbmV3IGNsYXNzIGV4dGVuZHMgUGFyc2VyIHtcbiAgICAgICAgICAgIGNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcmFuZ2VzWzBdLmZyb20sIHRvID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VyID0ge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRQb3M6IGZyb20sXG4gICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3ggPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC50ZW1wU2tpcHBlZC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bnRpbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3guc2NoZWR1bGVPbiA9IGN4LnNjaGVkdWxlT24gPyBQcm9taXNlLmFsbChbY3guc2NoZWR1bGVPbiwgdW50aWxdKSA6IHVudGlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSB0bztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIHRvIC0gZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRBdDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcEF0KCkgeyB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlzRG9uZSh1cHRvKSB7XG4gICAgICAgIHVwdG8gPSBNYXRoLm1pbih1cHRvLCB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICBsZXQgZnJhZ3MgPSB0aGlzLmZyYWdtZW50cztcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZUxlbiA+PSB1cHRvICYmIGZyYWdzLmxlbmd0aCAmJiBmcmFnc1swXS5mcm9tID09IDAgJiYgZnJhZ3NbMF0udG8gPj0gdXB0bztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjb250ZXh0IGZvciB0aGUgY3VycmVudCBwYXJzZSwgb3IgYG51bGxgIGlmIG5vIGVkaXRvclxuICAgIHBhcnNlIGlzIGluIHByb2dyZXNzLlxuICAgICovXG4gICAgc3RhdGljIGdldCgpIHsgcmV0dXJuIGN1cnJlbnRDb250ZXh0OyB9XG59XG5mdW5jdGlvbiBjdXRGcmFnbWVudHMoZnJhZ21lbnRzLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBUcmVlRnJhZ21lbnQuYXBwbHlDaGFuZ2VzKGZyYWdtZW50cywgW3sgZnJvbUE6IGZyb20sIHRvQTogdG8sIGZyb21COiBmcm9tLCB0b0I6IHRvIH1dKTtcbn1cbmNsYXNzIExhbmd1YWdlU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIEEgbXV0YWJsZSBwYXJzZSBzdGF0ZSB0aGF0IGlzIHVzZWQgdG8gcHJlc2VydmUgd29yayBkb25lIGR1cmluZ1xuICAgIC8vIHRoZSBsaWZldGltZSBvZiBhIHN0YXRlIHdoZW4gbW92aW5nIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy50cmVlID0gY29udGV4dC50cmVlO1xuICAgIH1cbiAgICBhcHBseSh0cikge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgJiYgdGhpcy50cmVlID09IHRoaXMuY29udGV4dC50cmVlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBuZXdDeCA9IHRoaXMuY29udGV4dC5jaGFuZ2VzKHRyLmNoYW5nZXMsIHRyLnN0YXRlKTtcbiAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIHBhcnNlIHdhc24ndCBkb25lLCBnbyBmb3J3YXJkIG9ubHkgdXAgdG8gaXRzXG4gICAgICAgIC8vIGVuZCBwb3NpdGlvbiBvciB0aGUgZW5kIG9mIHRoZSB2aWV3cG9ydCwgdG8gYXZvaWQgc2xvd2luZyBkb3duXG4gICAgICAgIC8vIHN0YXRlIHVwZGF0ZXMgd2l0aCBwYXJzZSB3b3JrIGJleW9uZCB0aGUgdmlld3BvcnQuXG4gICAgICAgIGxldCB1cHRvID0gdGhpcy5jb250ZXh0LnRyZWVMZW4gPT0gdHIuc3RhcnRTdGF0ZS5kb2MubGVuZ3RoID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IE1hdGgubWF4KHRyLmNoYW5nZXMubWFwUG9zKHRoaXMuY29udGV4dC50cmVlTGVuKSwgbmV3Q3gudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAoIW5ld0N4LndvcmsoMjAgLyogV29yay5BcHBseSAqLywgdXB0bykpXG4gICAgICAgICAgICBuZXdDeC50YWtlVHJlZSgpO1xuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlU3RhdGUobmV3Q3gpO1xuICAgIH1cbiAgICBzdGF0aWMgaW5pdChzdGF0ZSkge1xuICAgICAgICBsZXQgdnBUbyA9IE1hdGgubWluKDMwMDAgLyogV29yay5Jbml0Vmlld3BvcnQgKi8sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICBsZXQgcGFyc2VTdGF0ZSA9IFBhcnNlQ29udGV4dC5jcmVhdGUoc3RhdGUuZmFjZXQobGFuZ3VhZ2UpLnBhcnNlciwgc3RhdGUsIHsgZnJvbTogMCwgdG86IHZwVG8gfSk7XG4gICAgICAgIGlmICghcGFyc2VTdGF0ZS53b3JrKDIwIC8qIFdvcmsuQXBwbHkgKi8sIHZwVG8pKVxuICAgICAgICAgICAgcGFyc2VTdGF0ZS50YWtlVHJlZSgpO1xuICAgICAgICByZXR1cm4gbmV3IExhbmd1YWdlU3RhdGUocGFyc2VTdGF0ZSk7XG4gICAgfVxufVxuTGFuZ3VhZ2Uuc3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZTogTGFuZ3VhZ2VTdGF0ZS5pbml0LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKVxuICAgICAgICAgICAgaWYgKGUuaXMoTGFuZ3VhZ2Uuc2V0U3RhdGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgICAgICBpZiAodHIuc3RhcnRTdGF0ZS5mYWNldChsYW5ndWFnZSkgIT0gdHIuc3RhdGUuZmFjZXQobGFuZ3VhZ2UpKVxuICAgICAgICAgICAgcmV0dXJuIExhbmd1YWdlU3RhdGUuaW5pdCh0ci5zdGF0ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0cik7XG4gICAgfVxufSk7XG5sZXQgcmVxdWVzdElkbGUgPSAoY2FsbGJhY2spID0+IHtcbiAgICBsZXQgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gY2FsbGJhY2soKSwgNTAwIC8qIFdvcmsuTWF4UGF1c2UgKi8pO1xuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dCk7XG59O1xuaWYgKHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrICE9IFwidW5kZWZpbmVkXCIpXG4gICAgcmVxdWVzdElkbGUgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgbGV0IGlkbGUgPSAtMSwgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWRsZSA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soY2FsbGJhY2ssIHsgdGltZW91dDogNTAwIC8qIFdvcmsuTWF4UGF1c2UgKi8gLSAxMDAgLyogV29yay5NaW5QYXVzZSAqLyB9KTtcbiAgICAgICAgfSwgMTAwIC8qIFdvcmsuTWluUGF1c2UgKi8pO1xuICAgICAgICByZXR1cm4gKCkgPT4gaWRsZSA8IDAgPyBjbGVhclRpbWVvdXQodGltZW91dCkgOiBjYW5jZWxJZGxlQ2FsbGJhY2soaWRsZSk7XG4gICAgfTtcbmNvbnN0IGlzSW5wdXRQZW5kaW5nID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmICgoX2EgPSBuYXZpZ2F0b3Iuc2NoZWR1bGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzSW5wdXRQZW5kaW5nKVxuICAgID8gKCkgPT4gbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcoKSA6IG51bGw7XG5jb25zdCBwYXJzZVdvcmtlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyBQYXJzZVdvcmtlciB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLndvcmtpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLndvcmtTY2hlZHVsZWQgPSAwO1xuICAgICAgICAvLyBFbmQgb2YgdGhlIGN1cnJlbnQgdGltZSBjaHVua1xuICAgICAgICB0aGlzLmNodW5rRW5kID0gLTE7XG4gICAgICAgIC8vIE1pbGxpc2Vjb25kcyBvZiBidWRnZXQgbGVmdCBmb3IgdGhpcyBjaHVua1xuICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ID0gLTE7XG4gICAgICAgIHRoaXMud29yayA9IHRoaXMud29yay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjeCA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSkuY29udGV4dDtcbiAgICAgICAgaWYgKGN4LnVwZGF0ZVZpZXdwb3J0KHVwZGF0ZS52aWV3LnZpZXdwb3J0KSB8fCB0aGlzLnZpZXcudmlld3BvcnQudG8gPiBjeC50cmVlTGVuKVxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaGFzRm9jdXMpXG4gICAgICAgICAgICAgICAgdGhpcy5jaHVua0J1ZGdldCArPSA1MCAvKiBXb3JrLkNoYW5nZUJvbnVzICovO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVdvcmsoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrQXN5bmNTY2hlZHVsZShjeCk7XG4gICAgfVxuICAgIHNjaGVkdWxlV29yaygpIHtcbiAgICAgICAgaWYgKHRoaXMud29ya2luZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHRoaXMudmlldywgZmllbGQgPSBzdGF0ZS5maWVsZChMYW5ndWFnZS5zdGF0ZSk7XG4gICAgICAgIGlmIChmaWVsZC50cmVlICE9IGZpZWxkLmNvbnRleHQudHJlZSB8fCAhZmllbGQuY29udGV4dC5pc0RvbmUoc3RhdGUuZG9jLmxlbmd0aCkpXG4gICAgICAgICAgICB0aGlzLndvcmtpbmcgPSByZXF1ZXN0SWRsZSh0aGlzLndvcmspO1xuICAgIH1cbiAgICB3b3JrKGRlYWRsaW5lKSB7XG4gICAgICAgIHRoaXMud29ya2luZyA9IG51bGw7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAodGhpcy5jaHVua0VuZCA8IG5vdyAmJiAodGhpcy5jaHVua0VuZCA8IDAgfHwgdGhpcy52aWV3Lmhhc0ZvY3VzKSkgeyAvLyBTdGFydCBhIG5ldyBjaHVua1xuICAgICAgICAgICAgdGhpcy5jaHVua0VuZCA9IG5vdyArIDMwMDAwIC8qIFdvcmsuQ2h1bmtUaW1lICovO1xuICAgICAgICAgICAgdGhpcy5jaHVua0J1ZGdldCA9IDMwMDAgLyogV29yay5DaHVua0J1ZGdldCAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaHVua0J1ZGdldCA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBObyBtb3JlIGJ1ZGdldFxuICAgICAgICBsZXQgeyBzdGF0ZSwgdmlld3BvcnQ6IHsgdG86IHZwVG8gfSB9ID0gdGhpcy52aWV3LCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKTtcbiAgICAgICAgaWYgKGZpZWxkLnRyZWUgPT0gZmllbGQuY29udGV4dC50cmVlICYmIGZpZWxkLmNvbnRleHQuaXNEb25lKHZwVG8gKyAxMDAwMDAgLyogV29yay5NYXhQYXJzZUFoZWFkICovKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGVuZFRpbWUgPSBEYXRlLm5vdygpICsgTWF0aC5taW4odGhpcy5jaHVua0J1ZGdldCwgMTAwIC8qIFdvcmsuU2xpY2UgKi8sIGRlYWRsaW5lICYmICFpc0lucHV0UGVuZGluZyA/IE1hdGgubWF4KDI1IC8qIFdvcmsuTWluU2xpY2UgKi8sIGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSAtIDUpIDogMWU5KTtcbiAgICAgICAgbGV0IHZpZXdwb3J0Rmlyc3QgPSBmaWVsZC5jb250ZXh0LnRyZWVMZW4gPCB2cFRvICYmIHN0YXRlLmRvYy5sZW5ndGggPiB2cFRvICsgMTAwMDtcbiAgICAgICAgbGV0IGRvbmUgPSBmaWVsZC5jb250ZXh0LndvcmsoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlzSW5wdXRQZW5kaW5nICYmIGlzSW5wdXRQZW5kaW5nKCkgfHwgRGF0ZS5ub3coKSA+IGVuZFRpbWU7XG4gICAgICAgIH0sIHZwVG8gKyAodmlld3BvcnRGaXJzdCA/IDAgOiAxMDAwMDAgLyogV29yay5NYXhQYXJzZUFoZWFkICovKSk7XG4gICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgLT0gRGF0ZS5ub3coKSAtIG5vdztcbiAgICAgICAgaWYgKGRvbmUgfHwgdGhpcy5jaHVua0J1ZGdldCA8PSAwKSB7XG4gICAgICAgICAgICBmaWVsZC5jb250ZXh0LnRha2VUcmVlKCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBMYW5ndWFnZS5zZXRTdGF0ZS5vZihuZXcgTGFuZ3VhZ2VTdGF0ZShmaWVsZC5jb250ZXh0KSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtCdWRnZXQgPiAwICYmICEoZG9uZSAmJiAhdmlld3BvcnRGaXJzdCkpXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICB0aGlzLmNoZWNrQXN5bmNTY2hlZHVsZShmaWVsZC5jb250ZXh0KTtcbiAgICB9XG4gICAgY2hlY2tBc3luY1NjaGVkdWxlKGN4KSB7XG4gICAgICAgIGlmIChjeC5zY2hlZHVsZU9uKSB7XG4gICAgICAgICAgICB0aGlzLndvcmtTY2hlZHVsZWQrKztcbiAgICAgICAgICAgIGN4LnNjaGVkdWxlT25cbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLnNjaGVkdWxlV29yaygpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4gbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZXJyKSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLndvcmtTY2hlZHVsZWQtLSk7XG4gICAgICAgICAgICBjeC5zY2hlZHVsZU9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nKVxuICAgICAgICAgICAgdGhpcy53b3JraW5nKCk7XG4gICAgfVxuICAgIGlzV29ya2luZygpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMud29ya2luZyB8fCB0aGlzLndvcmtTY2hlZHVsZWQgPiAwKTtcbiAgICB9XG59LCB7XG4gICAgZXZlbnRIYW5kbGVyczogeyBmb2N1cygpIHsgdGhpcy5zY2hlZHVsZVdvcmsoKTsgfSB9XG59KTtcbi8qKlxuVGhlIGZhY2V0IHVzZWQgdG8gYXNzb2NpYXRlIGEgbGFuZ3VhZ2Ugd2l0aCBhbiBlZGl0b3Igc3RhdGUuIFVzZWRcbmJ5IGBMYW5ndWFnZWAgb2JqZWN0J3MgYGV4dGVuc2lvbmAgcHJvcGVydHkgKHNvIHlvdSBkb24ndCBuZWVkIHRvXG5tYW51YWxseSB3cmFwIHlvdXIgbGFuZ3VhZ2VzIGluIHRoaXMpLiBDYW4gYmUgdXNlZCB0byBhY2Nlc3MgdGhlXG5jdXJyZW50IGxhbmd1YWdlIG9uIGEgc3RhdGUuXG4qL1xuY29uc3QgbGFuZ3VhZ2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGxhbmd1YWdlcykgeyByZXR1cm4gbGFuZ3VhZ2VzLmxlbmd0aCA/IGxhbmd1YWdlc1swXSA6IG51bGw7IH0sXG4gICAgZW5hYmxlczogbGFuZ3VhZ2UgPT4gW1xuICAgICAgICBMYW5ndWFnZS5zdGF0ZSxcbiAgICAgICAgcGFyc2VXb3JrZXIsXG4gICAgICAgIEVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMuY29tcHV0ZShbbGFuZ3VhZ2VdLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKTtcbiAgICAgICAgICAgIHJldHVybiBsYW5nICYmIGxhbmcubmFtZSA/IHsgXCJkYXRhLWxhbmd1YWdlXCI6IGxhbmcubmFtZSB9IDoge307XG4gICAgICAgIH0pXG4gICAgXVxufSk7XG4vKipcblRoaXMgY2xhc3MgYnVuZGxlcyBhIFtsYW5ndWFnZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkgd2l0aCBhblxub3B0aW9uYWwgc2V0IG9mIHN1cHBvcnRpbmcgZXh0ZW5zaW9ucy4gTGFuZ3VhZ2UgcGFja2FnZXMgYXJlXG5lbmNvdXJhZ2VkIHRvIGV4cG9ydCBhIGZ1bmN0aW9uIHRoYXQgb3B0aW9uYWxseSB0YWtlcyBhXG5jb25maWd1cmF0aW9uIG9iamVjdCBhbmQgcmV0dXJucyBhIGBMYW5ndWFnZVN1cHBvcnRgIGluc3RhbmNlLCBhc1xudGhlIG1haW4gd2F5IGZvciBjbGllbnQgY29kZSB0byB1c2UgdGhlIHBhY2thZ2UuXG4qL1xuY2xhc3MgTGFuZ3VhZ2VTdXBwb3J0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBsYW5ndWFnZSBzdXBwb3J0IG9iamVjdC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsYW5ndWFnZSBvYmplY3QuXG4gICAgKi9cbiAgICBsYW5ndWFnZSwgXG4gICAgLyoqXG4gICAgQW4gb3B0aW9uYWwgc2V0IG9mIHN1cHBvcnRpbmcgZXh0ZW5zaW9ucy4gV2hlbiBuZXN0aW5nIGFcbiAgICBsYW5ndWFnZSBpbiBhbm90aGVyIGxhbmd1YWdlLCB0aGUgb3V0ZXIgbGFuZ3VhZ2UgaXMgZW5jb3VyYWdlZFxuICAgIHRvIGluY2x1ZGUgdGhlIHN1cHBvcnRpbmcgZXh0ZW5zaW9ucyBmb3IgaXRzIGlubmVyIGxhbmd1YWdlc1xuICAgIGluIGl0cyBvd24gc2V0IG9mIHN1cHBvcnQgZXh0ZW5zaW9ucy5cbiAgICAqL1xuICAgIHN1cHBvcnQgPSBbXSkge1xuICAgICAgICB0aGlzLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gICAgICAgIHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQ7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gW2xhbmd1YWdlLCBzdXBwb3J0XTtcbiAgICB9XG59XG4vKipcbkxhbmd1YWdlIGRlc2NyaXB0aW9ucyBhcmUgdXNlZCB0byBzdG9yZSBtZXRhZGF0YSBhYm91dCBsYW5ndWFnZXNcbmFuZCB0byBkeW5hbWljYWxseSBsb2FkIHRoZW0uIFRoZWlyIG1haW4gcm9sZSBpcyBmaW5kaW5nIHRoZVxuYXBwcm9wcmlhdGUgbGFuZ3VhZ2UgZm9yIGEgZmlsZW5hbWUgb3IgZHluYW1pY2FsbHkgbG9hZGluZyBuZXN0ZWRcbnBhcnNlcnMuXG4qL1xuY2xhc3MgTGFuZ3VhZ2VEZXNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgb2YgdGhpcyBsYW5ndWFnZS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEFsdGVybmF0aXZlIG5hbWVzIGZvciB0aGUgbW9kZSAobG93ZXJjYXNlZCwgaW5jbHVkZXMgYHRoaXMubmFtZWApLlxuICAgICovXG4gICAgYWxpYXMsIFxuICAgIC8qKlxuICAgIEZpbGUgZXh0ZW5zaW9ucyBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYW5ndWFnZS5cbiAgICAqL1xuICAgIGV4dGVuc2lvbnMsIFxuICAgIC8qKlxuICAgIE9wdGlvbmFsIGZpbGVuYW1lIHBhdHRlcm4gdGhhdCBzaG91bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHRoaXNcbiAgICBsYW5ndWFnZS5cbiAgICAqL1xuICAgIGZpbGVuYW1lLCBsb2FkRnVuYywgXG4gICAgLyoqXG4gICAgSWYgdGhlIGxhbmd1YWdlIGhhcyBiZWVuIGxvYWRlZCwgdGhpcyB3aWxsIGhvbGQgaXRzIHZhbHVlLlxuICAgICovXG4gICAgc3VwcG9ydCA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFsaWFzID0gYWxpYXM7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5sb2FkRnVuYyA9IGxvYWRGdW5jO1xuICAgICAgICB0aGlzLnN1cHBvcnQgPSBzdXBwb3J0O1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGFydCBsb2FkaW5nIHRoZSB0aGUgbGFuZ3VhZ2UuIFdpbGwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0XG4gICAgcmVzb2x2ZXMgdG8gYSBbYExhbmd1YWdlU3VwcG9ydGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2VTdXBwb3J0KVxuICAgIG9iamVjdCB3aGVuIHRoZSBsYW5ndWFnZSBzdWNjZXNzZnVsbHkgbG9hZHMuXG4gICAgKi9cbiAgICBsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkaW5nIHx8ICh0aGlzLmxvYWRpbmcgPSB0aGlzLmxvYWRGdW5jKCkudGhlbihzdXBwb3J0ID0+IHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQsIGVyciA9PiB7IHRoaXMubG9hZGluZyA9IG51bGw7IHRocm93IGVycjsgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBsYW5ndWFnZSBkZXNjcmlwdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihzcGVjKSB7XG4gICAgICAgIGxldCB7IGxvYWQsIHN1cHBvcnQgfSA9IHNwZWM7XG4gICAgICAgIGlmICghbG9hZCkge1xuICAgICAgICAgICAgaWYgKCFzdXBwb3J0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVzdCBwYXNzIGVpdGhlciAnbG9hZCcgb3IgJ3N1cHBvcnQnIHRvIExhbmd1YWdlRGVzY3JpcHRpb24ub2ZcIik7XG4gICAgICAgICAgICBsb2FkID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHN1cHBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VEZXNjcmlwdGlvbihzcGVjLm5hbWUsIChzcGVjLmFsaWFzIHx8IFtdKS5jb25jYXQoc3BlYy5uYW1lKS5tYXAocyA9PiBzLnRvTG93ZXJDYXNlKCkpLCBzcGVjLmV4dGVuc2lvbnMgfHwgW10sIHNwZWMuZmlsZW5hbWUsIGxvYWQsIHN1cHBvcnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciBhIGxhbmd1YWdlIGluIHRoZSBnaXZlbiBhcnJheSBvZiBkZXNjcmlwdGlvbnMgdGhhdFxuICAgIG1hdGNoZXMgdGhlIGZpbGVuYW1lLiBXaWxsIGZpcnN0IG1hdGNoXG4gICAgW2BmaWxlbmFtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2VEZXNjcmlwdGlvbi5maWxlbmFtZSkgcGF0dGVybnMsXG4gICAgYW5kIHRoZW4gW2V4dGVuc2lvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2VEZXNjcmlwdGlvbi5leHRlbnNpb25zKSxcbiAgICBhbmQgcmV0dXJuIHRoZSBmaXJzdCBsYW5ndWFnZSB0aGF0IG1hdGNoZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF0Y2hGaWxlbmFtZShkZXNjcywgZmlsZW5hbWUpIHtcbiAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgIGlmIChkLmZpbGVuYW1lICYmIGQuZmlsZW5hbWUudGVzdChmaWxlbmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIGxldCBleHQgPSAvXFwuKFteLl0rKSQvLmV4ZWMoZmlsZW5hbWUpO1xuICAgICAgICBpZiAoZXh0KVxuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgICAgICBpZiAoZC5leHRlbnNpb25zLmluZGV4T2YoZXh0WzFdKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIGEgbGFuZ3VhZ2Ugd2hvc2UgbmFtZSBvciBhbGlhcyBtYXRjaGVzIHRoZSB0aGUgZ2l2ZW5cbiAgICBuYW1lIChjYXNlLWluc2Vuc2l0aXZlbHkpLiBJZiBgZnV6enlgIGlzIHRydWUsIGFuZCBubyBkaXJlY3RcbiAgICBtYXRjaHMgaXMgZm91bmQsIHRoaXMnbGwgYWxzbyBzZWFyY2ggZm9yIGEgbGFuZ3VhZ2Ugd2hvc2UgbmFtZVxuICAgIG9yIGFsaWFzIG9jY3VycyBpbiB0aGUgc3RyaW5nIChmb3IgbmFtZXMgc2hvcnRlciB0aGFuIHRocmVlXG4gICAgY2hhcmFjdGVycywgb25seSB3aGVuIHN1cnJvdW5kZWQgYnkgbm9uLXdvcmQgY2hhcmFjdGVycykuXG4gICAgKi9cbiAgICBzdGF0aWMgbWF0Y2hMYW5ndWFnZU5hbWUoZGVzY3MsIG5hbWUsIGZ1enp5ID0gdHJ1ZSkge1xuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgaWYgKGQuYWxpYXMuc29tZShhID0+IGEgPT0gbmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIGlmIChmdXp6eSlcbiAgICAgICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYSBvZiBkLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IG5hbWUuaW5kZXhPZihhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kID4gLTEgJiYgKGEubGVuZ3RoID4gMiB8fCAhL1xcdy8udGVzdChuYW1lW2ZvdW5kIC0gMV0pICYmICEvXFx3Ly50ZXN0KG5hbWVbZm91bmQgKyBhLmxlbmd0aF0pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbkZhY2V0IHRoYXQgZGVmaW5lcyBhIHdheSB0byBwcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBjb21wdXRlcyB0aGVcbmFwcHJvcHJpYXRlIGluZGVudGF0aW9uIGRlcHRoLCBhcyBhIGNvbHVtbiBudW1iZXIgKHNlZVxuW2BpbmRlbnRTdHJpbmdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFN0cmluZykpLCBhdCB0aGUgc3RhcnQgb2YgYSBnaXZlblxubGluZS4gQSByZXR1cm4gdmFsdWUgb2YgYG51bGxgIGluZGljYXRlcyBubyBpbmRlbnRhdGlvbiBjYW4gYmVcbmRldGVybWluZWQsIGFuZCB0aGUgbGluZSBzaG91bGQgaW5oZXJpdCB0aGUgaW5kZW50YXRpb24gb2YgdGhlIG9uZVxuYWJvdmUgaXQuIEEgcmV0dXJuIHZhbHVlIG9mIGB1bmRlZmluZWRgIGRlZmVycyB0byB0aGUgbmV4dCBpbmRlbnRcbnNlcnZpY2UuXG4qL1xuY29uc3QgaW5kZW50U2VydmljZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRmFjZXQgZm9yIG92ZXJyaWRpbmcgdGhlIHVuaXQgYnkgd2hpY2ggaW5kZW50YXRpb24gaGFwcGVucy4gU2hvdWxkXG5iZSBhIHN0cmluZyBjb25zaXN0aW5nIGVpdGhlciBlbnRpcmVseSBvZiB0aGUgc2FtZSB3aGl0ZXNwYWNlXG5jaGFyYWN0ZXIuIFdoZW4gbm90IHNldCwgdGhpcyBkZWZhdWx0cyB0byAyIHNwYWNlcy5cbiovXG5jb25zdCBpbmRlbnRVbml0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFwiICBcIjtcbiAgICAgICAgbGV0IHVuaXQgPSB2YWx1ZXNbMF07XG4gICAgICAgIGlmICghdW5pdCB8fCAvXFxTLy50ZXN0KHVuaXQpIHx8IEFycmF5LmZyb20odW5pdCkuc29tZShlID0+IGUgIT0gdW5pdFswXSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluZGVudCB1bml0OiBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlc1swXSkpO1xuICAgICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG59KTtcbi8qKlxuUmV0dXJuIHRoZSBfY29sdW1uIHdpZHRoXyBvZiBhbiBpbmRlbnQgdW5pdCBpbiB0aGUgc3RhdGUuXG5EZXRlcm1pbmVkIGJ5IHRoZSBbYGluZGVudFVuaXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpXG5mYWNldCwgYW5kIFtgdGFiU2l6ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSkgd2hlbiB0aGF0XG5jb250YWlucyB0YWJzLlxuKi9cbmZ1bmN0aW9uIGdldEluZGVudFVuaXQoc3RhdGUpIHtcbiAgICBsZXQgdW5pdCA9IHN0YXRlLmZhY2V0KGluZGVudFVuaXQpO1xuICAgIHJldHVybiB1bml0LmNoYXJDb2RlQXQoMCkgPT0gOSA/IHN0YXRlLnRhYlNpemUgKiB1bml0Lmxlbmd0aCA6IHVuaXQubGVuZ3RoO1xufVxuLyoqXG5DcmVhdGUgYW4gaW5kZW50YXRpb24gc3RyaW5nIHRoYXQgY292ZXJzIGNvbHVtbnMgMCB0byBgY29sc2AuXG5XaWxsIHVzZSB0YWJzIGZvciBhcyBtdWNoIG9mIHRoZSBjb2x1bW5zIGFzIHBvc3NpYmxlIHdoZW4gdGhlXG5bYGluZGVudFVuaXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFVuaXQpIGZhY2V0IGNvbnRhaW5zXG50YWJzLlxuKi9cbmZ1bmN0aW9uIGluZGVudFN0cmluZyhzdGF0ZSwgY29scykge1xuICAgIGxldCByZXN1bHQgPSBcIlwiLCB0cyA9IHN0YXRlLnRhYlNpemUsIGNoID0gc3RhdGUuZmFjZXQoaW5kZW50VW5pdClbMF07XG4gICAgaWYgKGNoID09IFwiXFx0XCIpIHtcbiAgICAgICAgd2hpbGUgKGNvbHMgPj0gdHMpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcdFwiO1xuICAgICAgICAgICAgY29scyAtPSB0cztcbiAgICAgICAgfVxuICAgICAgICBjaCA9IFwiIFwiO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHM7IGkrKylcbiAgICAgICAgcmVzdWx0ICs9IGNoO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkdldCB0aGUgaW5kZW50YXRpb24sIGFzIGEgY29sdW1uIG51bWJlciwgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuV2lsbCBmaXJzdCBjb25zdWx0IGFueSBbaW5kZW50IHNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpXG50aGF0IGFyZSByZWdpc3RlcmVkLCBhbmQgaWYgbm9uZSBvZiB0aG9zZSByZXR1cm4gYW4gaW5kZW50YXRpb24sXG50aGlzIHdpbGwgY2hlY2sgdGhlIHN5bnRheCB0cmVlIGZvciB0aGUgW2luZGVudCBub2RlXG5wcm9wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudE5vZGVQcm9wKSBhbmQgdXNlIHRoYXQgaWYgZm91bmQuIFJldHVybnMgYVxubnVtYmVyIHdoZW4gYW4gaW5kZW50YXRpb24gY291bGQgYmUgZGV0ZXJtaW5lZCwgYW5kIG51bGxcbm90aGVyd2lzZS5cbiovXG5mdW5jdGlvbiBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBwb3MpIHtcbiAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIEVkaXRvclN0YXRlKVxuICAgICAgICBjb250ZXh0ID0gbmV3IEluZGVudENvbnRleHQoY29udGV4dCk7XG4gICAgZm9yIChsZXQgc2VydmljZSBvZiBjb250ZXh0LnN0YXRlLmZhY2V0KGluZGVudFNlcnZpY2UpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXJ2aWNlKGNvbnRleHQsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShjb250ZXh0LnN0YXRlKTtcbiAgICByZXR1cm4gdHJlZS5sZW5ndGggPj0gcG9zID8gc3ludGF4SW5kZW50YXRpb24oY29udGV4dCwgdHJlZSwgcG9zKSA6IG51bGw7XG59XG4vKipcbkNyZWF0ZSBhIGNoYW5nZSBzZXQgdGhhdCBhdXRvLWluZGVudHMgYWxsIGxpbmVzIHRvdWNoZWQgYnkgdGhlXG5naXZlbiBkb2N1bWVudCByYW5nZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRSYW5nZShzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICBsZXQgdXBkYXRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChzdGF0ZSwgeyBvdmVycmlkZUluZGVudGF0aW9uOiBzdGFydCA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHVwZGF0ZWRbc3RhcnRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAtMTsgfSB9KTtcbiAgICBsZXQgY2hhbmdlcyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IGZyb207IHBvcyA8PSB0bzspIHtcbiAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIHBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oY29udGV4dCwgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICghL1xcUy8udGVzdChsaW5lLnRleHQpKVxuICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgaWYgKGN1ciAhPSBub3JtKSB7XG4gICAgICAgICAgICB1cGRhdGVkW2xpbmUuZnJvbV0gPSBpbmRlbnQ7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmNoYW5nZXMoY2hhbmdlcyk7XG59XG4vKipcbkluZGVudGF0aW9uIGNvbnRleHRzIGFyZSB1c2VkIHdoZW4gY2FsbGluZyBbaW5kZW50YXRpb25cbnNlcnZpY2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmluZGVudFNlcnZpY2UpLiBUaGV5IHByb3ZpZGUgaGVscGVyIHV0aWxpdGllc1xudXNlZnVsIGluIGluZGVudGF0aW9uIGxvZ2ljLCBhbmQgY2FuIHNlbGVjdGl2ZWx5IG92ZXJyaWRlIHRoZVxuaW5kZW50YXRpb24gcmVwb3J0ZWQgZm9yIHNvbWUgbGluZXMuXG4qL1xuY2xhc3MgSW5kZW50Q29udGV4dCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluZGVudCBjb250ZXh0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudW5pdCA9IGdldEluZGVudFVuaXQoc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBkZXNjcmlwdGlvbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIHRha2luZ1xuICAgIFtzaW11bGF0ZWQgbGluZVxuICAgIGJyZWFrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5JbmRlbnRDb250ZXh0LmNvbnN0cnVjdG9yXm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICBpbnRvIGFjY291bnQuIElmIHRoZXJlIGlzIHN1Y2ggYSBicmVhayBhdCBgcG9zYCwgdGhlIGBiaWFzYFxuICAgIGFyZ3VtZW50IGRldGVybWluZXMgd2hldGhlciB0aGUgcGFydCBvZiB0aGUgbGluZSBsaW5lIGJlZm9yZSBvclxuICAgIGFmdGVyIHRoZSBicmVhayBpcyB1c2VkLlxuICAgICovXG4gICAgbGluZUF0KHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IHsgc2ltdWxhdGVCcmVhaywgc2ltdWxhdGVEb3VibGVCcmVhayB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoc2ltdWxhdGVCcmVhayAhPSBudWxsICYmIHNpbXVsYXRlQnJlYWsgPj0gbGluZS5mcm9tICYmIHNpbXVsYXRlQnJlYWsgPD0gbGluZS50bykge1xuICAgICAgICAgICAgaWYgKHNpbXVsYXRlRG91YmxlQnJlYWsgJiYgc2ltdWxhdGVCcmVhayA9PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdGV4dDogXCJcIiwgZnJvbTogcG9zIH07XG4gICAgICAgICAgICBlbHNlIGlmIChiaWFzIDwgMCA/IHNpbXVsYXRlQnJlYWsgPCBwb3MgOiBzaW11bGF0ZUJyZWFrIDw9IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnRleHQuc2xpY2Uoc2ltdWxhdGVCcmVhayAtIGxpbmUuZnJvbSksIGZyb206IHNpbXVsYXRlQnJlYWsgfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBsaW5lLnRleHQuc2xpY2UoMCwgc2ltdWxhdGVCcmVhayAtIGxpbmUuZnJvbSksIGZyb206IGxpbmUuZnJvbSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHRleHQgZGlyZWN0bHkgYWZ0ZXIgYHBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICB0ZXh0QWZ0ZXJQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbXVsYXRlRG91YmxlQnJlYWsgJiYgcG9zID09IHRoaXMub3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKHBvcyAtIGZyb20sIE1hdGgubWluKHRleHQubGVuZ3RoLCBwb3MgKyAxMDAgLSBmcm9tKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGNvbHVtbiBmb3IgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgY29sdW1uKHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY291bnRDb2x1bW4odGV4dCwgcG9zIC0gZnJvbSk7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uID8gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb24oZnJvbSkgOiAtMTtcbiAgICAgICAgaWYgKG92ZXJyaWRlID4gLTEpXG4gICAgICAgICAgICByZXN1bHQgKz0gb3ZlcnJpZGUgLSB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHRleHQuc2VhcmNoKC9cXFN8JC8pKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY29sdW1uIHBvc2l0aW9uICh0YWtpbmcgdGFicyBpbnRvIGFjY291bnQpIG9mIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICBjb3VudENvbHVtbihsaW5lLCBwb3MgPSBsaW5lLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY291bnRDb2x1bW4obGluZSwgdGhpcy5zdGF0ZS50YWJTaXplLCBwb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBpbmRlbnRhdGlvbiBjb2x1bW4gb2YgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHBvaW50LlxuICAgICovXG4gICAgbGluZUluZGVudChwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20gfSA9IHRoaXMubGluZUF0KHBvcywgYmlhcyk7XG4gICAgICAgIGxldCBvdmVycmlkZSA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uO1xuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGxldCBvdmVycmlkZW4gPSBvdmVycmlkZShmcm9tKTtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZW4gPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50Q29sdW1uKHRleHQsIHRleHQuc2VhcmNoKC9cXFN8JC8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgW3NpbXVsYXRlZCBsaW5lXG4gICAgYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgZm9yIHRoaXMgY29udGV4dCwgaWYgYW55LlxuICAgICovXG4gICAgZ2V0IHNpbXVsYXRlZEJyZWFrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpbXVsYXRlQnJlYWsgfHwgbnVsbDtcbiAgICB9XG59XG4vKipcbkEgc3ludGF4IHRyZWUgbm9kZSBwcm9wIHVzZWQgdG8gYXNzb2NpYXRlIGluZGVudGF0aW9uIHN0cmF0ZWdpZXNcbndpdGggbm9kZSB0eXBlcy4gU3VjaCBhIHN0cmF0ZWd5IGlzIGEgZnVuY3Rpb24gZnJvbSBhbiBpbmRlbnRhdGlvblxuY29udGV4dCB0byBhIGNvbHVtbiBudW1iZXIgKHNlZSBhbHNvXG5bYGluZGVudFN0cmluZ2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKSkgb3IgbnVsbCwgd2hlcmUgbnVsbFxuaW5kaWNhdGVzIHRoYXQgbm8gZGVmaW5pdGl2ZSBpbmRlbnRhdGlvbiBjYW4gYmUgZGV0ZXJtaW5lZC5cbiovXG5jb25zdCBpbmRlbnROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8vIENvbXB1dGUgdGhlIGluZGVudGF0aW9uIGZvciBhIGdpdmVuIHBvc2l0aW9uIGZyb20gdGhlIHN5bnRheCB0cmVlLlxuZnVuY3Rpb24gc3ludGF4SW5kZW50YXRpb24oY3gsIGFzdCwgcG9zKSB7XG4gICAgbGV0IHN0YWNrID0gYXN0LnJlc29sdmVTdGFjayhwb3MpO1xuICAgIGxldCBpbm5lciA9IGFzdC5yZXNvbHZlSW5uZXIocG9zLCAtMSkucmVzb2x2ZShwb3MsIDApLmVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlKHBvcyk7XG4gICAgaWYgKGlubmVyICE9IHN0YWNrLm5vZGUpIHtcbiAgICAgICAgbGV0IGFkZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBpbm5lcjsgY3VyICYmICEoY3VyLmZyb20gPT0gc3RhY2subm9kZS5mcm9tICYmIGN1ci50eXBlID09IHN0YWNrLm5vZGUudHlwZSk7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgICAgICBhZGQucHVzaChjdXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gYWRkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgc3RhY2sgPSB7IG5vZGU6IGFkZFtpXSwgbmV4dDogc3RhY2sgfTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGVudEZvcihzdGFjaywgY3gsIHBvcyk7XG59XG5mdW5jdGlvbiBpbmRlbnRGb3Ioc3RhY2ssIGN4LCBwb3MpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFjazsgY3VyOyBjdXIgPSBjdXIubmV4dCkge1xuICAgICAgICBsZXQgc3RyYXRlZ3kgPSBpbmRlbnRTdHJhdGVneShjdXIubm9kZSk7XG4gICAgICAgIGlmIChzdHJhdGVneSlcbiAgICAgICAgICAgIHJldHVybiBzdHJhdGVneShUcmVlSW5kZW50Q29udGV4dC5jcmVhdGUoY3gsIHBvcywgY3VyKSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaWdub3JlQ2xvc2VkKGN4KSB7XG4gICAgcmV0dXJuIGN4LnBvcyA9PSBjeC5vcHRpb25zLnNpbXVsYXRlQnJlYWsgJiYgY3gub3B0aW9ucy5zaW11bGF0ZURvdWJsZUJyZWFrO1xufVxuZnVuY3Rpb24gaW5kZW50U3RyYXRlZ3kodHJlZSkge1xuICAgIGxldCBzdHJhdGVneSA9IHRyZWUudHlwZS5wcm9wKGluZGVudE5vZGVQcm9wKTtcbiAgICBpZiAoc3RyYXRlZ3kpXG4gICAgICAgIHJldHVybiBzdHJhdGVneTtcbiAgICBsZXQgZmlyc3QgPSB0cmVlLmZpcnN0Q2hpbGQsIGNsb3NlO1xuICAgIGlmIChmaXJzdCAmJiAoY2xvc2UgPSBmaXJzdC50eXBlLnByb3AoTm9kZVByb3AuY2xvc2VkQnkpKSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRyZWUubGFzdENoaWxkLCBjbG9zZWQgPSBsYXN0ICYmIGNsb3NlLmluZGV4T2YobGFzdC5uYW1lKSA+IC0xO1xuICAgICAgICByZXR1cm4gY3ggPT4gZGVsaW1pdGVkU3RyYXRlZ3koY3gsIHRydWUsIDEsIHVuZGVmaW5lZCwgY2xvc2VkICYmICFpZ25vcmVDbG9zZWQoY3gpID8gbGFzdC5mcm9tIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWUucGFyZW50ID09IG51bGwgPyB0b3BJbmRlbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gdG9wSW5kZW50KCkgeyByZXR1cm4gMDsgfVxuLyoqXG5PYmplY3RzIG9mIHRoaXMgdHlwZSBwcm92aWRlIGNvbnRleHQgaW5mb3JtYXRpb24gYW5kIGhlbHBlclxubWV0aG9kcyB0byBpbmRlbnRhdGlvbiBmdW5jdGlvbnMgcmVnaXN0ZXJlZCBvbiBzeW50YXggbm9kZXMuXG4qL1xuY2xhc3MgVHJlZUluZGVudENvbnRleHQgZXh0ZW5kcyBJbmRlbnRDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgd2hpY2ggaW5kZW50YXRpb24gaXMgYmVpbmcgY29tcHV0ZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29udGV4dCkge1xuICAgICAgICBzdXBlcihiYXNlLnN0YXRlLCBiYXNlLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN5bnRheCB0cmVlIG5vZGUgdG8gd2hpY2ggdGhlIGluZGVudGF0aW9uIHN0cmF0ZWd5XG4gICAgYXBwbGllcy5cbiAgICAqL1xuICAgIGdldCBub2RlKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0Lm5vZGU7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoYmFzZSwgcG9zLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUluZGVudENvbnRleHQoYmFzZSwgcG9zLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB0ZXh0IGRpcmVjdGx5IGFmdGVyIGB0aGlzLnBvc2AsIGVpdGhlciB0aGUgZW50aXJlIGxpbmVcbiAgICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICAgKi9cbiAgICBnZXQgdGV4dEFmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0QWZ0ZXJQb3ModGhpcy5wb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGF0IHRoZSByZWZlcmVuY2UgbGluZSBmb3IgYHRoaXMubm9kZWAsIHdoaWNoXG4gICAgaXMgdGhlIGxpbmUgb24gd2hpY2ggaXQgc3RhcnRzLCB1bmxlc3MgdGhlcmUgaXMgYSBub2RlIHRoYXQgaXNcbiAgICBfbm90XyBhIHBhcmVudCBvZiB0aGlzIG5vZGUgY292ZXJpbmcgdGhlIHN0YXJ0IG9mIHRoYXQgbGluZS4gSWZcbiAgICBzbywgdGhlIGxpbmUgYXQgdGhlIHN0YXJ0IG9mIHRoYXQgbm9kZSBpcyB0cmllZCwgYWdhaW4gc2tpcHBpbmdcbiAgICBvbiBpZiBpdCBpcyBjb3ZlcmVkIGJ5IGFub3RoZXIgc3VjaCBub2RlLlxuICAgICovXG4gICAgZ2V0IGJhc2VJbmRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VJbmRlbnRGb3IodGhpcy5ub2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBmb3IgdGhlIHJlZmVyZW5jZSBsaW5lIG9mIHRoZSBnaXZlbiBub2RlXG4gICAgKHNlZSBbYGJhc2VJbmRlbnRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlRyZWVJbmRlbnRDb250ZXh0LmJhc2VJbmRlbnQpKS5cbiAgICAqL1xuICAgIGJhc2VJbmRlbnRGb3Iobm9kZSkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChub2RlLmZyb20pO1xuICAgICAgICAvLyBTa2lwIGxpbmUgc3RhcnRzIHRoYXQgYXJlIGNvdmVyZWQgYnkgYSBzaWJsaW5nIChvciBjb3VzaW4sIGV0YylcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGF0QnJlYWsgPSBub2RlLnJlc29sdmUobGluZS5mcm9tKTtcbiAgICAgICAgICAgIHdoaWxlIChhdEJyZWFrLnBhcmVudCAmJiBhdEJyZWFrLnBhcmVudC5mcm9tID09IGF0QnJlYWsuZnJvbSlcbiAgICAgICAgICAgICAgICBhdEJyZWFrID0gYXRCcmVhay5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNQYXJlbnQoYXRCcmVhaywgbm9kZSkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KGF0QnJlYWsuZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUluZGVudChsaW5lLmZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBDb250aW51ZSBsb29raW5nIGZvciBpbmRlbnRhdGlvbnMgaW4gdGhlIG5vZGUncyBwYXJlbnQgbm9kZXMsXG4gICAgYW5kIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoYXQuXG4gICAgKi9cbiAgICBjb250aW51ZSgpIHtcbiAgICAgICAgcmV0dXJuIGluZGVudEZvcih0aGlzLmNvbnRleHQubmV4dCwgdGhpcy5iYXNlLCB0aGlzLnBvcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQYXJlbnQocGFyZW50LCBvZikge1xuICAgIGZvciAobGV0IGN1ciA9IG9mOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpXG4gICAgICAgIGlmIChwYXJlbnQgPT0gY3VyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQ2hlY2sgd2hldGhlciBhIGRlbGltaXRlZCBub2RlIGlzIGFsaWduZWQgKG1lYW5pbmcgdGhlcmUgYXJlXG4vLyBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgc2FtZSBsaW5lIGFzIHRoZSBvcGVuaW5nIGRlbGltaXRlcikuIEFuZFxuLy8gaWYgc28sIHJldHVybiB0aGUgb3BlbmluZyB0b2tlbi5cbmZ1bmN0aW9uIGJyYWNrZXRlZEFsaWduZWQoY29udGV4dCkge1xuICAgIGxldCB0cmVlID0gY29udGV4dC5ub2RlO1xuICAgIGxldCBvcGVuVG9rZW4gPSB0cmVlLmNoaWxkQWZ0ZXIodHJlZS5mcm9tKSwgbGFzdCA9IHRyZWUubGFzdENoaWxkO1xuICAgIGlmICghb3BlblRva2VuKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgc2ltID0gY29udGV4dC5vcHRpb25zLnNpbXVsYXRlQnJlYWs7XG4gICAgbGV0IG9wZW5MaW5lID0gY29udGV4dC5zdGF0ZS5kb2MubGluZUF0KG9wZW5Ub2tlbi5mcm9tKTtcbiAgICBsZXQgbGluZUVuZCA9IHNpbSA9PSBudWxsIHx8IHNpbSA8PSBvcGVuTGluZS5mcm9tID8gb3BlbkxpbmUudG8gOiBNYXRoLm1pbihvcGVuTGluZS50bywgc2ltKTtcbiAgICBmb3IgKGxldCBwb3MgPSBvcGVuVG9rZW4udG87Oykge1xuICAgICAgICBsZXQgbmV4dCA9IHRyZWUuY2hpbGRBZnRlcihwb3MpO1xuICAgICAgICBpZiAoIW5leHQgfHwgbmV4dCA9PSBsYXN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghbmV4dC50eXBlLmlzU2tpcHBlZCkge1xuICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA+PSBsaW5lRW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbGV0IHNwYWNlID0gL14gKi8uZXhlYyhvcGVuTGluZS50ZXh0LnNsaWNlKG9wZW5Ub2tlbi50byAtIG9wZW5MaW5lLmZyb20pKVswXS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBvcGVuVG9rZW4uZnJvbSwgdG86IG9wZW5Ub2tlbi50byArIHNwYWNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbmV4dC50bztcbiAgICB9XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IGZvciBkZWxpbWl0ZWQgKHVzdWFsbHkgYnJhY2tldGVkKSBub2Rlcy5cbldpbGwsIGJ5IGRlZmF1bHQsIGluZGVudCBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIHBhcmVudCdzIGJhc2VcbmluZGVudCB1bmxlc3MgdGhlIGxpbmUgc3RhcnRzIHdpdGggYSBjbG9zaW5nIHRva2VuLiBXaGVuIGBhbGlnbmBcbmlzIHRydWUgYW5kIHRoZXJlIGFyZSBub24tc2tpcHBlZCBub2RlcyBvbiB0aGUgbm9kZSdzIG9wZW5pbmdcbmxpbmUsIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIHdpbGwgYmUgYWxpZ25lZCB3aXRoIHRoZSBlbmQgb2YgdGhlXG5vcGVuaW5nIG5vZGUsIGxpa2UgdGhpczpcblxuICAgIGZvbyhiYXIsXG4gICAgICAgIGJheilcbiovXG5mdW5jdGlvbiBkZWxpbWl0ZWRJbmRlbnQoeyBjbG9zaW5nLCBhbGlnbiA9IHRydWUsIHVuaXRzID0gMSB9KSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiBkZWxpbWl0ZWRTdHJhdGVneShjb250ZXh0LCBhbGlnbiwgdW5pdHMsIGNsb3NpbmcpO1xufVxuZnVuY3Rpb24gZGVsaW1pdGVkU3RyYXRlZ3koY29udGV4dCwgYWxpZ24sIHVuaXRzLCBjbG9zaW5nLCBjbG9zZWRBdCkge1xuICAgIGxldCBhZnRlciA9IGNvbnRleHQudGV4dEFmdGVyLCBzcGFjZSA9IGFmdGVyLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcbiAgICBsZXQgY2xvc2VkID0gY2xvc2luZyAmJiBhZnRlci5zbGljZShzcGFjZSwgc3BhY2UgKyBjbG9zaW5nLmxlbmd0aCkgPT0gY2xvc2luZyB8fCBjbG9zZWRBdCA9PSBjb250ZXh0LnBvcyArIHNwYWNlO1xuICAgIGxldCBhbGlnbmVkID0gYWxpZ24gPyBicmFja2V0ZWRBbGlnbmVkKGNvbnRleHQpIDogbnVsbDtcbiAgICBpZiAoYWxpZ25lZClcbiAgICAgICAgcmV0dXJuIGNsb3NlZCA/IGNvbnRleHQuY29sdW1uKGFsaWduZWQuZnJvbSkgOiBjb250ZXh0LmNvbHVtbihhbGlnbmVkLnRvKTtcbiAgICByZXR1cm4gY29udGV4dC5iYXNlSW5kZW50ICsgKGNsb3NlZCA/IDAgOiBjb250ZXh0LnVuaXQgKiB1bml0cyk7XG59XG4vKipcbkFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQgYWxpZ25zIGEgbm9kZSdzIGNvbnRlbnQgdG8gaXRzIGJhc2VcbmluZGVudGF0aW9uLlxuKi9cbmNvbnN0IGZsYXRJbmRlbnQgPSAoY29udGV4dCkgPT4gY29udGV4dC5iYXNlSW5kZW50O1xuLyoqXG5DcmVhdGVzIGFuIGluZGVudGF0aW9uIHN0cmF0ZWd5IHRoYXQsIGJ5IGRlZmF1bHQsIGluZGVudHNcbmNvbnRpbnVlZCBsaW5lcyBvbmUgdW5pdCBtb3JlIHRoYW4gdGhlIG5vZGUncyBiYXNlIGluZGVudGF0aW9uLlxuWW91IGNhbiBwcm92aWRlIGBleGNlcHRgIHRvIHByZXZlbnQgaW5kZW50YXRpb24gb2YgbGluZXMgdGhhdFxubWF0Y2ggYSBwYXR0ZXJuIChmb3IgZXhhbXBsZSBgL15lbHNlXFxiL2AgaW4gYGlmYC9gZWxzZWBcbmNvbnN0cnVjdHMpLCBhbmQgeW91IGNhbiBjaGFuZ2UgdGhlIGFtb3VudCBvZiB1bml0cyB1c2VkIHdpdGggdGhlXG5gdW5pdHNgIG9wdGlvbi5cbiovXG5mdW5jdGlvbiBjb250aW51ZWRJbmRlbnQoeyBleGNlcHQsIHVuaXRzID0gMSB9ID0ge30pIHtcbiAgICByZXR1cm4gKGNvbnRleHQpID0+IHtcbiAgICAgICAgbGV0IG1hdGNoRXhjZXB0ID0gZXhjZXB0ICYmIGV4Y2VwdC50ZXN0KGNvbnRleHQudGV4dEFmdGVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChtYXRjaEV4Y2VwdCA/IDAgOiB1bml0cyAqIGNvbnRleHQudW5pdCk7XG4gICAgfTtcbn1cbmNvbnN0IERvbnRJbmRlbnRCZXlvbmQgPSAyMDA7XG4vKipcbkVuYWJsZXMgcmVpbmRlbnRhdGlvbiBvbiBpbnB1dC4gV2hlbiBhIGxhbmd1YWdlIGRlZmluZXMgYW5cbmBpbmRlbnRPbklucHV0YCBmaWVsZCBpbiBpdHMgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSwgd2hpY2ggbXVzdCBob2xkIGEgcmVndWxhclxuZXhwcmVzc2lvbiwgdGhlIGxpbmUgYXQgdGhlIGN1cnNvciB3aWxsIGJlIHJlaW5kZW50ZWQgd2hlbmV2ZXIgbmV3XG50ZXh0IGlzIHR5cGVkIGFuZCB0aGUgaW5wdXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGxpbmUgdXAgdG8gdGhlXG5jdXJzb3IgbWF0Y2hlcyB0aGF0IHJlZ2V4cC5cblxuVG8gYXZvaWQgdW5uZWNjZXNhcnkgcmVpbmRlbnRzLCBpdCBpcyByZWNvbW1lbmRlZCB0byBzdGFydCB0aGVcbnJlZ2V4cCB3aXRoIGBeYCAodXN1YWxseSBmb2xsb3dlZCBieSBgXFxzKmApLCBhbmQgZW5kIGl0IHdpdGggYCRgLlxuRm9yIGV4YW1wbGUsIGAvXlxccypcXH0kL2Agd2lsbCByZWluZGVudCB3aGVuIGEgY2xvc2luZyBicmFjZSBpc1xuYWRkZWQgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZS5cbiovXG5mdW5jdGlvbiBpbmRlbnRPbklucHV0KCkge1xuICAgIHJldHVybiBFZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkZpbHRlci5vZih0ciA9PiB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCB8fCAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpICYmICF0ci5pc1VzZXJFdmVudChcImlucHV0LmNvbXBsZXRlXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgcnVsZXMgPSB0ci5zdGFydFN0YXRlLmxhbmd1YWdlRGF0YUF0KFwiaW5kZW50T25JbnB1dFwiLCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGRvYyA9IHRyLm5ld0RvYywgeyBoZWFkIH0gPSB0ci5uZXdTZWxlY3Rpb24ubWFpbiwgbGluZSA9IGRvYy5saW5lQXQoaGVhZCk7XG4gICAgICAgIGlmIChoZWFkID4gbGluZS5mcm9tICsgRG9udEluZGVudEJleW9uZClcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGRvYy5zbGljZVN0cmluZyhsaW5lLmZyb20sIGhlYWQpO1xuICAgICAgICBpZiAoIXJ1bGVzLnNvbWUociA9PiByLnRlc3QobGluZVN0YXJ0KSkpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0ciwgbGFzdCA9IC0xLCBjaGFuZ2VzID0gW107XG4gICAgICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChoZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxhc3QgPSBsaW5lLmZyb207XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gZ2V0SW5kZW50YXRpb24oc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgICAgICBsZXQgbm9ybSA9IGluZGVudFN0cmluZyhzdGF0ZSwgaW5kZW50KTtcbiAgICAgICAgICAgIGlmIChjdXIgIT0gbm9ybSlcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBsaW5lLmZyb20gKyBjdXIubGVuZ3RoLCBpbnNlcnQ6IG5vcm0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZXMubGVuZ3RoID8gW3RyLCB7IGNoYW5nZXMsIHNlcXVlbnRpYWw6IHRydWUgfV0gOiB0cjtcbiAgICB9KTtcbn1cblxuLyoqXG5BIGZhY2V0IHRoYXQgcmVnaXN0ZXJzIGEgY29kZSBmb2xkaW5nIHNlcnZpY2UuIFdoZW4gY2FsbGVkIHdpdGhcbnRoZSBleHRlbnQgb2YgYSBsaW5lLCBzdWNoIGEgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGZvbGRhYmxlXG5yYW5nZSB0aGF0IHN0YXJ0cyBvbiB0aGF0IGxpbmUgKGJ1dCBjb250aW51ZXMgYmV5b25kIGl0KSwgaWYgb25lXG5jYW4gYmUgZm91bmQuXG4qL1xuY29uc3QgZm9sZFNlcnZpY2UgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcblRoaXMgbm9kZSBwcm9wIGlzIHVzZWQgdG8gYXNzb2NpYXRlIGZvbGRpbmcgaW5mb3JtYXRpb24gd2l0aFxuc3ludGF4IG5vZGUgdHlwZXMuIEdpdmVuIGEgc3ludGF4IG5vZGUsIGl0IHNob3VsZCBjaGVjayB3aGV0aGVyXG50aGF0IHRyZWUgaXMgZm9sZGFibGUgYW5kIHJldHVybiB0aGUgcmFuZ2UgdGhhdCBjYW4gYmUgY29sbGFwc2VkXG53aGVuIGl0IGlzLlxuKi9cbmNvbnN0IGZvbGROb2RlUHJvcCA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbi8qKlxuW0ZvbGRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBmdW5jdGlvbiB0aGF0IGZvbGRzIGV2ZXJ5dGhpbmcgYnV0XG50aGUgZmlyc3QgYW5kIHRoZSBsYXN0IGNoaWxkIG9mIGEgc3ludGF4IG5vZGUuIFVzZWZ1bCBmb3Igbm9kZXNcbnRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIGRlbGltaXRlcnMuXG4qL1xuZnVuY3Rpb24gZm9sZEluc2lkZShub2RlKSB7XG4gICAgbGV0IGZpcnN0ID0gbm9kZS5maXJzdENoaWxkLCBsYXN0ID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LnRvIDwgbGFzdC5mcm9tID8geyBmcm9tOiBmaXJzdC50bywgdG86IGxhc3QudHlwZS5pc0Vycm9yID8gbm9kZS50byA6IGxhc3QuZnJvbSB9IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHN5bnRheEZvbGRpbmcoc3RhdGUsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUoc3RhdGUpO1xuICAgIGlmICh0cmVlLmxlbmd0aCA8IGVuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHN0YWNrID0gdHJlZS5yZXNvbHZlU3RhY2soZW5kLCAxKTtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIGZvciAobGV0IGl0ZXIgPSBzdGFjazsgaXRlcjsgaXRlciA9IGl0ZXIubmV4dCkge1xuICAgICAgICBsZXQgY3VyID0gaXRlci5ub2RlO1xuICAgICAgICBpZiAoY3VyLnRvIDw9IGVuZCB8fCBjdXIuZnJvbSA+IGVuZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoZm91bmQgJiYgY3VyLmZyb20gPCBzdGFydClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgcHJvcCA9IGN1ci50eXBlLnByb3AoZm9sZE5vZGVQcm9wKTtcbiAgICAgICAgaWYgKHByb3AgJiYgKGN1ci50byA8IHRyZWUubGVuZ3RoIC0gNTAgfHwgdHJlZS5sZW5ndGggPT0gc3RhdGUuZG9jLmxlbmd0aCB8fCAhaXNVbmZpbmlzaGVkKGN1cikpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9wKGN1ciwgc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmZyb20gPD0gZW5kICYmIHZhbHVlLmZyb20gPj0gc3RhcnQgJiYgdmFsdWUudG8gPiBlbmQpXG4gICAgICAgICAgICAgICAgZm91bmQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBpc1VuZmluaXNoZWQobm9kZSkge1xuICAgIGxldCBjaCA9IG5vZGUubGFzdENoaWxkO1xuICAgIHJldHVybiBjaCAmJiBjaC50byA9PSBub2RlLnRvICYmIGNoLnR5cGUuaXNFcnJvcjtcbn1cbi8qKlxuQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gbGluZSBpcyBmb2xkYWJsZS4gRmlyc3QgYXNrcyBhbnkgZm9sZFxuc2VydmljZXMgcmVnaXN0ZXJlZCB0aHJvdWdoXG5bYGZvbGRTZXJ2aWNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkU2VydmljZSksIGFuZCBpZiBub25lIG9mIHRoZW0gcmV0dXJuXG5hIHJlc3VsdCwgdHJpZXMgdG8gcXVlcnkgdGhlIFtmb2xkIG5vZGVcbnByb3BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZE5vZGVQcm9wKSBvZiBzeW50YXggbm9kZXMgdGhhdCBjb3ZlciB0aGUgZW5kXG5vZiB0aGUgbGluZS5cbiovXG5mdW5jdGlvbiBmb2xkYWJsZShzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKSB7XG4gICAgZm9yIChsZXQgc2VydmljZSBvZiBzdGF0ZS5mYWNldChmb2xkU2VydmljZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNlcnZpY2Uoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gc3ludGF4Rm9sZGluZyhzdGF0ZSwgbGluZVN0YXJ0LCBsaW5lRW5kKTtcbn1cbmZ1bmN0aW9uIG1hcFJhbmdlKHJhbmdlLCBtYXBwaW5nKSB7XG4gICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFBvcyhyYW5nZS5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFBvcyhyYW5nZS50bywgLTEpO1xuICAgIHJldHVybiBmcm9tID49IHRvID8gdW5kZWZpbmVkIDogeyBmcm9tLCB0byB9O1xufVxuLyoqXG5TdGF0ZSBlZmZlY3QgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gYSB0cmFuc2FjdGlvbiB0byBmb2xkIHRoZVxuZ2l2ZW4gcmFuZ2UuIChZb3UgcHJvYmFibHkgb25seSBuZWVkIHRoaXMgaW4gZXhjZXB0aW9uYWxcbmNpcmN1bXN0YW5jZXPigJR1c3VhbGx5IHlvdSdsbCBqdXN0IHdhbnQgdG8gbGV0XG5bYGZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQ29kZSkgYW5kIHRoZSBbZm9sZFxuZ3V0dGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRHdXR0ZXIpIGNyZWF0ZSB0aGUgdHJhbnNhY3Rpb25zLilcbiovXG5jb25zdCBmb2xkRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogbWFwUmFuZ2UgfSk7XG4vKipcblN0YXRlIGVmZmVjdCB0aGF0IHVuZm9sZHMgdGhlIGdpdmVuIHJhbmdlIChpZiBpdCB3YXMgZm9sZGVkKS5cbiovXG5jb25zdCB1bmZvbGRFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiBtYXBSYW5nZSB9KTtcbmZ1bmN0aW9uIHNlbGVjdGVkTGluZXModmlldykge1xuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IHsgaGVhZCB9IG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICBpZiAobGluZXMuc29tZShsID0+IGwuZnJvbSA8PSBoZWFkICYmIGwudG8gPj0gaGVhZCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGluZXMucHVzaCh2aWV3LmxpbmVCbG9ja0F0KGhlYWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuLyoqXG5UaGUgc3RhdGUgZmllbGQgdGhhdCBzdG9yZXMgdGhlIGZvbGRlZCByYW5nZXMgKGFzIGEgW2RlY29yYXRpb25cbnNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25TZXQpKS4gQ2FuIGJlIHBhc3NlZCB0b1xuW2BFZGl0b3JTdGF0ZS50b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgYW5kXG5bYGZyb21KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5mcm9tSlNPTikgdG8gc2VyaWFsaXplIHRoZSBmb2xkXG5zdGF0ZS5cbiovXG5jb25zdCBmb2xkU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICB9LFxuICAgIHVwZGF0ZShmb2xkZWQsIHRyKSB7XG4gICAgICAgIGZvbGRlZCA9IGZvbGRlZC5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGUuaXMoZm9sZEVmZmVjdCkgJiYgIWZvbGRFeGlzdHMoZm9sZGVkLCBlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgcHJlcGFyZVBsYWNlaG9sZGVyIH0gPSB0ci5zdGF0ZS5mYWNldChmb2xkQ29uZmlnKTtcbiAgICAgICAgICAgICAgICBsZXQgd2lkZ2V0ID0gIXByZXBhcmVQbGFjZWhvbGRlciA/IGZvbGRXaWRnZXQgOlxuICAgICAgICAgICAgICAgICAgICBEZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IG5ldyBQcmVwYXJlZEZvbGRXaWRnZXQocHJlcGFyZVBsYWNlaG9sZGVyKHRyLnN0YXRlLCBlLnZhbHVlKSkgfSk7XG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7IGFkZDogW3dpZGdldC5yYW5nZShlLnZhbHVlLmZyb20sIGUudmFsdWUudG8pXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUuaXModW5mb2xkRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIGZvbGRlZCA9IGZvbGRlZC51cGRhdGUoeyBmaWx0ZXI6IChmcm9tLCB0bykgPT4gZS52YWx1ZS5mcm9tICE9IGZyb20gfHwgZS52YWx1ZS50byAhPSB0byxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRnJvbTogZS52YWx1ZS5mcm9tLCBmaWx0ZXJUbzogZS52YWx1ZS50byB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBmb2xkZWQgcmFuZ2VzIHRoYXQgY292ZXIgdGhlIHNlbGVjdGlvbiBoZWFkXG4gICAgICAgIGlmICh0ci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBvblNlbGVjdGlvbiA9IGZhbHNlLCB7IGhlYWQgfSA9IHRyLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgZm9sZGVkLmJldHdlZW4oaGVhZCwgaGVhZCwgKGEsIGIpID0+IHsgaWYgKGEgPCBoZWFkICYmIGIgPiBoZWFkKVxuICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICBpZiAob25TZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgZm9sZGVkID0gZm9sZGVkLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZyb206IGhlYWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRvOiBoZWFkLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IChhLCBiKSA9PiBiIDw9IGhlYWQgfHwgYSA+PSBoZWFkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvbGRlZDtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYpLFxuICAgIHRvSlNPTihmb2xkZWQsIHN0YXRlKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9sZGVkLmJldHdlZW4oMCwgc3RhdGUuZG9jLmxlbmd0aCwgKGZyb20sIHRvKSA9PiB7IHJhbmdlcy5wdXNoKGZyb20sIHRvKTsgfSk7XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfSxcbiAgICBmcm9tSlNPTih2YWx1ZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCAlIDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiBmb3IgZm9sZCBzdGF0ZVwiKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gdmFsdWVbaSsrXSwgdG8gPSB2YWx1ZVtpKytdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIHRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gZm9yIGZvbGQgc3RhdGVcIik7XG4gICAgICAgICAgICByYW5nZXMucHVzaChmb2xkV2lkZ2V0LnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KHJhbmdlcywgdHJ1ZSk7XG4gICAgfVxufSk7XG4vKipcbkdldCBhIFtyYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQpIGNvbnRhaW5pbmcgdGhlIGZvbGRlZCByYW5nZXNcbmluIHRoZSBnaXZlbiBzdGF0ZS5cbiovXG5mdW5jdGlvbiBmb2xkZWRSYW5nZXMoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgfHwgUmFuZ2VTZXQuZW1wdHk7XG59XG5mdW5jdGlvbiBmaW5kRm9sZChzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAoX2EgPSBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJldHdlZW4oZnJvbSwgdG8sIChmcm9tLCB0bykgPT4ge1xuICAgICAgICBpZiAoIWZvdW5kIHx8IGZvdW5kLmZyb20gPiBmcm9tKVxuICAgICAgICAgICAgZm91bmQgPSB7IGZyb20sIHRvIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gZm9sZEV4aXN0cyhmb2xkZWQsIGZyb20sIHRvKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgZm9sZGVkLmJldHdlZW4oZnJvbSwgZnJvbSwgKGEsIGIpID0+IHsgaWYgKGEgPT0gZnJvbSAmJiBiID09IHRvKVxuICAgICAgICBmb3VuZCA9IHRydWU7IH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIG1heWJlRW5hYmxlKHN0YXRlLCBvdGhlcikge1xuICAgIHJldHVybiBzdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSA/IG90aGVyIDogb3RoZXIuY29uY2F0KFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihjb2RlRm9sZGluZygpKSk7XG59XG4vKipcbkZvbGQgdGhlIGxpbmVzIHRoYXQgYXJlIHNlbGVjdGVkLCBpZiBwb3NzaWJsZS5cbiovXG5jb25zdCBmb2xkQ29kZSA9IHZpZXcgPT4ge1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgcmFuZ2UgPSBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBbZm9sZEVmZmVjdC5vZihyYW5nZSksIGFubm91bmNlRm9sZCh2aWV3LCByYW5nZSldKSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcblVuZm9sZCBmb2xkZWQgcmFuZ2VzIG9uIHNlbGVjdGVkIGxpbmVzLlxuKi9cbmNvbnN0IHVuZm9sZENvZGUgPSB2aWV3ID0+IHtcbiAgICBpZiAoIXZpZXcuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSwgYW5ub3VuY2VGb2xkKHZpZXcsIGZvbGRlZCwgZmFsc2UpKTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICByZXR1cm4gZWZmZWN0cy5sZW5ndGggPiAwO1xufTtcbmZ1bmN0aW9uIGFubm91bmNlRm9sZCh2aWV3LCByYW5nZSwgZm9sZCA9IHRydWUpIHtcbiAgICBsZXQgbGluZUZyb20gPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSkubnVtYmVyLCBsaW5lVG8gPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocmFuZ2UudG8pLm51bWJlcjtcbiAgICByZXR1cm4gRWRpdG9yVmlldy5hbm5vdW5jZS5vZihgJHt2aWV3LnN0YXRlLnBocmFzZShmb2xkID8gXCJGb2xkZWQgbGluZXNcIiA6IFwiVW5mb2xkZWQgbGluZXNcIil9ICR7bGluZUZyb219ICR7dmlldy5zdGF0ZS5waHJhc2UoXCJ0b1wiKX0gJHtsaW5lVG99LmApO1xufVxuLyoqXG5Gb2xkIGFsbCB0b3AtbGV2ZWwgZm9sZGFibGUgcmFuZ2VzLiBOb3RlIHRoYXQsIGluIG1vc3QgY2FzZXMsXG5mb2xkaW5nIGluZm9ybWF0aW9uIHdpbGwgZGVwZW5kIG9uIHRoZSBbc3ludGF4XG50cmVlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnN5bnRheFRyZWUpLCBhbmQgZm9sZGluZyBldmVyeXRoaW5nIG1heSBub3Qgd29ya1xucmVsaWFibHkgd2hlbiB0aGUgZG9jdW1lbnQgaGFzbid0IGJlZW4gZnVsbHkgcGFyc2VkIChlaXRoZXJcbmJlY2F1c2UgdGhlIGVkaXRvciBzdGF0ZSB3YXMgb25seSBqdXN0IGluaXRpYWxpemVkLCBvciBiZWNhdXNlIHRoZVxuZG9jdW1lbnQgaXMgc28gYmlnIHRoYXQgdGhlIHBhcnNlciBkZWNpZGVkIG5vdCB0byBwYXJzZSBpdFxuZW50aXJlbHkpLlxuKi9cbmNvbnN0IGZvbGRBbGwgPSB2aWV3ID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IHN0YXRlLmRvYy5sZW5ndGg7KSB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChwb3MpLCByYW5nZSA9IGZvbGRhYmxlKHN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goZm9sZEVmZmVjdC5vZihyYW5nZSkpO1xuICAgICAgICBwb3MgPSAocmFuZ2UgPyB2aWV3LmxpbmVCbG9ja0F0KHJhbmdlLnRvKSA6IGxpbmUpLnRvICsgMTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoKVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgZWZmZWN0cykgfSk7XG4gICAgcmV0dXJuICEhZWZmZWN0cy5sZW5ndGg7XG59O1xuLyoqXG5VbmZvbGQgYWxsIGZvbGRlZCBjb2RlLlxuKi9cbmNvbnN0IHVuZm9sZEFsbCA9IHZpZXcgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZCB8fCAhZmllbGQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZmllbGQuYmV0d2VlbigwLCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgsIChmcm9tLCB0bykgPT4geyBlZmZlY3RzLnB1c2godW5mb2xkRWZmZWN0Lm9mKHsgZnJvbSwgdG8gfSkpOyB9KTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vLyBGaW5kIHRoZSBmb2xkYWJsZSByZWdpb24gY29udGFpbmluZyB0aGUgZ2l2ZW4gbGluZSwgaWYgb25lIGV4aXN0c1xuZnVuY3Rpb24gZm9sZGFibGVDb250YWluZXIodmlldywgbGluZUJsb2NrKSB7XG4gICAgLy8gTG9vayBiYWNrd2FyZHMgdGhyb3VnaCBsaW5lIGJsb2NrcyB1bnRpbCB3ZSBmaW5kIGEgZm9sZGFibGUgcmVnaW9uIHRoYXRcbiAgICAvLyBpbnRlcnNlY3RzIHdpdGggdGhlIGxpbmVcbiAgICBmb3IgKGxldCBsaW5lID0gbGluZUJsb2NrOzspIHtcbiAgICAgICAgbGV0IGZvbGRhYmxlUmVnaW9uID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRhYmxlUmVnaW9uICYmIGZvbGRhYmxlUmVnaW9uLnRvID4gbGluZUJsb2NrLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gZm9sZGFibGVSZWdpb247XG4gICAgICAgIGlmICghbGluZS5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0KGxpbmUuZnJvbSAtIDEpO1xuICAgIH1cbn1cbi8qKlxuVG9nZ2xlIGZvbGRpbmcgYXQgY3Vyc29ycy4gVW5mb2xkcyBpZiB0aGVyZSBpcyBhbiBleGlzdGluZyBmb2xkXG5zdGFydGluZyBpbiB0aGF0IGxpbmUsIHRyaWVzIHRvIGZpbmQgYSBmb2xkYWJsZSByYW5nZSBhcm91bmQgaXRcbm90aGVyd2lzZS5cbiovXG5jb25zdCB0b2dnbGVGb2xkID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgb2Ygc2VsZWN0ZWRMaW5lcyh2aWV3KSkge1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZGVkLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZvbGRSYW5nZSA9IGZvbGRhYmxlQ29udGFpbmVyKHZpZXcsIGxpbmUpO1xuICAgICAgICAgICAgaWYgKGZvbGRSYW5nZSlcbiAgICAgICAgICAgICAgICBlZmZlY3RzLnB1c2goZm9sZEVmZmVjdC5vZihmb2xkUmFuZ2UpLCBhbm5vdW5jZUZvbGQodmlldywgZm9sZFJhbmdlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVmZmVjdHMubGVuZ3RoID4gMClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIGVmZmVjdHMpIH0pO1xuICAgIHJldHVybiAhIWVmZmVjdHMubGVuZ3RoO1xufTtcbi8qKlxuRGVmYXVsdCBmb2xkLXJlbGF0ZWQga2V5IGJpbmRpbmdzLlxuXG4gLSBDdHJsLVNoaWZ0LVsgKENtZC1BbHQtWyBvbiBtYWNPUyk6IFtgZm9sZENvZGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRDb2RlKS5cbiAtIEN0cmwtU2hpZnQtXSAoQ21kLUFsdC1dIG9uIG1hY09TKTogW2B1bmZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS51bmZvbGRDb2RlKS5cbiAtIEN0cmwtQWx0LVs6IFtgZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZEFsbCkuXG4gLSBDdHJsLUFsdC1dOiBbYHVuZm9sZEFsbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UudW5mb2xkQWxsKS5cbiovXG5jb25zdCBmb2xkS2V5bWFwID0gW1xuICAgIHsga2V5OiBcIkN0cmwtU2hpZnQtW1wiLCBtYWM6IFwiQ21kLUFsdC1bXCIsIHJ1bjogZm9sZENvZGUgfSxcbiAgICB7IGtleTogXCJDdHJsLVNoaWZ0LV1cIiwgbWFjOiBcIkNtZC1BbHQtXVwiLCBydW46IHVuZm9sZENvZGUgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1bXCIsIHJ1bjogZm9sZEFsbCB9LFxuICAgIHsga2V5OiBcIkN0cmwtQWx0LV1cIiwgcnVuOiB1bmZvbGRBbGwgfVxuXTtcbmNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgcGxhY2Vob2xkZXJET006IG51bGwsXG4gICAgcHJlcGFyZVBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHBsYWNlaG9sZGVyVGV4dDogXCLigKZcIlxufTtcbmNvbnN0IGZvbGRDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHZhbHVlcykgeyByZXR1cm4gY29tYmluZUNvbmZpZyh2YWx1ZXMsIGRlZmF1bHRDb25maWcpOyB9XG59KTtcbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbmZpZ3VyZXMgY29kZSBmb2xkaW5nLlxuKi9cbmZ1bmN0aW9uIGNvZGVGb2xkaW5nKGNvbmZpZykge1xuICAgIGxldCByZXN1bHQgPSBbZm9sZFN0YXRlLCBiYXNlVGhlbWUkMV07XG4gICAgaWYgKGNvbmZpZylcbiAgICAgICAgcmVzdWx0LnB1c2goZm9sZENvbmZpZy5vZihjb25maWcpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gd2lkZ2V0VG9ET00odmlldywgcHJlcGFyZWQpIHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY29uZiA9IHN0YXRlLmZhY2V0KGZvbGRDb25maWcpO1xuICAgIGxldCBvbmNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdCh2aWV3LnBvc0F0RE9NKGV2ZW50LnRhcmdldCkpO1xuICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKGZvbGRlZClcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSB9KTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIGlmIChjb25mLnBsYWNlaG9sZGVyRE9NKVxuICAgICAgICByZXR1cm4gY29uZi5wbGFjZWhvbGRlckRPTSh2aWV3LCBvbmNsaWNrLCBwcmVwYXJlZCk7XG4gICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBlbGVtZW50LnRleHRDb250ZW50ID0gY29uZi5wbGFjZWhvbGRlclRleHQ7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHN0YXRlLnBocmFzZShcImZvbGRlZCBjb2RlXCIpKTtcbiAgICBlbGVtZW50LnRpdGxlID0gc3RhdGUucGhyYXNlKFwidW5mb2xkXCIpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJjbS1mb2xkUGxhY2Vob2xkZXJcIjtcbiAgICBlbGVtZW50Lm9uY2xpY2sgPSBvbmNsaWNrO1xuICAgIHJldHVybiBlbGVtZW50O1xufVxuY29uc3QgZm9sZFdpZGdldCA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IC8qQF9fUFVSRV9fKi9uZXcgY2xhc3MgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICAgICAgdG9ET00odmlldykgeyByZXR1cm4gd2lkZ2V0VG9ET00odmlldywgbnVsbCk7IH1cbiAgICB9IH0pO1xuY2xhc3MgUHJlcGFyZWRGb2xkV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy52YWx1ZSA9PSBvdGhlci52YWx1ZTsgfVxuICAgIHRvRE9NKHZpZXcpIHsgcmV0dXJuIHdpZGdldFRvRE9NKHZpZXcsIHRoaXMudmFsdWUpOyB9XG59XG5jb25zdCBmb2xkR3V0dGVyRGVmYXVsdHMgPSB7XG4gICAgb3BlblRleHQ6IFwi4oyEXCIsXG4gICAgY2xvc2VkVGV4dDogXCLigLpcIixcbiAgICBtYXJrZXJET006IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge30sXG4gICAgZm9sZGluZ0NoYW5nZWQ6ICgpID0+IGZhbHNlXG59O1xuY2xhc3MgRm9sZE1hcmtlciBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBvcGVuKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcy5jb25maWcgPT0gb3RoZXIuY29uZmlnICYmIHRoaXMub3BlbiA9PSBvdGhlci5vcGVuOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBpZiAodGhpcy5jb25maWcubWFya2VyRE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLm1hcmtlckRPTSh0aGlzLm9wZW4pO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gdGhpcy5vcGVuID8gdGhpcy5jb25maWcub3BlblRleHQgOiB0aGlzLmNvbmZpZy5jbG9zZWRUZXh0O1xuICAgICAgICBzcGFuLnRpdGxlID0gdmlldy5zdGF0ZS5waHJhc2UodGhpcy5vcGVuID8gXCJGb2xkIGxpbmVcIiA6IFwiVW5mb2xkIGxpbmVcIik7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cbi8qKlxuQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IHJlZ2lzdGVycyBhIGZvbGQgZ3V0dGVyLCB3aGljaCBzaG93cyBhXG5mb2xkIHN0YXR1cyBpbmRpY2F0b3IgYmVmb3JlIGZvbGRhYmxlIGxpbmVzICh3aGljaCBjYW4gYmUgY2xpY2tlZFxudG8gZm9sZCBvciB1bmZvbGQgdGhlIGxpbmUpLlxuKi9cbmZ1bmN0aW9uIGZvbGRHdXR0ZXIoY29uZmlnID0ge30pIHtcbiAgICBsZXQgZnVsbENvbmZpZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZm9sZEd1dHRlckRlZmF1bHRzKSwgY29uZmlnKTtcbiAgICBsZXQgY2FuRm9sZCA9IG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIHRydWUpLCBjYW5VbmZvbGQgPSBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCBmYWxzZSk7XG4gICAgbGV0IG1hcmtlcnMgPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IHZpZXcudmlld3BvcnQuZnJvbTtcbiAgICAgICAgICAgIHRoaXMubWFya2VycyA9IHRoaXMuYnVpbGRNYXJrZXJzKHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAgICAgdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGFuZ3VhZ2UpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsYW5ndWFnZSkgfHxcbiAgICAgICAgICAgICAgICB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChmb2xkU3RhdGUsIGZhbHNlKSAhPSB1cGRhdGUuc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgfHxcbiAgICAgICAgICAgICAgICBzeW50YXhUcmVlKHVwZGF0ZS5zdGFydFN0YXRlKSAhPSBzeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSkgfHxcbiAgICAgICAgICAgICAgICBmdWxsQ29uZmlnLmZvbGRpbmdDaGFuZ2VkKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gdGhpcy5idWlsZE1hcmtlcnModXBkYXRlLnZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkTWFya2Vycyh2aWV3KSB7XG4gICAgICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGxpbmUgb2Ygdmlldy52aWV3cG9ydExpbmVCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyayA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50bykgPyBjYW5VbmZvbGRcbiAgICAgICAgICAgICAgICAgICAgOiBmb2xkYWJsZSh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pID8gY2FuRm9sZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmspXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGxpbmUuZnJvbSwgbGluZS5mcm9tLCBtYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHsgZG9tRXZlbnRIYW5kbGVycyB9ID0gZnVsbENvbmZpZztcbiAgICByZXR1cm4gW1xuICAgICAgICBtYXJrZXJzLFxuICAgICAgICBndXR0ZXIoe1xuICAgICAgICAgICAgY2xhc3M6IFwiY20tZm9sZEd1dHRlclwiLFxuICAgICAgICAgICAgbWFya2Vycyh2aWV3KSB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihtYXJrZXJzKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcmtlcnMpIHx8IFJhbmdlU2V0LmVtcHR5OyB9LFxuICAgICAgICAgICAgaW5pdGlhbFNwYWNlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbUV2ZW50SGFuZGxlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZG9tRXZlbnRIYW5kbGVycyksIHsgY2xpY2s6ICh2aWV3LCBsaW5lLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tRXZlbnRIYW5kbGVycy5jbGljayAmJiBkb21FdmVudEhhbmRsZXJzLmNsaWNrKHZpZXcsIGxpbmUsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm9sZGVkID0gZmluZEZvbGQodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVuZm9sZEVmZmVjdC5vZihmb2xkZWQpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogZm9sZEVmZmVjdC5vZihyYW5nZSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSB9KVxuICAgICAgICB9KSxcbiAgICAgICAgY29kZUZvbGRpbmcoKVxuICAgIF07XG59XG5jb25zdCBiYXNlVGhlbWUkMSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCIuY20tZm9sZFBsYWNlaG9sZGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNlZWVcIixcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjZGRkXCIsXG4gICAgICAgIGNvbG9yOiBcIiM4ODhcIixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiBcIi4yZW1cIixcbiAgICAgICAgbWFyZ2luOiBcIjAgMXB4XCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAxcHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tZm9sZEd1dHRlciBzcGFuXCI6IHtcbiAgICAgICAgcGFkZGluZzogXCIwIDFweFwiLFxuICAgICAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gICAgfVxufSk7XG5cbi8qKlxuQSBoaWdobGlnaHQgc3R5bGUgYXNzb2NpYXRlcyBDU1Mgc3R5bGVzIHdpdGggaGlnbGlnaHRpbmdcblt0YWdzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2hpZ2hsaWdodC5UYWcpLlxuKi9cbmNsYXNzIEhpZ2hsaWdodFN0eWxlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdGFnIHN0eWxlcyB1c2VkIHRvIGNyZWF0ZSB0aGlzIGhpZ2hsaWdodCBzdHlsZS5cbiAgICAqL1xuICAgIHNwZWNzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3BlY3MgPSBzcGVjcztcbiAgICAgICAgbGV0IG1vZFNwZWM7XG4gICAgICAgIGZ1bmN0aW9uIGRlZihzcGVjKSB7XG4gICAgICAgICAgICBsZXQgY2xzID0gU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuICAgICAgICAgICAgKG1vZFNwZWMgfHwgKG1vZFNwZWMgPSBPYmplY3QuY3JlYXRlKG51bGwpKSlbXCIuXCIgKyBjbHNdID0gc3BlYztcbiAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsID0gdHlwZW9mIG9wdGlvbnMuYWxsID09IFwic3RyaW5nXCIgPyBvcHRpb25zLmFsbCA6IG9wdGlvbnMuYWxsID8gZGVmKG9wdGlvbnMuYWxsKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2NvcGVPcHQgPSBvcHRpb25zLnNjb3BlO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGVPcHQgaW5zdGFuY2VvZiBMYW5ndWFnZSA/ICh0eXBlKSA9PiB0eXBlLnByb3AobGFuZ3VhZ2VEYXRhUHJvcCkgPT0gc2NvcGVPcHQuZGF0YVxuICAgICAgICAgICAgOiBzY29wZU9wdCA/ICh0eXBlKSA9PiB0eXBlID09IHNjb3BlT3B0IDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0eWxlID0gdGFnSGlnaGxpZ2h0ZXIoc3BlY3MubWFwKHN0eWxlID0+ICh7XG4gICAgICAgICAgICB0YWc6IHN0eWxlLnRhZyxcbiAgICAgICAgICAgIGNsYXNzOiBzdHlsZS5jbGFzcyB8fCBkZWYoT2JqZWN0LmFzc2lnbih7fSwgc3R5bGUsIHsgdGFnOiBudWxsIH0pKVxuICAgICAgICB9KSksIHtcbiAgICAgICAgICAgIGFsbCxcbiAgICAgICAgfSkuc3R5bGU7XG4gICAgICAgIHRoaXMubW9kdWxlID0gbW9kU3BlYyA/IG5ldyBTdHlsZU1vZHVsZShtb2RTcGVjKSA6IG51bGw7XG4gICAgICAgIHRoaXMudGhlbWVUeXBlID0gb3B0aW9ucy50aGVtZVR5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGhpZ2hsaWdodGVyIHN0eWxlIHRoYXQgYXNzb2NpYXRlcyB0aGUgZ2l2ZW4gc3R5bGVzIHRvXG4gICAgdGhlIGdpdmVuIHRhZ3MuIFRoZSBzcGVjcyBtdXN0IGJlIG9iamVjdHMgdGhhdCBob2xkIGEgc3R5bGUgdGFnXG4gICAgb3IgYXJyYXkgb2YgdGFncyBpbiB0aGVpciBgdGFnYCBwcm9wZXJ0eSwgYW5kIGVpdGhlciBhIHNpbmdsZVxuICAgIGBjbGFzc2AgcHJvcGVydHkgcHJvdmlkaW5nIGEgc3RhdGljIENTUyBjbGFzcyAoZm9yIGhpZ2hsaWdodGVyXG4gICAgdGhhdCByZWx5IG9uIGV4dGVybmFsIHN0eWxpbmcpLCBvciBhXG4gICAgW2BzdHlsZS1tb2RgXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbiktc3R5bGVcbiAgICBzZXQgb2YgQ1NTIHByb3BlcnRpZXMgKHdoaWNoIGRlZmluZSB0aGUgc3R5bGluZyBmb3IgdGhvc2UgdGFncykuXG4gICAgXG4gICAgVGhlIENTUyBydWxlcyBjcmVhdGVkIGZvciBhIGhpZ2hsaWdodGVyIHdpbGwgYmUgZW1pdHRlZCBpbiB0aGVcbiAgICBvcmRlciBvZiB0aGUgc3BlYydzIHByb3BlcnRpZXMuIFRoYXQgbWVhbnMgdGhhdCBmb3IgZWxlbWVudHMgdGhhdFxuICAgIGhhdmUgbXVsdGlwbGUgdGFncyBhc3NvY2lhdGVkIHdpdGggdGhlbSwgc3R5bGVzIGRlZmluZWQgZnVydGhlclxuICAgIGRvd24gaW4gdGhlIGxpc3Qgd2lsbCBoYXZlIGEgaGlnaGVyIENTUyBwcmVjZWRlbmNlIHRoYW4gc3R5bGVzXG4gICAgZGVmaW5lZCBlYXJsaWVyLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodFN0eWxlKHNwZWNzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB9XG59XG5jb25zdCBoaWdobGlnaHRlckZhY2V0ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZmFsbGJhY2tIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUodmFsdWVzKSB7IHJldHVybiB2YWx1ZXMubGVuZ3RoID8gW3ZhbHVlc1swXV0gOiBudWxsOyB9XG59KTtcbmZ1bmN0aW9uIGdldEhpZ2hsaWdodGVycyhzdGF0ZSkge1xuICAgIGxldCBtYWluID0gc3RhdGUuZmFjZXQoaGlnaGxpZ2h0ZXJGYWNldCk7XG4gICAgcmV0dXJuIG1haW4ubGVuZ3RoID8gbWFpbiA6IHN0YXRlLmZhY2V0KGZhbGxiYWNrSGlnaGxpZ2h0ZXIpO1xufVxuLyoqXG5XcmFwIGEgaGlnaGxpZ2h0ZXIgaW4gYW4gZWRpdG9yIGV4dGVuc2lvbiB0aGF0IHVzZXMgaXQgdG8gYXBwbHlcbnN5bnRheCBoaWdobGlnaHRpbmcgdG8gdGhlIGVkaXRvciBjb250ZW50LlxuXG5XaGVuIG11bHRpcGxlIChub24tZmFsbGJhY2spIHN0eWxlcyBhcmUgcHJvdmlkZWQsIHRoZSBzdHlsaW5nXG5hcHBsaWVkIGlzIHRoZSB1bmlvbiBvZiB0aGUgY2xhc3NlcyB0aGV5IGVtaXQuXG4qL1xuZnVuY3Rpb24gc3ludGF4SGlnaGxpZ2h0aW5nKGhpZ2hsaWdodGVyLCBvcHRpb25zKSB7XG4gICAgbGV0IGV4dCA9IFt0cmVlSGlnaGxpZ2h0ZXJdLCB0aGVtZVR5cGU7XG4gICAgaWYgKGhpZ2hsaWdodGVyIGluc3RhbmNlb2YgSGlnaGxpZ2h0U3R5bGUpIHtcbiAgICAgICAgaWYgKGhpZ2hsaWdodGVyLm1vZHVsZSlcbiAgICAgICAgICAgIGV4dC5wdXNoKEVkaXRvclZpZXcuc3R5bGVNb2R1bGUub2YoaGlnaGxpZ2h0ZXIubW9kdWxlKSk7XG4gICAgICAgIHRoZW1lVHlwZSA9IGhpZ2hsaWdodGVyLnRoZW1lVHlwZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mYWxsYmFjaylcbiAgICAgICAgZXh0LnB1c2goZmFsbGJhY2tIaWdobGlnaHRlci5vZihoaWdobGlnaHRlcikpO1xuICAgIGVsc2UgaWYgKHRoZW1lVHlwZSlcbiAgICAgICAgZXh0LnB1c2goaGlnaGxpZ2h0ZXJGYWNldC5jb21wdXRlTihbRWRpdG9yVmlldy5kYXJrVGhlbWVdLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5kYXJrVGhlbWUpID09ICh0aGVtZVR5cGUgPT0gXCJkYXJrXCIpID8gW2hpZ2hsaWdodGVyXSA6IFtdO1xuICAgICAgICB9KSk7XG4gICAgZWxzZVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRlckZhY2V0Lm9mKGhpZ2hsaWdodGVyKSk7XG4gICAgcmV0dXJuIGV4dDtcbn1cbi8qKlxuUmV0dXJucyB0aGUgQ1NTIGNsYXNzZXMgKGlmIGFueSkgdGhhdCB0aGUgaGlnaGxpZ2h0ZXJzIGFjdGl2ZSBpblxudGhlIHN0YXRlIHdvdWxkIGFzc2lnbiB0byB0aGUgZ2l2ZW4gc3R5bGVcblt0YWdzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2hpZ2hsaWdodC5UYWcpIGFuZFxuKG9wdGlvbmFsKSBsYW5ndWFnZVxuW3Njb3BlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkhpZ2hsaWdodFN0eWxlXmRlZmluZV5vcHRpb25zLnNjb3BlKS5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRpbmdGb3Ioc3RhdGUsIHRhZ3MsIHNjb3BlKSB7XG4gICAgbGV0IGhpZ2hsaWdodGVycyA9IGdldEhpZ2hsaWdodGVycyhzdGF0ZSk7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKGhpZ2hsaWdodGVycylcbiAgICAgICAgZm9yIChsZXQgaGlnaGxpZ2h0ZXIgb2YgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoIWhpZ2hsaWdodGVyLnNjb3BlIHx8IHNjb3BlICYmIGhpZ2hsaWdodGVyLnNjb3BlKHNjb3BlKSkge1xuICAgICAgICAgICAgICAgIGxldCBjbHMgPSBoaWdobGlnaHRlci5zdHlsZSh0YWdzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPyByZXN1bHQgKyBcIiBcIiArIGNscyA6IGNscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBUcmVlSGlnaGxpZ2h0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5tYXJrQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnRyZWUgPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpO1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY28odmlldywgZ2V0SGlnaGxpZ2h0ZXJzKHZpZXcuc3RhdGUpKTtcbiAgICAgICAgdGhpcy5kZWNvcmF0ZWRUbyA9IHZpZXcudmlld3BvcnQudG87XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSksIGhpZ2hsaWdodGVycyA9IGdldEhpZ2hsaWdodGVycyh1cGRhdGUuc3RhdGUpO1xuICAgICAgICBsZXQgc3R5bGVDaGFuZ2UgPSBoaWdobGlnaHRlcnMgIT0gZ2V0SGlnaGxpZ2h0ZXJzKHVwZGF0ZS5zdGFydFN0YXRlKTtcbiAgICAgICAgbGV0IHsgdmlld3BvcnQgfSA9IHVwZGF0ZS52aWV3LCBkZWNvcmF0ZWRUb01hcHBlZCA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLmRlY29yYXRlZFRvLCAxKTtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoIDwgdmlld3BvcnQudG8gJiYgIXN0eWxlQ2hhbmdlICYmIHRyZWUudHlwZSA9PSB0aGlzLnRyZWUudHlwZSAmJiBkZWNvcmF0ZWRUb01hcHBlZCA+PSB2aWV3cG9ydC50bykge1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdGlvbnMubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGVkVG8gPSBkZWNvcmF0ZWRUb01hcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmVlICE9IHRoaXMudHJlZSB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IHN0eWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYnVpbGREZWNvKHVwZGF0ZS52aWV3LCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZWRUbyA9IHZpZXdwb3J0LnRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkRGVjbyh2aWV3LCBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgaWYgKCFoaWdobGlnaHRlcnMgfHwgIXRoaXMudHJlZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgaGlnaGxpZ2h0VHJlZSh0aGlzLnRyZWUsIGhpZ2hsaWdodGVycywgKGZyb20sIHRvLCBzdHlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKGZyb20sIHRvLCB0aGlzLm1hcmtDYWNoZVtzdHlsZV0gfHwgKHRoaXMubWFya0NhY2hlW3N0eWxlXSA9IERlY29yYXRpb24ubWFyayh7IGNsYXNzOiBzdHlsZSB9KSkpO1xuICAgICAgICAgICAgfSwgZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZGVyLmZpbmlzaCgpO1xuICAgIH1cbn1cbmNvbnN0IHRyZWVIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2goLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKFRyZWVIaWdobGlnaHRlciwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pKTtcbi8qKlxuQSBkZWZhdWx0IGhpZ2hsaWdodCBzdHlsZSAod29ya3Mgd2VsbCB3aXRoIGxpZ2h0IHRoZW1lcykuXG4qL1xuY29uc3QgZGVmYXVsdEhpZ2hsaWdodFN0eWxlID0gLypAX19QVVJFX18qL0hpZ2hsaWdodFN0eWxlLmRlZmluZShbXG4gICAgeyB0YWc6IHRhZ3MubWV0YSxcbiAgICAgICAgY29sb3I6IFwiIzQwNDc0MFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubGluayxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIgfSxcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIixcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcyxcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3Ryb25nLFxuICAgICAgICBmb250V2VpZ2h0OiBcImJvbGRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cmlrZXRocm91Z2gsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcImxpbmUtdGhyb3VnaFwiIH0sXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCxcbiAgICAgICAgY29sb3I6IFwiIzcwOFwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLmF0b20sIHRhZ3MuYm9vbCwgdGFncy51cmwsIHRhZ3MuY29udGVudFNlcGFyYXRvciwgdGFncy5sYWJlbE5hbWVdLFxuICAgICAgICBjb2xvcjogXCIjMjE5XCIgfSxcbiAgICB7IHRhZzogW3RhZ3MubGl0ZXJhbCwgdGFncy5pbnNlcnRlZF0sXG4gICAgICAgIGNvbG9yOiBcIiMxNjRcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5zdHJpbmcsIHRhZ3MuZGVsZXRlZF0sXG4gICAgICAgIGNvbG9yOiBcIiNhMTFcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5yZWdleHAsIHRhZ3MuZXNjYXBlLCAvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sXG4gICAgICAgIGNvbG9yOiBcIiNlNDBcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzAwZlwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmxvY2FsKHRhZ3MudmFyaWFibGVOYW1lKSxcbiAgICAgICAgY29sb3I6IFwiIzMwYVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnR5cGVOYW1lLCB0YWdzLm5hbWVzcGFjZV0sXG4gICAgICAgIGNvbG9yOiBcIiMwODVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNsYXNzTmFtZSxcbiAgICAgICAgY29sb3I6IFwiIzE2N1wiIH0sXG4gICAgeyB0YWc6IFsvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3MudmFyaWFibGVOYW1lKSwgdGFncy5tYWNyb05hbWVdLFxuICAgICAgICBjb2xvcjogXCIjMjU2XCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MuZGVmaW5pdGlvbih0YWdzLnByb3BlcnR5TmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMwMGNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmNvbW1lbnQsXG4gICAgICAgIGNvbG9yOiBcIiM5NDBcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmludmFsaWQsXG4gICAgICAgIGNvbG9yOiBcIiNmMDBcIiB9XG5dKTtcblxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbWF0Y2hpbmdCcmFja2V0XCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMzMjhjODI1MlwiIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLW5vbm1hdGNoaW5nQnJhY2tldFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjYmI1NTU1NDRcIiB9XG59KTtcbmNvbnN0IERlZmF1bHRTY2FuRGlzdCA9IDEwMDAwLCBEZWZhdWx0QnJhY2tldHMgPSBcIigpW117fVwiO1xuY29uc3QgYnJhY2tldE1hdGNoaW5nQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIGFmdGVyQ3Vyc29yOiB0cnVlLFxuICAgICAgICAgICAgYnJhY2tldHM6IERlZmF1bHRCcmFja2V0cyxcbiAgICAgICAgICAgIG1heFNjYW5EaXN0YW5jZTogRGVmYXVsdFNjYW5EaXN0LFxuICAgICAgICAgICAgcmVuZGVyTWF0Y2g6IGRlZmF1bHRSZW5kZXJNYXRjaFxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbmNvbnN0IG1hdGNoaW5nTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1tYXRjaGluZ0JyYWNrZXRcIiB9KSwgbm9ubWF0Y2hpbmdNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLW5vbm1hdGNoaW5nQnJhY2tldFwiIH0pO1xuZnVuY3Rpb24gZGVmYXVsdFJlbmRlck1hdGNoKG1hdGNoKSB7XG4gICAgbGV0IGRlY29yYXRpb25zID0gW107XG4gICAgbGV0IG1hcmsgPSBtYXRjaC5tYXRjaGVkID8gbWF0Y2hpbmdNYXJrIDogbm9ubWF0Y2hpbmdNYXJrO1xuICAgIGRlY29yYXRpb25zLnB1c2gobWFyay5yYW5nZShtYXRjaC5zdGFydC5mcm9tLCBtYXRjaC5zdGFydC50bykpO1xuICAgIGlmIChtYXRjaC5lbmQpXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2gobWFyay5yYW5nZShtYXRjaC5lbmQuZnJvbSwgbWF0Y2guZW5kLnRvKSk7XG4gICAgcmV0dXJuIGRlY29yYXRpb25zO1xufVxuY29uc3QgYnJhY2tldE1hdGNoaW5nU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIERlY29yYXRpb24ubm9uZTsgfSxcbiAgICB1cGRhdGUoZGVjbywgdHIpIHtcbiAgICAgICAgaWYgKCF0ci5kb2NDaGFuZ2VkICYmICF0ci5zZWxlY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gZGVjbztcbiAgICAgICAgbGV0IGRlY29yYXRpb25zID0gW107XG4gICAgICAgIGxldCBjb25maWcgPSB0ci5zdGF0ZS5mYWNldChicmFja2V0TWF0Y2hpbmdDb25maWcpO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiB0ci5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCwgLTEsIGNvbmZpZylcbiAgICAgICAgICAgICAgICB8fCAocmFuZ2UuaGVhZCA+IDAgJiYgbWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCAtIDEsIDEsIGNvbmZpZykpXG4gICAgICAgICAgICAgICAgfHwgKGNvbmZpZy5hZnRlckN1cnNvciAmJlxuICAgICAgICAgICAgICAgICAgICAobWF0Y2hCcmFja2V0cyh0ci5zdGF0ZSwgcmFuZ2UuaGVhZCwgMSwgY29uZmlnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJhbmdlLmhlYWQgPCB0ci5zdGF0ZS5kb2MubGVuZ3RoICYmIG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQgKyAxLCAtMSwgY29uZmlnKSkpKTtcbiAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucyA9IGRlY29yYXRpb25zLmNvbmNhdChjb25maWcucmVuZGVyTWF0Y2gobWF0Y2gsIHRyLnN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY29yYXRpb25zLCB0cnVlKTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGYpXG59KTtcbmNvbnN0IGJyYWNrZXRNYXRjaGluZ1VuaXF1ZSA9IFtcbiAgICBicmFja2V0TWF0Y2hpbmdTdGF0ZSxcbiAgICBiYXNlVGhlbWVcbl07XG4vKipcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIGJyYWNrZXQgbWF0Y2hpbmcuIFdoZW5ldmVyIHRoZVxuY3Vyc29yIGlzIG5leHQgdG8gYSBicmFja2V0LCB0aGF0IGJyYWNrZXQgYW5kIHRoZSBvbmUgaXQgbWF0Y2hlc1xuYXJlIGhpZ2hsaWdodGVkLiBPciwgd2hlbiBubyBtYXRjaGluZyBicmFja2V0IGlzIGZvdW5kLCBhbm90aGVyXG5oaWdobGlnaHRpbmcgc3R5bGUgaXMgdXNlZCB0byBpbmRpY2F0ZSB0aGlzLlxuKi9cbmZ1bmN0aW9uIGJyYWNrZXRNYXRjaGluZyhjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbYnJhY2tldE1hdGNoaW5nQ29uZmlnLm9mKGNvbmZpZyksIGJyYWNrZXRNYXRjaGluZ1VuaXF1ZV07XG59XG4vKipcbldoZW4gbGFyZ2VyIHN5bnRheCBub2Rlcywgc3VjaCBhcyBIVE1MIHRhZ3MsIGFyZSBtYXJrZWQgYXNcbm9wZW5pbmcvY2xvc2luZywgaXQgY2FuIGJlIGEgYml0IG1lc3N5IHRvIHRyZWF0IHRoZSB3aG9sZSBub2RlIGFzXG5hIG1hdGNoYWJsZSBicmFja2V0LiBUaGlzIG5vZGUgcHJvcCBhbGxvd3MgeW91IHRvIGRlZmluZSwgZm9yIHN1Y2hcbmEgbm9kZSwgYSDigJhoYW5kbGXigJnigJR0aGUgcGFydCBvZiB0aGUgbm9kZSB0aGF0IGlzIGhpZ2hsaWdodGVkLCBhbmRcbnRoYXQgdGhlIGN1cnNvciBtdXN0IGJlIG9uIHRvIGFjdGl2YXRlIGhpZ2hsaWdodGluZyBpbiB0aGUgZmlyc3RcbnBsYWNlLlxuKi9cbmNvbnN0IGJyYWNrZXRNYXRjaGluZ0hhbmRsZSA9IC8qQF9fUFVSRV9fKi9uZXcgTm9kZVByb3AoKTtcbmZ1bmN0aW9uIG1hdGNoaW5nTm9kZXMobm9kZSwgZGlyLCBicmFja2V0cykge1xuICAgIGxldCBieVByb3AgPSBub2RlLnByb3AoZGlyIDwgMCA/IE5vZGVQcm9wLm9wZW5lZEJ5IDogTm9kZVByb3AuY2xvc2VkQnkpO1xuICAgIGlmIChieVByb3ApXG4gICAgICAgIHJldHVybiBieVByb3A7XG4gICAgaWYgKG5vZGUubmFtZS5sZW5ndGggPT0gMSkge1xuICAgICAgICBsZXQgaW5kZXggPSBicmFja2V0cy5pbmRleE9mKG5vZGUubmFtZSk7XG4gICAgICAgIGlmIChpbmRleCA+IC0xICYmIGluZGV4ICUgMiA9PSAoZGlyIDwgMCA/IDEgOiAwKSlcbiAgICAgICAgICAgIHJldHVybiBbYnJhY2tldHNbaW5kZXggKyBkaXJdXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kSGFuZGxlKG5vZGUpIHtcbiAgICBsZXQgaGFzSGFuZGxlID0gbm9kZS50eXBlLnByb3AoYnJhY2tldE1hdGNoaW5nSGFuZGxlKTtcbiAgICByZXR1cm4gaGFzSGFuZGxlID8gaGFzSGFuZGxlKG5vZGUubm9kZSkgOiBub2RlO1xufVxuLyoqXG5GaW5kIHRoZSBtYXRjaGluZyBicmFja2V0IGZvciB0aGUgdG9rZW4gYXQgYHBvc2AsIHNjYW5uaW5nXG5kaXJlY3Rpb24gYGRpcmAuIE9ubHkgdGhlIGBicmFja2V0c2AgYW5kIGBtYXhTY2FuRGlzdGFuY2VgXG5wcm9wZXJ0aWVzIGFyZSB1c2VkIGZyb20gYGNvbmZpZ2AsIGlmIGdpdmVuLiBSZXR1cm5zIG51bGwgaWYgbm9cbmJyYWNrZXQgd2FzIGZvdW5kIGF0IGBwb3NgLCBvciBhIG1hdGNoIHJlc3VsdCBvdGhlcndpc2UuXG4qL1xuZnVuY3Rpb24gbWF0Y2hCcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIGNvbmZpZyA9IHt9KSB7XG4gICAgbGV0IG1heFNjYW5EaXN0YW5jZSA9IGNvbmZpZy5tYXhTY2FuRGlzdGFuY2UgfHwgRGVmYXVsdFNjYW5EaXN0LCBicmFja2V0cyA9IGNvbmZpZy5icmFja2V0cyB8fCBEZWZhdWx0QnJhY2tldHM7XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKSwgbm9kZSA9IHRyZWUucmVzb2x2ZUlubmVyKHBvcywgZGlyKTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnQpIHtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSBtYXRjaGluZ05vZGVzKGN1ci50eXBlLCBkaXIsIGJyYWNrZXRzKTtcbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgY3VyLmZyb20gPCBjdXIudG8pIHtcbiAgICAgICAgICAgIGxldCBoYW5kbGUgPSBmaW5kSGFuZGxlKGN1cik7XG4gICAgICAgICAgICBpZiAoaGFuZGxlICYmIChkaXIgPiAwID8gcG9zID49IGhhbmRsZS5mcm9tICYmIHBvcyA8IGhhbmRsZS50byA6IHBvcyA+IGhhbmRsZS5mcm9tICYmIHBvcyA8PSBoYW5kbGUudG8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaE1hcmtlZEJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgY3VyLCBoYW5kbGUsIG1hdGNoZXMsIGJyYWNrZXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hQbGFpbkJyYWNrZXRzKHN0YXRlLCBwb3MsIGRpciwgdHJlZSwgbm9kZS50eXBlLCBtYXhTY2FuRGlzdGFuY2UsIGJyYWNrZXRzKTtcbn1cbmZ1bmN0aW9uIG1hdGNoTWFya2VkQnJhY2tldHMoX3N0YXRlLCBfcG9zLCBkaXIsIHRva2VuLCBoYW5kbGUsIG1hdGNoaW5nLCBicmFja2V0cykge1xuICAgIGxldCBwYXJlbnQgPSB0b2tlbi5wYXJlbnQsIGZpcnN0VG9rZW4gPSB7IGZyb206IGhhbmRsZS5mcm9tLCB0bzogaGFuZGxlLnRvIH07XG4gICAgbGV0IGRlcHRoID0gMCwgY3Vyc29yID0gcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmN1cnNvcigpO1xuICAgIGlmIChjdXJzb3IgJiYgKGRpciA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUodG9rZW4uZnJvbSkgOiBjdXJzb3IuY2hpbGRBZnRlcih0b2tlbi50bykpKVxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZGlyIDwgMCA/IGN1cnNvci50byA8PSB0b2tlbi5mcm9tIDogY3Vyc29yLmZyb20gPj0gdG9rZW4udG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT0gMCAmJiBtYXRjaGluZy5pbmRleE9mKGN1cnNvci50eXBlLm5hbWUpID4gLTEgJiYgY3Vyc29yLmZyb20gPCBjdXJzb3IudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZEhhbmRsZSA9IGZpbmRIYW5kbGUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGZpcnN0VG9rZW4sIGVuZDogZW5kSGFuZGxlID8geyBmcm9tOiBlbmRIYW5kbGUuZnJvbSwgdG86IGVuZEhhbmRsZS50byB9IDogdW5kZWZpbmVkLCBtYXRjaGVkOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nTm9kZXMoY3Vyc29yLnR5cGUsIGRpciwgYnJhY2tldHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nTm9kZXMoY3Vyc29yLnR5cGUsIC1kaXIsIGJyYWNrZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVuZEhhbmRsZSA9IGZpbmRIYW5kbGUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGZpcnN0VG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBlbmRIYW5kbGUgJiYgZW5kSGFuZGxlLmZyb20gPCBlbmRIYW5kbGUudG8gPyB7IGZyb206IGVuZEhhbmRsZS5mcm9tLCB0bzogZW5kSGFuZGxlLnRvIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGRpciA8IDAgPyBjdXJzb3IucHJldlNpYmxpbmcoKSA6IGN1cnNvci5uZXh0U2libGluZygpKTtcbiAgICByZXR1cm4geyBzdGFydDogZmlyc3RUb2tlbiwgbWF0Y2hlZDogZmFsc2UgfTtcbn1cbmZ1bmN0aW9uIG1hdGNoUGxhaW5CcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIHRyZWUsIHRva2VuVHlwZSwgbWF4U2NhbkRpc3RhbmNlLCBicmFja2V0cykge1xuICAgIGxldCBzdGFydENoID0gZGlyIDwgMCA/IHN0YXRlLnNsaWNlRG9jKHBvcyAtIDEsIHBvcykgOiBzdGF0ZS5zbGljZURvYyhwb3MsIHBvcyArIDEpO1xuICAgIGxldCBicmFja2V0ID0gYnJhY2tldHMuaW5kZXhPZihzdGFydENoKTtcbiAgICBpZiAoYnJhY2tldCA8IDAgfHwgKGJyYWNrZXQgJSAyID09IDApICE9IChkaXIgPiAwKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHN0YXJ0VG9rZW4gPSB7IGZyb206IGRpciA8IDAgPyBwb3MgLSAxIDogcG9zLCB0bzogZGlyID4gMCA/IHBvcyArIDEgOiBwb3MgfTtcbiAgICBsZXQgaXRlciA9IHN0YXRlLmRvYy5pdGVyUmFuZ2UocG9zLCBkaXIgPiAwID8gc3RhdGUuZG9jLmxlbmd0aCA6IDApLCBkZXB0aCA9IDA7XG4gICAgZm9yIChsZXQgZGlzdGFuY2UgPSAwOyAhKGl0ZXIubmV4dCgpKS5kb25lICYmIGRpc3RhbmNlIDw9IG1heFNjYW5EaXN0YW5jZTspIHtcbiAgICAgICAgbGV0IHRleHQgPSBpdGVyLnZhbHVlO1xuICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHRleHQubGVuZ3RoO1xuICAgICAgICBsZXQgYmFzZVBvcyA9IHBvcyArIGRpc3RhbmNlICogZGlyO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSBkaXIgPiAwID8gMCA6IHRleHQubGVuZ3RoIC0gMSwgZW5kID0gZGlyID4gMCA/IHRleHQubGVuZ3RoIDogLTE7IHBvcyAhPSBlbmQ7IHBvcyArPSBkaXIpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGJyYWNrZXRzLmluZGV4T2YodGV4dFtwb3NdKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA8IDAgfHwgdHJlZS5yZXNvbHZlSW5uZXIoYmFzZVBvcyArIHBvcywgMSkudHlwZSAhPSB0b2tlblR5cGUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoKGZvdW5kICUgMiA9PSAwKSA9PSAoZGlyID4gMCkpIHtcbiAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVwdGggPT0gMSkgeyAvLyBDbG9zaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0VG9rZW4sIGVuZDogeyBmcm9tOiBiYXNlUG9zICsgcG9zLCB0bzogYmFzZVBvcyArIHBvcyArIDEgfSwgbWF0Y2hlZDogKGZvdW5kID4+IDEpID09IChicmFja2V0ID4+IDEpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBpdGVyLmRvbmUgPyB7IHN0YXJ0OiBzdGFydFRva2VuLCBtYXRjaGVkOiBmYWxzZSB9IDogbnVsbDtcbn1cblxuLy8gQ291bnRzIHRoZSBjb2x1bW4gb2Zmc2V0IGluIGEgc3RyaW5nLCB0YWtpbmcgdGFicyBpbnRvIGFjY291bnQuXG4vLyBVc2VkIG1vc3RseSB0byBmaW5kIGluZGVudGF0aW9uLlxuZnVuY3Rpb24gY291bnRDb2woc3RyaW5nLCBlbmQsIHRhYlNpemUsIHN0YXJ0SW5kZXggPSAwLCBzdGFydFZhbHVlID0gMCkge1xuICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSBzdHJpbmcuc2VhcmNoKC9bXlxcc1xcdTAwYTBdLyk7XG4gICAgICAgIGlmIChlbmQgPT0gLTEpXG4gICAgICAgICAgICBlbmQgPSBzdHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgbiA9IHN0YXJ0VmFsdWU7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT0gOSlcbiAgICAgICAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG4rKztcbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG4vKipcbkVuY2Fwc3VsYXRlcyBhIHNpbmdsZSBsaW5lIG9mIGlucHV0LiBHaXZlbiB0byBzdHJlYW0gc3ludGF4IGNvZGUsXG53aGljaCB1c2VzIGl0IHRvIHRva2VuaXplIHRoZSBjb250ZW50LlxuKi9cbmNsYXNzIFN0cmluZ1N0cmVhbSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc3RyZWFtLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxpbmUuXG4gICAgKi9cbiAgICBzdHJpbmcsIHRhYlNpemUsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGluZGVudCB1bml0IHNpemUuXG4gICAgKi9cbiAgICBpbmRlbnRVbml0LCBvdmVycmlkZUluZGVudCkge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgdGhpcy50YWJTaXplID0gdGFiU2l6ZTtcbiAgICAgICAgdGhpcy5pbmRlbnRVbml0ID0gaW5kZW50VW5pdDtcbiAgICAgICAgdGhpcy5vdmVycmlkZUluZGVudCA9IG92ZXJyaWRlSW5kZW50O1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIGxpbmUuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCB0b2tlbi5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydCA9IDA7XG4gICAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IDA7XG4gICAgICAgIHRoaXMubGFzdENvbHVtblZhbHVlID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB3ZSBhcmUgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIGVvbCgpIHsgcmV0dXJuIHRoaXMucG9zID49IHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgd2UgYXJlIGF0IHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHNvbCgpIHsgcmV0dXJuIHRoaXMucG9zID09IDA7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5leHQgY29kZSB1bml0IGFmdGVyIHRoZSBjdXJyZW50IHBvc2l0aW9uLCBvciB1bmRlZmluZWRcbiAgICBpZiB3ZSdyZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgcGVlaygpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykgfHwgdW5kZWZpbmVkOyB9XG4gICAgLyoqXG4gICAgUmVhZCB0aGUgbmV4dCBjb2RlIHVuaXQgYW5kIGFkdmFuY2UgYHRoaXMucG9zYC5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyA8IHRoaXMuc3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MrKyk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hdGNoIHRoZSBuZXh0IGNoYXJhY3RlciBhZ2FpbnN0IHRoZSBnaXZlbiBzdHJpbmcsIHJlZ3VsYXJcbiAgICBleHByZXNzaW9uLCBvciBwcmVkaWNhdGUuIENvbnN1bWUgYW5kIHJldHVybiBpdCBpZiBpdCBtYXRjaGVzLlxuICAgICovXG4gICAgZWF0KG1hdGNoKSB7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcyk7XG4gICAgICAgIGxldCBvaztcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgb2sgPSBjaCA9PSBtYXRjaDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb2sgPSBjaCAmJiAobWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHAgPyBtYXRjaC50ZXN0KGNoKSA6IG1hdGNoKGNoKSk7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDb250aW51ZSBtYXRjaGluZyBjaGFyYWN0ZXJzIHRoYXQgbWF0Y2ggdGhlIGdpdmVuIHN0cmluZyxcbiAgICByZWd1bGFyIGV4cHJlc3Npb24sIG9yIHByZWRpY2F0ZSBmdW5jdGlvbi4gUmV0dXJuIHRydWUgaWYgYW55XG4gICAgY2hhcmFjdGVycyB3ZXJlIGNvbnN1bWVkLlxuICAgICovXG4gICAgZWF0V2hpbGUobWF0Y2gpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHdoaWxlICh0aGlzLmVhdChtYXRjaCkpIHsgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uc3VtZSB3aGl0ZXNwYWNlIGFoZWFkIG9mIGB0aGlzLnBvc2AuIFJldHVybiB0cnVlIGlmIGFueSB3YXNcbiAgICBmb3VuZC5cbiAgICAqL1xuICAgIGVhdFNwYWNlKCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnBvcztcbiAgICAgICAgd2hpbGUgKC9bXFxzXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSkpXG4gICAgICAgICAgICArK3RoaXMucG9zO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgPiBzdGFydDtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICAgICovXG4gICAgc2tpcFRvRW5kKCkgeyB0aGlzLnBvcyA9IHRoaXMuc3RyaW5nLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gZGlyZWN0bHkgYmVmb3JlIHRoZSBnaXZlbiBjaGFyYWN0ZXIsIGlmIGZvdW5kIG9uIHRoZVxuICAgIGN1cnJlbnQgbGluZS5cbiAgICAqL1xuICAgIHNraXBUbyhjaCkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLnN0cmluZy5pbmRleE9mKGNoLCB0aGlzLnBvcyk7XG4gICAgICAgIGlmIChmb3VuZCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGZvdW5kO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBiYWNrIGBuYCBjaGFyYWN0ZXJzLlxuICAgICovXG4gICAgYmFja1VwKG4pIHsgdGhpcy5wb3MgLT0gbjsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29sdW1uIHBvc2l0aW9uIGF0IGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICBjb2x1bW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3RDb2x1bW5Qb3MgPCB0aGlzLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IGNvdW50Q29sKHRoaXMuc3RyaW5nLCB0aGlzLnN0YXJ0LCB0aGlzLnRhYlNpemUsIHRoaXMubGFzdENvbHVtblBvcywgdGhpcy5sYXN0Q29sdW1uVmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q29sdW1uVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgaW5kZW50YXRpb24gY29sdW1uIG9mIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgKi9cbiAgICBpbmRlbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5vdmVycmlkZUluZGVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY291bnRDb2wodGhpcy5zdHJpbmcsIG51bGwsIHRoaXMudGFiU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hdGNoIHRoZSBpbnB1dCBhZ2FpbnN0IHRoZSBnaXZlbiBzdHJpbmcgb3IgcmVndWxhciBleHByZXNzaW9uXG4gICAgKHdoaWNoIHNob3VsZCBzdGFydCB3aXRoIGEgYF5gKS4gUmV0dXJuIHRydWUgb3IgdGhlIHJlZ2V4cCBtYXRjaFxuICAgIGlmIGl0IG1hdGNoZXMuXG4gICAgXG4gICAgVW5sZXNzIGBjb25zdW1lYCBpcyBzZXQgdG8gYGZhbHNlYCwgdGhpcyB3aWxsIG1vdmUgYHRoaXMucG9zYFxuICAgIHBhc3QgdGhlIG1hdGNoZWQgdGV4dC5cbiAgICBcbiAgICBXaGVuIG1hdGNoaW5nIGEgc3RyaW5nIGBjYXNlSW5zZW5zaXRpdmVgIGNhbiBiZSBzZXQgdG8gdHJ1ZSB0b1xuICAgIG1ha2UgdGhlIG1hdGNoIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgKi9cbiAgICBtYXRjaChwYXR0ZXJuLCBjb25zdW1lLCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxldCBjYXNlZCA9IChzdHIpID0+IGNhc2VJbnNlbnNpdGl2ZSA/IHN0ci50b0xvd2VyQ2FzZSgpIDogc3RyO1xuICAgICAgICAgICAgbGV0IHN1YnN0ciA9IHRoaXMuc3RyaW5nLnN1YnN0cih0aGlzLnBvcywgcGF0dGVybi5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGNhc2VkKHN1YnN0cikgPT0gY2FzZWQocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uc3VtZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zICs9IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5wb3MpLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4ID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBjb25zdW1lICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjdXJyZW50IHRva2VuLlxuICAgICovXG4gICAgY3VycmVudCgpIHsgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMucG9zKTsgfVxufVxuXG5mdW5jdGlvbiBmdWxsUGFyc2VyKHNwZWMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBzcGVjLm5hbWUgfHwgXCJcIixcbiAgICAgICAgdG9rZW46IHNwZWMudG9rZW4sXG4gICAgICAgIGJsYW5rTGluZTogc3BlYy5ibGFua0xpbmUgfHwgKCgpID0+IHsgfSksXG4gICAgICAgIHN0YXJ0U3RhdGU6IHNwZWMuc3RhcnRTdGF0ZSB8fCAoKCkgPT4gdHJ1ZSksXG4gICAgICAgIGNvcHlTdGF0ZTogc3BlYy5jb3B5U3RhdGUgfHwgZGVmYXVsdENvcHlTdGF0ZSxcbiAgICAgICAgaW5kZW50OiBzcGVjLmluZGVudCB8fCAoKCkgPT4gbnVsbCksXG4gICAgICAgIGxhbmd1YWdlRGF0YTogc3BlYy5sYW5ndWFnZURhdGEgfHwge30sXG4gICAgICAgIHRva2VuVGFibGU6IHNwZWMudG9rZW5UYWJsZSB8fCBub1Rva2Vuc1xuICAgIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0Q29weVN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgbGV0IG5ld1N0YXRlID0ge307XG4gICAgZm9yIChsZXQgcHJvcCBpbiBzdGF0ZSkge1xuICAgICAgICBsZXQgdmFsID0gc3RhdGVbcHJvcF07XG4gICAgICAgIG5ld1N0YXRlW3Byb3BdID0gKHZhbCBpbnN0YW5jZW9mIEFycmF5ID8gdmFsLnNsaWNlKCkgOiB2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3U3RhdGU7XG59XG5jb25zdCBJbmRlbnRlZEZyb20gPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8qKlxuQSBbbGFuZ3VhZ2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuTGFuZ3VhZ2UpIGNsYXNzIGJhc2VkIG9uIGEgQ29kZU1pcnJvclxuNS1zdHlsZSBbc3RyZWFtaW5nIHBhcnNlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5TdHJlYW1QYXJzZXIpLlxuKi9cbmNsYXNzIFN0cmVhbUxhbmd1YWdlIGV4dGVuZHMgTGFuZ3VhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICBsZXQgZGF0YSA9IGRlZmluZUxhbmd1YWdlRmFjZXQocGFyc2VyLmxhbmd1YWdlRGF0YSk7XG4gICAgICAgIGxldCBwID0gZnVsbFBhcnNlcihwYXJzZXIpLCBzZWxmO1xuICAgICAgICBsZXQgaW1wbCA9IG5ldyBjbGFzcyBleHRlbmRzIFBhcnNlciB7XG4gICAgICAgICAgICBjcmVhdGVQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlKHNlbGYsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKGRhdGEsIGltcGwsIFtdLCBwYXJzZXIubmFtZSk7XG4gICAgICAgIHRoaXMudG9wTm9kZSA9IGRvY0lEKGRhdGEsIHRoaXMpO1xuICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5zdHJlYW1QYXJzZXIgPSBwO1xuICAgICAgICB0aGlzLnN0YXRlQWZ0ZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnRva2VuVGFibGUgPSBwYXJzZXIudG9rZW5UYWJsZSA/IG5ldyBUb2tlblRhYmxlKHAudG9rZW5UYWJsZSkgOiBkZWZhdWx0VG9rZW5UYWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgc3RyZWFtIGxhbmd1YWdlLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjKSB7IHJldHVybiBuZXcgU3RyZWFtTGFuZ3VhZ2Uoc3BlYyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldEluZGVudChjeCkge1xuICAgICAgICBsZXQgZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHsgb3ZlcnJpZGVJbmRlbnRhdGlvbiB9ID0gY3gub3B0aW9ucztcbiAgICAgICAgaWYgKG92ZXJyaWRlSW5kZW50YXRpb24pIHtcbiAgICAgICAgICAgIGZyb20gPSBJbmRlbnRlZEZyb20uZ2V0KGN4LnN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmcm9tICE9IG51bGwgJiYgZnJvbSA8IGN4LnBvcyAtIDFlNClcbiAgICAgICAgICAgICAgICBmcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IGZpbmRTdGF0ZSh0aGlzLCBjeC5ub2RlLnRyZWUsIGN4Lm5vZGUuZnJvbSwgY3gubm9kZS5mcm9tLCBmcm9tICE9PSBudWxsICYmIGZyb20gIT09IHZvaWQgMCA/IGZyb20gOiBjeC5wb3MpLCBzdGF0ZVBvcywgc3RhdGU7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgICAgIHN0YXRlUG9zID0gc3RhcnQucG9zICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShjeC51bml0KTtcbiAgICAgICAgICAgIHN0YXRlUG9zID0gY3gubm9kZS5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjeC5wb3MgLSBzdGF0ZVBvcyA+IDEwMDAwIC8qIEMuTWF4SW5kZW50U2NhbkRpc3QgKi8pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgd2hpbGUgKHN0YXRlUG9zIDwgY3gucG9zKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGN4LnN0YXRlLmRvYy5saW5lQXQoc3RhdGVQb3MpLCBlbmQgPSBNYXRoLm1pbihjeC5wb3MsIGxpbmUudG8pO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGVudGF0aW9uID0gb3ZlcnJpZGVJbmRlbnRhdGlvbiA/IG92ZXJyaWRlSW5kZW50YXRpb24obGluZS5mcm9tKSA6IC0xO1xuICAgICAgICAgICAgICAgIGxldCBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUudGV4dCwgY3guc3RhdGUudGFiU2l6ZSwgY3gudW5pdCwgaW5kZW50YXRpb24gPCAwID8gdW5kZWZpbmVkIDogaW5kZW50YXRpb24pO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHJlYW0ucG9zIDwgZW5kIC0gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICByZWFkVG9rZW4odGhpcy5zdHJlYW1QYXJzZXIudG9rZW4sIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1QYXJzZXIuYmxhbmtMaW5lKHN0YXRlLCBjeC51bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPT0gY3gucG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RhdGVQb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZSA9IGN4LmxpbmVBdChjeC5wb3MpO1xuICAgICAgICBpZiAob3ZlcnJpZGVJbmRlbnRhdGlvbiAmJiBmcm9tID09IG51bGwpXG4gICAgICAgICAgICBJbmRlbnRlZEZyb20uc2V0KGN4LnN0YXRlLCBsaW5lLmZyb20pO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW1QYXJzZXIuaW5kZW50KHN0YXRlLCAvXlxccyooLiopLy5leGVjKGxpbmUudGV4dClbMV0sIGN4KTtcbiAgICB9XG4gICAgZ2V0IGFsbG93c05lc3RpbmcoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuZnVuY3Rpb24gZmluZFN0YXRlKGxhbmcsIHRyZWUsIG9mZiwgc3RhcnRQb3MsIGJlZm9yZSkge1xuICAgIGxldCBzdGF0ZSA9IG9mZiA+PSBzdGFydFBvcyAmJiBvZmYgKyB0cmVlLmxlbmd0aCA8PSBiZWZvcmUgJiYgdHJlZS5wcm9wKGxhbmcuc3RhdGVBZnRlcik7XG4gICAgaWYgKHN0YXRlKVxuICAgICAgICByZXR1cm4geyBzdGF0ZTogbGFuZy5zdHJlYW1QYXJzZXIuY29weVN0YXRlKHN0YXRlKSwgcG9zOiBvZmYgKyB0cmVlLmxlbmd0aCB9O1xuICAgIGZvciAobGV0IGkgPSB0cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHRyZWUuY2hpbGRyZW5baV0sIHBvcyA9IG9mZiArIHRyZWUucG9zaXRpb25zW2ldO1xuICAgICAgICBsZXQgZm91bmQgPSBjaGlsZCBpbnN0YW5jZW9mIFRyZWUgJiYgcG9zIDwgYmVmb3JlICYmIGZpbmRTdGF0ZShsYW5nLCBjaGlsZCwgcG9zLCBzdGFydFBvcywgYmVmb3JlKTtcbiAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGN1dFRyZWUobGFuZywgdHJlZSwgZnJvbSwgdG8sIGluc2lkZSkge1xuICAgIGlmIChpbnNpZGUgJiYgZnJvbSA8PSAwICYmIHRvID49IHRyZWUubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICBpZiAoIWluc2lkZSAmJiBmcm9tID09IDAgJiYgdHJlZS50eXBlID09IGxhbmcudG9wTm9kZSlcbiAgICAgICAgaW5zaWRlID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgcG9zID0gdHJlZS5wb3NpdGlvbnNbaV0sIGNoaWxkID0gdHJlZS5jaGlsZHJlbltpXSwgaW5uZXI7XG4gICAgICAgIGlmIChwb3MgPCB0byAmJiBjaGlsZCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgIGlmICghKGlubmVyID0gY3V0VHJlZShsYW5nLCBjaGlsZCwgZnJvbSAtIHBvcywgdG8gLSBwb3MsIGluc2lkZSkpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcmV0dXJuICFpbnNpZGUgPyBpbm5lclxuICAgICAgICAgICAgICAgIDogbmV3IFRyZWUodHJlZS50eXBlLCB0cmVlLmNoaWxkcmVuLnNsaWNlKDAsIGkpLmNvbmNhdChpbm5lciksIHRyZWUucG9zaXRpb25zLnNsaWNlKDAsIGkgKyAxKSwgcG9zICsgaW5uZXIubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRTdGFydEluRnJhZ21lbnRzKGxhbmcsIGZyYWdtZW50cywgc3RhcnRQb3MsIGVuZFBvcywgZWRpdG9yU3RhdGUpIHtcbiAgICBmb3IgKGxldCBmIG9mIGZyYWdtZW50cykge1xuICAgICAgICBsZXQgZnJvbSA9IGYuZnJvbSArIChmLm9wZW5TdGFydCA/IDI1IDogMCksIHRvID0gZi50byAtIChmLm9wZW5FbmQgPyAyNSA6IDApO1xuICAgICAgICBsZXQgZm91bmQgPSBmcm9tIDw9IHN0YXJ0UG9zICYmIHRvID4gc3RhcnRQb3MgJiYgZmluZFN0YXRlKGxhbmcsIGYudHJlZSwgMCAtIGYub2Zmc2V0LCBzdGFydFBvcywgdG8pLCB0cmVlO1xuICAgICAgICBpZiAoZm91bmQgJiYgZm91bmQucG9zIDw9IGVuZFBvcyAmJiAodHJlZSA9IGN1dFRyZWUobGFuZywgZi50cmVlLCBzdGFydFBvcyArIGYub2Zmc2V0LCBmb3VuZC5wb3MgKyBmLm9mZnNldCwgZmFsc2UpKSlcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBmb3VuZC5zdGF0ZSwgdHJlZSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0ZTogbGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShlZGl0b3JTdGF0ZSA/IGdldEluZGVudFVuaXQoZWRpdG9yU3RhdGUpIDogNCksIHRyZWU6IFRyZWUuZW1wdHkgfTtcbn1cbmNsYXNzIFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihsYW5nLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5sYW5nID0gbGFuZztcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMudG8gPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICBsZXQgY29udGV4dCA9IFBhcnNlQ29udGV4dC5nZXQoKSwgZnJvbSA9IHJhbmdlc1swXS5mcm9tO1xuICAgICAgICBsZXQgeyBzdGF0ZSwgdHJlZSB9ID0gZmluZFN0YXJ0SW5GcmFnbWVudHMobGFuZywgZnJhZ21lbnRzLCBmcm9tLCB0aGlzLnRvLCBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQuc3RhdGUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucGFyc2VkUG9zID0gdGhpcy5jaHVua1N0YXJ0ID0gZnJvbSArIHRyZWUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2godHJlZS5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godHJlZS5wb3NpdGlvbnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0ICYmIHRoaXMucGFyc2VkUG9zIDwgY29udGV4dC52aWV3cG9ydC5mcm9tIC0gMTAwMDAwIC8qIEMuTWF4RGlzdGFuY2VCZWZvcmVWaWV3cG9ydCAqLyAmJlxuICAgICAgICAgICAgcmFuZ2VzLnNvbWUociA9PiByLmZyb20gPD0gY29udGV4dC52aWV3cG9ydC5mcm9tICYmIHIudG8gPj0gY29udGV4dC52aWV3cG9ydC5mcm9tKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMubGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShnZXRJbmRlbnRVbml0KGNvbnRleHQuc3RhdGUpKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2tpcFVudGlsSW5WaWV3KHRoaXMucGFyc2VkUG9zLCBjb250ZXh0LnZpZXdwb3J0LmZyb20pO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBjb250ZXh0LnZpZXdwb3J0LmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlUmFuZ2VJbmRleCgpO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBsZXQgY29udGV4dCA9IFBhcnNlQ29udGV4dC5nZXQoKTtcbiAgICAgICAgbGV0IHBhcnNlRW5kID0gdGhpcy5zdG9wcGVkQXQgPT0gbnVsbCA/IHRoaXMudG8gOiBNYXRoLm1pbih0aGlzLnRvLCB0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihwYXJzZUVuZCwgdGhpcy5jaHVua1N0YXJ0ICsgMjA0OCAvKiBDLkNodW5rU2l6ZSAqLyk7XG4gICAgICAgIGlmIChjb250ZXh0KVxuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBjb250ZXh0LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgd2hpbGUgKHRoaXMucGFyc2VkUG9zIDwgZW5kKVxuICAgICAgICAgICAgdGhpcy5wYXJzZUxpbmUoY29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rU3RhcnQgPCB0aGlzLnBhcnNlZFBvcylcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsoKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkUG9zID49IHBhcnNlRW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGlmIChjb250ZXh0ICYmIHRoaXMucGFyc2VkUG9zID49IGNvbnRleHQudmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2tpcFVudGlsSW5WaWV3KHRoaXMucGFyc2VkUG9zLCBwYXJzZUVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgbGluZUFmdGVyKHBvcykge1xuICAgICAgICBsZXQgY2h1bmsgPSB0aGlzLmlucHV0LmNodW5rKHBvcyk7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dC5saW5lQ2h1bmtzKSB7XG4gICAgICAgICAgICBsZXQgZW9sID0gY2h1bmsuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICAgIGlmIChlb2wgPiAtMSlcbiAgICAgICAgICAgICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIGVvbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2h1bmsgPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgY2h1bmsgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3MgKyBjaHVuay5sZW5ndGggPD0gdGhpcy50byA/IGNodW5rIDogY2h1bmsuc2xpY2UoMCwgdGhpcy50byAtIHBvcyk7XG4gICAgfVxuICAgIG5leHRMaW5lKCkge1xuICAgICAgICBsZXQgZnJvbSA9IHRoaXMucGFyc2VkUG9zLCBsaW5lID0gdGhpcy5saW5lQWZ0ZXIoZnJvbSksIGVuZCA9IGZyb20gKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSB0aGlzLnJhbmdlSW5kZXg7Oykge1xuICAgICAgICAgICAgbGV0IHJhbmdlRW5kID0gdGhpcy5yYW5nZXNbaW5kZXhdLnRvO1xuICAgICAgICAgICAgaWYgKHJhbmdlRW5kID49IGVuZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIHJhbmdlRW5kIC0gKGVuZCAtIGxpbmUubGVuZ3RoKSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCByYW5nZVN0YXJ0ID0gdGhpcy5yYW5nZXNbaW5kZXhdLmZyb207XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmxpbmVBZnRlcihyYW5nZVN0YXJ0KTtcbiAgICAgICAgICAgIGxpbmUgKz0gYWZ0ZXI7XG4gICAgICAgICAgICBlbmQgPSByYW5nZVN0YXJ0ICsgYWZ0ZXIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmUsIGVuZCB9O1xuICAgIH1cbiAgICBza2lwR2Fwc1RvKHBvcywgb2Zmc2V0LCBzaWRlKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXhdLnRvLCBvZmZQb3MgPSBwb3MgKyBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoc2lkZSA+IDAgPyBlbmQgPiBvZmZQb3MgOiBlbmQgPj0gb2ZmUG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdLmZyb207XG4gICAgICAgICAgICBvZmZzZXQgKz0gc3RhcnQgLSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgbW92ZVJhbmdlSW5kZXgoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXhdLnRvIDwgdGhpcy5wYXJzZWRQb3MpXG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXgrKztcbiAgICB9XG4gICAgZW1pdFRva2VuKGlkLCBmcm9tLCB0bywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBzaXplID0gNDtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2tpcEdhcHNUbyhmcm9tLCBvZmZzZXQsIDEpO1xuICAgICAgICAgICAgZnJvbSArPSBvZmZzZXQ7XG4gICAgICAgICAgICBsZXQgbGVuMCA9IHRoaXMuY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5za2lwR2Fwc1RvKHRvLCBvZmZzZXQsIC0xKTtcbiAgICAgICAgICAgIHRvICs9IG9mZnNldDtcbiAgICAgICAgICAgIHNpemUgKz0gdGhpcy5jaHVuay5sZW5ndGggLSBsZW4wO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5jaHVuay5sZW5ndGggLSA0O1xuICAgICAgICBpZiAoc2l6ZSA9PSA0ICYmIGxhc3QgPj0gMCAmJiB0aGlzLmNodW5rW2xhc3RdID09IGlkICYmIHRoaXMuY2h1bmtbbGFzdCArIDJdID09IGZyb20pXG4gICAgICAgICAgICB0aGlzLmNodW5rW2xhc3QgKyAyXSA9IHRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmNodW5rLnB1c2goaWQsIGZyb20sIHRvLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgcGFyc2VMaW5lKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHsgbGluZSwgZW5kIH0gPSB0aGlzLm5leHRMaW5lKCksIG9mZnNldCA9IDAsIHsgc3RyZWFtUGFyc2VyIH0gPSB0aGlzLmxhbmc7XG4gICAgICAgIGxldCBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUsIGNvbnRleHQgPyBjb250ZXh0LnN0YXRlLnRhYlNpemUgOiA0LCBjb250ZXh0ID8gZ2V0SW5kZW50VW5pdChjb250ZXh0LnN0YXRlKSA6IDIpO1xuICAgICAgICBpZiAoc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgICBzdHJlYW1QYXJzZXIuYmxhbmtMaW5lKHRoaXMuc3RhdGUsIHN0cmVhbS5pbmRlbnRVbml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gcmVhZFRva2VuKHN0cmVhbVBhcnNlci50b2tlbiwgc3RyZWFtLCB0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuZW1pdFRva2VuKHRoaXMubGFuZy50b2tlblRhYmxlLnJlc29sdmUodG9rZW4pLCB0aGlzLnBhcnNlZFBvcyArIHN0cmVhbS5zdGFydCwgdGhpcy5wYXJzZWRQb3MgKyBzdHJlYW0ucG9zLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uc3RhcnQgPiAxMDAwMCAvKiBDLk1heExpbmVMZW5ndGggKi8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VkUG9zID0gZW5kO1xuICAgICAgICB0aGlzLm1vdmVSYW5nZUluZGV4KCk7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFBvcyA8IHRoaXMudG8pXG4gICAgICAgICAgICB0aGlzLnBhcnNlZFBvcysrO1xuICAgIH1cbiAgICBmaW5pc2hDaHVuaygpIHtcbiAgICAgICAgbGV0IHRyZWUgPSBUcmVlLmJ1aWxkKHtcbiAgICAgICAgICAgIGJ1ZmZlcjogdGhpcy5jaHVuayxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmNodW5rU3RhcnQsXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMucGFyc2VkUG9zIC0gdGhpcy5jaHVua1N0YXJ0LFxuICAgICAgICAgICAgbm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiAwLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiAyMDQ4IC8qIEMuQ2h1bmtTaXplICovLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLmNodW5rUmV1c2VkXG4gICAgICAgIH0pO1xuICAgICAgICB0cmVlID0gbmV3IFRyZWUodHJlZS50eXBlLCB0cmVlLmNoaWxkcmVuLCB0cmVlLnBvc2l0aW9ucywgdHJlZS5sZW5ndGgsIFtbdGhpcy5sYW5nLnN0YXRlQWZ0ZXIsIHRoaXMubGFuZy5zdHJlYW1QYXJzZXIuY29weVN0YXRlKHRoaXMuc3RhdGUpXV0pO1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHRyZWUpO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godGhpcy5jaHVua1N0YXJ0IC0gdGhpcy5yYW5nZXNbMF0uZnJvbSk7XG4gICAgICAgIHRoaXMuY2h1bmsgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1JldXNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gdGhpcy5wYXJzZWRQb3M7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMubGFuZy50b3BOb2RlLCB0aGlzLmNodW5rcywgdGhpcy5jaHVua1BvcywgdGhpcy5wYXJzZWRQb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tKS5iYWxhbmNlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVhZFRva2VuKHRva2VuLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRva2VuKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBpZiAoc3RyZWFtLnBvcyA+IHN0cmVhbS5zdGFydClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBwYXJzZXIgZmFpbGVkIHRvIGFkdmFuY2Ugc3RyZWFtLlwiKTtcbn1cbmNvbnN0IG5vVG9rZW5zID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCB0eXBlQXJyYXkgPSBbTm9kZVR5cGUubm9uZV07XG5jb25zdCBub2RlU2V0ID0gLypAX19QVVJFX18qL25ldyBOb2RlU2V0KHR5cGVBcnJheSk7XG5jb25zdCB3YXJuZWQgPSBbXTtcbi8vIENhY2hlIG9mIG5vZGUgdHlwZXMgYnkgbmFtZSBhbmQgdGFnc1xuY29uc3QgYnlUYWcgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IGRlZmF1bHRUYWJsZSA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuZm9yIChsZXQgW2xlZ2FjeU5hbWUsIG5hbWVdIG9mIFtcbiAgICBbXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlTmFtZVwiXSxcbiAgICBbXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIl0sXG4gICAgW1wic3RyaW5nLTJcIiwgXCJzdHJpbmcuc3BlY2lhbFwiXSxcbiAgICBbXCJkZWZcIiwgXCJ2YXJpYWJsZU5hbWUuZGVmaW5pdGlvblwiXSxcbiAgICBbXCJ0YWdcIiwgXCJ0YWdOYW1lXCJdLFxuICAgIFtcImF0dHJpYnV0ZVwiLCBcImF0dHJpYnV0ZU5hbWVcIl0sXG4gICAgW1widHlwZVwiLCBcInR5cGVOYW1lXCJdLFxuICAgIFtcImJ1aWx0aW5cIiwgXCJ2YXJpYWJsZU5hbWUuc3RhbmRhcmRcIl0sXG4gICAgW1wicXVhbGlmaWVyXCIsIFwibW9kaWZpZXJcIl0sXG4gICAgW1wiZXJyb3JcIiwgXCJpbnZhbGlkXCJdLFxuICAgIFtcImhlYWRlclwiLCBcImhlYWRpbmdcIl0sXG4gICAgW1wicHJvcGVydHlcIiwgXCJwcm9wZXJ0eU5hbWVcIl1cbl0pXG4gICAgZGVmYXVsdFRhYmxlW2xlZ2FjeU5hbWVdID0gLypAX19QVVJFX18qL2NyZWF0ZVRva2VuVHlwZShub1Rva2VucywgbmFtZSk7XG5jbGFzcyBUb2tlblRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihleHRyYSkge1xuICAgICAgICB0aGlzLmV4dHJhID0gZXh0cmE7XG4gICAgICAgIHRoaXMudGFibGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGRlZmF1bHRUYWJsZSk7XG4gICAgfVxuICAgIHJlc29sdmUodGFnKSB7XG4gICAgICAgIHJldHVybiAhdGFnID8gMCA6IHRoaXMudGFibGVbdGFnXSB8fCAodGhpcy50YWJsZVt0YWddID0gY3JlYXRlVG9rZW5UeXBlKHRoaXMuZXh0cmEsIHRhZykpO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRUb2tlblRhYmxlID0gLypAX19QVVJFX18qL25ldyBUb2tlblRhYmxlKG5vVG9rZW5zKTtcbmZ1bmN0aW9uIHdhcm5Gb3JQYXJ0KHBhcnQsIG1zZykge1xuICAgIGlmICh3YXJuZWQuaW5kZXhPZihwYXJ0KSA+IC0xKVxuICAgICAgICByZXR1cm47XG4gICAgd2FybmVkLnB1c2gocGFydCk7XG4gICAgY29uc29sZS53YXJuKG1zZyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlblR5cGUoZXh0cmEsIHRhZ1N0cikge1xuICAgIGxldCB0YWdzJDEgPSBbXTtcbiAgICBmb3IgKGxldCBuYW1lIG9mIHRhZ1N0ci5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gW107XG4gICAgICAgIGZvciAobGV0IHBhcnQgb2YgbmFtZS5zcGxpdChcIi5cIikpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IChleHRyYVtwYXJ0XSB8fCB0YWdzW3BhcnRdKTtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgVW5rbm93biBoaWdobGlnaHRpbmcgdGFnICR7cGFydH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYE1vZGlmaWVyICR7cGFydH0gdXNlZCBhdCBzdGFydCBvZiB0YWdgKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gZm91bmQubWFwKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBUYWcgJHtwYXJ0fSB1c2VkIGFzIG1vZGlmaWVyYCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHRhZyBvZiBmb3VuZClcbiAgICAgICAgICAgIHRhZ3MkMS5wdXNoKHRhZyk7XG4gICAgfVxuICAgIGlmICghdGFncyQxLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgbGV0IG5hbWUgPSB0YWdTdHIucmVwbGFjZSgvIC9nLCBcIl9cIiksIGtleSA9IG5hbWUgKyBcIiBcIiArIHRhZ3MkMS5tYXAodCA9PiB0LmlkKTtcbiAgICBsZXQga25vd24gPSBieVRhZ1trZXldO1xuICAgIGlmIChrbm93bilcbiAgICAgICAgcmV0dXJuIGtub3duLmlkO1xuICAgIGxldCB0eXBlID0gYnlUYWdba2V5XSA9IE5vZGVUeXBlLmRlZmluZSh7XG4gICAgICAgIGlkOiB0eXBlQXJyYXkubGVuZ3RoLFxuICAgICAgICBuYW1lLFxuICAgICAgICBwcm9wczogW3N0eWxlVGFncyh7IFtuYW1lXTogdGFncyQxIH0pXVxuICAgIH0pO1xuICAgIHR5cGVBcnJheS5wdXNoKHR5cGUpO1xuICAgIHJldHVybiB0eXBlLmlkO1xufVxuZnVuY3Rpb24gZG9jSUQoZGF0YSwgbGFuZykge1xuICAgIGxldCB0eXBlID0gTm9kZVR5cGUuZGVmaW5lKHsgaWQ6IHR5cGVBcnJheS5sZW5ndGgsIG5hbWU6IFwiRG9jdW1lbnRcIiwgcHJvcHM6IFtcbiAgICAgICAgICAgIGxhbmd1YWdlRGF0YVByb3AuYWRkKCgpID0+IGRhdGEpLFxuICAgICAgICAgICAgaW5kZW50Tm9kZVByb3AuYWRkKCgpID0+IGN4ID0+IGxhbmcuZ2V0SW5kZW50KGN4KSlcbiAgICAgICAgXSwgdG9wOiB0cnVlIH0pO1xuICAgIHR5cGVBcnJheS5wdXNoKHR5cGUpO1xuICAgIHJldHVybiB0eXBlO1xufVxuXG5mdW5jdGlvbiBidWlsZEZvckxpbmUobGluZSkge1xuICAgIHJldHVybiBsaW5lLmxlbmd0aCA8PSA0MDk2ICYmIC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXFx1ZmI1MC1cXHVmZGZmXS8udGVzdChsaW5lKTtcbn1cbmZ1bmN0aW9uIHRleHRIYXNSVEwodGV4dCkge1xuICAgIGZvciAobGV0IGkgPSB0ZXh0Lml0ZXIoKTsgIWkubmV4dCgpLmRvbmU7KVxuICAgICAgICBpZiAoYnVpbGRGb3JMaW5lKGkudmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2hhbmdlQWRkc1JUTChjaGFuZ2UpIHtcbiAgICBsZXQgYWRkZWQgPSBmYWxzZTtcbiAgICBjaGFuZ2UuaXRlckNoYW5nZXMoKGZBLCB0QSwgZkIsIHRCLCBpbnMpID0+IHtcbiAgICAgICAgaWYgKCFhZGRlZCAmJiB0ZXh0SGFzUlRMKGlucykpXG4gICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFkZGVkO1xufVxuY29uc3QgYWx3YXlzSXNvbGF0ZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KSB9KTtcbi8qKlxuTWFrZSBzdXJlIG5vZGVzXG5bbWFya2VkXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tb24uTm9kZVByb3BeaXNvbGF0ZSlcbmFzIGlzb2xhdGluZyBmb3IgYmlkaXJlY3Rpb25hbCB0ZXh0IGFyZSByZW5kZXJlZCBpbiBhIHdheSB0aGF0XG5pc29sYXRlcyB0aGVtIGZyb20gdGhlIHN1cnJvdW5kaW5nIHRleHQuXG4qL1xuZnVuY3Rpb24gYmlkaUlzb2xhdGVzKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBleHRlbnNpb25zID0gW2lzb2xhdGVNYXJrc107XG4gICAgaWYgKG9wdGlvbnMuYWx3YXlzSXNvbGF0ZSlcbiAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKGFsd2F5c0lzb2xhdGUub2YodHJ1ZSkpO1xuICAgIHJldHVybiBleHRlbnNpb25zO1xufVxuY29uc3QgaXNvbGF0ZU1hcmtzID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMuYWx3YXlzID0gdmlldy5zdGF0ZS5mYWNldChhbHdheXNJc29sYXRlKSB8fFxuICAgICAgICAgICAgdmlldy50ZXh0RGlyZWN0aW9uICE9IERpcmVjdGlvbi5MVFIgfHxcbiAgICAgICAgICAgIHZpZXcuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5wZXJMaW5lVGV4dERpcmVjdGlvbik7XG4gICAgICAgIHRoaXMuaGFzUlRMID0gIXRoaXMuYWx3YXlzICYmIHRleHRIYXNSVEwodmlldy5zdGF0ZS5kb2MpO1xuICAgICAgICB0aGlzLnRyZWUgPSBzeW50YXhUcmVlKHZpZXcuc3RhdGUpO1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5hbHdheXMgfHwgdGhpcy5oYXNSVEwgPyBidWlsZERlY28odmlldywgdGhpcy50cmVlLCB0aGlzLmFsd2F5cykgOiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGFsd2F5cyA9IHVwZGF0ZS5zdGF0ZS5mYWNldChhbHdheXNJc29sYXRlKSB8fFxuICAgICAgICAgICAgdXBkYXRlLnZpZXcudGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSIHx8XG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuZmFjZXQoRWRpdG9yVmlldy5wZXJMaW5lVGV4dERpcmVjdGlvbik7XG4gICAgICAgIGlmICghYWx3YXlzICYmICF0aGlzLmhhc1JUTCAmJiBjaGFuZ2VBZGRzUlRMKHVwZGF0ZS5jaGFuZ2VzKSlcbiAgICAgICAgICAgIHRoaXMuaGFzUlRMID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFhbHdheXMgJiYgIXRoaXMuaGFzUlRMKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgdHJlZSA9IHN5bnRheFRyZWUodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKGFsd2F5cyAhPSB0aGlzLmFsd2F5cyB8fCB0cmVlICE9IHRoaXMudHJlZSB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICAgICAgdGhpcy5hbHdheXMgPSBhbHdheXM7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gYnVpbGREZWNvKHVwZGF0ZS52aWV3LCB0cmVlLCBhbHdheXMpO1xuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIHByb3ZpZGU6IHBsdWdpbiA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIGFjY2Vzcyh2aWV3KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHZpZXcucGx1Z2luKHBsdWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWNvcmF0aW9ucykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbRWRpdG9yVmlldy5vdXRlckRlY29yYXRpb25zLm9mKGFjY2VzcyksXG4gICAgICAgICAgICBQcmVjLmxvd2VzdChFZGl0b3JWaWV3LmJpZGlJc29sYXRlZFJhbmdlcy5vZihhY2Nlc3MpKV07XG4gICAgfVxufSk7XG5mdW5jdGlvbiBidWlsZERlY28odmlldywgdHJlZSwgYWx3YXlzKSB7XG4gICAgbGV0IGRlY28gPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgbGV0IHJhbmdlcyA9IHZpZXcudmlzaWJsZVJhbmdlcztcbiAgICBpZiAoIWFsd2F5cylcbiAgICAgICAgcmFuZ2VzID0gY2xpcFJUTExpbmVzKHJhbmdlcywgdmlldy5zdGF0ZS5kb2MpO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiByYW5nZXMpIHtcbiAgICAgICAgdHJlZS5pdGVyYXRlKHtcbiAgICAgICAgICAgIGVudGVyOiBub2RlID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaXNvID0gbm9kZS50eXBlLnByb3AoTm9kZVByb3AuaXNvbGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzbylcbiAgICAgICAgICAgICAgICAgICAgZGVjby5hZGQobm9kZS5mcm9tLCBub2RlLnRvLCBtYXJrc1tpc29dKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tLCB0b1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY28uZmluaXNoKCk7XG59XG5mdW5jdGlvbiBjbGlwUlRMTGluZXMocmFuZ2VzLCBkb2MpIHtcbiAgICBsZXQgY3VyID0gZG9jLml0ZXIoKSwgcG9zID0gMCwgcmVzdWx0ID0gW10sIGxhc3QgPSBudWxsO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiByYW5nZXMpIHtcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC50byA+IGZyb20pIHtcbiAgICAgICAgICAgIGZyb20gPSBsYXN0LnRvO1xuICAgICAgICAgICAgaWYgKGZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyArIGN1ci52YWx1ZS5sZW5ndGggPCBmcm9tKSB7XG4gICAgICAgICAgICBjdXIubmV4dChmcm9tIC0gKHBvcyArIGN1ci52YWx1ZS5sZW5ndGgpKTtcbiAgICAgICAgICAgIHBvcyA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcG9zLCBlbmQgPSBwb3MgKyBjdXIudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCFjdXIubGluZUJyZWFrICYmIGJ1aWxkRm9yTGluZShjdXIudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC50byA+IHN0YXJ0IC0gMTApXG4gICAgICAgICAgICAgICAgICAgIGxhc3QudG8gPSBNYXRoLm1pbih0bywgZW5kKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxhc3QgPSB7IGZyb206IHN0YXJ0LCB0bzogTWF0aC5taW4odG8sIGVuZCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID49IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICAgICAgY3VyLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgbWFya3MgPSB7XG4gICAgcnRsOiAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20taXNvXCIsIGluY2x1c2l2ZTogdHJ1ZSwgYXR0cmlidXRlczogeyBkaXI6IFwicnRsXCIgfSwgYmlkaUlzb2xhdGU6IERpcmVjdGlvbi5SVEwgfSksXG4gICAgbHRyOiAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20taXNvXCIsIGluY2x1c2l2ZTogdHJ1ZSwgYXR0cmlidXRlczogeyBkaXI6IFwibHRyXCIgfSwgYmlkaUlzb2xhdGU6IERpcmVjdGlvbi5MVFIgfSksXG4gICAgYXV0bzogLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWlzb1wiLCBpbmNsdXNpdmU6IHRydWUsIGF0dHJpYnV0ZXM6IHsgZGlyOiBcImF1dG9cIiB9LCBiaWRpSXNvbGF0ZTogbnVsbCB9KVxufTtcblxuZXhwb3J0IHsgRG9jSW5wdXQsIEhpZ2hsaWdodFN0eWxlLCBJbmRlbnRDb250ZXh0LCBMUkxhbmd1YWdlLCBMYW5ndWFnZSwgTGFuZ3VhZ2VEZXNjcmlwdGlvbiwgTGFuZ3VhZ2VTdXBwb3J0LCBQYXJzZUNvbnRleHQsIFN0cmVhbUxhbmd1YWdlLCBTdHJpbmdTdHJlYW0sIFRyZWVJbmRlbnRDb250ZXh0LCBiaWRpSXNvbGF0ZXMsIGJyYWNrZXRNYXRjaGluZywgYnJhY2tldE1hdGNoaW5nSGFuZGxlLCBjb2RlRm9sZGluZywgY29udGludWVkSW5kZW50LCBkZWZhdWx0SGlnaGxpZ2h0U3R5bGUsIGRlZmluZUxhbmd1YWdlRmFjZXQsIGRlbGltaXRlZEluZGVudCwgZW5zdXJlU3ludGF4VHJlZSwgZmxhdEluZGVudCwgZm9sZEFsbCwgZm9sZENvZGUsIGZvbGRFZmZlY3QsIGZvbGRHdXR0ZXIsIGZvbGRJbnNpZGUsIGZvbGRLZXltYXAsIGZvbGROb2RlUHJvcCwgZm9sZFNlcnZpY2UsIGZvbGRTdGF0ZSwgZm9sZGFibGUsIGZvbGRlZFJhbmdlcywgZm9yY2VQYXJzaW5nLCBnZXRJbmRlbnRVbml0LCBnZXRJbmRlbnRhdGlvbiwgaGlnaGxpZ2h0aW5nRm9yLCBpbmRlbnROb2RlUHJvcCwgaW5kZW50T25JbnB1dCwgaW5kZW50UmFuZ2UsIGluZGVudFNlcnZpY2UsIGluZGVudFN0cmluZywgaW5kZW50VW5pdCwgbGFuZ3VhZ2UsIGxhbmd1YWdlRGF0YVByb3AsIG1hdGNoQnJhY2tldHMsIHN1Ymxhbmd1YWdlUHJvcCwgc3ludGF4SGlnaGxpZ2h0aW5nLCBzeW50YXhQYXJzZXJSdW5uaW5nLCBzeW50YXhUcmVlLCBzeW50YXhUcmVlQXZhaWxhYmxlLCB0b2dnbGVGb2xkLCB1bmZvbGRBbGwsIHVuZm9sZENvZGUsIHVuZm9sZEVmZmVjdCB9O1xuIl0sIm5hbWVzIjpbIk5vZGVQcm9wIiwiSXRlck1vZGUiLCJUcmVlIiwiVHJlZUZyYWdtZW50IiwiUGFyc2VyIiwiTm9kZVR5cGUiLCJOb2RlU2V0IiwiU3RhdGVFZmZlY3QiLCJTdGF0ZUZpZWxkIiwiRmFjZXQiLCJFZGl0b3JTdGF0ZSIsImNvdW50Q29sdW1uIiwiY29tYmluZUNvbmZpZyIsIlJhbmdlU2V0IiwiUmFuZ2VTZXRCdWlsZGVyIiwiUHJlYyIsIlZpZXdQbHVnaW4iLCJsb2dFeGNlcHRpb24iLCJFZGl0b3JWaWV3IiwiRGVjb3JhdGlvbiIsIldpZGdldFR5cGUiLCJndXR0ZXIiLCJHdXR0ZXJNYXJrZXIiLCJEaXJlY3Rpb24iLCJ0YWdzIiwidGFnSGlnaGxpZ2h0ZXIiLCJoaWdobGlnaHRUcmVlIiwic3R5bGVUYWdzIiwiU3R5bGVNb2R1bGUiLCJfYSIsImxhbmd1YWdlRGF0YVByb3AiLCJkZWZpbmVMYW5ndWFnZUZhY2V0IiwiYmFzZURhdGEiLCJkZWZpbmUiLCJjb21iaW5lIiwidmFsdWVzIiwiY29uY2F0IiwidW5kZWZpbmVkIiwic3VibGFuZ3VhZ2VQcm9wIiwiTGFuZ3VhZ2UiLCJjb25zdHJ1Y3RvciIsImRhdGEiLCJwYXJzZXIiLCJleHRyYUV4dGVuc2lvbnMiLCJuYW1lIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsInN5bnRheFRyZWUiLCJleHRlbnNpb24iLCJsYW5ndWFnZSIsIm9mIiwibGFuZ3VhZ2VEYXRhIiwic3RhdGUiLCJwb3MiLCJzaWRlIiwidG9wIiwidG9wTm9kZUF0IiwidHlwZSIsInByb3AiLCJiYXNlIiwiZmFjZXQiLCJzdWIiLCJpbm5lck5vZGUiLCJyZXNvbHZlIiwiZnJvbSIsInN1YmxhbmciLCJ0ZXN0IiwiaXNBY3RpdmVBdCIsImZpbmRSZWdpb25zIiwibGFuZyIsInRvIiwiZG9jIiwibGVuZ3RoIiwiYWxsb3dzTmVzdGluZyIsInJlc3VsdCIsImV4cGxvcmUiLCJ0cmVlIiwicHVzaCIsIm1vdW50IiwibW91bnRlZCIsIm92ZXJsYXkiLCJyIiwic2l6ZSIsImkiLCJjaGlsZHJlbiIsImNoIiwicG9zaXRpb25zIiwic2V0U3RhdGUiLCJ0b3BMYW5nIiwidG9wTm9kZSIsIm5vZGUiLCJlbnRlciIsIkV4Y2x1ZGVCdWZmZXJzIiwiaXNUb3AiLCJMUkxhbmd1YWdlIiwic3BlYyIsImNvbmZpZ3VyZSIsInByb3BzIiwiYWRkIiwib3B0aW9ucyIsImhhc1dyYXBwZXJzIiwiZmllbGQiLCJlbXB0eSIsImVuc3VyZVN5bnRheFRyZWUiLCJ1cHRvIiwidGltZW91dCIsInBhcnNlIiwiY29udGV4dCIsIm9sZFZpZXBvcnQiLCJ2aWV3cG9ydCIsInVwZGF0ZVZpZXdwb3J0IiwiaXNEb25lIiwid29yayIsInN5bnRheFRyZWVBdmFpbGFibGUiLCJmb3JjZVBhcnNpbmciLCJ2aWV3Iiwic3VjY2VzcyIsImRpc3BhdGNoIiwic3ludGF4UGFyc2VyUnVubmluZyIsInBsdWdpbiIsInBhcnNlV29ya2VyIiwiaXNXb3JraW5nIiwiRG9jSW5wdXQiLCJjdXJzb3JQb3MiLCJzdHJpbmciLCJjdXJzb3IiLCJpdGVyIiwic3luY1RvIiwibmV4dCIsInZhbHVlIiwiY2h1bmsiLCJsaW5lQ2h1bmtzIiwicmVhZCIsInN0cmluZ1N0YXJ0Iiwic2xpY2VTdHJpbmciLCJzbGljZSIsImN1cnJlbnRDb250ZXh0IiwiUGFyc2VDb250ZXh0IiwiZnJhZ21lbnRzIiwidHJlZUxlbiIsInNraXBwZWQiLCJzY2hlZHVsZU9uIiwidGVtcFNraXBwZWQiLCJjcmVhdGUiLCJzdGFydFBhcnNlIiwidW50aWwiLCJ0YWtlVHJlZSIsIndpdGhDb250ZXh0IiwiZW5kVGltZSIsIkRhdGUiLCJub3ciLCJzdG9wcGVkQXQiLCJzdG9wQXQiLCJkb25lIiwiYWR2YW5jZSIsIndpdGhvdXRUZW1wU2tpcHBlZCIsImFkZFRyZWUiLCJwYXJzZWRQb3MiLCJmIiwicHJldiIsInBvcCIsImN1dEZyYWdtZW50cyIsImNoYW5nZXMiLCJuZXdTdGF0ZSIsInJhbmdlcyIsIml0ZXJDaGFuZ2VkUmFuZ2VzIiwiZnJvbUEiLCJ0b0EiLCJmcm9tQiIsInRvQiIsImFwcGx5Q2hhbmdlcyIsIm1hcFBvcyIsInN0YXJ0TGVuIiwic3BsaWNlIiwicmVzZXQiLCJza2lwVW50aWxJblZpZXciLCJnZXRTa2lwcGluZ1BhcnNlciIsImNyZWF0ZVBhcnNlIiwiaW5wdXQiLCJjeCIsIlByb21pc2UiLCJhbGwiLCJub25lIiwiTWF0aCIsIm1pbiIsImZyYWdzIiwiTGFuZ3VhZ2VTdGF0ZSIsImFwcGx5IiwidHIiLCJkb2NDaGFuZ2VkIiwibmV3Q3giLCJzdGFydFN0YXRlIiwibWF4IiwiaW5pdCIsInZwVG8iLCJwYXJzZVN0YXRlIiwidXBkYXRlIiwiZSIsImVmZmVjdHMiLCJpcyIsInJlcXVlc3RJZGxlIiwiY2FsbGJhY2siLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicmVxdWVzdElkbGVDYWxsYmFjayIsImlkbGUiLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJpc0lucHV0UGVuZGluZyIsIm5hdmlnYXRvciIsInNjaGVkdWxpbmciLCJmcm9tQ2xhc3MiLCJQYXJzZVdvcmtlciIsIndvcmtpbmciLCJ3b3JrU2NoZWR1bGVkIiwiY2h1bmtFbmQiLCJjaHVua0J1ZGdldCIsImJpbmQiLCJzY2hlZHVsZVdvcmsiLCJzZWxlY3Rpb25TZXQiLCJoYXNGb2N1cyIsImNoZWNrQXN5bmNTY2hlZHVsZSIsImRlYWRsaW5lIiwidGltZVJlbWFpbmluZyIsInZpZXdwb3J0Rmlyc3QiLCJ0aGVuIiwiY2F0Y2giLCJlcnIiLCJkZXN0cm95IiwiZXZlbnRIYW5kbGVycyIsImZvY3VzIiwibGFuZ3VhZ2VzIiwiZW5hYmxlcyIsImNvbnRlbnRBdHRyaWJ1dGVzIiwiY29tcHV0ZSIsIkxhbmd1YWdlU3VwcG9ydCIsInN1cHBvcnQiLCJMYW5ndWFnZURlc2NyaXB0aW9uIiwiYWxpYXMiLCJleHRlbnNpb25zIiwiZmlsZW5hbWUiLCJsb2FkRnVuYyIsImxvYWRpbmciLCJsb2FkIiwiUmFuZ2VFcnJvciIsIm1hcCIsInMiLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoRmlsZW5hbWUiLCJkZXNjcyIsImQiLCJleHQiLCJleGVjIiwiaW5kZXhPZiIsIm1hdGNoTGFuZ3VhZ2VOYW1lIiwiZnV6enkiLCJzb21lIiwiYSIsImZvdW5kIiwiaW5kZW50U2VydmljZSIsImluZGVudFVuaXQiLCJ1bml0IiwiQXJyYXkiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRJbmRlbnRVbml0IiwiY2hhckNvZGVBdCIsInRhYlNpemUiLCJpbmRlbnRTdHJpbmciLCJjb2xzIiwidHMiLCJnZXRJbmRlbnRhdGlvbiIsIkluZGVudENvbnRleHQiLCJzZXJ2aWNlIiwic3ludGF4SW5kZW50YXRpb24iLCJpbmRlbnRSYW5nZSIsInVwZGF0ZWQiLCJvdmVycmlkZUluZGVudGF0aW9uIiwic3RhcnQiLCJsaW5lIiwibGluZUF0IiwiaW5kZW50IiwidGV4dCIsImN1ciIsIm5vcm0iLCJpbnNlcnQiLCJiaWFzIiwic2ltdWxhdGVCcmVhayIsInNpbXVsYXRlRG91YmxlQnJlYWsiLCJ0ZXh0QWZ0ZXJQb3MiLCJjb2x1bW4iLCJvdmVycmlkZSIsInNlYXJjaCIsImxpbmVJbmRlbnQiLCJvdmVycmlkZW4iLCJzaW11bGF0ZWRCcmVhayIsImluZGVudE5vZGVQcm9wIiwiYXN0Iiwic3RhY2siLCJyZXNvbHZlU3RhY2siLCJpbm5lciIsInJlc29sdmVJbm5lciIsImVudGVyVW5maW5pc2hlZE5vZGVzQmVmb3JlIiwicGFyZW50IiwiaW5kZW50Rm9yIiwic3RyYXRlZ3kiLCJpbmRlbnRTdHJhdGVneSIsIlRyZWVJbmRlbnRDb250ZXh0IiwiaWdub3JlQ2xvc2VkIiwiZmlyc3QiLCJmaXJzdENoaWxkIiwiY2xvc2UiLCJjbG9zZWRCeSIsImxhc3QiLCJsYXN0Q2hpbGQiLCJjbG9zZWQiLCJkZWxpbWl0ZWRTdHJhdGVneSIsInRvcEluZGVudCIsInRleHRBZnRlciIsImJhc2VJbmRlbnQiLCJiYXNlSW5kZW50Rm9yIiwiYXRCcmVhayIsImlzUGFyZW50IiwiY29udGludWUiLCJicmFja2V0ZWRBbGlnbmVkIiwib3BlblRva2VuIiwiY2hpbGRBZnRlciIsInNpbSIsIm9wZW5MaW5lIiwibGluZUVuZCIsImlzU2tpcHBlZCIsInNwYWNlIiwiZGVsaW1pdGVkSW5kZW50IiwiY2xvc2luZyIsImFsaWduIiwidW5pdHMiLCJjbG9zZWRBdCIsImFmdGVyIiwibWF0Y2giLCJhbGlnbmVkIiwiZmxhdEluZGVudCIsImNvbnRpbnVlZEluZGVudCIsImV4Y2VwdCIsIm1hdGNoRXhjZXB0IiwiRG9udEluZGVudEJleW9uZCIsImluZGVudE9uSW5wdXQiLCJ0cmFuc2FjdGlvbkZpbHRlciIsImlzVXNlckV2ZW50IiwicnVsZXMiLCJsYW5ndWFnZURhdGFBdCIsInNlbGVjdGlvbiIsIm1haW4iLCJoZWFkIiwibmV3RG9jIiwibmV3U2VsZWN0aW9uIiwibGluZVN0YXJ0Iiwic2VxdWVudGlhbCIsImZvbGRTZXJ2aWNlIiwiZm9sZE5vZGVQcm9wIiwiZm9sZEluc2lkZSIsImlzRXJyb3IiLCJzeW50YXhGb2xkaW5nIiwiZW5kIiwiaXNVbmZpbmlzaGVkIiwiZm9sZGFibGUiLCJtYXBSYW5nZSIsInJhbmdlIiwibWFwcGluZyIsImZvbGRFZmZlY3QiLCJ1bmZvbGRFZmZlY3QiLCJzZWxlY3RlZExpbmVzIiwibGluZXMiLCJsIiwibGluZUJsb2NrQXQiLCJmb2xkU3RhdGUiLCJmb2xkZWQiLCJmb2xkRXhpc3RzIiwicHJlcGFyZVBsYWNlaG9sZGVyIiwiZm9sZENvbmZpZyIsIndpZGdldCIsImZvbGRXaWRnZXQiLCJyZXBsYWNlIiwiUHJlcGFyZWRGb2xkV2lkZ2V0IiwiZmlsdGVyIiwiZmlsdGVyRnJvbSIsImZpbHRlclRvIiwib25TZWxlY3Rpb24iLCJiZXR3ZWVuIiwiYiIsInByb3ZpZGUiLCJkZWNvcmF0aW9ucyIsInRvSlNPTiIsImZyb21KU09OIiwiaXNBcnJheSIsInNldCIsImZvbGRlZFJhbmdlcyIsImZpbmRGb2xkIiwibWF5YmVFbmFibGUiLCJvdGhlciIsImFwcGVuZENvbmZpZyIsImNvZGVGb2xkaW5nIiwiZm9sZENvZGUiLCJhbm5vdW5jZUZvbGQiLCJ1bmZvbGRDb2RlIiwiZm9sZCIsImxpbmVGcm9tIiwibnVtYmVyIiwibGluZVRvIiwiYW5ub3VuY2UiLCJwaHJhc2UiLCJmb2xkQWxsIiwidW5mb2xkQWxsIiwiZm9sZGFibGVDb250YWluZXIiLCJsaW5lQmxvY2siLCJmb2xkYWJsZVJlZ2lvbiIsInRvZ2dsZUZvbGQiLCJmb2xkUmFuZ2UiLCJmb2xkS2V5bWFwIiwia2V5IiwibWFjIiwicnVuIiwiZGVmYXVsdENvbmZpZyIsInBsYWNlaG9sZGVyRE9NIiwicGxhY2Vob2xkZXJUZXh0IiwiY29uZmlnIiwiYmFzZVRoZW1lJDEiLCJ3aWRnZXRUb0RPTSIsInByZXBhcmVkIiwiY29uZiIsIm9uY2xpY2siLCJldmVudCIsInBvc0F0RE9NIiwidGFyZ2V0IiwicHJldmVudERlZmF1bHQiLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidGV4dENvbnRlbnQiLCJzZXRBdHRyaWJ1dGUiLCJ0aXRsZSIsImNsYXNzTmFtZSIsInRvRE9NIiwiZXEiLCJmb2xkR3V0dGVyRGVmYXVsdHMiLCJvcGVuVGV4dCIsImNsb3NlZFRleHQiLCJtYXJrZXJET00iLCJkb21FdmVudEhhbmRsZXJzIiwiZm9sZGluZ0NoYW5nZWQiLCJGb2xkTWFya2VyIiwib3BlbiIsInNwYW4iLCJmb2xkR3V0dGVyIiwiZnVsbENvbmZpZyIsImFzc2lnbiIsImNhbkZvbGQiLCJjYW5VbmZvbGQiLCJtYXJrZXJzIiwiYnVpbGRNYXJrZXJzIiwidmlld3BvcnRDaGFuZ2VkIiwiYnVpbGRlciIsInZpZXdwb3J0TGluZUJsb2NrcyIsIm1hcmsiLCJmaW5pc2giLCJjbGFzcyIsImluaXRpYWxTcGFjZXIiLCJjbGljayIsImJhc2VUaGVtZSIsImJhY2tncm91bmRDb2xvciIsImJvcmRlciIsImNvbG9yIiwiYm9yZGVyUmFkaXVzIiwibWFyZ2luIiwicGFkZGluZyIsIkhpZ2hsaWdodFN0eWxlIiwic3BlY3MiLCJtb2RTcGVjIiwiZGVmIiwiY2xzIiwibmV3TmFtZSIsInNjb3BlT3B0Iiwic2NvcGUiLCJzdHlsZSIsInRhZyIsIm1vZHVsZSIsInRoZW1lVHlwZSIsImhpZ2hsaWdodGVyRmFjZXQiLCJmYWxsYmFja0hpZ2hsaWdodGVyIiwiZ2V0SGlnaGxpZ2h0ZXJzIiwic3ludGF4SGlnaGxpZ2h0aW5nIiwiaGlnaGxpZ2h0ZXIiLCJ0cmVlSGlnaGxpZ2h0ZXIiLCJzdHlsZU1vZHVsZSIsImZhbGxiYWNrIiwiY29tcHV0ZU4iLCJkYXJrVGhlbWUiLCJoaWdobGlnaHRpbmdGb3IiLCJoaWdobGlnaHRlcnMiLCJUcmVlSGlnaGxpZ2h0ZXIiLCJtYXJrQ2FjaGUiLCJidWlsZERlY28iLCJkZWNvcmF0ZWRUbyIsInN0eWxlQ2hhbmdlIiwiZGVjb3JhdGVkVG9NYXBwZWQiLCJ2aXNpYmxlUmFuZ2VzIiwiaGlnaCIsInYiLCJkZWZhdWx0SGlnaGxpZ2h0U3R5bGUiLCJtZXRhIiwibGluayIsInRleHREZWNvcmF0aW9uIiwiaGVhZGluZyIsImZvbnRXZWlnaHQiLCJlbXBoYXNpcyIsImZvbnRTdHlsZSIsInN0cm9uZyIsInN0cmlrZXRocm91Z2giLCJrZXl3b3JkIiwiYXRvbSIsImJvb2wiLCJ1cmwiLCJjb250ZW50U2VwYXJhdG9yIiwibGFiZWxOYW1lIiwibGl0ZXJhbCIsImluc2VydGVkIiwiZGVsZXRlZCIsInJlZ2V4cCIsImVzY2FwZSIsInNwZWNpYWwiLCJkZWZpbml0aW9uIiwidmFyaWFibGVOYW1lIiwibG9jYWwiLCJ0eXBlTmFtZSIsIm5hbWVzcGFjZSIsIm1hY3JvTmFtZSIsInByb3BlcnR5TmFtZSIsImNvbW1lbnQiLCJpbnZhbGlkIiwiRGVmYXVsdFNjYW5EaXN0IiwiRGVmYXVsdEJyYWNrZXRzIiwiYnJhY2tldE1hdGNoaW5nQ29uZmlnIiwiY29uZmlncyIsImFmdGVyQ3Vyc29yIiwiYnJhY2tldHMiLCJtYXhTY2FuRGlzdGFuY2UiLCJyZW5kZXJNYXRjaCIsImRlZmF1bHRSZW5kZXJNYXRjaCIsIm1hdGNoaW5nTWFyayIsIm5vbm1hdGNoaW5nTWFyayIsIm1hdGNoZWQiLCJicmFja2V0TWF0Y2hpbmdTdGF0ZSIsImRlY28iLCJtYXRjaEJyYWNrZXRzIiwiYnJhY2tldE1hdGNoaW5nVW5pcXVlIiwiYnJhY2tldE1hdGNoaW5nIiwiYnJhY2tldE1hdGNoaW5nSGFuZGxlIiwibWF0Y2hpbmdOb2RlcyIsImRpciIsImJ5UHJvcCIsIm9wZW5lZEJ5IiwiaW5kZXgiLCJmaW5kSGFuZGxlIiwiaGFzSGFuZGxlIiwibWF0Y2hlcyIsImhhbmRsZSIsIm1hdGNoTWFya2VkQnJhY2tldHMiLCJtYXRjaFBsYWluQnJhY2tldHMiLCJfc3RhdGUiLCJfcG9zIiwidG9rZW4iLCJtYXRjaGluZyIsImZpcnN0VG9rZW4iLCJkZXB0aCIsImNoaWxkQmVmb3JlIiwiZW5kSGFuZGxlIiwicHJldlNpYmxpbmciLCJuZXh0U2libGluZyIsInRva2VuVHlwZSIsInN0YXJ0Q2giLCJzbGljZURvYyIsImJyYWNrZXQiLCJzdGFydFRva2VuIiwiaXRlclJhbmdlIiwiZGlzdGFuY2UiLCJiYXNlUG9zIiwiY291bnRDb2wiLCJzdGFydEluZGV4Iiwic3RhcnRWYWx1ZSIsIm4iLCJTdHJpbmdTdHJlYW0iLCJvdmVycmlkZUluZGVudCIsImxhc3RDb2x1bW5Qb3MiLCJsYXN0Q29sdW1uVmFsdWUiLCJlb2wiLCJzb2wiLCJwZWVrIiwiY2hhckF0IiwiZWF0Iiwib2siLCJSZWdFeHAiLCJlYXRXaGlsZSIsImVhdFNwYWNlIiwic2tpcFRvRW5kIiwic2tpcFRvIiwiYmFja1VwIiwiaW5kZW50YXRpb24iLCJwYXR0ZXJuIiwiY29uc3VtZSIsImNhc2VJbnNlbnNpdGl2ZSIsImNhc2VkIiwic3RyIiwic3Vic3RyIiwiY3VycmVudCIsImZ1bGxQYXJzZXIiLCJibGFua0xpbmUiLCJjb3B5U3RhdGUiLCJkZWZhdWx0Q29weVN0YXRlIiwidG9rZW5UYWJsZSIsIm5vVG9rZW5zIiwidmFsIiwiSW5kZW50ZWRGcm9tIiwiV2Vha01hcCIsIlN0cmVhbUxhbmd1YWdlIiwicCIsInNlbGYiLCJpbXBsIiwiUGFyc2UiLCJkb2NJRCIsInN0cmVhbVBhcnNlciIsInN0YXRlQWZ0ZXIiLCJwZXJOb2RlIiwiVG9rZW5UYWJsZSIsImRlZmF1bHRUb2tlblRhYmxlIiwiZ2V0SW5kZW50IiwiZmluZFN0YXRlIiwic3RhdGVQb3MiLCJzdHJlYW0iLCJyZWFkVG9rZW4iLCJvZmYiLCJzdGFydFBvcyIsImJlZm9yZSIsImNoaWxkIiwiY3V0VHJlZSIsImluc2lkZSIsImZpbmRTdGFydEluRnJhZ21lbnRzIiwiZW5kUG9zIiwiZWRpdG9yU3RhdGUiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwib2Zmc2V0IiwiY2h1bmtzIiwiY2h1bmtQb3MiLCJjaHVua1JldXNlZCIsInJhbmdlSW5kZXgiLCJjaHVua1N0YXJ0IiwibW92ZVJhbmdlSW5kZXgiLCJwYXJzZUVuZCIsInBhcnNlTGluZSIsImZpbmlzaENodW5rIiwibGluZUFmdGVyIiwibmV4dExpbmUiLCJyYW5nZUVuZCIsInJhbmdlU3RhcnQiLCJza2lwR2Fwc1RvIiwib2ZmUG9zIiwiZW1pdFRva2VuIiwiaWQiLCJsZW4wIiwiYnVpbGQiLCJidWZmZXIiLCJub2RlU2V0IiwidG9wSUQiLCJtYXhCdWZmZXJMZW5ndGgiLCJyZXVzZWQiLCJiYWxhbmNlIiwidHlwZUFycmF5Iiwid2FybmVkIiwiYnlUYWciLCJkZWZhdWx0VGFibGUiLCJsZWdhY3lOYW1lIiwiY3JlYXRlVG9rZW5UeXBlIiwiZXh0cmEiLCJ0YWJsZSIsIndhcm5Gb3JQYXJ0IiwicGFydCIsIm1zZyIsImNvbnNvbGUiLCJ3YXJuIiwidGFnU3RyIiwidGFncyQxIiwic3BsaXQiLCJ0Iiwia25vd24iLCJidWlsZEZvckxpbmUiLCJ0ZXh0SGFzUlRMIiwiY2hhbmdlQWRkc1JUTCIsImNoYW5nZSIsImFkZGVkIiwiaXRlckNoYW5nZXMiLCJmQSIsInRBIiwiZkIiLCJ0QiIsImlucyIsImFsd2F5c0lzb2xhdGUiLCJ4IiwiYmlkaUlzb2xhdGVzIiwiaXNvbGF0ZU1hcmtzIiwiYWx3YXlzIiwidGV4dERpcmVjdGlvbiIsIkxUUiIsInBlckxpbmVUZXh0RGlyZWN0aW9uIiwiaGFzUlRMIiwiYWNjZXNzIiwiX2IiLCJvdXRlckRlY29yYXRpb25zIiwibG93ZXN0IiwiYmlkaUlzb2xhdGVkUmFuZ2VzIiwiY2xpcFJUTExpbmVzIiwiaXRlcmF0ZSIsImlzbyIsImlzb2xhdGUiLCJtYXJrcyIsImxpbmVCcmVhayIsInJ0bCIsImluY2x1c2l2ZSIsImF0dHJpYnV0ZXMiLCJiaWRpSXNvbGF0ZSIsIlJUTCIsImx0ciIsImF1dG8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/language/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/lint/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/lint/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeLintPanel: () => (/* binding */ closeLintPanel),\n/* harmony export */   diagnosticCount: () => (/* binding */ diagnosticCount),\n/* harmony export */   forEachDiagnostic: () => (/* binding */ forEachDiagnostic),\n/* harmony export */   forceLinting: () => (/* binding */ forceLinting),\n/* harmony export */   lintGutter: () => (/* binding */ lintGutter),\n/* harmony export */   lintKeymap: () => (/* binding */ lintKeymap),\n/* harmony export */   linter: () => (/* binding */ linter),\n/* harmony export */   nextDiagnostic: () => (/* binding */ nextDiagnostic),\n/* harmony export */   openLintPanel: () => (/* binding */ openLintPanel),\n/* harmony export */   previousDiagnostic: () => (/* binding */ previousDiagnostic),\n/* harmony export */   setDiagnostics: () => (/* binding */ setDiagnostics),\n/* harmony export */   setDiagnosticsEffect: () => (/* binding */ setDiagnosticsEffect)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"(ssr)/./node_modules/crelt/index.js\");\n\n\n\nclass SelectedDiagnostic {\n    constructor(from, to, diagnostic){\n        this.from = from;\n        this.to = to;\n        this.diagnostic = diagnostic;\n    }\n}\nclass LintState {\n    constructor(diagnostics, panel, selected){\n        this.diagnostics = diagnostics;\n        this.panel = panel;\n        this.selected = selected;\n    }\n    static init(diagnostics, panel, state) {\n        // Filter the list of diagnostics for which to create markers\n        let markedDiagnostics = diagnostics;\n        let diagnosticFilter = state.facet(lintConfig).markerFilter;\n        if (diagnosticFilter) markedDiagnostics = diagnosticFilter(markedDiagnostics, state);\n        let sorted = diagnostics.slice().sort((a, b)=>a.from - b.from || a.to - b.to);\n        let deco = new _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder(), active = [], pos = 0;\n        for(let i = 0;;){\n            let next = i == sorted.length ? null : sorted[i];\n            if (!next && !active.length) break;\n            let from, to;\n            if (active.length) {\n                from = pos;\n                to = active.reduce((p, d)=>Math.min(p, d.to), next && next.from > from ? next.from : 1e8);\n            } else {\n                from = next.from;\n                to = next.to;\n                active.push(next);\n                i++;\n            }\n            while(i < sorted.length){\n                let next = sorted[i];\n                if (next.from == from && (next.to > next.from || next.to == from)) {\n                    active.push(next);\n                    i++;\n                    to = Math.min(next.to, to);\n                } else {\n                    to = Math.min(next.from, to);\n                    break;\n                }\n            }\n            let sev = maxSeverity(active);\n            if (active.some((d)=>d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from)) {\n                deco.add(from, from, _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget({\n                    widget: new DiagnosticWidget(sev),\n                    diagnostics: active.slice()\n                }));\n            } else {\n                let markClass = active.reduce((c, d)=>d.markClass ? c + \" \" + d.markClass : c, \"\");\n                deco.add(from, to, _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n                    class: \"cm-lintRange cm-lintRange-\" + sev + markClass,\n                    diagnostics: active.slice(),\n                    inclusiveEnd: active.some((a)=>a.to > to)\n                }));\n            }\n            pos = to;\n            for(let i = 0; i < active.length; i++)if (active[i].to <= pos) active.splice(i--, 1);\n        }\n        let set = deco.finish();\n        return new LintState(set, panel, findDiagnostic(set));\n    }\n}\nfunction findDiagnostic(diagnostics, diagnostic = null, after = 0) {\n    let found = null;\n    diagnostics.between(after, 1e9, (from, to, { spec })=>{\n        if (diagnostic && spec.diagnostics.indexOf(diagnostic) < 0) return;\n        if (!found) found = new SelectedDiagnostic(from, to, diagnostic || spec.diagnostics[0]);\n        else if (spec.diagnostics.indexOf(found.diagnostic) < 0) return false;\n        else found = new SelectedDiagnostic(found.from, to, found.diagnostic);\n    });\n    return found;\n}\nfunction hideTooltip(tr, tooltip) {\n    let from = tooltip.pos, to = tooltip.end || from;\n    let result = tr.state.facet(lintConfig).hideOn(tr, from, to);\n    if (result != null) return result;\n    let line = tr.startState.doc.lineAt(tooltip.pos);\n    return !!(tr.effects.some((e)=>e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to)));\n}\nfunction maybeEnableLint(state, effects) {\n    return state.field(lintState, false) ? effects : effects.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of(lintExtensions));\n}\n/**\nReturns a transaction spec which updates the current set of\ndiagnostics, and enables the lint extension if if wasn't already\nactive.\n*/ function setDiagnostics(state, diagnostics) {\n    return {\n        effects: maybeEnableLint(state, [\n            setDiagnosticsEffect.of(diagnostics)\n        ])\n    };\n}\n/**\nThe state effect that updates the set of active diagnostics. Can\nbe useful when writing an extension that needs to track these.\n*/ const setDiagnosticsEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst movePanelSelection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst lintState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return new LintState(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none, null, null);\n    },\n    update (value, tr) {\n        if (tr.docChanged && value.diagnostics.size) {\n            let mapped = value.diagnostics.map(tr.changes), selected = null, panel = value.panel;\n            if (value.selected) {\n                let selPos = tr.changes.mapPos(value.selected.from, 1);\n                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);\n            }\n            if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel) panel = null;\n            value = new LintState(mapped, panel, selected);\n        }\n        for (let effect of tr.effects){\n            if (effect.is(setDiagnosticsEffect)) {\n                let panel = !tr.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;\n                value = LintState.init(effect.value, panel, tr.state);\n            } else if (effect.is(togglePanel)) {\n                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);\n            } else if (effect.is(movePanelSelection)) {\n                value = new LintState(value.diagnostics, value.panel, effect.value);\n            }\n        }\n        return value;\n    },\n    provide: (f)=>[\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, (val)=>val.panel),\n            _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.from(f, (s)=>s.diagnostics)\n        ]\n});\n/**\nReturns the number of active lint diagnostics in the given state.\n*/ function diagnosticCount(state) {\n    let lint = state.field(lintState, false);\n    return lint ? lint.diagnostics.size : 0;\n}\nconst activeMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-lintRange cm-lintRange-active\"\n});\nfunction lintTooltip(view, pos, side) {\n    let { diagnostics } = view.state.field(lintState);\n    let found, start = -1, end = -1;\n    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec })=>{\n        if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {\n            found = spec.diagnostics;\n            start = from;\n            end = to;\n            return false;\n        }\n    });\n    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;\n    if (found && diagnosticFilter) found = diagnosticFilter(found, view.state);\n    if (!found) return null;\n    return {\n        pos: start,\n        end: end,\n        above: view.state.doc.lineAt(start).to < end,\n        create () {\n            return {\n                dom: diagnosticsTooltip(view, found)\n            };\n        }\n    };\n}\nfunction diagnosticsTooltip(view, diagnostics) {\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", {\n        class: \"cm-tooltip-lint\"\n    }, diagnostics.map((d)=>renderDiagnostic(view, d, false)));\n}\n/**\nCommand to open and focus the lint panel.\n*/ const openLintPanel = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel) view.dispatch({\n        effects: maybeEnableLint(view.state, [\n            togglePanel.of(true)\n        ])\n    });\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, LintPanel.open);\n    if (panel) panel.dom.querySelector(\".cm-panel-lint ul\").focus();\n    return true;\n};\n/**\nCommand to close the lint panel, when open.\n*/ const closeLintPanel = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel) return false;\n    view.dispatch({\n        effects: togglePanel.of(false)\n    });\n    return true;\n};\n/**\nMove the selection to the next diagnostic.\n*/ const nextDiagnostic = (view)=>{\n    let field = view.state.field(lintState, false);\n    if (!field) return false;\n    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);\n    if (!next.value) {\n        next = field.diagnostics.iter(0);\n        if (!next.value || next.from == sel.from && next.to == sel.to) return false;\n    }\n    view.dispatch({\n        selection: {\n            anchor: next.from,\n            head: next.to\n        },\n        scrollIntoView: true\n    });\n    return true;\n};\n/**\nMove the selection to the previous diagnostic.\n*/ const previousDiagnostic = (view)=>{\n    let { state } = view, field = state.field(lintState, false);\n    if (!field) return false;\n    let sel = state.selection.main;\n    let prevFrom, prevTo, lastFrom, lastTo;\n    field.diagnostics.between(0, state.doc.length, (from, to)=>{\n        if (to < sel.to && (prevFrom == null || prevFrom < from)) {\n            prevFrom = from;\n            prevTo = to;\n        }\n        if (lastFrom == null || from > lastFrom) {\n            lastFrom = from;\n            lastTo = to;\n        }\n    });\n    if (lastFrom == null || prevFrom == null && lastFrom == sel.from) return false;\n    view.dispatch({\n        selection: {\n            anchor: prevFrom !== null && prevFrom !== void 0 ? prevFrom : lastFrom,\n            head: prevTo !== null && prevTo !== void 0 ? prevTo : lastTo\n        },\n        scrollIntoView: true\n    });\n    return true;\n};\n/**\nA set of default key bindings for the lint functionality.\n\n- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)\n- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)\n*/ const lintKeymap = [\n    {\n        key: \"Mod-Shift-m\",\n        run: openLintPanel,\n        preventDefault: true\n    },\n    {\n        key: \"F8\",\n        run: nextDiagnostic\n    }\n];\nconst lintPlugin = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.timeout = -1;\n        this.set = true;\n        let { delay } = view.state.facet(lintConfig);\n        this.lintTime = Date.now() + delay;\n        this.run = this.run.bind(this);\n        this.timeout = setTimeout(this.run, delay);\n    }\n    run() {\n        clearTimeout(this.timeout);\n        let now = Date.now();\n        if (now < this.lintTime - 10) {\n            this.timeout = setTimeout(this.run, this.lintTime - now);\n        } else {\n            this.set = false;\n            let { state } = this.view, { sources } = state.facet(lintConfig);\n            if (sources.length) batchResults(sources.map((s)=>Promise.resolve(s(this.view))), (annotations)=>{\n                if (this.view.state.doc == state.doc) this.view.dispatch(setDiagnostics(this.view.state, annotations.reduce((a, b)=>a.concat(b))));\n            }, (error)=>{\n                (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.logException)(this.view.state, error);\n            });\n        }\n    }\n    update(update) {\n        let config = update.state.facet(lintConfig);\n        if (update.docChanged || config != update.startState.facet(lintConfig) || config.needsRefresh && config.needsRefresh(update)) {\n            this.lintTime = Date.now() + config.delay;\n            if (!this.set) {\n                this.set = true;\n                this.timeout = setTimeout(this.run, config.delay);\n            }\n        }\n    }\n    force() {\n        if (this.set) {\n            this.lintTime = Date.now();\n            this.run();\n        }\n    }\n    destroy() {\n        clearTimeout(this.timeout);\n    }\n});\nfunction batchResults(promises, sink, error) {\n    let collected = [], timeout = -1;\n    for (let p of promises)p.then((value)=>{\n        collected.push(value);\n        clearTimeout(timeout);\n        if (collected.length == promises.length) sink(collected);\n        else timeout = setTimeout(()=>sink(collected), 200);\n    }, error);\n}\nconst lintConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (input) {\n        return Object.assign({\n            sources: input.map((i)=>i.source).filter((x)=>x != null)\n        }, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(input.map((i)=>i.config), {\n            delay: 750,\n            markerFilter: null,\n            tooltipFilter: null,\n            needsRefresh: null,\n            hideOn: ()=>null\n        }, {\n            needsRefresh: (a, b)=>!a ? b : !b ? a : (u)=>a(u) || b(u)\n        }));\n    }\n});\n/**\nGiven a diagnostic source, this function returns an extension that\nenables linting with that source. It will be called whenever the\neditor is idle (after its content changed). If `null` is given as\nsource, this only configures the lint extension.\n*/ function linter(source, config = {}) {\n    return [\n        lintConfig.of({\n            source,\n            config\n        }),\n        lintPlugin,\n        lintExtensions\n    ];\n}\n/**\nForces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the\neditor is idle to run right away.\n*/ function forceLinting(view) {\n    let plugin = view.plugin(lintPlugin);\n    if (plugin) plugin.force();\n}\nfunction assignKeys(actions) {\n    let assigned = [];\n    if (actions) actions: for (let { name } of actions){\n        for(let i = 0; i < name.length; i++){\n            let ch = name[i];\n            if (/[a-zA-Z]/.test(ch) && !assigned.some((c)=>c.toLowerCase() == ch.toLowerCase())) {\n                assigned.push(ch);\n                continue actions;\n            }\n        }\n        assigned.push(\"\");\n    }\n    return assigned;\n}\nfunction renderDiagnostic(view, diagnostic, inPanel) {\n    var _a;\n    let keys = inPanel ? assignKeys(diagnostic.actions) : [];\n    return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"li\", {\n        class: \"cm-diagnostic cm-diagnostic-\" + diagnostic.severity\n    }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", {\n        class: \"cm-diagnosticText\"\n    }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i)=>{\n        let fired = false, click = (e)=>{\n            e.preventDefault();\n            if (fired) return;\n            fired = true;\n            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);\n            if (found) action.apply(view, found.from, found.to);\n        };\n        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;\n        let nameElt = keyIndex < 0 ? name : [\n            name.slice(0, keyIndex),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"u\", name.slice(keyIndex, keyIndex + 1)),\n            name.slice(keyIndex + 1)\n        ];\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n            type: \"button\",\n            class: \"cm-diagnosticAction\",\n            onclick: click,\n            onmousedown: click,\n            \"aria-label\": ` Action: ${name}${keyIndex < 0 ? \"\" : ` (access key \"${keys[i]})\"`}.`\n        }, nameElt);\n    }), diagnostic.source && (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n        class: \"cm-diagnosticSource\"\n    }, diagnostic.source));\n}\nclass DiagnosticWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.WidgetType {\n    constructor(sev){\n        super();\n        this.sev = sev;\n    }\n    eq(other) {\n        return other.sev == this.sev;\n    }\n    toDOM() {\n        return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"span\", {\n            class: \"cm-lintPoint cm-lintPoint-\" + this.sev\n        });\n    }\n}\nclass PanelItem {\n    constructor(view, diagnostic){\n        this.diagnostic = diagnostic;\n        this.id = \"item_\" + Math.floor(Math.random() * 0xffffffff).toString(16);\n        this.dom = renderDiagnostic(view, diagnostic, true);\n        this.dom.id = this.id;\n        this.dom.setAttribute(\"role\", \"option\");\n    }\n}\nclass LintPanel {\n    constructor(view){\n        this.view = view;\n        this.items = [];\n        let onkeydown = (event)=>{\n            if (event.keyCode == 27) {\n                closeLintPanel(this.view);\n                this.view.focus();\n            } else if (event.keyCode == 38 || event.keyCode == 33) {\n                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);\n            } else if (event.keyCode == 40 || event.keyCode == 34) {\n                this.moveSelection((this.selectedIndex + 1) % this.items.length);\n            } else if (event.keyCode == 36) {\n                this.moveSelection(0);\n            } else if (event.keyCode == 35) {\n                this.moveSelection(this.items.length - 1);\n            } else if (event.keyCode == 13) {\n                this.view.focus();\n            } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {\n                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);\n                for(let i = 0; i < keys.length; i++)if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {\n                    let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);\n                    if (found) diagnostic.actions[i].apply(view, found.from, found.to);\n                }\n            } else {\n                return;\n            }\n            event.preventDefault();\n        };\n        let onclick = (event)=>{\n            for(let i = 0; i < this.items.length; i++){\n                if (this.items[i].dom.contains(event.target)) this.moveSelection(i);\n            }\n        };\n        this.list = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"ul\", {\n            tabIndex: 0,\n            role: \"listbox\",\n            \"aria-label\": this.view.state.phrase(\"Diagnostics\"),\n            onkeydown,\n            onclick\n        });\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n            class: \"cm-panel-lint\"\n        }, this.list, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n            type: \"button\",\n            name: \"close\",\n            \"aria-label\": this.view.state.phrase(\"close\"),\n            onclick: ()=>closeLintPanel(this.view)\n        }, \"\\xd7\"));\n        this.update();\n    }\n    get selectedIndex() {\n        let selected = this.view.state.field(lintState).selected;\n        if (!selected) return -1;\n        for(let i = 0; i < this.items.length; i++)if (this.items[i].diagnostic == selected.diagnostic) return i;\n        return -1;\n    }\n    update() {\n        let { diagnostics, selected } = this.view.state.field(lintState);\n        let i = 0, needsSync = false, newSelectedItem = null;\n        let seen = new Set();\n        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec })=>{\n            for (let diagnostic of spec.diagnostics){\n                if (seen.has(diagnostic)) continue;\n                seen.add(diagnostic);\n                let found = -1, item;\n                for(let j = i; j < this.items.length; j++)if (this.items[j].diagnostic == diagnostic) {\n                    found = j;\n                    break;\n                }\n                if (found < 0) {\n                    item = new PanelItem(this.view, diagnostic);\n                    this.items.splice(i, 0, item);\n                    needsSync = true;\n                } else {\n                    item = this.items[found];\n                    if (found > i) {\n                        this.items.splice(i, found - i);\n                        needsSync = true;\n                    }\n                }\n                if (selected && item.diagnostic == selected.diagnostic) {\n                    if (!item.dom.hasAttribute(\"aria-selected\")) {\n                        item.dom.setAttribute(\"aria-selected\", \"true\");\n                        newSelectedItem = item;\n                    }\n                } else if (item.dom.hasAttribute(\"aria-selected\")) {\n                    item.dom.removeAttribute(\"aria-selected\");\n                }\n                i++;\n            }\n        });\n        while(i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)){\n            needsSync = true;\n            this.items.pop();\n        }\n        if (this.items.length == 0) {\n            this.items.push(new PanelItem(this.view, {\n                from: -1,\n                to: -1,\n                severity: \"info\",\n                message: this.view.state.phrase(\"No diagnostics\")\n            }));\n            needsSync = true;\n        }\n        if (newSelectedItem) {\n            this.list.setAttribute(\"aria-activedescendant\", newSelectedItem.id);\n            this.view.requestMeasure({\n                key: this,\n                read: ()=>({\n                        sel: newSelectedItem.dom.getBoundingClientRect(),\n                        panel: this.list.getBoundingClientRect()\n                    }),\n                write: ({ sel, panel })=>{\n                    let scaleY = panel.height / this.list.offsetHeight;\n                    if (sel.top < panel.top) this.list.scrollTop -= (panel.top - sel.top) / scaleY;\n                    else if (sel.bottom > panel.bottom) this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;\n                }\n            });\n        } else if (this.selectedIndex < 0) {\n            this.list.removeAttribute(\"aria-activedescendant\");\n        }\n        if (needsSync) this.sync();\n    }\n    sync() {\n        let domPos = this.list.firstChild;\n        function rm() {\n            let prev = domPos;\n            domPos = prev.nextSibling;\n            prev.remove();\n        }\n        for (let item of this.items){\n            if (item.dom.parentNode == this.list) {\n                while(domPos != item.dom)rm();\n                domPos = item.dom.nextSibling;\n            } else {\n                this.list.insertBefore(item.dom, domPos);\n            }\n        }\n        while(domPos)rm();\n    }\n    moveSelection(selectedIndex) {\n        if (this.selectedIndex < 0) return;\n        let field = this.view.state.field(lintState);\n        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);\n        if (!selection) return;\n        this.view.dispatch({\n            selection: {\n                anchor: selection.from,\n                head: selection.to\n            },\n            scrollIntoView: true,\n            effects: movePanelSelection.of(selection)\n        });\n    }\n    static open(view) {\n        return new LintPanel(view);\n    }\n}\nfunction svg(content, attrs = `viewBox=\"0 0 40 40\"`) {\n    return `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" ${attrs}>${encodeURIComponent(content)}</svg>')`;\n}\nfunction underline(color) {\n    return svg(`<path d=\"m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0\" stroke=\"${color}\" fill=\"none\" stroke-width=\".7\"/>`, `width=\"6\" height=\"3\"`);\n}\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-diagnostic\": {\n        padding: \"3px 6px 3px 8px\",\n        marginLeft: \"-1px\",\n        display: \"block\",\n        whiteSpace: \"pre-wrap\"\n    },\n    \".cm-diagnostic-error\": {\n        borderLeft: \"5px solid #d11\"\n    },\n    \".cm-diagnostic-warning\": {\n        borderLeft: \"5px solid orange\"\n    },\n    \".cm-diagnostic-info\": {\n        borderLeft: \"5px solid #999\"\n    },\n    \".cm-diagnostic-hint\": {\n        borderLeft: \"5px solid #66d\"\n    },\n    \".cm-diagnosticAction\": {\n        font: \"inherit\",\n        border: \"none\",\n        padding: \"2px 4px\",\n        backgroundColor: \"#444\",\n        color: \"white\",\n        borderRadius: \"3px\",\n        marginLeft: \"8px\",\n        cursor: \"pointer\"\n    },\n    \".cm-diagnosticSource\": {\n        fontSize: \"70%\",\n        opacity: .7\n    },\n    \".cm-lintRange\": {\n        backgroundPosition: \"left bottom\",\n        backgroundRepeat: \"repeat-x\",\n        paddingBottom: \"0.7px\"\n    },\n    \".cm-lintRange-error\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#d11\")\n    },\n    \".cm-lintRange-warning\": {\n        backgroundImage: /*@__PURE__*/ underline(\"orange\")\n    },\n    \".cm-lintRange-info\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#999\")\n    },\n    \".cm-lintRange-hint\": {\n        backgroundImage: /*@__PURE__*/ underline(\"#66d\")\n    },\n    \".cm-lintRange-active\": {\n        backgroundColor: \"#ffdd9980\"\n    },\n    \".cm-tooltip-lint\": {\n        padding: 0,\n        margin: 0\n    },\n    \".cm-lintPoint\": {\n        position: \"relative\",\n        \"&:after\": {\n            content: '\"\"',\n            position: \"absolute\",\n            bottom: 0,\n            left: \"-2px\",\n            borderLeft: \"3px solid transparent\",\n            borderRight: \"3px solid transparent\",\n            borderBottom: \"4px solid #d11\"\n        }\n    },\n    \".cm-lintPoint-warning\": {\n        \"&:after\": {\n            borderBottomColor: \"orange\"\n        }\n    },\n    \".cm-lintPoint-info\": {\n        \"&:after\": {\n            borderBottomColor: \"#999\"\n        }\n    },\n    \".cm-lintPoint-hint\": {\n        \"&:after\": {\n            borderBottomColor: \"#66d\"\n        }\n    },\n    \".cm-panel.cm-panel-lint\": {\n        position: \"relative\",\n        \"& ul\": {\n            maxHeight: \"100px\",\n            overflowY: \"auto\",\n            \"& [aria-selected]\": {\n                backgroundColor: \"#ddd\",\n                \"& u\": {\n                    textDecoration: \"underline\"\n                }\n            },\n            \"&:focus [aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            },\n            \"& u\": {\n                textDecoration: \"none\"\n            },\n            padding: 0,\n            margin: 0\n        },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"2px\",\n            background: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        }\n    }\n});\nfunction severityWeight(sev) {\n    return sev == \"error\" ? 4 : sev == \"warning\" ? 3 : sev == \"info\" ? 2 : 1;\n}\nfunction maxSeverity(diagnostics) {\n    let sev = \"hint\", weight = 1;\n    for (let d of diagnostics){\n        let w = severityWeight(d.severity);\n        if (w > weight) {\n            weight = w;\n            sev = d.severity;\n        }\n    }\n    return sev;\n}\nclass LintGutterMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.GutterMarker {\n    constructor(diagnostics){\n        super();\n        this.diagnostics = diagnostics;\n        this.severity = maxSeverity(diagnostics);\n    }\n    toDOM(view) {\n        let elt = document.createElement(\"div\");\n        elt.className = \"cm-lint-marker cm-lint-marker-\" + this.severity;\n        let diagnostics = this.diagnostics;\n        let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;\n        if (diagnosticsFilter) diagnostics = diagnosticsFilter(diagnostics, view.state);\n        if (diagnostics.length) elt.onmouseover = ()=>gutterMarkerMouseOver(view, elt, diagnostics);\n        return elt;\n    }\n}\nfunction trackHoverOn(view, marker) {\n    let mousemove = (event)=>{\n        let rect = marker.getBoundingClientRect();\n        if (event.clientX > rect.left - 10 /* Hover.Margin */  && event.clientX < rect.right + 10 /* Hover.Margin */  && event.clientY > rect.top - 10 /* Hover.Margin */  && event.clientY < rect.bottom + 10 /* Hover.Margin */ ) return;\n        for(let target = event.target; target; target = target.parentNode){\n            if (target.nodeType == 1 && target.classList.contains(\"cm-tooltip-lint\")) return;\n        }\n        window.removeEventListener(\"mousemove\", mousemove);\n        if (view.state.field(lintGutterTooltip)) view.dispatch({\n            effects: setLintGutterTooltip.of(null)\n        });\n    };\n    window.addEventListener(\"mousemove\", mousemove);\n}\nfunction gutterMarkerMouseOver(view, marker, diagnostics) {\n    function hovered() {\n        let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);\n        const linePos = view.coordsAtPos(line.from);\n        if (linePos) {\n            view.dispatch({\n                effects: setLintGutterTooltip.of({\n                    pos: line.from,\n                    above: false,\n                    clip: false,\n                    create () {\n                        return {\n                            dom: diagnosticsTooltip(view, diagnostics),\n                            getCoords: ()=>marker.getBoundingClientRect()\n                        };\n                    }\n                })\n            });\n        }\n        marker.onmouseout = marker.onmousemove = null;\n        trackHoverOn(view, marker);\n    }\n    let { hoverTime } = view.state.facet(lintGutterConfig);\n    let hoverTimeout = setTimeout(hovered, hoverTime);\n    marker.onmouseout = ()=>{\n        clearTimeout(hoverTimeout);\n        marker.onmouseout = marker.onmousemove = null;\n    };\n    marker.onmousemove = ()=>{\n        clearTimeout(hoverTimeout);\n        hoverTimeout = setTimeout(hovered, hoverTime);\n    };\n}\nfunction markersForDiagnostics(doc, diagnostics) {\n    let byLine = Object.create(null);\n    for (let diagnostic of diagnostics){\n        let line = doc.lineAt(diagnostic.from);\n        (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);\n    }\n    let markers = [];\n    for(let line in byLine){\n        markers.push(new LintGutterMarker(byLine[line]).range(+line));\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.of(markers, true);\n}\nconst lintGutterExtension = /*@__PURE__*/ (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.gutter)({\n    class: \"cm-gutter-lint\",\n    markers: (view)=>view.state.field(lintGutterMarkers),\n    widgetMarker: (view, widget, block)=>{\n        let diagnostics = [];\n        view.state.field(lintGutterMarkers).between(block.from, block.to, (from, to, value)=>{\n            if (from > block.from && from < block.to) diagnostics.push(...value.diagnostics);\n        });\n        return diagnostics.length ? new LintGutterMarker(diagnostics) : null;\n    }\n});\nconst lintGutterMarkers = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\n    },\n    update (markers, tr) {\n        markers = markers.map(tr.changes);\n        let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;\n        for (let effect of tr.effects){\n            if (effect.is(setDiagnosticsEffect)) {\n                let diagnostics = effect.value;\n                if (diagnosticFilter) diagnostics = diagnosticFilter(diagnostics || [], tr.state);\n                markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));\n            }\n        }\n        return markers;\n    }\n});\nconst setLintGutterTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst lintGutterTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return null;\n    },\n    update (tooltip, tr) {\n        if (tooltip && tr.docChanged) tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), {\n            pos: tr.changes.mapPos(tooltip.pos)\n        });\n        return tr.effects.reduce((t, e)=>e.is(setLintGutterTooltip) ? e.value : t, tooltip);\n    },\n    provide: (field)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showTooltip.from(field)\n});\nconst lintGutterTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-gutter-lint\": {\n        width: \"1.4em\",\n        \"& .cm-gutterElement\": {\n            padding: \".2em\"\n        }\n    },\n    \".cm-lint-marker\": {\n        width: \"1em\",\n        height: \"1em\"\n    },\n    \".cm-lint-marker-info\": {\n        content: /*@__PURE__*/ svg(`<path fill=\"#aaf\" stroke=\"#77e\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M5 5L35 5L35 35L5 35Z\"/>`)\n    },\n    \".cm-lint-marker-warning\": {\n        content: /*@__PURE__*/ svg(`<path fill=\"#fe8\" stroke=\"#fd7\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M20 6L37 35L3 35Z\"/>`)\n    },\n    \".cm-lint-marker-error\": {\n        content: /*@__PURE__*/ svg(`<circle cx=\"20\" cy=\"20\" r=\"15\" fill=\"#f87\" stroke=\"#f43\" stroke-width=\"6\"/>`)\n    }\n});\nconst lintExtensions = [\n    lintState,\n    /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.decorations.compute([\n        lintState\n    ], (state)=>{\n        let { selected, panel } = state.field(lintState);\n        return !selected || !panel || selected.from == selected.to ? _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none : _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set([\n            activeMark.range(selected.from, selected.to)\n        ]);\n    }),\n    /*@__PURE__*/ (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.hoverTooltip)(lintTooltip, {\n        hideOn: hideTooltip\n    }),\n    baseTheme\n];\nconst lintGutterConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            hoverTime: 300 /* Hover.Time */ ,\n            markerFilter: null,\n            tooltipFilter: null\n        });\n    }\n});\n/**\nReturns an extension that installs a gutter showing markers for\neach line that has diagnostics, which can be hovered over to see\nthe diagnostics.\n*/ function lintGutter(config = {}) {\n    return [\n        lintGutterConfig.of(config),\n        lintGutterMarkers,\n        lintGutterExtension,\n        lintGutterTheme,\n        lintGutterTooltip\n    ];\n}\n/**\nIterate over the marked diagnostics for the given editor state,\ncalling `f` for each of them. Note that, if the document changed\nsince the diagnostics were created, the `Diagnostic` object will\nhold the original outdated position, whereas the `to` and `from`\narguments hold the diagnostic's current position.\n*/ function forEachDiagnostic(state, f) {\n    let lState = state.field(lintState, false);\n    if (lState && lState.diagnostics.size) {\n        let pending = [], pendingStart = [], lastEnd = -1;\n        for(let iter = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSet.iter([\n            lState.diagnostics\n        ]);; iter.next()){\n            for(let i = 0; i < pending.length; i++)if (!iter.value || iter.value.spec.diagnostics.indexOf(pending[i]) < 0) {\n                f(pending[i], pendingStart[i], lastEnd);\n                pending.splice(i, 1);\n                pendingStart.splice(i--, 1);\n            }\n            if (!iter.value) break;\n            for (let d of iter.value.spec.diagnostics)if (pending.indexOf(d) < 0) {\n                pending.push(d);\n                pendingStart.push(iter.from);\n            }\n            lastEnd = iter.to;\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGludC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzSztBQUN6RDtBQUNyRjtBQUV4QixNQUFNa0I7SUFDRkMsWUFBWUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLFVBQVUsQ0FBRTtRQUM5QixJQUFJLENBQUNGLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNDLFVBQVUsR0FBR0E7SUFDdEI7QUFDSjtBQUNBLE1BQU1DO0lBQ0ZKLFlBQVlLLFdBQVcsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLENBQUU7UUFDdEMsSUFBSSxDQUFDRixXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtJQUNwQjtJQUNBLE9BQU9DLEtBQUtILFdBQVcsRUFBRUMsS0FBSyxFQUFFRyxLQUFLLEVBQUU7UUFDbkMsNkRBQTZEO1FBQzdELElBQUlDLG9CQUFvQkw7UUFDeEIsSUFBSU0sbUJBQW1CRixNQUFNRyxLQUFLLENBQUNDLFlBQVlDLFlBQVk7UUFDM0QsSUFBSUgsa0JBQ0FELG9CQUFvQkMsaUJBQWlCRCxtQkFBbUJEO1FBQzVELElBQUlNLFNBQVNWLFlBQVlXLEtBQUssR0FBR0MsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVqQixJQUFJLEdBQUdrQixFQUFFbEIsSUFBSSxJQUFJaUIsRUFBRWhCLEVBQUUsR0FBR2lCLEVBQUVqQixFQUFFO1FBQzlFLElBQUlrQixPQUFPLElBQUl2Qiw4REFBZUEsSUFBSXdCLFNBQVMsRUFBRSxFQUFFQyxNQUFNO1FBQ3JELElBQUssSUFBSUMsSUFBSSxJQUFLO1lBQ2QsSUFBSUMsT0FBT0QsS0FBS1IsT0FBT1UsTUFBTSxHQUFHLE9BQU9WLE1BQU0sQ0FBQ1EsRUFBRTtZQUNoRCxJQUFJLENBQUNDLFFBQVEsQ0FBQ0gsT0FB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TUFBTSxDQUFDdEIsS0FBSztZQUM3QjtZQUNKLElBQUksQ0FBQ2lHLEtBQUtyQyxLQUFLLEVBQ1g7WUFDSixLQUFLLElBQUl2RCxLQUFLNEYsS0FBS3JDLEtBQUssQ0FBQy9CLElBQUksQ0FBQy9DLFdBQVcsQ0FDckMsSUFBSXVVLFFBQVF2UixPQUFPLENBQUN6QixLQUFLLEdBQUc7Z0JBQ3hCZ1QsUUFBUTdTLElBQUksQ0FBQ0g7Z0JBQ2JpVCxhQUFhOVMsSUFBSSxDQUFDeUYsS0FBS3ZILElBQUk7WUFDL0I7WUFDSjZVLFVBQVV0TixLQUFLdEgsRUFBRTtRQUNyQjtJQUNKO0FBQ0o7QUFFcU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrbmljaGUvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGludC9kaXN0L2luZGV4LmpzP2Y5ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVjb3JhdGlvbiwgc2hvd1BhbmVsLCBFZGl0b3JWaWV3LCBWaWV3UGx1Z2luLCBndXR0ZXIsIHNob3dUb29sdGlwLCBob3ZlclRvb2x0aXAsIGdldFBhbmVsLCBsb2dFeGNlcHRpb24sIFdpZGdldFR5cGUsIEd1dHRlck1hcmtlciB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgU3RhdGVFZmZlY3QsIFN0YXRlRmllbGQsIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBSYW5nZVNldCwgUmFuZ2VTZXRCdWlsZGVyIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IGVsdCBmcm9tICdjcmVsdCc7XG5cbmNsYXNzIFNlbGVjdGVkRGlhZ25vc3RpYyB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIGRpYWdub3N0aWMpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xuICAgIH1cbn1cbmNsYXNzIExpbnRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoZGlhZ25vc3RpY3MsIHBhbmVsLCBzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3M7XG4gICAgICAgIHRoaXMucGFuZWwgPSBwYW5lbDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgIH1cbiAgICBzdGF0aWMgaW5pdChkaWFnbm9zdGljcywgcGFuZWwsIHN0YXRlKSB7XG4gICAgICAgIC8vIEZpbHRlciB0aGUgbGlzdCBvZiBkaWFnbm9zdGljcyBmb3Igd2hpY2ggdG8gY3JlYXRlIG1hcmtlcnNcbiAgICAgICAgbGV0IG1hcmtlZERpYWdub3N0aWNzID0gZGlhZ25vc3RpY3M7XG4gICAgICAgIGxldCBkaWFnbm9zdGljRmlsdGVyID0gc3RhdGUuZmFjZXQobGludENvbmZpZykubWFya2VyRmlsdGVyO1xuICAgICAgICBpZiAoZGlhZ25vc3RpY0ZpbHRlcilcbiAgICAgICAgICAgIG1hcmtlZERpYWdub3N0aWNzID0gZGlhZ25vc3RpY0ZpbHRlcihtYXJrZWREaWFnbm9zdGljcywgc3RhdGUpO1xuICAgICAgICBsZXQgc29ydGVkID0gZGlhZ25vc3RpY3Muc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20gfHwgYS50byAtIGIudG8pO1xuICAgICAgICBsZXQgZGVjbyA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKSwgYWN0aXZlID0gW10sIHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA9PSBzb3J0ZWQubGVuZ3RoID8gbnVsbCA6IHNvcnRlZFtpXTtcbiAgICAgICAgICAgIGlmICghbmV4dCAmJiAhYWN0aXZlLmxlbmd0aClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBmcm9tLCB0bztcbiAgICAgICAgICAgIGlmIChhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9IHBvcztcbiAgICAgICAgICAgICAgICB0byA9IGFjdGl2ZS5yZWR1Y2UoKHAsIGQpID0+IE1hdGgubWluKHAsIGQudG8pLCBuZXh0ICYmIG5leHQuZnJvbSA+IGZyb20gPyBuZXh0LmZyb20gOiAxZTgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9IG5leHQuZnJvbTtcbiAgICAgICAgICAgICAgICB0byA9IG5leHQudG87XG4gICAgICAgICAgICAgICAgYWN0aXZlLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGkgPCBzb3J0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBzb3J0ZWRbaV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA9PSBmcm9tICYmIChuZXh0LnRvID4gbmV4dC5mcm9tIHx8IG5leHQudG8gPT0gZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1pbihuZXh0LnRvLCB0byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWluKG5leHQuZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2V2ID0gbWF4U2V2ZXJpdHkoYWN0aXZlKTtcbiAgICAgICAgICAgIGlmIChhY3RpdmUuc29tZShkID0+IGQuZnJvbSA9PSBkLnRvIHx8IChkLmZyb20gPT0gZC50byAtIDEgJiYgc3RhdGUuZG9jLmxpbmVBdChkLmZyb20pLnRvID09IGQuZnJvbSkpKSB7XG4gICAgICAgICAgICAgICAgZGVjby5hZGQoZnJvbSwgZnJvbSwgRGVjb3JhdGlvbi53aWRnZXQoe1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBEaWFnbm9zdGljV2lkZ2V0KHNldiksXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzOiBhY3RpdmUuc2xpY2UoKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrQ2xhc3MgPSBhY3RpdmUucmVkdWNlKChjLCBkKSA9PiBkLm1hcmtDbGFzcyA/IGMgKyBcIiBcIiArIGQubWFya0NsYXNzIDogYywgXCJcIik7XG4gICAgICAgICAgICAgICAgZGVjby5hZGQoZnJvbSwgdG8sIERlY29yYXRpb24ubWFyayh7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBcImNtLWxpbnRSYW5nZSBjbS1saW50UmFuZ2UtXCIgKyBzZXYgKyBtYXJrQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzOiBhY3RpdmUuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlRW5kOiBhY3RpdmUuc29tZShhID0+IGEudG8gPiB0bylcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSB0bztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVbaV0udG8gPD0gcG9zKVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNldCA9IGRlY28uZmluaXNoKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGludFN0YXRlKHNldCwgcGFuZWwsIGZpbmREaWFnbm9zdGljKHNldCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmREaWFnbm9zdGljKGRpYWdub3N0aWNzLCBkaWFnbm9zdGljID0gbnVsbCwgYWZ0ZXIgPSAwKSB7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBkaWFnbm9zdGljcy5iZXR3ZWVuKGFmdGVyLCAxZTksIChmcm9tLCB0bywgeyBzcGVjIH0pID0+IHtcbiAgICAgICAgaWYgKGRpYWdub3N0aWMgJiYgc3BlYy5kaWFnbm9zdGljcy5pbmRleE9mKGRpYWdub3N0aWMpIDwgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIGZvdW5kID0gbmV3IFNlbGVjdGVkRGlhZ25vc3RpYyhmcm9tLCB0bywgZGlhZ25vc3RpYyB8fCBzcGVjLmRpYWdub3N0aWNzWzBdKTtcbiAgICAgICAgZWxzZSBpZiAoc3BlYy5kaWFnbm9zdGljcy5pbmRleE9mKGZvdW5kLmRpYWdub3N0aWMpIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZm91bmQgPSBuZXcgU2VsZWN0ZWREaWFnbm9zdGljKGZvdW5kLmZyb20sIHRvLCBmb3VuZC5kaWFnbm9zdGljKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBoaWRlVG9vbHRpcCh0ciwgdG9vbHRpcCkge1xuICAgIGxldCBmcm9tID0gdG9vbHRpcC5wb3MsIHRvID0gdG9vbHRpcC5lbmQgfHwgZnJvbTtcbiAgICBsZXQgcmVzdWx0ID0gdHIuc3RhdGUuZmFjZXQobGludENvbmZpZykuaGlkZU9uKHRyLCBmcm9tLCB0byk7XG4gICAgaWYgKHJlc3VsdCAhPSBudWxsKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGxldCBsaW5lID0gdHIuc3RhcnRTdGF0ZS5kb2MubGluZUF0KHRvb2x0aXAucG9zKTtcbiAgICByZXR1cm4gISEodHIuZWZmZWN0cy5zb21lKGUgPT4gZS5pcyhzZXREaWFnbm9zdGljc0VmZmVjdCkpIHx8IHRyLmNoYW5nZXMudG91Y2hlc1JhbmdlKGxpbmUuZnJvbSwgTWF0aC5tYXgobGluZS50bywgdG8pKSk7XG59XG5mdW5jdGlvbiBtYXliZUVuYWJsZUxpbnQoc3RhdGUsIGVmZmVjdHMpIHtcbiAgICByZXR1cm4gc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSkgPyBlZmZlY3RzIDogZWZmZWN0cy5jb25jYXQoU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKGxpbnRFeHRlbnNpb25zKSk7XG59XG4vKipcblJldHVybnMgYSB0cmFuc2FjdGlvbiBzcGVjIHdoaWNoIHVwZGF0ZXMgdGhlIGN1cnJlbnQgc2V0IG9mXG5kaWFnbm9zdGljcywgYW5kIGVuYWJsZXMgdGhlIGxpbnQgZXh0ZW5zaW9uIGlmIGlmIHdhc24ndCBhbHJlYWR5XG5hY3RpdmUuXG4qL1xuZnVuY3Rpb24gc2V0RGlhZ25vc3RpY3Moc3RhdGUsIGRpYWdub3N0aWNzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZWZmZWN0czogbWF5YmVFbmFibGVMaW50KHN0YXRlLCBbc2V0RGlhZ25vc3RpY3NFZmZlY3Qub2YoZGlhZ25vc3RpY3MpXSlcbiAgICB9O1xufVxuLyoqXG5UaGUgc3RhdGUgZWZmZWN0IHRoYXQgdXBkYXRlcyB0aGUgc2V0IG9mIGFjdGl2ZSBkaWFnbm9zdGljcy4gQ2FuXG5iZSB1c2VmdWwgd2hlbiB3cml0aW5nIGFuIGV4dGVuc2lvbiB0aGF0IG5lZWRzIHRvIHRyYWNrIHRoZXNlLlxuKi9cbmNvbnN0IHNldERpYWdub3N0aWNzRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgdG9nZ2xlUGFuZWwgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBtb3ZlUGFuZWxTZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBsaW50U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW50U3RhdGUoRGVjb3JhdGlvbi5ub25lLCBudWxsLCBudWxsKTtcbiAgICB9LFxuICAgIHVwZGF0ZSh2YWx1ZSwgdHIpIHtcbiAgICAgICAgaWYgKHRyLmRvY0NoYW5nZWQgJiYgdmFsdWUuZGlhZ25vc3RpY3Muc2l6ZSkge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHZhbHVlLmRpYWdub3N0aWNzLm1hcCh0ci5jaGFuZ2VzKSwgc2VsZWN0ZWQgPSBudWxsLCBwYW5lbCA9IHZhbHVlLnBhbmVsO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbFBvcyA9IHRyLmNoYW5nZXMubWFwUG9zKHZhbHVlLnNlbGVjdGVkLmZyb20sIDEpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gZmluZERpYWdub3N0aWMobWFwcGVkLCB2YWx1ZS5zZWxlY3RlZC5kaWFnbm9zdGljLCBzZWxQb3MpIHx8IGZpbmREaWFnbm9zdGljKG1hcHBlZCwgbnVsbCwgc2VsUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWFwcGVkLnNpemUgJiYgcGFuZWwgJiYgdHIuc3RhdGUuZmFjZXQobGludENvbmZpZykuYXV0b1BhbmVsKVxuICAgICAgICAgICAgICAgIHBhbmVsID0gbnVsbDtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IExpbnRTdGF0ZShtYXBwZWQsIHBhbmVsLCBzZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0RGlhZ25vc3RpY3NFZmZlY3QpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhbmVsID0gIXRyLnN0YXRlLmZhY2V0KGxpbnRDb25maWcpLmF1dG9QYW5lbCA/IHZhbHVlLnBhbmVsIDogZWZmZWN0LnZhbHVlLmxlbmd0aCA/IExpbnRQYW5lbC5vcGVuIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IExpbnRTdGF0ZS5pbml0KGVmZmVjdC52YWx1ZSwgcGFuZWwsIHRyLnN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyh0b2dnbGVQYW5lbCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBMaW50U3RhdGUodmFsdWUuZGlhZ25vc3RpY3MsIGVmZmVjdC52YWx1ZSA/IExpbnRQYW5lbC5vcGVuIDogbnVsbCwgdmFsdWUuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKG1vdmVQYW5lbFNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBMaW50U3RhdGUodmFsdWUuZGlhZ25vc3RpY3MsIHZhbHVlLnBhbmVsLCBlZmZlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gW3Nob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwucGFuZWwpLFxuICAgICAgICBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZiwgcyA9PiBzLmRpYWdub3N0aWNzKV1cbn0pO1xuLyoqXG5SZXR1cm5zIHRoZSBudW1iZXIgb2YgYWN0aXZlIGxpbnQgZGlhZ25vc3RpY3MgaW4gdGhlIGdpdmVuIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIGRpYWdub3N0aWNDb3VudChzdGF0ZSkge1xuICAgIGxldCBsaW50ID0gc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgcmV0dXJuIGxpbnQgPyBsaW50LmRpYWdub3N0aWNzLnNpemUgOiAwO1xufVxuY29uc3QgYWN0aXZlTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1saW50UmFuZ2UgY20tbGludFJhbmdlLWFjdGl2ZVwiIH0pO1xuZnVuY3Rpb24gbGludFRvb2x0aXAodmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IHsgZGlhZ25vc3RpY3MgfSA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICBsZXQgZm91bmQsIHN0YXJ0ID0gLTEsIGVuZCA9IC0xO1xuICAgIGRpYWdub3N0aWNzLmJldHdlZW4ocG9zIC0gKHNpZGUgPCAwID8gMSA6IDApLCBwb3MgKyAoc2lkZSA+IDAgPyAxIDogMCksIChmcm9tLCB0bywgeyBzcGVjIH0pID0+IHtcbiAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0byAmJlxuICAgICAgICAgICAgKGZyb20gPT0gdG8gfHwgKChwb3MgPiBmcm9tIHx8IHNpZGUgPiAwKSAmJiAocG9zIDwgdG8gfHwgc2lkZSA8IDApKSkpIHtcbiAgICAgICAgICAgIGZvdW5kID0gc3BlYy5kaWFnbm9zdGljcztcbiAgICAgICAgICAgIHN0YXJ0ID0gZnJvbTtcbiAgICAgICAgICAgIGVuZCA9IHRvO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGRpYWdub3N0aWNGaWx0ZXIgPSB2aWV3LnN0YXRlLmZhY2V0KGxpbnRDb25maWcpLnRvb2x0aXBGaWx0ZXI7XG4gICAgaWYgKGZvdW5kICYmIGRpYWdub3N0aWNGaWx0ZXIpXG4gICAgICAgIGZvdW5kID0gZGlhZ25vc3RpY0ZpbHRlcihmb3VuZCwgdmlldy5zdGF0ZSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBzdGFydCxcbiAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgIGFib3ZlOiB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhcnQpLnRvIDwgZW5kLFxuICAgICAgICBjcmVhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb206IGRpYWdub3N0aWNzVG9vbHRpcCh2aWV3LCBmb3VuZCkgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBkaWFnbm9zdGljc1Rvb2x0aXAodmlldywgZGlhZ25vc3RpY3MpIHtcbiAgICByZXR1cm4gZWx0KFwidWxcIiwgeyBjbGFzczogXCJjbS10b29sdGlwLWxpbnRcIiB9LCBkaWFnbm9zdGljcy5tYXAoZCA9PiByZW5kZXJEaWFnbm9zdGljKHZpZXcsIGQsIGZhbHNlKSkpO1xufVxuLyoqXG5Db21tYW5kIHRvIG9wZW4gYW5kIGZvY3VzIHRoZSBsaW50IHBhbmVsLlxuKi9cbmNvbnN0IG9wZW5MaW50UGFuZWwgPSAodmlldykgPT4ge1xuICAgIGxldCBmaWVsZCA9IHZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZCB8fCAhZmllbGQucGFuZWwpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZUxpbnQodmlldy5zdGF0ZSwgW3RvZ2dsZVBhbmVsLm9mKHRydWUpXSkgfSk7XG4gICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgTGludFBhbmVsLm9wZW4pO1xuICAgIGlmIChwYW5lbClcbiAgICAgICAgcGFuZWwuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tcGFuZWwtbGludCB1bFwiKS5mb2N1cygpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ29tbWFuZCB0byBjbG9zZSB0aGUgbGludCBwYW5lbCwgd2hlbiBvcGVuLlxuKi9cbmNvbnN0IGNsb3NlTGludFBhbmVsID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQgfHwgIWZpZWxkLnBhbmVsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRvZ2dsZVBhbmVsLm9mKGZhbHNlKSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbk1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgbmV4dCBkaWFnbm9zdGljLlxuKi9cbmNvbnN0IG5leHREaWFnbm9zdGljID0gKHZpZXcpID0+IHtcbiAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbiwgbmV4dCA9IGZpZWxkLmRpYWdub3N0aWNzLml0ZXIoc2VsLnRvICsgMSk7XG4gICAgaWYgKCFuZXh0LnZhbHVlKSB7XG4gICAgICAgIG5leHQgPSBmaWVsZC5kaWFnbm9zdGljcy5pdGVyKDApO1xuICAgICAgICBpZiAoIW5leHQudmFsdWUgfHwgbmV4dC5mcm9tID09IHNlbC5mcm9tICYmIG5leHQudG8gPT0gc2VsLnRvKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aWV3LmRpc3BhdGNoKHsgc2VsZWN0aW9uOiB7IGFuY2hvcjogbmV4dC5mcm9tLCBoZWFkOiBuZXh0LnRvIH0sIHNjcm9sbEludG9WaWV3OiB0cnVlIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBwcmV2aW91cyBkaWFnbm9zdGljLlxuKi9cbmNvbnN0IHByZXZpb3VzRGlhZ25vc3RpYyA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQobGludFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFmaWVsZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgcHJldkZyb20sIHByZXZUbywgbGFzdEZyb20sIGxhc3RUbztcbiAgICBmaWVsZC5kaWFnbm9zdGljcy5iZXR3ZWVuKDAsIHN0YXRlLmRvYy5sZW5ndGgsIChmcm9tLCB0bykgPT4ge1xuICAgICAgICBpZiAodG8gPCBzZWwudG8gJiYgKHByZXZGcm9tID09IG51bGwgfHwgcHJldkZyb20gPCBmcm9tKSkge1xuICAgICAgICAgICAgcHJldkZyb20gPSBmcm9tO1xuICAgICAgICAgICAgcHJldlRvID0gdG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RGcm9tID09IG51bGwgfHwgZnJvbSA+IGxhc3RGcm9tKSB7XG4gICAgICAgICAgICBsYXN0RnJvbSA9IGZyb207XG4gICAgICAgICAgICBsYXN0VG8gPSB0bztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChsYXN0RnJvbSA9PSBudWxsIHx8IHByZXZGcm9tID09IG51bGwgJiYgbGFzdEZyb20gPT0gc2VsLmZyb20pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgc2VsZWN0aW9uOiB7IGFuY2hvcjogcHJldkZyb20gIT09IG51bGwgJiYgcHJldkZyb20gIT09IHZvaWQgMCA/IHByZXZGcm9tIDogbGFzdEZyb20sIGhlYWQ6IHByZXZUbyAhPT0gbnVsbCAmJiBwcmV2VG8gIT09IHZvaWQgMCA/IHByZXZUbyA6IGxhc3RUbyB9LCBzY3JvbGxJbnRvVmlldzogdHJ1ZSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkEgc2V0IG9mIGRlZmF1bHQga2V5IGJpbmRpbmdzIGZvciB0aGUgbGludCBmdW5jdGlvbmFsaXR5LlxuXG4tIEN0cmwtU2hpZnQtbSAoQ21kLVNoaWZ0LW0gb24gbWFjT1MpOiBbYG9wZW5MaW50UGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQub3BlbkxpbnRQYW5lbClcbi0gRjg6IFtgbmV4dERpYWdub3N0aWNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xpbnQubmV4dERpYWdub3N0aWMpXG4qL1xuY29uc3QgbGludEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtU2hpZnQtbVwiLCBydW46IG9wZW5MaW50UGFuZWwsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiRjhcIiwgcnVuOiBuZXh0RGlhZ25vc3RpYyB9XG5dO1xuY29uc3QgbGludFBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5zZXQgPSB0cnVlO1xuICAgICAgICBsZXQgeyBkZWxheSB9ID0gdmlldy5zdGF0ZS5mYWNldChsaW50Q29uZmlnKTtcbiAgICAgICAgdGhpcy5saW50VGltZSA9IERhdGUubm93KCkgKyBkZWxheTtcbiAgICAgICAgdGhpcy5ydW4gPSB0aGlzLnJ1bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMucnVuLCBkZWxheSk7XG4gICAgfVxuICAgIHJ1bigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgIGxldCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAobm93IDwgdGhpcy5saW50VGltZSAtIDEwKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMucnVuLCB0aGlzLmxpbnRUaW1lIC0gbm93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCB7IHNvdXJjZXMgfSA9IHN0YXRlLmZhY2V0KGxpbnRDb25maWcpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJhdGNoUmVzdWx0cyhzb3VyY2VzLm1hcChzID0+IFByb21pc2UucmVzb2x2ZShzKHRoaXMudmlldykpKSwgYW5ub3RhdGlvbnMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmRvYyA9PSBzdGF0ZS5kb2MpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goc2V0RGlhZ25vc3RpY3ModGhpcy52aWV3LnN0YXRlLCBhbm5vdGF0aW9ucy5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKSkpO1xuICAgICAgICAgICAgICAgIH0sIGVycm9yID0+IHsgbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZXJyb3IpOyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB1cGRhdGUuc3RhdGUuZmFjZXQobGludENvbmZpZyk7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCBjb25maWcgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQobGludENvbmZpZykgfHxcbiAgICAgICAgICAgIGNvbmZpZy5uZWVkc1JlZnJlc2ggJiYgY29uZmlnLm5lZWRzUmVmcmVzaCh1cGRhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKSArIGNvbmZpZy5kZWxheTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnJ1biwgY29uZmlnLmRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JjZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmxpbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBiYXRjaFJlc3VsdHMocHJvbWlzZXMsIHNpbmssIGVycm9yKSB7XG4gICAgbGV0IGNvbGxlY3RlZCA9IFtdLCB0aW1lb3V0ID0gLTE7XG4gICAgZm9yIChsZXQgcCBvZiBwcm9taXNlcylcbiAgICAgICAgcC50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIGNvbGxlY3RlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIGlmIChjb2xsZWN0ZWQubGVuZ3RoID09IHByb21pc2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBzaW5rKGNvbGxlY3RlZCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gc2luayhjb2xsZWN0ZWQpLCAyMDApO1xuICAgICAgICB9LCBlcnJvcik7XG59XG5jb25zdCBsaW50Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHNvdXJjZXM6IGlucHV0Lm1hcChpID0+IGkuc291cmNlKS5maWx0ZXIoeCA9PiB4ICE9IG51bGwpIH0sIGNvbWJpbmVDb25maWcoaW5wdXQubWFwKGkgPT4gaS5jb25maWcpLCB7XG4gICAgICAgICAgICBkZWxheTogNzUwLFxuICAgICAgICAgICAgbWFya2VyRmlsdGVyOiBudWxsLFxuICAgICAgICAgICAgdG9vbHRpcEZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIG5lZWRzUmVmcmVzaDogbnVsbCxcbiAgICAgICAgICAgIGhpZGVPbjogKCkgPT4gbnVsbCxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbmVlZHNSZWZyZXNoOiAoYSwgYikgPT4gIWEgPyBiIDogIWIgPyBhIDogdSA9PiBhKHUpIHx8IGIodSlcbiAgICAgICAgfSkpO1xuICAgIH1cbn0pO1xuLyoqXG5HaXZlbiBhIGRpYWdub3N0aWMgc291cmNlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXRcbmVuYWJsZXMgbGludGluZyB3aXRoIHRoYXQgc291cmNlLiBJdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGVcbmVkaXRvciBpcyBpZGxlIChhZnRlciBpdHMgY29udGVudCBjaGFuZ2VkKS4gSWYgYG51bGxgIGlzIGdpdmVuIGFzXG5zb3VyY2UsIHRoaXMgb25seSBjb25maWd1cmVzIHRoZSBsaW50IGV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBsaW50ZXIoc291cmNlLCBjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGxpbnRDb25maWcub2YoeyBzb3VyY2UsIGNvbmZpZyB9KSxcbiAgICAgICAgbGludFBsdWdpbixcbiAgICAgICAgbGludEV4dGVuc2lvbnNcbiAgICBdO1xufVxuLyoqXG5Gb3JjZXMgYW55IGxpbnRlcnMgW2NvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGludC5saW50ZXIpIHRvIHJ1biB3aGVuIHRoZVxuZWRpdG9yIGlzIGlkbGUgdG8gcnVuIHJpZ2h0IGF3YXkuXG4qL1xuZnVuY3Rpb24gZm9yY2VMaW50aW5nKHZpZXcpIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4obGludFBsdWdpbik7XG4gICAgaWYgKHBsdWdpbilcbiAgICAgICAgcGx1Z2luLmZvcmNlKCk7XG59XG5mdW5jdGlvbiBhc3NpZ25LZXlzKGFjdGlvbnMpIHtcbiAgICBsZXQgYXNzaWduZWQgPSBbXTtcbiAgICBpZiAoYWN0aW9ucylcbiAgICAgICAgYWN0aW9uczogZm9yIChsZXQgeyBuYW1lIH0gb2YgYWN0aW9ucykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gbmFtZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoL1thLXpBLVpdLy50ZXN0KGNoKSAmJiAhYXNzaWduZWQuc29tZShjID0+IGMudG9Mb3dlckNhc2UoKSA9PSBjaC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ25lZC5wdXNoKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgYWN0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NpZ25lZC5wdXNoKFwiXCIpO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGFzc2lnbmVkO1xufVxuZnVuY3Rpb24gcmVuZGVyRGlhZ25vc3RpYyh2aWV3LCBkaWFnbm9zdGljLCBpblBhbmVsKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBrZXlzID0gaW5QYW5lbCA/IGFzc2lnbktleXMoZGlhZ25vc3RpYy5hY3Rpb25zKSA6IFtdO1xuICAgIHJldHVybiBlbHQoXCJsaVwiLCB7IGNsYXNzOiBcImNtLWRpYWdub3N0aWMgY20tZGlhZ25vc3RpYy1cIiArIGRpYWdub3N0aWMuc2V2ZXJpdHkgfSwgZWx0KFwic3BhblwiLCB7IGNsYXNzOiBcImNtLWRpYWdub3N0aWNUZXh0XCIgfSwgZGlhZ25vc3RpYy5yZW5kZXJNZXNzYWdlID8gZGlhZ25vc3RpYy5yZW5kZXJNZXNzYWdlKHZpZXcpIDogZGlhZ25vc3RpYy5tZXNzYWdlKSwgKF9hID0gZGlhZ25vc3RpYy5hY3Rpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChhY3Rpb24sIGkpID0+IHtcbiAgICAgICAgbGV0IGZpcmVkID0gZmFsc2UsIGNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChmaXJlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmaW5kRGlhZ25vc3RpYyh2aWV3LnN0YXRlLmZpZWxkKGxpbnRTdGF0ZSkuZGlhZ25vc3RpY3MsIGRpYWdub3N0aWMpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgIGFjdGlvbi5hcHBseSh2aWV3LCBmb3VuZC5mcm9tLCBmb3VuZC50byk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCB7IG5hbWUgfSA9IGFjdGlvbiwga2V5SW5kZXggPSBrZXlzW2ldID8gbmFtZS5pbmRleE9mKGtleXNbaV0pIDogLTE7XG4gICAgICAgIGxldCBuYW1lRWx0ID0ga2V5SW5kZXggPCAwID8gbmFtZSA6IFtuYW1lLnNsaWNlKDAsIGtleUluZGV4KSxcbiAgICAgICAgICAgIGVsdChcInVcIiwgbmFtZS5zbGljZShrZXlJbmRleCwga2V5SW5kZXggKyAxKSksXG4gICAgICAgICAgICBuYW1lLnNsaWNlKGtleUluZGV4ICsgMSldO1xuICAgICAgICByZXR1cm4gZWx0KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBjbGFzczogXCJjbS1kaWFnbm9zdGljQWN0aW9uXCIsXG4gICAgICAgICAgICBvbmNsaWNrOiBjbGljayxcbiAgICAgICAgICAgIG9ubW91c2Vkb3duOiBjbGljayxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBgIEFjdGlvbjogJHtuYW1lfSR7a2V5SW5kZXggPCAwID8gXCJcIiA6IGAgKGFjY2VzcyBrZXkgXCIke2tleXNbaV19KVwiYH0uYFxuICAgICAgICB9LCBuYW1lRWx0KTtcbiAgICB9KSwgZGlhZ25vc3RpYy5zb3VyY2UgJiYgZWx0KFwiZGl2XCIsIHsgY2xhc3M6IFwiY20tZGlhZ25vc3RpY1NvdXJjZVwiIH0sIGRpYWdub3N0aWMuc291cmNlKSk7XG59XG5jbGFzcyBEaWFnbm9zdGljV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc2V2KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2V2ID0gc2V2O1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuc2V2ID09IHRoaXMuc2V2OyB9XG4gICAgdG9ET00oKSB7XG4gICAgICAgIHJldHVybiBlbHQoXCJzcGFuXCIsIHsgY2xhc3M6IFwiY20tbGludFBvaW50IGNtLWxpbnRQb2ludC1cIiArIHRoaXMuc2V2IH0pO1xuICAgIH1cbn1cbmNsYXNzIFBhbmVsSXRlbSB7XG4gICAgY29uc3RydWN0b3IodmlldywgZGlhZ25vc3RpYykge1xuICAgICAgICB0aGlzLmRpYWdub3N0aWMgPSBkaWFnbm9zdGljO1xuICAgICAgICB0aGlzLmlkID0gXCJpdGVtX1wiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICB0aGlzLmRvbSA9IHJlbmRlckRpYWdub3N0aWModmlldywgZGlhZ25vc3RpYywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZG9tLmlkID0gdGhpcy5pZDtcbiAgICAgICAgdGhpcy5kb20uc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKTtcbiAgICB9XG59XG5jbGFzcyBMaW50UGFuZWwge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICBsZXQgb25rZXlkb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykgeyAvLyBFc2NhcGVcbiAgICAgICAgICAgICAgICBjbG9zZUxpbnRQYW5lbCh0aGlzLnZpZXcpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSAzOCB8fCBldmVudC5rZXlDb2RlID09IDMzKSB7IC8vIEFycm93VXAsIFBhZ2VVcFxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigodGhpcy5zZWxlY3RlZEluZGV4IC0gMSArIHRoaXMuaXRlbXMubGVuZ3RoKSAlIHRoaXMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gNDAgfHwgZXZlbnQua2V5Q29kZSA9PSAzNCkgeyAvLyBBcnJvd0Rvd24sIFBhZ2VEb3duXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKCh0aGlzLnNlbGVjdGVkSW5kZXggKyAxKSAlIHRoaXMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzYpIHsgLy8gSG9tZVxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMzUpIHsgLy8gRW5kXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKHRoaXMuaXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDEzKSB7IC8vIEVudGVyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID49IDY1ICYmIGV2ZW50LmtleUNvZGUgPD0gOTAgJiYgdGhpcy5zZWxlY3RlZEluZGV4ID49IDApIHsgLy8gQS1aXG4gICAgICAgICAgICAgICAgbGV0IHsgZGlhZ25vc3RpYyB9ID0gdGhpcy5pdGVtc1t0aGlzLnNlbGVjdGVkSW5kZXhdLCBrZXlzID0gYXNzaWduS2V5cyhkaWFnbm9zdGljLmFjdGlvbnMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXNbaV0udG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApID09IGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZpbmREaWFnbm9zdGljKHRoaXMudmlldy5zdGF0ZS5maWVsZChsaW50U3RhdGUpLmRpYWdub3N0aWNzLCBkaWFnbm9zdGljKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljLmFjdGlvbnNbaV0uYXBwbHkodmlldywgZm91bmQuZnJvbSwgZm91bmQudG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgb25jbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbaV0uZG9tLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbihpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0ID0gZWx0KFwidWxcIiwge1xuICAgICAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgICAgICByb2xlOiBcImxpc3Rib3hcIixcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiRGlhZ25vc3RpY3NcIiksXG4gICAgICAgICAgICBvbmtleWRvd24sXG4gICAgICAgICAgICBvbmNsaWNrXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvbSA9IGVsdChcImRpdlwiLCB7IGNsYXNzOiBcImNtLXBhbmVsLWxpbnRcIiB9LCB0aGlzLmxpc3QsIGVsdChcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgbmFtZTogXCJjbG9zZVwiLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHRoaXMudmlldy5zdGF0ZS5waHJhc2UoXCJjbG9zZVwiKSxcbiAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IGNsb3NlTGludFBhbmVsKHRoaXMudmlldylcbiAgICAgICAgfSwgXCLDl1wiKSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKS5zZWxlY3RlZDtcbiAgICAgICAgaWYgKCFzZWxlY3RlZClcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbaV0uZGlhZ25vc3RpYyA9PSBzZWxlY3RlZC5kaWFnbm9zdGljKVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgbGV0IHsgZGlhZ25vc3RpY3MsIHNlbGVjdGVkIH0gPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICAgICAgbGV0IGkgPSAwLCBuZWVkc1N5bmMgPSBmYWxzZSwgbmV3U2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgbGV0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgICAgIGRpYWdub3N0aWNzLmJldHdlZW4oMCwgdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGgsIChfc3RhcnQsIF9lbmQsIHsgc3BlYyB9KSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBkaWFnbm9zdGljIG9mIHNwZWMuZGlhZ25vc3RpY3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Vlbi5oYXMoZGlhZ25vc3RpYykpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHNlZW4uYWRkKGRpYWdub3N0aWMpO1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IC0xLCBpdGVtO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgdGhpcy5pdGVtcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbXNbal0uZGlhZ25vc3RpYyA9PSBkaWFnbm9zdGljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IG5ldyBQYW5lbEl0ZW0odGhpcy52aWV3LCBkaWFnbm9zdGljKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgMCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gdGhpcy5pdGVtc1tmb3VuZF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIGZvdW5kIC0gaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkc1N5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiBpdGVtLmRpYWdub3N0aWMgPT0gc2VsZWN0ZWQuZGlhZ25vc3RpYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uZG9tLmhhc0F0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0ZWRJdGVtID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdGVtLmRvbS5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZG9tLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5pdGVtcy5sZW5ndGggJiYgISh0aGlzLml0ZW1zLmxlbmd0aCA9PSAxICYmIHRoaXMuaXRlbXNbMF0uZGlhZ25vc3RpYy5mcm9tIDwgMCkpIHtcbiAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLml0ZW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gobmV3IFBhbmVsSXRlbSh0aGlzLnZpZXcsIHtcbiAgICAgICAgICAgICAgICBmcm9tOiAtMSwgdG86IC0xLFxuICAgICAgICAgICAgICAgIHNldmVyaXR5OiBcImluZm9cIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0aGlzLnZpZXcuc3RhdGUucGhyYXNlKFwiTm8gZGlhZ25vc3RpY3NcIilcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIG5lZWRzU3luYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1NlbGVjdGVkSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5saXN0LnNldEF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCBuZXdTZWxlY3RlZEl0ZW0uaWQpO1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHtcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVhZDogKCkgPT4gKHsgc2VsOiBuZXdTZWxlY3RlZEl0ZW0uZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBwYW5lbDogdGhpcy5saXN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIH0pLFxuICAgICAgICAgICAgICAgIHdyaXRlOiAoeyBzZWwsIHBhbmVsIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNjYWxlWSA9IHBhbmVsLmhlaWdodCAvIHRoaXMubGlzdC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwudG9wIDwgcGFuZWwudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0LnNjcm9sbFRvcCAtPSAocGFuZWwudG9wIC0gc2VsLnRvcCkgLyBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbC5ib3R0b20gPiBwYW5lbC5ib3R0b20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3Quc2Nyb2xsVG9wICs9IChzZWwuYm90dG9tIC0gcGFuZWwuYm90dG9tKSAvIHNjYWxlWTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3QucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc1N5bmMpXG4gICAgICAgICAgICB0aGlzLnN5bmMoKTtcbiAgICB9XG4gICAgc3luYygpIHtcbiAgICAgICAgbGV0IGRvbVBvcyA9IHRoaXMubGlzdC5maXJzdENoaWxkO1xuICAgICAgICBmdW5jdGlvbiBybSgpIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gZG9tUG9zO1xuICAgICAgICAgICAgZG9tUG9zID0gcHJldi5uZXh0U2libGluZztcbiAgICAgICAgICAgIHByZXYucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmxpc3QpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tUG9zICE9IGl0ZW0uZG9tKVxuICAgICAgICAgICAgICAgICAgICBybSgpO1xuICAgICAgICAgICAgICAgIGRvbVBvcyA9IGl0ZW0uZG9tLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0Lmluc2VydEJlZm9yZShpdGVtLmRvbSwgZG9tUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZG9tUG9zKVxuICAgICAgICAgICAgcm0oKTtcbiAgICB9XG4gICAgbW92ZVNlbGVjdGlvbihzZWxlY3RlZEluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZmllbGQgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQobGludFN0YXRlKTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGZpbmREaWFnbm9zdGljKGZpZWxkLmRpYWdub3N0aWNzLCB0aGlzLml0ZW1zW3NlbGVjdGVkSW5kZXhdLmRpYWdub3N0aWMpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IHNlbGVjdGlvbi5mcm9tLCBoZWFkOiBzZWxlY3Rpb24udG8gfSxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlLFxuICAgICAgICAgICAgZWZmZWN0czogbW92ZVBhbmVsU2VsZWN0aW9uLm9mKHNlbGVjdGlvbilcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBvcGVuKHZpZXcpIHsgcmV0dXJuIG5ldyBMaW50UGFuZWwodmlldyk7IH1cbn1cbmZ1bmN0aW9uIHN2Zyhjb250ZW50LCBhdHRycyA9IGB2aWV3Qm94PVwiMCAwIDQwIDQwXCJgKSB7XG4gICAgcmV0dXJuIGB1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbCw8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAke2F0dHJzfT4ke2VuY29kZVVSSUNvbXBvbmVudChjb250ZW50KX08L3N2Zz4nKWA7XG59XG5mdW5jdGlvbiB1bmRlcmxpbmUoY29sb3IpIHtcbiAgICByZXR1cm4gc3ZnKGA8cGF0aCBkPVwibTAgMi41IGwyIC0xLjUgbDEgMCBsMiAxLjUgbDEgMFwiIHN0cm9rZT1cIiR7Y29sb3J9XCIgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIuN1wiLz5gLCBgd2lkdGg9XCI2XCIgaGVpZ2h0PVwiM1wiYCk7XG59XG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLWRpYWdub3N0aWNcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjNweCA2cHggM3B4IDhweFwiLFxuICAgICAgICBtYXJnaW5MZWZ0OiBcIi0xcHhcIixcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICB3aGl0ZVNwYWNlOiBcInByZS13cmFwXCJcbiAgICB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtZXJyb3JcIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCAjZDExXCIgfSxcbiAgICBcIi5jbS1kaWFnbm9zdGljLXdhcm5pbmdcIjogeyBib3JkZXJMZWZ0OiBcIjVweCBzb2xpZCBvcmFuZ2VcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtaW5mb1wiOiB7IGJvcmRlckxlZnQ6IFwiNXB4IHNvbGlkICM5OTlcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWMtaGludFwiOiB7IGJvcmRlckxlZnQ6IFwiNXB4IHNvbGlkICM2NmRcIiB9LFxuICAgIFwiLmNtLWRpYWdub3N0aWNBY3Rpb25cIjoge1xuICAgICAgICBmb250OiBcImluaGVyaXRcIixcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgcGFkZGluZzogXCIycHggNHB4XCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjNDQ0XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCIzcHhcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCI4cHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgXCIuY20tZGlhZ25vc3RpY1NvdXJjZVwiOiB7XG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBvcGFjaXR5OiAuN1xuICAgIH0sXG4gICAgXCIuY20tbGludFJhbmdlXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZFBvc2l0aW9uOiBcImxlZnQgYm90dG9tXCIsXG4gICAgICAgIGJhY2tncm91bmRSZXBlYXQ6IFwicmVwZWF0LXhcIixcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogXCIwLjdweFwiLFxuICAgIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWVycm9yXCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwiI2QxMVwiKSB9LFxuICAgIFwiLmNtLWxpbnRSYW5nZS13YXJuaW5nXCI6IHsgYmFja2dyb3VuZEltYWdlOiAvKkBfX1BVUkVfXyovdW5kZXJsaW5lKFwib3JhbmdlXCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWluZm9cIjogeyBiYWNrZ3JvdW5kSW1hZ2U6IC8qQF9fUFVSRV9fKi91bmRlcmxpbmUoXCIjOTk5XCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWhpbnRcIjogeyBiYWNrZ3JvdW5kSW1hZ2U6IC8qQF9fUFVSRV9fKi91bmRlcmxpbmUoXCIjNjZkXCIpIH0sXG4gICAgXCIuY20tbGludFJhbmdlLWFjdGl2ZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmZkZDk5ODBcIiB9LFxuICAgIFwiLmNtLXRvb2x0aXAtbGludFwiOiB7XG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG1hcmdpbjogMFxuICAgIH0sXG4gICAgXCIuY20tbGludFBvaW50XCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdcIlwiJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICBsZWZ0OiBcIi0ycHhcIixcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6IFwiM3B4IHNvbGlkIHRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBib3JkZXJSaWdodDogXCIzcHggc29saWQgdHJhbnNwYXJlbnRcIixcbiAgICAgICAgICAgIGJvcmRlckJvdHRvbTogXCI0cHggc29saWQgI2QxMVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbnRQb2ludC13YXJuaW5nXCI6IHtcbiAgICAgICAgXCImOmFmdGVyXCI6IHsgYm9yZGVyQm90dG9tQ29sb3I6IFwib3JhbmdlXCIgfVxuICAgIH0sXG4gICAgXCIuY20tbGludFBvaW50LWluZm9cIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBib3JkZXJCb3R0b21Db2xvcjogXCIjOTk5XCIgfVxuICAgIH0sXG4gICAgXCIuY20tbGludFBvaW50LWhpbnRcIjoge1xuICAgICAgICBcIiY6YWZ0ZXJcIjogeyBib3JkZXJCb3R0b21Db2xvcjogXCIjNjZkXCIgfVxuICAgIH0sXG4gICAgXCIuY20tcGFuZWwuY20tcGFuZWwtbGludFwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJiB1bFwiOiB7XG4gICAgICAgICAgICBtYXhIZWlnaHQ6IFwiMTAwcHhcIixcbiAgICAgICAgICAgIG92ZXJmbG93WTogXCJhdXRvXCIsXG4gICAgICAgICAgICBcIiYgW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2RkZFwiLFxuICAgICAgICAgICAgICAgIFwiJiB1XCI6IHsgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjpmb2N1cyBbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRfZmFsbGJhY2s6IFwiI2JkZlwiLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJIaWdobGlnaHRcIixcbiAgICAgICAgICAgICAgICBjb2xvcl9mYWxsYmFjazogXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBcIkhpZ2hsaWdodFRleHRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJiB1XCI6IHsgdGV4dERlY29yYXRpb246IFwibm9uZVwiIH0sXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBbbmFtZT1jbG9zZV1cIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgICByaWdodDogXCIycHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgICAgIGZvbnQ6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMFxuICAgICAgICB9XG4gICAgfVxufSk7XG5mdW5jdGlvbiBzZXZlcml0eVdlaWdodChzZXYpIHtcbiAgICByZXR1cm4gc2V2ID09IFwiZXJyb3JcIiA/IDQgOiBzZXYgPT0gXCJ3YXJuaW5nXCIgPyAzIDogc2V2ID09IFwiaW5mb1wiID8gMiA6IDE7XG59XG5mdW5jdGlvbiBtYXhTZXZlcml0eShkaWFnbm9zdGljcykge1xuICAgIGxldCBzZXYgPSBcImhpbnRcIiwgd2VpZ2h0ID0gMTtcbiAgICBmb3IgKGxldCBkIG9mIGRpYWdub3N0aWNzKSB7XG4gICAgICAgIGxldCB3ID0gc2V2ZXJpdHlXZWlnaHQoZC5zZXZlcml0eSk7XG4gICAgICAgIGlmICh3ID4gd2VpZ2h0KSB7XG4gICAgICAgICAgICB3ZWlnaHQgPSB3O1xuICAgICAgICAgICAgc2V2ID0gZC5zZXZlcml0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2V2O1xufVxuY2xhc3MgTGludEd1dHRlck1hcmtlciBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IoZGlhZ25vc3RpY3MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljcyA9IGRpYWdub3N0aWNzO1xuICAgICAgICB0aGlzLnNldmVyaXR5ID0gbWF4U2V2ZXJpdHkoZGlhZ25vc3RpY3MpO1xuICAgIH1cbiAgICB0b0RPTSh2aWV3KSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlbHQuY2xhc3NOYW1lID0gXCJjbS1saW50LW1hcmtlciBjbS1saW50LW1hcmtlci1cIiArIHRoaXMuc2V2ZXJpdHk7XG4gICAgICAgIGxldCBkaWFnbm9zdGljcyA9IHRoaXMuZGlhZ25vc3RpY3M7XG4gICAgICAgIGxldCBkaWFnbm9zdGljc0ZpbHRlciA9IHZpZXcuc3RhdGUuZmFjZXQobGludEd1dHRlckNvbmZpZykudG9vbHRpcEZpbHRlcjtcbiAgICAgICAgaWYgKGRpYWdub3N0aWNzRmlsdGVyKVxuICAgICAgICAgICAgZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljc0ZpbHRlcihkaWFnbm9zdGljcywgdmlldy5zdGF0ZSk7XG4gICAgICAgIGlmIChkaWFnbm9zdGljcy5sZW5ndGgpXG4gICAgICAgICAgICBlbHQub25tb3VzZW92ZXIgPSAoKSA9PiBndXR0ZXJNYXJrZXJNb3VzZU92ZXIodmlldywgZWx0LCBkaWFnbm9zdGljcyk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhY2tIb3Zlck9uKHZpZXcsIG1hcmtlcikge1xuICAgIGxldCBtb3VzZW1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IHJlY3QgPSBtYXJrZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRYID4gcmVjdC5sZWZ0IC0gMTAgLyogSG92ZXIuTWFyZ2luICovICYmIGV2ZW50LmNsaWVudFggPCByZWN0LnJpZ2h0ICsgMTAgLyogSG92ZXIuTWFyZ2luICovICYmXG4gICAgICAgICAgICBldmVudC5jbGllbnRZID4gcmVjdC50b3AgLSAxMCAvKiBIb3Zlci5NYXJnaW4gKi8gJiYgZXZlbnQuY2xpZW50WSA8IHJlY3QuYm90dG9tICsgMTAgLyogSG92ZXIuTWFyZ2luICovKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQ7IHRhcmdldDsgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT0gMSAmJiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiY20tdG9vbHRpcC1saW50XCIpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZW1vdmUpO1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5maWVsZChsaW50R3V0dGVyVG9vbHRpcCkpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0TGludEd1dHRlclRvb2x0aXAub2YobnVsbCkgfSk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZW1vdmUpO1xufVxuZnVuY3Rpb24gZ3V0dGVyTWFya2VyTW91c2VPdmVyKHZpZXcsIG1hcmtlciwgZGlhZ25vc3RpY3MpIHtcbiAgICBmdW5jdGlvbiBob3ZlcmVkKCkge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcuZWxlbWVudEF0SGVpZ2h0KG1hcmtlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyA1IC0gdmlldy5kb2N1bWVudFRvcCk7XG4gICAgICAgIGNvbnN0IGxpbmVQb3MgPSB2aWV3LmNvb3Jkc0F0UG9zKGxpbmUuZnJvbSk7XG4gICAgICAgIGlmIChsaW5lUG9zKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0TGludEd1dHRlclRvb2x0aXAub2Yoe1xuICAgICAgICAgICAgICAgICAgICBwb3M6IGxpbmUuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgYWJvdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjbGlwOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb206IGRpYWdub3N0aWNzVG9vbHRpcCh2aWV3LCBkaWFnbm9zdGljcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29vcmRzOiAoKSA9PiBtYXJrZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSB9KTtcbiAgICAgICAgfVxuICAgICAgICBtYXJrZXIub25tb3VzZW91dCA9IG1hcmtlci5vbm1vdXNlbW92ZSA9IG51bGw7XG4gICAgICAgIHRyYWNrSG92ZXJPbih2aWV3LCBtYXJrZXIpO1xuICAgIH1cbiAgICBsZXQgeyBob3ZlclRpbWUgfSA9IHZpZXcuc3RhdGUuZmFjZXQobGludEd1dHRlckNvbmZpZyk7XG4gICAgbGV0IGhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQoaG92ZXJlZCwgaG92ZXJUaW1lKTtcbiAgICBtYXJrZXIub25tb3VzZW91dCA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGhvdmVyVGltZW91dCk7XG4gICAgICAgIG1hcmtlci5vbm1vdXNlb3V0ID0gbWFya2VyLm9ubW91c2Vtb3ZlID0gbnVsbDtcbiAgICB9O1xuICAgIG1hcmtlci5vbm1vdXNlbW92ZSA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGhvdmVyVGltZW91dCk7XG4gICAgICAgIGhvdmVyVGltZW91dCA9IHNldFRpbWVvdXQoaG92ZXJlZCwgaG92ZXJUaW1lKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFya2Vyc0ZvckRpYWdub3N0aWNzKGRvYywgZGlhZ25vc3RpY3MpIHtcbiAgICBsZXQgYnlMaW5lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBkaWFnbm9zdGljIG9mIGRpYWdub3N0aWNzKSB7XG4gICAgICAgIGxldCBsaW5lID0gZG9jLmxpbmVBdChkaWFnbm9zdGljLmZyb20pO1xuICAgICAgICAoYnlMaW5lW2xpbmUuZnJvbV0gfHwgKGJ5TGluZVtsaW5lLmZyb21dID0gW10pKS5wdXNoKGRpYWdub3N0aWMpO1xuICAgIH1cbiAgICBsZXQgbWFya2VycyA9IFtdO1xuICAgIGZvciAobGV0IGxpbmUgaW4gYnlMaW5lKSB7XG4gICAgICAgIG1hcmtlcnMucHVzaChuZXcgTGludEd1dHRlck1hcmtlcihieUxpbmVbbGluZV0pLnJhbmdlKCtsaW5lKSk7XG4gICAgfVxuICAgIHJldHVybiBSYW5nZVNldC5vZihtYXJrZXJzLCB0cnVlKTtcbn1cbmNvbnN0IGxpbnRHdXR0ZXJFeHRlbnNpb24gPSAvKkBfX1BVUkVfXyovZ3V0dGVyKHtcbiAgICBjbGFzczogXCJjbS1ndXR0ZXItbGludFwiLFxuICAgIG1hcmtlcnM6IHZpZXcgPT4gdmlldy5zdGF0ZS5maWVsZChsaW50R3V0dGVyTWFya2VycyksXG4gICAgd2lkZ2V0TWFya2VyOiAodmlldywgd2lkZ2V0LCBibG9jaykgPT4ge1xuICAgICAgICBsZXQgZGlhZ25vc3RpY3MgPSBbXTtcbiAgICAgICAgdmlldy5zdGF0ZS5maWVsZChsaW50R3V0dGVyTWFya2VycykuYmV0d2VlbihibG9jay5mcm9tLCBibG9jay50bywgKGZyb20sIHRvLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGZyb20gPiBibG9jay5mcm9tICYmIGZyb20gPCBibG9jay50bylcbiAgICAgICAgICAgICAgICBkaWFnbm9zdGljcy5wdXNoKC4uLnZhbHVlLmRpYWdub3N0aWNzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkaWFnbm9zdGljcy5sZW5ndGggPyBuZXcgTGludEd1dHRlck1hcmtlcihkaWFnbm9zdGljcykgOiBudWxsO1xuICAgIH1cbn0pO1xuY29uc3QgbGludEd1dHRlck1hcmtlcnMgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlU2V0LmVtcHR5O1xuICAgIH0sXG4gICAgdXBkYXRlKG1hcmtlcnMsIHRyKSB7XG4gICAgICAgIG1hcmtlcnMgPSBtYXJrZXJzLm1hcCh0ci5jaGFuZ2VzKTtcbiAgICAgICAgbGV0IGRpYWdub3N0aWNGaWx0ZXIgPSB0ci5zdGF0ZS5mYWNldChsaW50R3V0dGVyQ29uZmlnKS5tYXJrZXJGaWx0ZXI7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldERpYWdub3N0aWNzRWZmZWN0KSkge1xuICAgICAgICAgICAgICAgIGxldCBkaWFnbm9zdGljcyA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGlhZ25vc3RpY0ZpbHRlcilcbiAgICAgICAgICAgICAgICAgICAgZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljRmlsdGVyKGRpYWdub3N0aWNzIHx8IFtdLCB0ci5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgbWFya2VycyA9IG1hcmtlcnNGb3JEaWFnbm9zdGljcyh0ci5zdGF0ZS5kb2MsIGRpYWdub3N0aWNzLnNsaWNlKDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFya2VycztcbiAgICB9XG59KTtcbmNvbnN0IHNldExpbnRHdXR0ZXJUb29sdGlwID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgbGludEd1dHRlclRvb2x0aXAgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHRvb2x0aXAsIHRyKSB7XG4gICAgICAgIGlmICh0b29sdGlwICYmIHRyLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB0b29sdGlwID0gaGlkZVRvb2x0aXAodHIsIHRvb2x0aXApID8gbnVsbCA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdG9vbHRpcCksIHsgcG9zOiB0ci5jaGFuZ2VzLm1hcFBvcyh0b29sdGlwLnBvcykgfSk7XG4gICAgICAgIHJldHVybiB0ci5lZmZlY3RzLnJlZHVjZSgodCwgZSkgPT4gZS5pcyhzZXRMaW50R3V0dGVyVG9vbHRpcCkgPyBlLnZhbHVlIDogdCwgdG9vbHRpcCk7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmaWVsZCA9PiBzaG93VG9vbHRpcC5mcm9tKGZpZWxkKVxufSk7XG5jb25zdCBsaW50R3V0dGVyVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLWd1dHRlci1saW50XCI6IHtcbiAgICAgICAgd2lkdGg6IFwiMS40ZW1cIixcbiAgICAgICAgXCImIC5jbS1ndXR0ZXJFbGVtZW50XCI6IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IFwiLjJlbVwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiLmNtLWxpbnQtbWFya2VyXCI6IHtcbiAgICAgICAgd2lkdGg6IFwiMWVtXCIsXG4gICAgICAgIGhlaWdodDogXCIxZW1cIlxuICAgIH0sXG4gICAgXCIuY20tbGludC1tYXJrZXItaW5mb1wiOiB7XG4gICAgICAgIGNvbnRlbnQ6IC8qQF9fUFVSRV9fKi9zdmcoYDxwYXRoIGZpbGw9XCIjYWFmXCIgc3Ryb2tlPVwiIzc3ZVwiIHN0cm9rZS13aWR0aD1cIjZcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNSA1TDM1IDVMMzUgMzVMNSAzNVpcIi8+YClcbiAgICB9LFxuICAgIFwiLmNtLWxpbnQtbWFya2VyLXdhcm5pbmdcIjoge1xuICAgICAgICBjb250ZW50OiAvKkBfX1BVUkVfXyovc3ZnKGA8cGF0aCBmaWxsPVwiI2ZlOFwiIHN0cm9rZT1cIiNmZDdcIiBzdHJva2Utd2lkdGg9XCI2XCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTIwIDZMMzcgMzVMMyAzNVpcIi8+YCksXG4gICAgfSxcbiAgICBcIi5jbS1saW50LW1hcmtlci1lcnJvclwiOiB7XG4gICAgICAgIGNvbnRlbnQ6IC8qQF9fUFVSRV9fKi9zdmcoYDxjaXJjbGUgY3g9XCIyMFwiIGN5PVwiMjBcIiByPVwiMTVcIiBmaWxsPVwiI2Y4N1wiIHN0cm9rZT1cIiNmNDNcIiBzdHJva2Utd2lkdGg9XCI2XCIvPmApXG4gICAgfSxcbn0pO1xuY29uc3QgbGludEV4dGVuc2lvbnMgPSBbXG4gICAgbGludFN0YXRlLFxuICAgIC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmRlY29yYXRpb25zLmNvbXB1dGUoW2xpbnRTdGF0ZV0sIHN0YXRlID0+IHtcbiAgICAgICAgbGV0IHsgc2VsZWN0ZWQsIHBhbmVsIH0gPSBzdGF0ZS5maWVsZChsaW50U3RhdGUpO1xuICAgICAgICByZXR1cm4gIXNlbGVjdGVkIHx8ICFwYW5lbCB8fCBzZWxlY3RlZC5mcm9tID09IHNlbGVjdGVkLnRvID8gRGVjb3JhdGlvbi5ub25lIDogRGVjb3JhdGlvbi5zZXQoW1xuICAgICAgICAgICAgYWN0aXZlTWFyay5yYW5nZShzZWxlY3RlZC5mcm9tLCBzZWxlY3RlZC50bylcbiAgICAgICAgXSk7XG4gICAgfSksXG4gICAgLypAX19QVVJFX18qL2hvdmVyVG9vbHRpcChsaW50VG9vbHRpcCwgeyBoaWRlT246IGhpZGVUb29sdGlwIH0pLFxuICAgIGJhc2VUaGVtZVxuXTtcbmNvbnN0IGxpbnRHdXR0ZXJDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgaG92ZXJUaW1lOiAzMDAgLyogSG92ZXIuVGltZSAqLyxcbiAgICAgICAgICAgIG1hcmtlckZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBGaWx0ZXI6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaW5zdGFsbHMgYSBndXR0ZXIgc2hvd2luZyBtYXJrZXJzIGZvclxuZWFjaCBsaW5lIHRoYXQgaGFzIGRpYWdub3N0aWNzLCB3aGljaCBjYW4gYmUgaG92ZXJlZCBvdmVyIHRvIHNlZVxudGhlIGRpYWdub3N0aWNzLlxuKi9cbmZ1bmN0aW9uIGxpbnRHdXR0ZXIoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW2xpbnRHdXR0ZXJDb25maWcub2YoY29uZmlnKSwgbGludEd1dHRlck1hcmtlcnMsIGxpbnRHdXR0ZXJFeHRlbnNpb24sIGxpbnRHdXR0ZXJUaGVtZSwgbGludEd1dHRlclRvb2x0aXBdO1xufVxuLyoqXG5JdGVyYXRlIG92ZXIgdGhlIG1hcmtlZCBkaWFnbm9zdGljcyBmb3IgdGhlIGdpdmVuIGVkaXRvciBzdGF0ZSxcbmNhbGxpbmcgYGZgIGZvciBlYWNoIG9mIHRoZW0uIE5vdGUgdGhhdCwgaWYgdGhlIGRvY3VtZW50IGNoYW5nZWRcbnNpbmNlIHRoZSBkaWFnbm9zdGljcyB3ZXJlIGNyZWF0ZWQsIHRoZSBgRGlhZ25vc3RpY2Agb2JqZWN0IHdpbGxcbmhvbGQgdGhlIG9yaWdpbmFsIG91dGRhdGVkIHBvc2l0aW9uLCB3aGVyZWFzIHRoZSBgdG9gIGFuZCBgZnJvbWBcbmFyZ3VtZW50cyBob2xkIHRoZSBkaWFnbm9zdGljJ3MgY3VycmVudCBwb3NpdGlvbi5cbiovXG5mdW5jdGlvbiBmb3JFYWNoRGlhZ25vc3RpYyhzdGF0ZSwgZikge1xuICAgIGxldCBsU3RhdGUgPSBzdGF0ZS5maWVsZChsaW50U3RhdGUsIGZhbHNlKTtcbiAgICBpZiAobFN0YXRlICYmIGxTdGF0ZS5kaWFnbm9zdGljcy5zaXplKSB7XG4gICAgICAgIGxldCBwZW5kaW5nID0gW10sIHBlbmRpbmdTdGFydCA9IFtdLCBsYXN0RW5kID0gLTE7XG4gICAgICAgIGZvciAobGV0IGl0ZXIgPSBSYW5nZVNldC5pdGVyKFtsU3RhdGUuZGlhZ25vc3RpY3NdKTs7IGl0ZXIubmV4dCgpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmcubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVyLnZhbHVlIHx8IGl0ZXIudmFsdWUuc3BlYy5kaWFnbm9zdGljcy5pbmRleE9mKHBlbmRpbmdbaV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBmKHBlbmRpbmdbaV0sIHBlbmRpbmdTdGFydFtpXSwgbGFzdEVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nU3RhcnQuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpdGVyLnZhbHVlKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBpdGVyLnZhbHVlLnNwZWMuZGlhZ25vc3RpY3MpXG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmcuaW5kZXhPZihkKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZy5wdXNoKGQpO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nU3RhcnQucHVzaChpdGVyLmZyb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RFbmQgPSBpdGVyLnRvO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBjbG9zZUxpbnRQYW5lbCwgZGlhZ25vc3RpY0NvdW50LCBmb3JFYWNoRGlhZ25vc3RpYywgZm9yY2VMaW50aW5nLCBsaW50R3V0dGVyLCBsaW50S2V5bWFwLCBsaW50ZXIsIG5leHREaWFnbm9zdGljLCBvcGVuTGludFBhbmVsLCBwcmV2aW91c0RpYWdub3N0aWMsIHNldERpYWdub3N0aWNzLCBzZXREaWFnbm9zdGljc0VmZmVjdCB9O1xuIl0sIm5hbWVzIjpbIkRlY29yYXRpb24iLCJzaG93UGFuZWwiLCJFZGl0b3JWaWV3IiwiVmlld1BsdWdpbiIsImd1dHRlciIsInNob3dUb29sdGlwIiwiaG92ZXJUb29sdGlwIiwiZ2V0UGFuZWwiLCJsb2dFeGNlcHRpb24iLCJXaWRnZXRUeXBlIiwiR3V0dGVyTWFya2VyIiwiU3RhdGVFZmZlY3QiLCJTdGF0ZUZpZWxkIiwiRmFjZXQiLCJjb21iaW5lQ29uZmlnIiwiUmFuZ2VTZXQiLCJSYW5nZVNldEJ1aWxkZXIiLCJlbHQiLCJTZWxlY3RlZERpYWdub3N0aWMiLCJjb25zdHJ1Y3RvciIsImZyb20iLCJ0byIsImRpYWdub3N0aWMiLCJMaW50U3RhdGUiLCJkaWFnbm9zdGljcyIsInBhbmVsIiwic2VsZWN0ZWQiLCJpbml0Iiwic3RhdGUiLCJtYXJrZWREaWFnbm9zdGljcyIsImRpYWdub3N0aWNGaWx0ZXIiLCJmYWNldCIsImxpbnRDb25maWciLCJtYXJrZXJGaWx0ZXIiLCJzb3J0ZWQiLCJzbGljZSIsInNvcnQiLCJhIiwiYiIsImRlY28iLCJhY3RpdmUiLCJwb3MiLCJpIiwibmV4dCIsImxlbmd0aCIsInJlZHVjZSIsInAiLCJkIiwiTWF0aCIsIm1pbiIsInB1c2giLCJzZXYiLCJtYXhTZXZlcml0eSIsInNvbWUiLCJkb2MiLCJsaW5lQXQiLCJhZGQiLCJ3aWRnZXQiLCJEaWFnbm9zdGljV2lkZ2V0IiwibWFya0NsYXNzIiwiYyIsIm1hcmsiLCJjbGFzcyIsImluY2x1c2l2ZUVuZCIsInNwbGljZSIsInNldCIsImZpbmlzaCIsImZpbmREaWFnbm9zdGljIiwiYWZ0ZXIiLCJmb3VuZCIsImJldHdlZW4iLCJzcGVjIiwiaW5kZXhPZiIsImhpZGVUb29sdGlwIiwidHIiLCJ0b29sdGlwIiwiZW5kIiwicmVzdWx0IiwiaGlkZU9uIiwibGluZSIsInN0YXJ0U3RhdGUiLCJlZmZlY3RzIiwiZSIsImlzIiwic2V0RGlhZ25vc3RpY3NFZmZlY3QiLCJjaGFuZ2VzIiwidG91Y2hlc1JhbmdlIiwibWF4IiwibWF5YmVFbmFibGVMaW50IiwiZmllbGQiLCJsaW50U3RhdGUiLCJjb25jYXQiLCJhcHBlbmRDb25maWciLCJvZiIsImxpbnRFeHRlbnNpb25zIiwic2V0RGlhZ25vc3RpY3MiLCJkZWZpbmUiLCJ0b2dnbGVQYW5lbCIsIm1vdmVQYW5lbFNlbGVjdGlvbiIsImNyZWF0ZSIsIm5vbmUiLCJ1cGRhdGUiLCJ2YWx1ZSIsImRvY0NoYW5nZWQiLCJzaXplIiwibWFwcGVkIiwibWFwIiwic2VsUG9zIiwibWFwUG9zIiwiYXV0b1BhbmVsIiwiZWZmZWN0IiwiTGludFBhbmVsIiwib3BlbiIsInByb3ZpZGUiLCJmIiwidmFsIiwiZGVjb3JhdGlvbnMiLCJzIiwiZGlhZ25vc3RpY0NvdW50IiwibGludCIsImFjdGl2ZU1hcmsiLCJsaW50VG9vbHRpcCIsInZpZXciLCJzaWRlIiwic3RhcnQiLCJ0b29sdGlwRmlsdGVyIiwiYWJvdmUiLCJkb20iLCJkaWFnbm9zdGljc1Rvb2x0aXAiLCJyZW5kZXJEaWFnbm9zdGljIiwib3BlbkxpbnRQYW5lbCIsImRpc3BhdGNoIiwicXVlcnlTZWxlY3RvciIsImZvY3VzIiwiY2xvc2VMaW50UGFuZWwiLCJuZXh0RGlhZ25vc3RpYyIsInNlbCIsInNlbGVjdGlvbiIsIm1haW4iLCJpdGVyIiwiYW5jaG9yIiwiaGVhZCIsInNjcm9sbEludG9WaWV3IiwicHJldmlvdXNEaWFnbm9zdGljIiwicHJldkZyb20iLCJwcmV2VG8iLCJsYXN0RnJvbSIsImxhc3RUbyIsImxpbnRLZXltYXAiLCJrZXkiLCJydW4iLCJwcmV2ZW50RGVmYXVsdCIsImxpbnRQbHVnaW4iLCJmcm9tQ2xhc3MiLCJ0aW1lb3V0IiwiZGVsYXkiLCJsaW50VGltZSIsIkRhdGUiLCJub3ciLCJiaW5kIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInNvdXJjZXMiLCJiYXRjaFJlc3VsdHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsImFubm90YXRpb25zIiwiZXJyb3IiLCJjb25maWciLCJuZWVkc1JlZnJlc2giLCJmb3JjZSIsImRlc3Ryb3kiLCJwcm9taXNlcyIsInNpbmsiLCJjb2xsZWN0ZWQiLCJ0aGVuIiwiY29tYmluZSIsImlucHV0IiwiT2JqZWN0IiwiYXNzaWduIiwic291cmNlIiwiZmlsdGVyIiwieCIsInUiLCJsaW50ZXIiLCJmb3JjZUxpbnRpbmciLCJwbHVnaW4iLCJhc3NpZ25LZXlzIiwiYWN0aW9ucyIsImFzc2lnbmVkIiwibmFtZSIsImNoIiwidGVzdCIsInRvTG93ZXJDYXNlIiwiaW5QYW5lbCIsIl9hIiwia2V5cyIsInNldmVyaXR5IiwicmVuZGVyTWVzc2FnZSIsIm1lc3NhZ2UiLCJhY3Rpb24iLCJmaXJlZCIsImNsaWNrIiwiYXBwbHkiLCJrZXlJbmRleCIsIm5hbWVFbHQiLCJ0eXBlIiwib25jbGljayIsIm9ubW91c2Vkb3duIiwiZXEiLCJvdGhlciIsInRvRE9NIiwiUGFuZWxJdGVtIiwiaWQiLCJmbG9vciIsInJhbmRvbSIsInRvU3RyaW5nIiwic2V0QXR0cmlidXRlIiwiaXRlbXMiLCJvbmtleWRvd24iLCJldmVudCIsImtleUNvZGUiLCJtb3ZlU2VsZWN0aW9uIiwic2VsZWN0ZWRJbmRleCIsInRvVXBwZXJDYXNlIiwiY2hhckNvZGVBdCIsImNvbnRhaW5zIiwidGFyZ2V0IiwibGlzdCIsInRhYkluZGV4Iiwicm9sZSIsInBocmFzZSIsIm5lZWRzU3luYyIsIm5ld1NlbGVjdGVkSXRlbSIsInNlZW4iLCJTZXQiLCJfc3RhcnQiLCJfZW5kIiwiaGFzIiwiaXRlbSIsImoiLCJoYXNBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJwb3AiLCJyZXF1ZXN0TWVhc3VyZSIsInJlYWQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3cml0ZSIsInNjYWxlWSIsImhlaWdodCIsIm9mZnNldEhlaWdodCIsInRvcCIsInNjcm9sbFRvcCIsImJvdHRvbSIsInN5bmMiLCJkb21Qb3MiLCJmaXJzdENoaWxkIiwicm0iLCJwcmV2IiwibmV4dFNpYmxpbmciLCJyZW1vdmUiLCJwYXJlbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwic3ZnIiwiY29udGVudCIsImF0dHJzIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidW5kZXJsaW5lIiwiY29sb3IiLCJiYXNlVGhlbWUiLCJwYWRkaW5nIiwibWFyZ2luTGVmdCIsImRpc3BsYXkiLCJ3aGl0ZVNwYWNlIiwiYm9yZGVyTGVmdCIsImZvbnQiLCJib3JkZXIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJSYWRpdXMiLCJjdXJzb3IiLCJmb250U2l6ZSIsIm9wYWNpdHkiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0IiwicGFkZGluZ0JvdHRvbSIsImJhY2tncm91bmRJbWFnZSIsIm1hcmdpbiIsInBvc2l0aW9uIiwibGVmdCIsImJvcmRlclJpZ2h0IiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyQm90dG9tQ29sb3IiLCJtYXhIZWlnaHQiLCJvdmVyZmxvd1kiLCJ0ZXh0RGVjb3JhdGlvbiIsImJhY2tncm91bmRfZmFsbGJhY2siLCJjb2xvcl9mYWxsYmFjayIsInJpZ2h0IiwiYmFja2dyb3VuZCIsInNldmVyaXR5V2VpZ2h0Iiwid2VpZ2h0IiwidyIsIkxpbnRHdXR0ZXJNYXJrZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJkaWFnbm9zdGljc0ZpbHRlciIsImxpbnRHdXR0ZXJDb25maWciLCJvbm1vdXNlb3ZlciIsImd1dHRlck1hcmtlck1vdXNlT3ZlciIsInRyYWNrSG92ZXJPbiIsIm1hcmtlciIsIm1vdXNlbW92ZSIsInJlY3QiLCJjbGllbnRYIiwiY2xpZW50WSIsIm5vZGVUeXBlIiwiY2xhc3NMaXN0Iiwid2luZG93IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxpbnRHdXR0ZXJUb29sdGlwIiwic2V0TGludEd1dHRlclRvb2x0aXAiLCJhZGRFdmVudExpc3RlbmVyIiwiaG92ZXJlZCIsImVsZW1lbnRBdEhlaWdodCIsImRvY3VtZW50VG9wIiwibGluZVBvcyIsImNvb3Jkc0F0UG9zIiwiY2xpcCIsImdldENvb3JkcyIsIm9ubW91c2VvdXQiLCJvbm1vdXNlbW92ZSIsImhvdmVyVGltZSIsImhvdmVyVGltZW91dCIsIm1hcmtlcnNGb3JEaWFnbm9zdGljcyIsImJ5TGluZSIsIm1hcmtlcnMiLCJyYW5nZSIsImxpbnRHdXR0ZXJFeHRlbnNpb24iLCJsaW50R3V0dGVyTWFya2VycyIsIndpZGdldE1hcmtlciIsImJsb2NrIiwiZW1wdHkiLCJ0IiwibGludEd1dHRlclRoZW1lIiwid2lkdGgiLCJjb21wdXRlIiwiY29uZmlncyIsImxpbnRHdXR0ZXIiLCJmb3JFYWNoRGlhZ25vc3RpYyIsImxTdGF0ZSIsInBlbmRpbmciLCJwZW5kaW5nU3RhcnQiLCJsYXN0RW5kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/lint/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/search/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@codemirror/search/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RegExpCursor: () => (/* binding */ RegExpCursor),\n/* harmony export */   SearchCursor: () => (/* binding */ SearchCursor),\n/* harmony export */   SearchQuery: () => (/* binding */ SearchQuery),\n/* harmony export */   closeSearchPanel: () => (/* binding */ closeSearchPanel),\n/* harmony export */   findNext: () => (/* binding */ findNext),\n/* harmony export */   findPrevious: () => (/* binding */ findPrevious),\n/* harmony export */   getSearchQuery: () => (/* binding */ getSearchQuery),\n/* harmony export */   gotoLine: () => (/* binding */ gotoLine),\n/* harmony export */   highlightSelectionMatches: () => (/* binding */ highlightSelectionMatches),\n/* harmony export */   openSearchPanel: () => (/* binding */ openSearchPanel),\n/* harmony export */   replaceAll: () => (/* binding */ replaceAll),\n/* harmony export */   replaceNext: () => (/* binding */ replaceNext),\n/* harmony export */   search: () => (/* binding */ search),\n/* harmony export */   searchKeymap: () => (/* binding */ searchKeymap),\n/* harmony export */   searchPanelOpen: () => (/* binding */ searchPanelOpen),\n/* harmony export */   selectMatches: () => (/* binding */ selectMatches),\n/* harmony export */   selectNextOccurrence: () => (/* binding */ selectNextOccurrence),\n/* harmony export */   selectSelectionMatches: () => (/* binding */ selectSelectionMatches),\n/* harmony export */   setSearchQuery: () => (/* binding */ setSearchQuery)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crelt */ \"(ssr)/./node_modules/crelt/index.js\");\n\n\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\" ? (x)=>x.normalize(\"NFKD\") : (x)=>x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/ class SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */ constructor(text, query, from = 0, to = text.length, normalize, test){\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */ this.value = {\n            from: 0,\n            to: 0\n        };\n        /**\n        Whether the end of the iterated region has been reached.\n        */ this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? (x)=>normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done) return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */ next() {\n        while(this.matches.length)this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */ nextOverlapping() {\n        for(;;){\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);\n            let norm = this.normalize(str);\n            if (norm.length) for(let i = 0, pos = start;; i++){\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos, this.bufferPos + this.bufferStart);\n                if (i == norm.length - 1) {\n                    if (match) {\n                        this.value = match;\n                        return this;\n                    }\n                    break;\n                }\n                if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;\n            }\n        }\n    }\n    match(code, pos, end) {\n        let match = null;\n        for(let i = 0; i < this.matches.length; i += 2){\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = {\n                        from: this.matches[i + 1],\n                        to: end\n                    };\n                } else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1) match = {\n                from: pos,\n                to: end\n            };\n            else this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart)) match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\") SearchCursor.prototype[Symbol.iterator] = function() {\n    return this;\n};\nconst empty = {\n    from: -1,\n    to: -1,\n    match: /*@__PURE__*/ /.*/.exec(\"\")\n};\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/ class RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */ constructor(text, query, options, from = 0, to = text.length){\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */ this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */ this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        } else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to) this.curLine = \"\";\n        else this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */ next() {\n        for(let off = this.matchPos - this.curLineStart;;){\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length) this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = {\n                        from,\n                        to,\n                        match\n                    };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            } else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            } else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/ new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text){\n        this.from = from;\n        this.text = text;\n    }\n    get to() {\n        return this.from + this.text.length;\n    }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to) return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to) text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to){\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */ ));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for(;;){\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {\n                    this.value = {\n                        from,\n                        to,\n                        match\n                    };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {\n        return this;\n    };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length) return pos;\n    let line = text.lineAt(pos), next;\n    while(pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)pos++;\n    return pos;\n}\nfunction createLineDialog(view) {\n    let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);\n    let input = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n        class: \"cm-textfield\",\n        name: \"line\",\n        value: line\n    });\n    let dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event)=>{\n            if (event.keyCode == 27) {\n                event.preventDefault();\n                view.dispatch({\n                    effects: dialogEffect.of(false)\n                });\n                view.focus();\n            } else if (event.keyCode == 13) {\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event)=>{\n            event.preventDefault();\n            go();\n        }\n    }, (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n        class: \"cm-button\",\n        type: \"submit\"\n    }, view.state.phrase(\"go\")), (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n        name: \"close\",\n        onclick: ()=>{\n            view.dispatch({\n                effects: dialogEffect.of(false)\n            });\n            view.focus();\n        },\n        \"aria-label\": view.state.phrase(\"close\"),\n        type: \"button\"\n    }, [\n        \"\\xd7\"\n    ]));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match) return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign) pc = pc * (sign == \"-\" ? -1 : 1) + startLine.number / state.doc.lines;\n            line = Math.round(state.doc.lines * pc);\n        } else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n        view.dispatch({\n            effects: [\n                dialogEffect.of(false),\n                _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(selection.from, {\n                    y: \"center\"\n                })\n            ],\n            selection\n        });\n        view.focus();\n    }\n    return {\n        dom\n    };\n}\nconst dialogEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst dialogField = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create () {\n        return true;\n    },\n    update (value, tr) {\n        for (let e of tr.effects)if (e.is(dialogEffect)) value = e.value;\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, (val)=>val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/ const gotoLine = (view)=>{\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\n    if (!panel) {\n        let effects = [\n            dialogEffect.of(true)\n        ];\n        if (view.state.field(dialogField, false) == null) effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([\n            dialogField,\n            baseTheme$1\n        ]));\n        view.dispatch({\n            effects\n        });\n        panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createLineDialog);\n    }\n    if (panel) panel.dom.querySelector(\"input\").select();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& label\": {\n            fontSize: \"80%\"\n        },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            bottom: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: \"0\"\n        }\n    }\n});\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (options) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b)=>a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/ function highlightSelectionMatches(options) {\n    let ext = [\n        defaultTheme,\n        matchHighlighter\n    ];\n    if (options) ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-selectionMatch\"\n});\nconst mainMatchDeco = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-selectionMatch cm-selectionMatch-main\"\n});\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word && check(state.sliceDoc(to - 1, to)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged) this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        } else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to))) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            } else {\n                query = state.sliceDoc(range.from, range.to);\n                if (!query) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges){\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while(!cursor.next().done){\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n                }\n            }\n        }\n        return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.set(deco);\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nconst defaultTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-selectionMatch\": {\n        backgroundColor: \"#99ff7780\"\n    },\n    \".cm-searchMatch .cm-selectionMatch\": {\n        backgroundColor: \"transparent\"\n    }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch })=>{\n    let { selection } = state;\n    let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(selection.ranges.map((range)=>state.wordAt(range.head) || _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection)) return false;\n    dispatch(state.update({\n        selection: newSel\n    }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for(let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;){\n        cursor.next();\n        if (cursor.done) {\n            if (cycled) return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        } else {\n            if (cycled && ranges.some((r)=>r.from == cursor.value.from)) continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to) continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/ const selectNextOccurrence = ({ state, dispatch })=>{\n    let { ranges } = state.selection;\n    if (ranges.some((sel)=>sel.from === sel.to)) return selectWord({\n        state,\n        dispatch\n    });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some((r)=>state.sliceDoc(r.from, r.to) != searchedText)) return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range) return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.from, range.to), false),\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\nconst searchConfigFacet = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            regexp: false,\n            wholeWord: false,\n            createPanel: (view)=>new SearchPanel(view),\n            scrollToMatch: (range)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/ function search(config) {\n    return config ? [\n        searchConfigFacet.of(config),\n        searchExtensions\n    ] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/ class SearchQuery {\n    /**\n    Create a query object.\n    */ constructor(config){\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n    }\n    /**\n    @internal\n    */ unquote(text) {\n        return this.literal ? text : text.replace(/\\\\([nrt\\\\])/g, (_, ch)=>ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */ eq(other) {\n        return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;\n    }\n    /**\n    @internal\n    */ create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */ getCursor(state, from = 0, to) {\n        let st = state.doc ? state : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.create({\n            doc: state\n        });\n        if (to == null) to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec){\n        this.spec = spec;\n    }\n}\nfunction stringCursor(spec, state, from, to) {\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : (x)=>x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos)=>{\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec){\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done) {\n            let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);\n            cursor = stringCursor(this.spec, state, 0, end).nextOverlapping();\n        }\n        return cursor.done || cursor.value.from == curFrom && cursor.value.to == curTo ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for(let pos = to;;){\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */  - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while(!cursor.nextOverlapping().done)range = cursor.value;\n            if (range) return range;\n            if (start == from) return null;\n            pos -= 10000 /* FindPrev.ChunkSize */ ;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        let found = this.prevMatchInRange(state, 0, curFrom);\n        if (!found) found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);\n        return found && (found.from != curFrom || found.to != curTo) ? found : null;\n    }\n    getReplacement(_result) {\n        return this.spec.unquote(this.spec.replace);\n    }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while(!cursor.next().done){\n            if (ranges.length >= limit) return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while(!cursor.next().done)add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction regexpCursor(spec, state, from, to) {\n    return new RegExpCursor(state.doc, spec.search, {\n        ignoreCase: !spec.caseSensitive,\n        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n    }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match)=>!match[0].length || (categorizer(charBefore(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charAfter(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done) cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for(let size = 1;; size++){\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */ );\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while(!cursor.next().done)range = cursor.value;\n            if (range && (start == from || range.from > start + 10)) return range;\n            if (start == from) return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace).replace(/\\$([$&]|\\d+)/g, (m, i)=>{\n            if (i == \"&\") return result.match[0];\n            if (i == \"$\") return \"$\";\n            for(let l = i.length; l > 0; l--){\n                let n = +i.slice(0, l);\n                if (n > 0 && n < result.match.length) return result.match[n] + i.slice(l);\n            }\n            return m;\n        });\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while(!cursor.next().done){\n            if (ranges.length >= limit) return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */ ), Math.min(to + 250 /* RegExp.HighlightMargin */ , state.doc.length));\n        while(!cursor.next().done)add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/ const setSearchQuery = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst togglePanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();\nconst searchState = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({\n    create (state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update (value, tr) {\n        for (let effect of tr.effects){\n            if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: (f)=>_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.showPanel.from(f, (val)=>val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/ function getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/ function searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel){\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-searchMatch\"\n}), selectedMatchMark = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.mark({\n    class: \"cm-searchMatch cm-searchMatch-selected\"\n});\nconst searchHighlighter = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged) this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid) return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.none;\n        let { view } = this;\n        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder();\n        for(let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++){\n            let { from, to } = ranges[i];\n            while(i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */ )to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to)=>{\n                let selected = view.state.selection.ranges.some((r)=>r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nfunction searchCommand(f) {\n    return (view)=>{\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/ const findNext = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next) return false;\n    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [\n            announceMatch(view, next),\n            config.scrollToMatch(selection.main, view)\n        ],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/ const findPrevious = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev) return false;\n    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [\n            announceMatch(view, prev),\n            config.scrollToMatch(selection.main, view)\n        ],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/ const selectMatches = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length) return false;\n    view.dispatch({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.map((r)=>_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/ const selectSelectionMatches = ({ state, dispatch })=>{\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty) return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for(let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;){\n        if (ranges.length > 1000) return false;\n        if (cur.value.from == from) main = ranges.length;\n        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/ const replaceNext = /*@__PURE__*/ searchCommand((view, { query })=>{\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly) return false;\n    let match = query.nextMatch(state, from, from);\n    if (!match) return false;\n    let next = match;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({\n            from: next.from,\n            to: next.to,\n            insert: replacement\n        });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= match.to ? 0 : match.to - match.from - replacement.length;\n        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from - off, next.to - off);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n    }\n    view.dispatch({\n        changes,\n        selection,\n        effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/ const replaceAll = /*@__PURE__*/ searchCommand((view, { query })=>{\n    if (view.state.readOnly) return false;\n    let changes = query.matchAll(view.state, 1e9).map((match)=>{\n        let { from, to } = match;\n        return {\n            from,\n            to,\n            insert: query.getReplacement(match)\n        };\n    });\n    if (!changes.length) return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d, _e;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText) return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n    });\n}\nfunction getSearchInput(view) {\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    return panel && panel.dom.querySelector(\"[main-field]\");\n}\nfunction selectSearchInput(view) {\n    let input = getSearchInput(view);\n    if (input && input == view.root.activeElement) input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/ const openSearchPanel = (view)=>{\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let searchInput = getSearchInput(view);\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid) view.dispatch({\n                effects: setSearchQuery.of(query)\n            });\n            searchInput.focus();\n            searchInput.select();\n        }\n    } else {\n        view.dispatch({\n            effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of(searchExtensions)\n            ]\n        });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/ const closeSearchPanel = (view)=>{\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel) return false;\n    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.getPanel)(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement)) view.focus();\n    view.dispatch({\n        effects: togglePanel.of(false)\n    });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/ const searchKeymap = [\n    {\n        key: \"Mod-f\",\n        run: openSearchPanel,\n        scope: \"editor search-panel\"\n    },\n    {\n        key: \"F3\",\n        run: findNext,\n        shift: findPrevious,\n        scope: \"editor search-panel\",\n        preventDefault: true\n    },\n    {\n        key: \"Mod-g\",\n        run: findNext,\n        shift: findPrevious,\n        scope: \"editor search-panel\",\n        preventDefault: true\n    },\n    {\n        key: \"Escape\",\n        run: closeSearchPanel,\n        scope: \"editor search-panel\"\n    },\n    {\n        key: \"Mod-Shift-l\",\n        run: selectSelectionMatches\n    },\n    {\n        key: \"Mod-Alt-g\",\n        run: gotoLine\n    },\n    {\n        key: \"Mod-d\",\n        run: selectNextOccurrence,\n        preventDefault: true\n    }\n];\nclass SearchPanel {\n    constructor(view){\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n                class: \"cm-button\",\n                name,\n                onclick,\n                type: \"button\"\n            }, content);\n        }\n        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"div\", {\n            onkeydown: (e)=>this.keydown(e),\n            class: \"cm-search\"\n        }, [\n            this.searchField,\n            button(\"next\", ()=>findNext(view), [\n                phrase(view, \"next\")\n            ]),\n            button(\"prev\", ()=>findPrevious(view), [\n                phrase(view, \"previous\")\n            ]),\n            button(\"select\", ()=>selectMatches(view), [\n                phrase(view, \"all\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.caseField,\n                phrase(view, \"match case\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.reField,\n                phrase(view, \"regexp\")\n            ]),\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"label\", null, [\n                this.wordField,\n                phrase(view, \"by word\")\n            ]),\n            ...view.state.readOnly ? [] : [\n                (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"br\"),\n                this.replaceField,\n                button(\"replace\", ()=>replaceNext(view), [\n                    phrase(view, \"replace\")\n                ]),\n                button(\"replaceAll\", ()=>replaceAll(view), [\n                    phrase(view, \"replace all\")\n                ])\n            ],\n            (0,crelt__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"button\", {\n                name: \"close\",\n                onclick: ()=>closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\n                \"\\xd7\"\n            ])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({\n                effects: setSearchQuery.of(query)\n            });\n        }\n    }\n    keydown(e) {\n        if ((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_2__.runScopeHandlers)(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        } else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        } else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)for (let effect of tr.effects){\n            if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value);\n        }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() {\n        return 80;\n    }\n    get top() {\n        return this.view.state.facet(searchConfigFacet).top;\n    }\n}\nfunction phrase(view, phrase) {\n    return view.state.phrase(phrase);\n}\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for(let i = 0; i < AnnounceMargin; i++)if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n            text = text.slice(i);\n            break;\n        }\n    }\n    if (end != lineEnd) {\n        for(let i = text.length - 1; i > text.length - AnnounceMargin; i--)if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n            text = text.slice(0, i);\n            break;\n        }\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_2__.EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": {\n        backgroundColor: \"#ffff0054\"\n    },\n    \"&dark .cm-searchMatch\": {\n        backgroundColor: \"#00ffff8a\"\n    },\n    \"&light .cm-searchMatch-selected\": {\n        backgroundColor: \"#ff6a0054\"\n    },\n    \"&dark .cm-searchMatch-selected\": {\n        backgroundColor: \"#ff00ff8a\"\n    }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.low(searchHighlighter),\n    baseTheme\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc2VhcmNoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2RztBQUNxRztBQUMxTDtBQUV4QixNQUFNb0IsaUJBQWlCLE9BQU9DLE9BQU9DLFNBQVMsQ0FBQ0MsU0FBUyxJQUFJLGFBQ3REQyxDQUFBQSxJQUFLQSxFQUFFRCxTQUFTLENBQUMsVUFBVUMsQ0FBQUEsSUFBS0E7QUFDdEM7OztBQUdBLEdBQ0EsTUFBTUM7SUFDRjs7Ozs7Ozs7Ozs7O0lBWUEsR0FDQUMsWUFBWUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLE9BQU8sQ0FBQyxFQUFFQyxLQUFLSCxLQUFLSSxNQUFNLEVBQUVSLFNBQVMsRUFBRVMsSUFBSSxDQUFFO1FBQ2xFLElBQUksQ0FBQ0EsSUFBSSxHQUFHQTtRQUNaOzs7O1FBSUEsR0FDQSxJQUFJLENBQUNDLEtBQUssR0FBRztZQUFFSixNQUFNO1lBQUdDLElBQUk7UUFBRTtRQUM5Qjs7UUFFQSxHQUNBLElBQUksQ0FBQ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtRQUNqQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsSUFBSSxHQUFHWCxLQUFLWSxTQUFTLENBQUNWLE1BQU1DO1FBQ2pDLElBQUksQ0FBQ1UsV0FBVyxHQUFHWDtRQUNuQixJQUFJLENBQUNOLFNBQVMsR0FBR0EsWUFBWUMsQ0FBQUEsSUFBS0QsVUFBVUgsZUFBZUksTUFBTUo7UUFDakUsSUFBSSxDQUFDUSxLQUFLLEdBQUcsSUFBSSxDQUFDTCxTQUFTLENBQUNLO0lBQ2hDO0lBQ0FhLE9BQU87UUFDSCxJQUFJLElBQUksQ0FBQ0osU0FBUyxJQUFJLElBQUksQ0FBQ0QsTUFBTSxDQUFDTCxNQUFNLEVBQUU7WUFDdEMsSUFBSSxDQUFDUyxXQUFXLElBQUksSUFBSSxDQUFDSixNQUFNLENBQUNMLE1BQU07WUFDdEMsSUFBSSxDQUFDTyxJQUFJLENBQUNJLElBQUk7WUFDZCxJQUFJLElBQUksQ0FBQ0osSUFBSSxDQUFDSixJQUFJLEVBQ2QsT0FBTyxDQUFDO1lBQ1osSUFBSSxDQUFDRyxTQUFTLEdBQUc7WUFDakIsSUFBSSxDQUFDRCxNQUFNLEdBQUcsSUFBSSxDQUFDRSxJQUFJLENBQUNMLEtBQUs7UUFDakM7UUFDQSxPQUFPM0IsOERBQVdBLENBQUMsSUFBSSxDQUFDOEIsTUFBTSxFQUFFLElBQUksQ0FBQ0MsU0FBUztJQUNsRDtJQUNBOzs7OztJQUtBLEdBQ0FLLE9BQU87UUFDSCxNQUFPLElBQUksQ0FBQ1AsT0FBTyxDQUFDSixNQUFNLENBQ3RCLElBQUksQ0FBQ0ksT0FBTyxDQUFDUSxHQUFHO1FBQ3BCLE9BQU8sSUFBSSxDQUFDQyxlQUFlO0lBQy9CO0lBQ0E7Ozs7SUFJQSxHQUNBQSxrQkFBa0I7UUFDZCxPQUFTO1lBQ0wsSUFBSUYsT0FBTyxJQUFJLENBQUNELElBQUk7WUFDcEIsSUFBSUMsT0FBTyxHQUFHO2dCQUNWLElBQUksQ0FBQ1IsSUFBSSxHQUFHO2dCQUNaLE9BQU8sSUFBSTtZQUNmO1lBQ0EsSUFBSVcsTUFBTXRDLGdFQUFhQSxDQUFDbUMsT0FBT0ksUUFBUSxJQUFJLENBQUNOLFdBQVcsR0FBRyxJQUFJLENBQUNILFNBQVM7WUFDeEUsSUFBSSxDQUFDQSxTQUFTLElBQUk3QixnRUFBYUEsQ0FBQ2tDO1lBQ2hDLElBQUlLLE9BQU8sSUFBSSxDQUFDeEIsU0FBUyxDQUFDc0I7WUFDMUIsSUFBSUUsS0FBS2hCLE1BQU0sRUFDWCxJQUFLLElBQUlpQixJQUFJLEdBQUdDLE1BQU1ILFFBQVFFLElBQUs7Z0JBQy9CLElBQUlFLE9BQU9ILEtBQUtJLFVBQVUsQ0FBQ0g7Z0JBQzNCLElBQUlJLFFBQVEsSUFBSSxDQUFDQSxLQUFLLENBQUNGLE1BQU1ELEtBQUssSUFBSSxDQUFDWixTQUFTLEdBQUcsSUFBSSxDQUFDRyxXQUFXO2dCQUNuRSxJQUFJUSxLQUFLRCxLQUFLaEIsTUFBTSxHQUFHLEdBQUc7b0JBQ3RCLElBQUlxQixPQUFPO3dCQUNQLElBQUksQ0FBQ25CLEtBQUssR0FBR21CO3dCQUNiLE9BQU8sSUFBSTtvQkFDZjtvQkFDQTtnQkFDSjtnQkFDQSxJQUFJSCxPQUFPSCxTQUFTRSxJQUFJSCxJQUFJZCxNQUFNLElBQUljLElBQUlNLFVBQVUsQ0FBQ0gsTUFBTUUsTUFDdkREO1lBQ1I7UUFDUjtJQUNKO0lBQ0FHLE1BQU1GLElBQUksRUFBRUQsR0FBRyxFQUFFSSxHQUFHLEVBQUU7UUFDbEIsSUFBSUQsUUFBUTtRQUNaLElBQUssSUFBSUosSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2IsT0FBTyxDQUFDSixNQUFNLEVBQUVpQixLQUFLLEVBQUc7WUFDN0MsSUFBSU0sUUFBUSxJQUFJLENBQUNuQixPQUFPLENBQUNhLEVBQUUsRUFBRU8sT0FBTztZQUNwQyxJQUFJLElBQUksQ0FBQzNCLEtBQUssQ0FBQ3VCLFVBQVUsQ0FBQ0csVUFBVUosTUFBTTtnQkFDdEMsSUFBSUksU0FBUyxJQUFJLENBQUMxQixLQUFLLENBQUNHLE1BQU0sR0FBRyxHQUFHO29CQUNoQ3FCLFFBQVE7d0JBQUV2QixNQUFNLElBQUksQ0FBQ00sT0FBTyxDQUFDYSxJQUFJLEVBQUU7d0JBQUVsQixJQUFJdUI7b0JBQUk7Z0JBQ2pELE9BQ0s7b0JBQ0QsSUFBSSxDQUFDbEIsT0FBTyxDQUFDYSxFQUFFO29CQUNmTyxPQUFPO2dCQUNYO1lBQ0o7WUFDQSxJQUFJLENBQUNBLE1BQU07Z0JBQ1AsSUFBSSxDQUFDcEIsT0FBTyxDQUFDcUIsTUFBTSxDQUFDUixHQUFHO2dCQUN2QkEsS0FBSztZQUNUO1FBQ0o7UUFDQSxJQUFJLElBQUksQ0FBQ3BCLEtBQUssQ0FBQ3VCLFVBQVUsQ0FBQyxNQUFNRCxNQUFNO1lBQ2xDLElBQUksSUFBSSxDQUFDdEIsS0FBSyxDQUFDRyxNQUFNLElBQUksR0FDckJxQixRQUFRO2dCQUFFdkIsTUFBTW9CO2dCQUFLbkIsSUFBSXVCO1lBQUk7aUJBRTdCLElBQUksQ0FBQ2xCLE9BQU8sQ0FBQ3NCLElBQUksQ0FBQyxHQUFHUjtRQUM3QjtRQUNBLElBQUlHLFNBQVMsSUFBSSxDQUFDcEIsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDQSxJQUFJLENBQUNvQixNQUFNdkIsSUFBSSxFQUFFdUIsTUFBTXRCLEVBQUUsRUFBRSxJQUFJLENBQUNNLE1BQU0sRUFBRSxJQUFJLENBQUNJLFdBQVcsR0FDcEZZLFFBQVE7UUFDWixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxJQUFJLE9BQU9NLFVBQVUsYUFDakJqQyxhQUFhSCxTQUFTLENBQUNvQyxPQUFPQyxRQUFRLENBQUMsR0FBRztJQUFjLE9BQU8sSUFBSTtBQUFFO0FBRXpFLE1BQU1DLFFBQVE7SUFBRS9CLE1BQU0sQ0FBQztJQUFHQyxJQUFJLENBQUM7SUFBR3NCLE9BQU8sV0FBVyxHQUFFLEtBQUtTLElBQUksQ0FBQztBQUFJO0FBQ3BFLE1BQU1DLFlBQVksT0FBUSxLQUFJQyxPQUFPLElBQUksT0FBTyxLQUFLLEdBQUU7QUFDdkQ7Ozs7QUFJQSxHQUNBLE1BQU1DO0lBQ0Y7Ozs7SUFJQSxHQUNBdEMsWUFBWUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVxQyxPQUFPLEVBQUVwQyxPQUFPLENBQUMsRUFBRUMsS0FBS0gsS0FBS0ksTUFBTSxDQUFFO1FBQzFELElBQUksQ0FBQ0osSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0csRUFBRSxHQUFHQTtRQUNWLElBQUksQ0FBQ29DLE9BQU8sR0FBRztRQUNmOzs7UUFHQSxHQUNBLElBQUksQ0FBQ2hDLElBQUksR0FBRztRQUNaOzs7O1FBSUEsR0FDQSxJQUFJLENBQUNELEtBQUssR0FBRzJCO1FBQ2IsSUFBSSx1QkFBdUI1QixJQUFJLENBQUNKLFFBQzVCLE9BQU8sSUFBSXVDLHNCQUFzQnhDLE1BQU1DLE9BQU9xQyxTQUFTcEMsTUFBTUM7UUFDakUsSUFBSSxDQUFDc0MsRUFBRSxHQUFHLElBQUlDLE9BQU96QyxPQUFPa0MsWUFBYSxFQUFDRyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUUssVUFBVSxJQUFJLE1BQU0sRUFBQztRQUN6SCxJQUFJLENBQUN0QyxJQUFJLEdBQUdpQyxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUWpDLElBQUk7UUFDMUUsSUFBSSxDQUFDTSxJQUFJLEdBQUdYLEtBQUtXLElBQUk7UUFDckIsSUFBSWlDLFlBQVk1QyxLQUFLNkMsTUFBTSxDQUFDM0M7UUFDNUIsSUFBSSxDQUFDNEMsWUFBWSxHQUFHRixVQUFVMUMsSUFBSTtRQUNsQyxJQUFJLENBQUM2QyxRQUFRLEdBQUdDLFVBQVVoRCxNQUFNRTtRQUNoQyxJQUFJLENBQUMrQyxPQUFPLENBQUMsSUFBSSxDQUFDSCxZQUFZO0lBQ2xDO0lBQ0FHLFFBQVFDLElBQUksRUFBRTtRQUNWLElBQUksQ0FBQ3ZDLElBQUksQ0FBQ0ksSUFBSSxDQUFDbUM7UUFDZixJQUFJLElBQUksQ0FBQ3ZDLElBQUksQ0FBQ3dDLFNBQVMsRUFBRTtZQUNyQixJQUFJLENBQUNaLE9BQU8sR0FBRztRQUNuQixPQUNLO1lBQ0QsSUFBSSxDQUFDQSxPQUFPLEdBQUcsSUFBSSxDQUFDNUIsSUFBSSxDQUFDTCxLQUFLO1lBQzlCLElBQUksSUFBSSxDQUFDd0MsWUFBWSxHQUFHLElBQUksQ0FBQ1AsT0FBTyxDQUFDbkMsTUFBTSxHQUFHLElBQUksQ0FBQ0QsRUFBRSxFQUNqRCxJQUFJLENBQUNvQyxPQUFPLEdBQUcsSUFBSSxDQUFDQSxPQUFPLENBQUNhLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQ2pELEVBQUUsR0FBRyxJQUFJLENBQUMyQyxZQUFZO1lBQ3BFLElBQUksQ0FBQ25DLElBQUksQ0FBQ0ksSUFBSTtRQUNsQjtJQUNKO0lBQ0FzQyxXQUFXO1FBQ1AsSUFBSSxDQUFDUCxZQUFZLEdBQUcsSUFBSSxDQUFDQSxZQUFZLEdBQUcsSUFBSSxDQUFDUCxPQUFPLENBQUNuQyxNQUFNLEdBQUc7UUFDOUQsSUFBSSxJQUFJLENBQUMwQyxZQUFZLEdBQUcsSUFBSSxDQUFDM0MsRUFBRSxFQUMzQixJQUFJLENBQUNvQyxPQUFPLEdBQUc7YUFFZixJQUFJLENBQUNVLE9BQU8sQ0FBQztJQUNyQjtJQUNBOztJQUVBLEdBQ0FsQyxPQUFPO1FBQ0gsSUFBSyxJQUFJdUMsTUFBTSxJQUFJLENBQUNQLFFBQVEsR0FBRyxJQUFJLENBQUNELFlBQVksR0FBSTtZQUNoRCxJQUFJLENBQUNMLEVBQUUsQ0FBQ2MsU0FBUyxHQUFHRDtZQUNwQixJQUFJN0IsUUFBUSxJQUFJLENBQUNzQixRQUFRLElBQUksSUFBSSxDQUFDNUMsRUFBRSxJQUFJLElBQUksQ0FBQ3NDLEVBQUUsQ0FBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQ0ssT0FBTztZQUNqRSxJQUFJZCxPQUFPO2dCQUNQLElBQUl2QixPQUFPLElBQUksQ0FBQzRDLFlBQVksR0FBR3JCLE1BQU1FLEtBQUssRUFBRXhCLEtBQUtELE9BQU91QixLQUFLLENBQUMsRUFBRSxDQUFDckIsTUFBTTtnQkFDdkUsSUFBSSxDQUFDMkMsUUFBUSxHQUFHQyxVQUFVLElBQUksQ0FBQ2hELElBQUksRUFBRUcsS0FBTUQsQ0FBQUEsUUFBUUMsS0FBSyxJQUFJO2dCQUM1RCxJQUFJRCxRQUFRLElBQUksQ0FBQzRDLFlBQVksR0FBRyxJQUFJLENBQUNQLE9BQU8sQ0FBQ25DLE1BQU0sRUFDL0MsSUFBSSxDQUFDaUQsUUFBUTtnQkFDakIsSUFBSSxDQUFDbkQsT0FBT0MsTUFBTUQsT0FBTyxJQUFJLENBQUNJLEtBQUssQ0FBQ0gsRUFBRSxLQUFNLEVBQUMsSUFBSSxDQUFDRSxJQUFJLElBQUksSUFBSSxDQUFDQSxJQUFJLENBQUNILE1BQU1DLElBQUlzQixNQUFLLEdBQUk7b0JBQ25GLElBQUksQ0FBQ25CLEtBQUssR0FBRzt3QkFBRUo7d0JBQU1DO3dCQUFJc0I7b0JBQU07b0JBQy9CLE9BQU8sSUFBSTtnQkFDZjtnQkFDQTZCLE1BQU0sSUFBSSxDQUFDUCxRQUFRLEdBQUcsSUFBSSxDQUFDRCxZQUFZO1lBQzNDLE9BQ0ssSUFBSSxJQUFJLENBQUNBLFlBQVksR0FBRyxJQUFJLENBQUNQLE9BQU8sQ0FBQ25DLE1BQU0sR0FBRyxJQUFJLENBQUNELEVBQUUsRUFBRTtnQkFDeEQsSUFBSSxDQUFDa0QsUUFBUTtnQkFDYkMsTUFBTTtZQUNWLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDL0MsSUFBSSxHQUFHO2dCQUNaLE9BQU8sSUFBSTtZQUNmO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsTUFBTWlELFlBQVksV0FBVyxHQUFFLElBQUlDO0FBQ25DLGtEQUFrRDtBQUNsRCxNQUFNQztJQUNGM0QsWUFBWUcsSUFBSSxFQUFFRixJQUFJLENBQUU7UUFDcEIsSUFBSSxDQUFDRSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDRixJQUFJLEdBQUdBO0lBQ2hCO0lBQ0EsSUFBSUcsS0FBSztRQUFFLE9BQU8sSUFBSSxDQUFDRCxJQUFJLEdBQUcsSUFBSSxDQUFDRixJQUFJLENBQUNJLE1BQU07SUFBRTtJQUNoRCxPQUFPdUQsSUFBSUMsR0FBRyxFQUFFMUQsSUFBSSxFQUFFQyxFQUFFLEVBQUU7UUFDdEIsSUFBSTBELFNBQVNMLFVBQVVHLEdBQUcsQ0FBQ0M7UUFDM0IsSUFBSSxDQUFDQyxVQUFVQSxPQUFPM0QsSUFBSSxJQUFJQyxNQUFNMEQsT0FBTzFELEVBQUUsSUFBSUQsTUFBTTtZQUNuRCxJQUFJNEQsT0FBTyxJQUFJSixhQUFheEQsTUFBTTBELElBQUlHLFdBQVcsQ0FBQzdELE1BQU1DO1lBQ3hEcUQsVUFBVVEsR0FBRyxDQUFDSixLQUFLRTtZQUNuQixPQUFPQTtRQUNYO1FBQ0EsSUFBSUQsT0FBTzNELElBQUksSUFBSUEsUUFBUTJELE9BQU8xRCxFQUFFLElBQUlBLElBQ3BDLE9BQU8wRDtRQUNYLElBQUksRUFBRTdELElBQUksRUFBRUUsTUFBTStELFVBQVUsRUFBRSxHQUFHSjtRQUNqQyxJQUFJSSxhQUFhL0QsTUFBTTtZQUNuQkYsT0FBTzRELElBQUlHLFdBQVcsQ0FBQzdELE1BQU0rRCxjQUFjakU7WUFDM0NpRSxhQUFhL0Q7UUFDakI7UUFDQSxJQUFJMkQsT0FBTzFELEVBQUUsR0FBR0EsSUFDWkgsUUFBUTRELElBQUlHLFdBQVcsQ0FBQ0YsT0FBTzFELEVBQUUsRUFBRUE7UUFDdkNxRCxVQUFVUSxHQUFHLENBQUNKLEtBQUssSUFBSUYsYUFBYU8sWUFBWWpFO1FBQ2hELE9BQU8sSUFBSTBELGFBQWF4RCxNQUFNRixLQUFLb0QsS0FBSyxDQUFDbEQsT0FBTytELFlBQVk5RCxLQUFLOEQ7SUFDckU7QUFDSjtBQUNBLE1BQU16QjtJQUNGekMsWUFBWUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVxQyxPQUFPLEVBQUVwQyxJQUFJLEVBQUVDLEVBQUUsQ0FBRTtRQUN4QyxJQUFJLENBQUNILElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNHLEVBQUUsR0FBR0E7UUFDVixJQUFJLENBQUNJLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0QsS0FBSyxHQUFHMkI7UUFDYixJQUFJLENBQUNjLFFBQVEsR0FBR0MsVUFBVWhELE1BQU1FO1FBQ2hDLElBQUksQ0FBQ3VDLEVBQUUsR0FBRyxJQUFJQyxPQUFPekMsT0FBT2tDLFlBQWEsRUFBQ0csWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFLLFVBQVUsSUFBSSxNQUFNLEVBQUM7UUFDekgsSUFBSSxDQUFDdEMsSUFBSSxHQUFHaUMsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFqQyxJQUFJO1FBQzFFLElBQUksQ0FBQ3lELElBQUksR0FBR0osYUFBYUMsR0FBRyxDQUFDM0QsTUFBTUUsTUFBTSxJQUFJLENBQUNnRSxRQUFRLENBQUNoRSxPQUFPLEtBQUssY0FBYztJQUNyRjtJQUNBZ0UsU0FBUzVDLEdBQUcsRUFBRTtRQUNWLE9BQU9BLE9BQU8sSUFBSSxDQUFDbkIsRUFBRSxHQUFHLElBQUksQ0FBQ0EsRUFBRSxHQUFHLElBQUksQ0FBQ0gsSUFBSSxDQUFDNkMsTUFBTSxDQUFDdkIsS0FBS25CLEVBQUU7SUFDOUQ7SUFDQVksT0FBTztRQUNILE9BQVM7WUFDTCxJQUFJdUMsTUFBTSxJQUFJLENBQUNiLEVBQUUsQ0FBQ2MsU0FBUyxHQUFHLElBQUksQ0FBQ1IsUUFBUSxHQUFHLElBQUksQ0FBQ2UsSUFBSSxDQUFDNUQsSUFBSTtZQUM1RCxJQUFJdUIsUUFBUSxJQUFJLENBQUNnQixFQUFFLENBQUNQLElBQUksQ0FBQyxJQUFJLENBQUM0QixJQUFJLENBQUM5RCxJQUFJO1lBQ3ZDLG1EQUFtRDtZQUNuRCxJQUFJeUIsU0FBUyxDQUFDQSxLQUFLLENBQUMsRUFBRSxJQUFJQSxNQUFNRSxLQUFLLElBQUkyQixLQUFLO2dCQUMxQyxJQUFJLENBQUNiLEVBQUUsQ0FBQ2MsU0FBUyxHQUFHRCxNQUFNO2dCQUMxQjdCLFFBQVEsSUFBSSxDQUFDZ0IsRUFBRSxDQUFDUCxJQUFJLENBQUMsSUFBSSxDQUFDNEIsSUFBSSxDQUFDOUQsSUFBSTtZQUN2QztZQUNBLElBQUl5QixPQUFPO2dCQUNQLElBQUl2QixPQUFPLElBQUksQ0FBQzRELElBQUksQ0FBQzVELElBQUksR0FBR3VCLE1BQU1FLEtBQUssRUFBRXhCLEtBQUtELE9BQU91QixLQUFLLENBQUMsRUFBRSxDQUFDckIsTUFBTTtnQkFDcEUsZ0VBQWdFO2dCQUNoRSxrREFBa0Q7Z0JBQ2xELElBQUksQ0FBQyxJQUFJLENBQUMwRCxJQUFJLENBQUMzRCxFQUFFLElBQUksSUFBSSxDQUFDQSxFQUFFLElBQUlzQixNQUFNRSxLQUFLLEdBQUdGLEtBQUssQ0FBQyxFQUFFLENBQUNyQixNQUFNLElBQUksSUFBSSxDQUFDMEQsSUFBSSxDQUFDOUQsSUFBSSxDQUFDSSxNQUFNLEdBQUcsRUFBQyxLQUNyRixFQUFDLElBQUksQ0FBQ0MsSUFBSSxJQUFJLElBQUksQ0FBQ0EsSUFBSSxDQUFDSCxNQUFNQyxJQUFJc0IsTUFBSyxHQUFJO29CQUM1QyxJQUFJLENBQUNuQixLQUFLLEdBQUc7d0JBQUVKO3dCQUFNQzt3QkFBSXNCO29CQUFNO29CQUMvQixJQUFJLENBQUNzQixRQUFRLEdBQUdDLFVBQVUsSUFBSSxDQUFDaEQsSUFBSSxFQUFFRyxLQUFNRCxDQUFBQSxRQUFRQyxLQUFLLElBQUk7b0JBQzVELE9BQU8sSUFBSTtnQkFDZjtZQUNKO1lBQ0EsSUFBSSxJQUFJLENBQUMyRCxJQUFJLENBQUMzRCxFQUFFLElBQUksSUFBSSxDQUFDQSxFQUFFLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQ0ksSUFBSSxHQUFHO2dCQUNaLE9BQU8sSUFBSTtZQUNmO1lBQ0EseUJBQXlCO1lBQ3pCLElBQUksQ0FBQ3VELElBQUksR0FBR0osYUFBYUMsR0FBRyxDQUFDLElBQUksQ0FBQzNELElBQUksRUFBRSxJQUFJLENBQUM4RCxJQUFJLENBQUM1RCxJQUFJLEVBQUUsSUFBSSxDQUFDZ0UsUUFBUSxDQUFDLElBQUksQ0FBQ0osSUFBSSxDQUFDNUQsSUFBSSxHQUFHLElBQUksQ0FBQzRELElBQUksQ0FBQzlELElBQUksQ0FBQ0ksTUFBTSxHQUFHO1FBQ25IO0lBQ0o7QUFDSjtBQUNBLElBQUksT0FBTzJCLFVBQVUsYUFBYTtJQUM5Qk0sYUFBYTFDLFNBQVMsQ0FBQ29DLE9BQU9DLFFBQVEsQ0FBQyxHQUFHUSxzQkFBc0I3QyxTQUFTLENBQUNvQyxPQUFPQyxRQUFRLENBQUMsR0FDdEY7UUFBYyxPQUFPLElBQUk7SUFBRTtBQUNuQztBQUNBLFNBQVNtQyxZQUFZQyxNQUFNO0lBQ3ZCLElBQUk7UUFDQSxJQUFJMUIsT0FBTzBCLFFBQVFqQztRQUNuQixPQUFPO0lBQ1gsRUFDQSxPQUFPa0MsSUFBSTtRQUNQLE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU3JCLFVBQVVoRCxJQUFJLEVBQUVzQixHQUFHO0lBQ3hCLElBQUlBLE9BQU90QixLQUFLSSxNQUFNLEVBQ2xCLE9BQU9rQjtJQUNYLElBQUlnRCxPQUFPdEUsS0FBSzZDLE1BQU0sQ0FBQ3ZCLE1BQU1QO0lBQzdCLE1BQU9PLE1BQU1nRCxLQUFLbkUsRUFBRSxJQUFJLENBQUNZLE9BQU91RCxLQUFLdEUsSUFBSSxDQUFDd0IsVUFBVSxDQUFDRixNQUFNZ0QsS0FBS3BFLElBQUksTUFBTSxVQUFVYSxPQUFPLE9BQ3ZGTztJQUNKLE9BQU9BO0FBQ1g7QUFFQSxTQUFTaUQsaUJBQWlCQyxJQUFJO0lBQzFCLElBQUlGLE9BQU81RSxPQUFPOEUsS0FBS0MsS0FBSyxDQUFDYixHQUFHLENBQUNmLE1BQU0sQ0FBQzJCLEtBQUtDLEtBQUssQ0FBQ0MsU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUksRUFBRUMsTUFBTTtJQUM5RSxJQUFJQyxRQUFRdEYsaURBQUdBLENBQUMsU0FBUztRQUFFdUYsT0FBTztRQUFnQkMsTUFBTTtRQUFRMUUsT0FBT2dFO0lBQUs7SUFDNUUsSUFBSVcsTUFBTXpGLGlEQUFHQSxDQUFDLFFBQVE7UUFDbEJ1RixPQUFPO1FBQ1BHLFdBQVcsQ0FBQ0M7WUFDUixJQUFJQSxNQUFNQyxPQUFPLElBQUksSUFBSTtnQkFDckJELE1BQU1FLGNBQWM7Z0JBQ3BCYixLQUFLYyxRQUFRLENBQUM7b0JBQUVDLFNBQVNDLGFBQWFDLEVBQUUsQ0FBQztnQkFBTztnQkFDaERqQixLQUFLa0IsS0FBSztZQUNkLE9BQ0ssSUFBSVAsTUFBTUMsT0FBTyxJQUFJLElBQUk7Z0JBQzFCRCxNQUFNRSxjQUFjO2dCQUNwQk07WUFDSjtRQUNKO1FBQ0FDLFVBQVUsQ0FBQ1Q7WUFDUEEsTUFBTUUsY0FBYztZQUNwQk07UUFDSjtJQUNKLEdBQUduRyxpREFBR0EsQ0FBQyxTQUFTZ0YsS0FBS0MsS0FBSyxDQUFDb0IsTUFBTSxDQUFDLGVBQWUsTUFBTWYsUUFBUSxLQUFLdEYsaURBQUdBLENBQUMsVUFBVTtRQUFFdUYsT0FBTztRQUFhZSxNQUFNO0lBQVMsR0FBR3RCLEtBQUtDLEtBQUssQ0FBQ29CLE1BQU0sQ0FBQyxRQUFRckcsaURBQUdBLENBQUMsVUFBVTtRQUM5SndGLE1BQU07UUFDTmUsU0FBUztZQUNMdkIsS0FBS2MsUUFBUSxDQUFDO2dCQUFFQyxTQUFTQyxhQUFhQyxFQUFFLENBQUM7WUFBTztZQUNoRGpCLEtBQUtrQixLQUFLO1FBQ2Q7UUFDQSxjQUFjbEIsS0FBS0MsS0FBSyxDQUFDb0IsTUFBTSxDQUFDO1FBQ2hDQyxNQUFNO0lBQ1YsR0FBRztRQUFDO0tBQUk7SUFDUixTQUFTSDtRQUNMLElBQUlsRSxRQUFRLDZCQUE2QlMsSUFBSSxDQUFDNEMsTUFBTXhFLEtBQUs7UUFDekQsSUFBSSxDQUFDbUIsT0FDRDtRQUNKLElBQUksRUFBRWdELEtBQUssRUFBRSxHQUFHRCxNQUFNNUIsWUFBWTZCLE1BQU1iLEdBQUcsQ0FBQ2YsTUFBTSxDQUFDNEIsTUFBTUMsU0FBUyxDQUFDQyxJQUFJLENBQUNDLElBQUk7UUFDNUUsSUFBSSxHQUFHb0IsTUFBTUMsSUFBSUMsSUFBSUMsUUFBUSxHQUFHMUU7UUFDaEMsSUFBSTJFLE1BQU1GLEtBQUssQ0FBQ0EsR0FBRzlDLEtBQUssQ0FBQyxLQUFLO1FBQzlCLElBQUlrQixPQUFPMkIsS0FBSyxDQUFDQSxLQUFLckQsVUFBVWlDLE1BQU07UUFDdEMsSUFBSW9CLE1BQU1FLFNBQVM7WUFDZixJQUFJRSxLQUFLL0IsT0FBTztZQUNoQixJQUFJMEIsTUFDQUssS0FBS0EsS0FBTUwsQ0FBQUEsUUFBUSxNQUFNLENBQUMsSUFBSSxLQUFNcEQsVUFBVWlDLE1BQU0sR0FBR0osTUFBTWIsR0FBRyxDQUFDMEMsS0FBSztZQUMxRWhDLE9BQU9pQyxLQUFLQyxLQUFLLENBQUMvQixNQUFNYixHQUFHLENBQUMwQyxLQUFLLEdBQUdEO1FBQ3hDLE9BQ0ssSUFBSUosTUFBTUQsTUFBTTtZQUNqQjFCLE9BQU9BLE9BQVEwQixDQUFBQSxRQUFRLE1BQU0sQ0FBQyxJQUFJLEtBQUtwRCxVQUFVaUMsTUFBTTtRQUMzRDtRQUNBLElBQUk0QixVQUFVaEMsTUFBTWIsR0FBRyxDQUFDVSxJQUFJLENBQUNpQyxLQUFLRyxHQUFHLENBQUMsR0FBR0gsS0FBS0ksR0FBRyxDQUFDbEMsTUFBTWIsR0FBRyxDQUFDMEMsS0FBSyxFQUFFaEM7UUFDbkUsSUFBSUksWUFBWTFGLDhEQUFlQSxDQUFDNEgsTUFBTSxDQUFDSCxRQUFRdkcsSUFBSSxHQUFHcUcsS0FBS0csR0FBRyxDQUFDLEdBQUdILEtBQUtJLEdBQUcsQ0FBQ1AsS0FBS0ssUUFBUXJHLE1BQU07UUFDOUZvRSxLQUFLYyxRQUFRLENBQUM7WUFDVkMsU0FBUztnQkFBQ0MsYUFBYUMsRUFBRSxDQUFDO2dCQUFRbkgsd0RBQVVBLENBQUN1SSxjQUFjLENBQUNuQyxVQUFVeEUsSUFBSSxFQUFFO29CQUFFNEcsR0FBRztnQkFBUzthQUFHO1lBQzdGcEM7UUFDSjtRQUNBRixLQUFLa0IsS0FBSztJQUNkO0lBQ0EsT0FBTztRQUFFVDtJQUFJO0FBQ2pCO0FBQ0EsTUFBTU8sZUFBZSxXQUFXLEdBQUUxRywwREFBV0EsQ0FBQ2lJLE1BQU07QUFDcEQsTUFBTUMsY0FBYyxXQUFXLEdBQUVqSSx5REFBVUEsQ0FBQ2dJLE1BQU0sQ0FBQztJQUMvQ0U7UUFBVyxPQUFPO0lBQU07SUFDeEJDLFFBQU81RyxLQUFLLEVBQUU2RyxFQUFFO1FBQ1osS0FBSyxJQUFJQyxLQUFLRCxHQUFHNUIsT0FBTyxDQUNwQixJQUFJNkIsRUFBRUMsRUFBRSxDQUFDN0IsZUFDTGxGLFFBQVE4RyxFQUFFOUcsS0FBSztRQUN2QixPQUFPQTtJQUNYO0lBQ0FnSCxTQUFTQyxDQUFBQSxJQUFLbEosdURBQVNBLENBQUM2QixJQUFJLENBQUNxSCxHQUFHQyxDQUFBQSxNQUFPQSxNQUFNakQsbUJBQW1CO0FBQ3BFO0FBQ0E7Ozs7Ozs7O0FBUUEsR0FDQSxNQUFNa0QsV0FBV2pELENBQUFBO0lBQ2IsSUFBSWtELFFBQVFuSiwwREFBUUEsQ0FBQ2lHLE1BQU1EO0lBQzNCLElBQUksQ0FBQ21ELE9BQU87UUFDUixJQUFJbkMsVUFBVTtZQUFDQyxhQUFhQyxFQUFFLENBQUM7U0FBTTtRQUNyQyxJQUFJakIsS0FBS0MsS0FBSyxDQUFDa0QsS0FBSyxDQUFDWCxhQUFhLFVBQVUsTUFDeEN6QixRQUFRekQsSUFBSSxDQUFDaEQsMERBQVdBLENBQUM4SSxZQUFZLENBQUNuQyxFQUFFLENBQUM7WUFBQ3VCO1lBQWFhO1NBQVk7UUFDdkVyRCxLQUFLYyxRQUFRLENBQUM7WUFBRUM7UUFBUTtRQUN4Qm1DLFFBQVFuSiwwREFBUUEsQ0FBQ2lHLE1BQU1EO0lBQzNCO0lBQ0EsSUFBSW1ELE9BQ0FBLE1BQU16QyxHQUFHLENBQUM2QyxhQUFhLENBQUMsU0FBU0MsTUFBTTtJQUMzQyxPQUFPO0FBQ1g7QUFDQSxNQUFNRixjQUFjLFdBQVcsR0FBRXZKLHdEQUFVQSxDQUFDMEosU0FBUyxDQUFDO0lBQ2xELHlCQUF5QjtRQUNyQkMsU0FBUztRQUNUQyxVQUFVO1FBQ1YsV0FBVztZQUFFQyxVQUFVO1FBQU07UUFDN0Isa0JBQWtCO1lBQ2RELFVBQVU7WUFDVkUsS0FBSztZQUFLQyxRQUFRO1lBQ2xCQyxPQUFPO1lBQ1BDLGlCQUFpQjtZQUNqQkMsUUFBUTtZQUNSQyxNQUFNO1lBQ05SLFNBQVM7UUFDYjtJQUNKO0FBQ0o7QUFFQSxNQUFNUywwQkFBMEI7SUFDNUJDLDJCQUEyQjtJQUMzQkMsb0JBQW9CO0lBQ3BCQyxZQUFZO0lBQ1pDLFlBQVk7QUFDaEI7QUFDQSxNQUFNQyxrQkFBa0IsV0FBVyxHQUFFOUosb0RBQUtBLENBQUM4SCxNQUFNLENBQUM7SUFDOUNpQyxTQUFRMUcsT0FBTztRQUNYLE9BQU9wRCxnRUFBYUEsQ0FBQ29ELFNBQVNvRyx5QkFBeUI7WUFDbkRDLDJCQUEyQixDQUFDTSxHQUFHQyxJQUFNRCxLQUFLQztZQUMxQ04sb0JBQW9CckMsS0FBS0ksR0FBRztZQUM1QmtDLFlBQVl0QyxLQUFLSSxHQUFHO1FBQ3hCO0lBQ0o7QUFDSjtBQUNBOzs7OztBQUtBLEdBQ0EsU0FBU3dDLDBCQUEwQjdHLE9BQU87SUFDdEMsSUFBSThHLE1BQU07UUFBQ0M7UUFBY0M7S0FBaUI7SUFDMUMsSUFBSWhILFNBQ0E4RyxJQUFJdEgsSUFBSSxDQUFDaUgsZ0JBQWdCdEQsRUFBRSxDQUFDbkQ7SUFDaEMsT0FBTzhHO0FBQ1g7QUFDQSxNQUFNRyxZQUFZLFdBQVcsR0FBRS9LLHdEQUFVQSxDQUFDZ0wsSUFBSSxDQUFDO0lBQUV6RSxPQUFPO0FBQW9CO0FBQzVFLE1BQU0wRSxnQkFBZ0IsV0FBVyxHQUFFakwsd0RBQVVBLENBQUNnTCxJQUFJLENBQUM7SUFBRXpFLE9BQU87QUFBMkM7QUFDdkcsc0ZBQXNGO0FBQ3RGLFNBQVMyRSxxQkFBcUJDLEtBQUssRUFBRWxGLEtBQUssRUFBRXZFLElBQUksRUFBRUMsRUFBRTtJQUNoRCxPQUFPLENBQUNELFFBQVEsS0FBS3lKLE1BQU1sRixNQUFNbUYsUUFBUSxDQUFDMUosT0FBTyxHQUFHQSxVQUFVZiwyREFBWUEsQ0FBQzBLLElBQUksS0FDMUUxSixDQUFBQSxNQUFNc0UsTUFBTWIsR0FBRyxDQUFDeEQsTUFBTSxJQUFJdUosTUFBTWxGLE1BQU1tRixRQUFRLENBQUN6SixJQUFJQSxLQUFLLE9BQU9oQiwyREFBWUEsQ0FBQzBLLElBQUk7QUFDekY7QUFDQSw2RUFBNkU7QUFDN0UsU0FBU0MsV0FBV0gsS0FBSyxFQUFFbEYsS0FBSyxFQUFFdkUsSUFBSSxFQUFFQyxFQUFFO0lBQ3RDLE9BQU93SixNQUFNbEYsTUFBTW1GLFFBQVEsQ0FBQzFKLE1BQU1BLE9BQU8sT0FBT2YsMkRBQVlBLENBQUMwSyxJQUFJLElBQzFERixNQUFNbEYsTUFBTW1GLFFBQVEsQ0FBQ3pKLEtBQUssR0FBR0EsUUFBUWhCLDJEQUFZQSxDQUFDMEssSUFBSTtBQUNqRTtBQUNBLE1BQU1QLG1CQUFtQixXQUFXLEdBQUU3Syx3REFBVUEsQ0FBQ3NMLFNBQVMsQ0FBQztJQUN2RGhLLFlBQVl5RSxJQUFJLENBQUU7UUFDZCxJQUFJLENBQUN3RixXQUFXLEdBQUcsSUFBSSxDQUFDQyxPQUFPLENBQUN6RjtJQUNwQztJQUNBMEMsT0FBT0EsTUFBTSxFQUFFO1FBQ1gsSUFBSUEsT0FBT2dELFlBQVksSUFBSWhELE9BQU9pRCxVQUFVLElBQUlqRCxPQUFPa0QsZUFBZSxFQUNsRSxJQUFJLENBQUNKLFdBQVcsR0FBRyxJQUFJLENBQUNDLE9BQU8sQ0FBQy9DLE9BQU8xQyxJQUFJO0lBQ25EO0lBQ0F5RixRQUFRekYsSUFBSSxFQUFFO1FBQ1YsSUFBSTZGLE9BQU83RixLQUFLQyxLQUFLLENBQUM2RixLQUFLLENBQUN2QjtRQUM1QixJQUFJLEVBQUV0RSxLQUFLLEVBQUUsR0FBR0QsTUFBTStGLE1BQU05RixNQUFNQyxTQUFTO1FBQzNDLElBQUk2RixJQUFJQyxNQUFNLENBQUNwSyxNQUFNLEdBQUcsR0FDcEIsT0FBTzVCLHdEQUFVQSxDQUFDaU0sSUFBSTtRQUMxQixJQUFJQyxRQUFRSCxJQUFJNUYsSUFBSSxFQUFFMUUsT0FBTzBKLFFBQVE7UUFDckMsSUFBSWUsTUFBTXpJLEtBQUssRUFBRTtZQUNiLElBQUksQ0FBQ29JLEtBQUsxQix5QkFBeUIsRUFDL0IsT0FBT25LLHdEQUFVQSxDQUFDaU0sSUFBSTtZQUMxQixJQUFJRSxPQUFPbEcsTUFBTW1HLE1BQU0sQ0FBQ0YsTUFBTTlGLElBQUk7WUFDbEMsSUFBSSxDQUFDK0YsTUFDRCxPQUFPbk0sd0RBQVVBLENBQUNpTSxJQUFJO1lBQzFCZCxRQUFRbEYsTUFBTW9HLGVBQWUsQ0FBQ0gsTUFBTTlGLElBQUk7WUFDeEMzRSxRQUFRd0UsTUFBTW1GLFFBQVEsQ0FBQ2UsS0FBS3pLLElBQUksRUFBRXlLLEtBQUt4SyxFQUFFO1FBQzdDLE9BQ0s7WUFDRCxJQUFJMkssTUFBTUosTUFBTXZLLEVBQUUsR0FBR3VLLE1BQU14SyxJQUFJO1lBQy9CLElBQUk0SyxNQUFNVCxLQUFLekIsa0JBQWtCLElBQUlrQyxNQUFNLEtBQ3ZDLE9BQU90TSx3REFBVUEsQ0FBQ2lNLElBQUk7WUFDMUIsSUFBSUosS0FBS3ZCLFVBQVUsRUFBRTtnQkFDakI3SSxRQUFRd0UsTUFBTW1GLFFBQVEsQ0FBQ2MsTUFBTXhLLElBQUksRUFBRXdLLE1BQU12SyxFQUFFLEdBQUcsa0RBQWtEO2dCQUNoR3dKLFFBQVFsRixNQUFNb0csZUFBZSxDQUFDSCxNQUFNOUYsSUFBSTtnQkFDeEMsSUFBSSxDQUFFOEUsQ0FBQUEscUJBQXFCQyxPQUFPbEYsT0FBT2lHLE1BQU14SyxJQUFJLEVBQUV3SyxNQUFNdkssRUFBRSxLQUN6RDJKLFdBQVdILE9BQU9sRixPQUFPaUcsTUFBTXhLLElBQUksRUFBRXdLLE1BQU12SyxFQUFFLElBQzdDLE9BQU8zQix3REFBVUEsQ0FBQ2lNLElBQUk7WUFDOUIsT0FDSztnQkFDRHhLLFFBQVF3RSxNQUFNbUYsUUFBUSxDQUFDYyxNQUFNeEssSUFBSSxFQUFFd0ssTUFBTXZLLEVBQUU7Z0JBQzNDLElBQUksQ0FBQ0YsT0FDRCxPQUFPekIsd0RBQVVBLENBQUNpTSxJQUFJO1lBQzlCO1FBQ0o7UUFDQSxJQUFJTSxPQUFPLEVBQUU7UUFDYixLQUFLLElBQUlDLFFBQVF4RyxLQUFLeUcsYUFBYSxDQUFFO1lBQ2pDLElBQUlyRSxTQUFTLElBQUk5RyxhQUFhMkUsTUFBTWIsR0FBRyxFQUFFM0QsT0FBTytLLEtBQUs5SyxJQUFJLEVBQUU4SyxLQUFLN0ssRUFBRTtZQUNsRSxNQUFPLENBQUN5RyxPQUFPN0YsSUFBSSxHQUFHUixJQUFJLENBQUU7Z0JBQ3hCLElBQUksRUFBRUwsSUFBSSxFQUFFQyxFQUFFLEVBQUUsR0FBR3lHLE9BQU90RyxLQUFLO2dCQUMvQixJQUFJLENBQUNxSixTQUFTRCxxQkFBcUJDLE9BQU9sRixPQUFPdkUsTUFBTUMsS0FBSztvQkFDeEQsSUFBSXVLLE1BQU16SSxLQUFLLElBQUkvQixRQUFRd0ssTUFBTXhLLElBQUksSUFBSUMsTUFBTXVLLE1BQU12SyxFQUFFLEVBQ25ENEssS0FBS2pKLElBQUksQ0FBQzJILGNBQWNpQixLQUFLLENBQUN4SyxNQUFNQzt5QkFDbkMsSUFBSUQsUUFBUXdLLE1BQU12SyxFQUFFLElBQUlBLE1BQU11SyxNQUFNeEssSUFBSSxFQUN6QzZLLEtBQUtqSixJQUFJLENBQUN5SCxVQUFVbUIsS0FBSyxDQUFDeEssTUFBTUM7b0JBQ3BDLElBQUk0SyxLQUFLM0ssTUFBTSxHQUFHaUssS0FBS3hCLFVBQVUsRUFDN0IsT0FBT3JLLHdEQUFVQSxDQUFDaU0sSUFBSTtnQkFDOUI7WUFDSjtRQUNKO1FBQ0EsT0FBT2pNLHdEQUFVQSxDQUFDd0YsR0FBRyxDQUFDK0c7SUFDMUI7QUFDSixHQUFHO0lBQ0NmLGFBQWFrQixDQUFBQSxJQUFLQSxFQUFFbEIsV0FBVztBQUNuQztBQUNBLE1BQU1YLGVBQWUsV0FBVyxHQUFFL0ssd0RBQVVBLENBQUMwSixTQUFTLENBQUM7SUFDbkQsc0JBQXNCO1FBQUVPLGlCQUFpQjtJQUFZO0lBQ3JELHNDQUFzQztRQUFFQSxpQkFBaUI7SUFBYztBQUMzRTtBQUNBLHVDQUF1QztBQUN2QyxNQUFNNEMsYUFBYSxDQUFDLEVBQUUxRyxLQUFLLEVBQUVhLFFBQVEsRUFBRTtJQUNuQyxJQUFJLEVBQUVaLFNBQVMsRUFBRSxHQUFHRDtJQUNwQixJQUFJMkcsU0FBU3BNLDhEQUFlQSxDQUFDaUksTUFBTSxDQUFDdkMsVUFBVThGLE1BQU0sQ0FBQ2EsR0FBRyxDQUFDWCxDQUFBQSxRQUFTakcsTUFBTW1HLE1BQU0sQ0FBQ0YsTUFBTTlGLElBQUksS0FBSzVGLDhEQUFlQSxDQUFDNEgsTUFBTSxDQUFDOEQsTUFBTTlGLElBQUksSUFBSUYsVUFBVTRHLFNBQVM7SUFDdEosSUFBSUYsT0FBT0csRUFBRSxDQUFDN0csWUFDVixPQUFPO0lBQ1hZLFNBQVNiLE1BQU15QyxNQUFNLENBQUM7UUFBRXhDLFdBQVcwRztJQUFPO0lBQzFDLE9BQU87QUFDWDtBQUNBLHFFQUFxRTtBQUNyRSw2Q0FBNkM7QUFDN0MsU0FBU0ksbUJBQW1CL0csS0FBSyxFQUFFeEUsS0FBSztJQUNwQyxJQUFJLEVBQUUwRSxJQUFJLEVBQUU2RixNQUFNLEVBQUUsR0FBRy9GLE1BQU1DLFNBQVM7SUFDdEMsSUFBSWlHLE9BQU9sRyxNQUFNbUcsTUFBTSxDQUFDakcsS0FBS0MsSUFBSSxHQUFHNkcsV0FBV2QsUUFBUUEsS0FBS3pLLElBQUksSUFBSXlFLEtBQUt6RSxJQUFJLElBQUl5SyxLQUFLeEssRUFBRSxJQUFJd0UsS0FBS3hFLEVBQUU7SUFDbkcsSUFBSyxJQUFJdUwsU0FBUyxPQUFPOUUsU0FBUyxJQUFJOUcsYUFBYTJFLE1BQU1iLEdBQUcsRUFBRTNELE9BQU91SyxNQUFNLENBQUNBLE9BQU9wSyxNQUFNLEdBQUcsRUFBRSxDQUFDRCxFQUFFLElBQUs7UUFDbEd5RyxPQUFPN0YsSUFBSTtRQUNYLElBQUk2RixPQUFPckcsSUFBSSxFQUFFO1lBQ2IsSUFBSW1MLFFBQ0EsT0FBTztZQUNYOUUsU0FBUyxJQUFJOUcsYUFBYTJFLE1BQU1iLEdBQUcsRUFBRTNELE9BQU8sR0FBR3NHLEtBQUtHLEdBQUcsQ0FBQyxHQUFHOEQsTUFBTSxDQUFDQSxPQUFPcEssTUFBTSxHQUFHLEVBQUUsQ0FBQ0YsSUFBSSxHQUFHO1lBQzVGd0wsU0FBUztRQUNiLE9BQ0s7WUFDRCxJQUFJQSxVQUFVbEIsT0FBT21CLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRTFMLElBQUksSUFBSTBHLE9BQU90RyxLQUFLLENBQUNKLElBQUksR0FDdEQ7WUFDSixJQUFJdUwsVUFBVTtnQkFDVixJQUFJZCxPQUFPbEcsTUFBTW1HLE1BQU0sQ0FBQ2hFLE9BQU90RyxLQUFLLENBQUNKLElBQUk7Z0JBQ3pDLElBQUksQ0FBQ3lLLFFBQVFBLEtBQUt6SyxJQUFJLElBQUkwRyxPQUFPdEcsS0FBSyxDQUFDSixJQUFJLElBQUl5SyxLQUFLeEssRUFBRSxJQUFJeUcsT0FBT3RHLEtBQUssQ0FBQ0gsRUFBRSxFQUNyRTtZQUNSO1lBQ0EsT0FBT3lHLE9BQU90RyxLQUFLO1FBQ3ZCO0lBQ0o7QUFDSjtBQUNBOzs7QUFHQSxHQUNBLE1BQU11TCx1QkFBdUIsQ0FBQyxFQUFFcEgsS0FBSyxFQUFFYSxRQUFRLEVBQUU7SUFDN0MsSUFBSSxFQUFFa0YsTUFBTSxFQUFFLEdBQUcvRixNQUFNQyxTQUFTO0lBQ2hDLElBQUk4RixPQUFPbUIsSUFBSSxDQUFDcEIsQ0FBQUEsTUFBT0EsSUFBSXJLLElBQUksS0FBS3FLLElBQUlwSyxFQUFFLEdBQ3RDLE9BQU9nTCxXQUFXO1FBQUUxRztRQUFPYTtJQUFTO0lBQ3hDLElBQUl3RyxlQUFlckgsTUFBTW1GLFFBQVEsQ0FBQ1ksTUFBTSxDQUFDLEVBQUUsQ0FBQ3RLLElBQUksRUFBRXNLLE1BQU0sQ0FBQyxFQUFFLENBQUNySyxFQUFFO0lBQzlELElBQUlzRSxNQUFNQyxTQUFTLENBQUM4RixNQUFNLENBQUNtQixJQUFJLENBQUNDLENBQUFBLElBQUtuSCxNQUFNbUYsUUFBUSxDQUFDZ0MsRUFBRTFMLElBQUksRUFBRTBMLEVBQUV6TCxFQUFFLEtBQUsyTCxlQUNqRSxPQUFPO0lBQ1gsSUFBSXBCLFFBQVFjLG1CQUFtQi9HLE9BQU9xSDtJQUN0QyxJQUFJLENBQUNwQixPQUNELE9BQU87SUFDWHBGLFNBQVNiLE1BQU15QyxNQUFNLENBQUM7UUFDbEJ4QyxXQUFXRCxNQUFNQyxTQUFTLENBQUNxSCxRQUFRLENBQUMvTSw4REFBZUEsQ0FBQzBMLEtBQUssQ0FBQ0EsTUFBTXhLLElBQUksRUFBRXdLLE1BQU12SyxFQUFFLEdBQUc7UUFDakZvRixTQUFTakgsd0RBQVVBLENBQUN1SSxjQUFjLENBQUM2RCxNQUFNdkssRUFBRTtJQUMvQztJQUNBLE9BQU87QUFDWDtBQUVBLE1BQU02TCxvQkFBb0IsV0FBVyxHQUFFL00sb0RBQUtBLENBQUM4SCxNQUFNLENBQUM7SUFDaERpQyxTQUFRaUQsT0FBTztRQUNYLE9BQU8vTSxnRUFBYUEsQ0FBQytNLFNBQVM7WUFDMUI3RCxLQUFLO1lBQ0w4RCxlQUFlO1lBQ2ZDLFNBQVM7WUFDVEMsUUFBUTtZQUNSQyxXQUFXO1lBQ1hDLGFBQWE5SCxDQUFBQSxPQUFRLElBQUkrSCxZQUFZL0g7WUFDckNnSSxlQUFlOUIsQ0FBQUEsUUFBU3BNLHdEQUFVQSxDQUFDdUksY0FBYyxDQUFDNkQ7UUFDdEQ7SUFDSjtBQUNKO0FBQ0E7Ozs7O0FBS0EsR0FDQSxTQUFTK0IsT0FBT0MsTUFBTTtJQUNsQixPQUFPQSxTQUFTO1FBQUNWLGtCQUFrQnZHLEVBQUUsQ0FBQ2lIO1FBQVNDO0tBQWlCLEdBQUdBO0FBQ3ZFO0FBQ0E7O0FBRUEsR0FDQSxNQUFNQztJQUNGOztJQUVBLEdBQ0E3TSxZQUFZMk0sTUFBTSxDQUFFO1FBQ2hCLElBQUksQ0FBQ0QsTUFBTSxHQUFHQyxPQUFPRCxNQUFNO1FBQzNCLElBQUksQ0FBQ1AsYUFBYSxHQUFHLENBQUMsQ0FBQ1EsT0FBT1IsYUFBYTtRQUMzQyxJQUFJLENBQUNDLE9BQU8sR0FBRyxDQUFDLENBQUNPLE9BQU9QLE9BQU87UUFDL0IsSUFBSSxDQUFDQyxNQUFNLEdBQUcsQ0FBQyxDQUFDTSxPQUFPTixNQUFNO1FBQzdCLElBQUksQ0FBQ1MsT0FBTyxHQUFHSCxPQUFPRyxPQUFPLElBQUk7UUFDakMsSUFBSSxDQUFDQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQ0wsTUFBTSxJQUFLLEVBQUMsSUFBSSxDQUFDTCxNQUFNLElBQUlqSSxZQUFZLElBQUksQ0FBQ3NJLE1BQU07UUFDdEUsSUFBSSxDQUFDTSxRQUFRLEdBQUcsSUFBSSxDQUFDQyxPQUFPLENBQUMsSUFBSSxDQUFDUCxNQUFNO1FBQ3hDLElBQUksQ0FBQ0osU0FBUyxHQUFHLENBQUMsQ0FBQ0ssT0FBT0wsU0FBUztJQUN2QztJQUNBOztJQUVBLEdBQ0FXLFFBQVFoTixJQUFJLEVBQUU7UUFDVixPQUFPLElBQUksQ0FBQ21NLE9BQU8sR0FBR25NLE9BQ2xCQSxLQUFLNk0sT0FBTyxDQUFDLGdCQUFnQixDQUFDSSxHQUFHQyxLQUFPQSxNQUFNLE1BQU0sT0FBT0EsTUFBTSxNQUFNLE9BQU9BLE1BQU0sTUFBTSxNQUFPO0lBQ3pHO0lBQ0E7O0lBRUEsR0FDQTNCLEdBQUc0QixLQUFLLEVBQUU7UUFDTixPQUFPLElBQUksQ0FBQ1YsTUFBTSxJQUFJVSxNQUFNVixNQUFNLElBQUksSUFBSSxDQUFDSSxPQUFPLElBQUlNLE1BQU1OLE9BQU8sSUFDL0QsSUFBSSxDQUFDWCxhQUFhLElBQUlpQixNQUFNakIsYUFBYSxJQUFJLElBQUksQ0FBQ0UsTUFBTSxJQUFJZSxNQUFNZixNQUFNLElBQ3hFLElBQUksQ0FBQ0MsU0FBUyxJQUFJYyxNQUFNZCxTQUFTO0lBQ3pDO0lBQ0E7O0lBRUEsR0FDQXBGLFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQ21GLE1BQU0sR0FBRyxJQUFJZ0IsWUFBWSxJQUFJLElBQUksSUFBSUMsWUFBWSxJQUFJO0lBQ3JFO0lBQ0E7OztJQUdBLEdBQ0FDLFVBQVU3SSxLQUFLLEVBQUV2RSxPQUFPLENBQUMsRUFBRUMsRUFBRSxFQUFFO1FBQzNCLElBQUlvTixLQUFLOUksTUFBTWIsR0FBRyxHQUFHYSxRQUFRbkYsMERBQVdBLENBQUMySCxNQUFNLENBQUM7WUFBRXJELEtBQUthO1FBQU07UUFDN0QsSUFBSXRFLE1BQU0sTUFDTkEsS0FBS29OLEdBQUczSixHQUFHLENBQUN4RCxNQUFNO1FBQ3RCLE9BQU8sSUFBSSxDQUFDZ00sTUFBTSxHQUFHb0IsYUFBYSxJQUFJLEVBQUVELElBQUlyTixNQUFNQyxNQUFNc04sYUFBYSxJQUFJLEVBQUVGLElBQUlyTixNQUFNQztJQUN6RjtBQUNKO0FBQ0EsTUFBTXVOO0lBQ0YzTixZQUFZNE4sSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO0lBQ2hCO0FBQ0o7QUFDQSxTQUFTRixhQUFhRSxJQUFJLEVBQUVsSixLQUFLLEVBQUV2RSxJQUFJLEVBQUVDLEVBQUU7SUFDdkMsT0FBTyxJQUFJTCxhQUFhMkUsTUFBTWIsR0FBRyxFQUFFK0osS0FBS1osUUFBUSxFQUFFN00sTUFBTUMsSUFBSXdOLEtBQUt6QixhQUFhLEdBQUcwQixZQUFZL04sQ0FBQUEsSUFBS0EsRUFBRWdPLFdBQVcsSUFBSUYsS0FBS3RCLFNBQVMsR0FBR3lCLGVBQWVySixNQUFNYixHQUFHLEVBQUVhLE1BQU1vRyxlQUFlLENBQUNwRyxNQUFNQyxTQUFTLENBQUNDLElBQUksQ0FBQ0MsSUFBSSxLQUFLZ0o7QUFDdE47QUFDQSxTQUFTRSxlQUFlbEssR0FBRyxFQUFFbUssV0FBVztJQUNwQyxPQUFPLENBQUM3TixNQUFNQyxJQUFJNk4sS0FBS0M7UUFDbkIsSUFBSUEsU0FBUy9OLFFBQVErTixTQUFTRCxJQUFJNU4sTUFBTSxHQUFHRCxJQUFJO1lBQzNDOE4sU0FBUzFILEtBQUtHLEdBQUcsQ0FBQyxHQUFHeEcsT0FBTztZQUM1QjhOLE1BQU1wSyxJQUFJRyxXQUFXLENBQUNrSyxRQUFRMUgsS0FBS0ksR0FBRyxDQUFDL0MsSUFBSXhELE1BQU0sRUFBRUQsS0FBSztRQUM1RDtRQUNBLE9BQU8sQ0FBQzROLFlBQVlHLFdBQVdGLEtBQUs5TixPQUFPK04sWUFBWTlPLDJEQUFZQSxDQUFDMEssSUFBSSxJQUNwRWtFLFlBQVlJLFVBQVVILEtBQUs5TixPQUFPK04sWUFBWTlPLDJEQUFZQSxDQUFDMEssSUFBSSxLQUM5RGtFLENBQUFBLFlBQVlJLFVBQVVILEtBQUs3TixLQUFLOE4sWUFBWTlPLDJEQUFZQSxDQUFDMEssSUFBSSxJQUMxRGtFLFlBQVlHLFdBQVdGLEtBQUs3TixLQUFLOE4sWUFBWTlPLDJEQUFZQSxDQUFDMEssSUFBSTtJQUMxRTtBQUNKO0FBQ0EsTUFBTXdELG9CQUFvQks7SUFDdEIzTixZQUFZNE4sSUFBSSxDQUFFO1FBQ2QsS0FBSyxDQUFDQTtJQUNWO0lBQ0FTLFVBQVUzSixLQUFLLEVBQUU0SixPQUFPLEVBQUVDLEtBQUssRUFBRTtRQUM3QixJQUFJMUgsU0FBUzZHLGFBQWEsSUFBSSxDQUFDRSxJQUFJLEVBQUVsSixPQUFPNkosT0FBTzdKLE1BQU1iLEdBQUcsQ0FBQ3hELE1BQU0sRUFBRWEsZUFBZTtRQUNwRixJQUFJMkYsT0FBT3JHLElBQUksRUFBRTtZQUNiLElBQUltQixNQUFNNkUsS0FBS0ksR0FBRyxDQUFDbEMsTUFBTWIsR0FBRyxDQUFDeEQsTUFBTSxFQUFFaU8sVUFBVSxJQUFJLENBQUNWLElBQUksQ0FBQ1osUUFBUSxDQUFDM00sTUFBTTtZQUN4RXdHLFNBQVM2RyxhQUFhLElBQUksQ0FBQ0UsSUFBSSxFQUFFbEosT0FBTyxHQUFHL0MsS0FBS1QsZUFBZTtRQUNuRTtRQUNBLE9BQU8yRixPQUFPckcsSUFBSSxJQUFJcUcsT0FBT3RHLEtBQUssQ0FBQ0osSUFBSSxJQUFJbU8sV0FBV3pILE9BQU90RyxLQUFLLENBQUNILEVBQUUsSUFBSW1PLFFBQVEsT0FBTzFILE9BQU90RyxLQUFLO0lBQ3hHO0lBQ0EsdUVBQXVFO0lBQ3ZFLHNEQUFzRDtJQUN0RGlPLGlCQUFpQjlKLEtBQUssRUFBRXZFLElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQzlCLElBQUssSUFBSW1CLE1BQU1uQixLQUFNO1lBQ2pCLElBQUlnQixRQUFRb0YsS0FBS0csR0FBRyxDQUFDeEcsTUFBTW9CLE1BQU0sTUFBTSxzQkFBc0IsTUFBSyxJQUFJLENBQUNxTSxJQUFJLENBQUNaLFFBQVEsQ0FBQzNNLE1BQU07WUFDM0YsSUFBSXdHLFNBQVM2RyxhQUFhLElBQUksQ0FBQ0UsSUFBSSxFQUFFbEosT0FBT3RELE9BQU9HLE1BQU1vSixRQUFRO1lBQ2pFLE1BQU8sQ0FBQzlELE9BQU8zRixlQUFlLEdBQUdWLElBQUksQ0FDakNtSyxRQUFROUQsT0FBT3RHLEtBQUs7WUFDeEIsSUFBSW9LLE9BQ0EsT0FBT0E7WUFDWCxJQUFJdkosU0FBU2pCLE1BQ1QsT0FBTztZQUNYb0IsT0FBTyxNQUFNLHNCQUFzQjtRQUN2QztJQUNKO0lBQ0FrTixVQUFVL0osS0FBSyxFQUFFNEosT0FBTyxFQUFFQyxLQUFLLEVBQUU7UUFDN0IsSUFBSUcsUUFBUSxJQUFJLENBQUNGLGdCQUFnQixDQUFDOUosT0FBTyxHQUFHNEo7UUFDNUMsSUFBSSxDQUFDSSxPQUNEQSxRQUFRLElBQUksQ0FBQ0YsZ0JBQWdCLENBQUM5SixPQUFPOEIsS0FBS0csR0FBRyxDQUFDLEdBQUc0SCxRQUFRLElBQUksQ0FBQ1gsSUFBSSxDQUFDWixRQUFRLENBQUMzTSxNQUFNLEdBQUdxRSxNQUFNYixHQUFHLENBQUN4RCxNQUFNO1FBQ3pHLE9BQU9xTyxTQUFVQSxDQUFBQSxNQUFNdk8sSUFBSSxJQUFJbU8sV0FBV0ksTUFBTXRPLEVBQUUsSUFBSW1PLEtBQUksSUFBS0csUUFBUTtJQUMzRTtJQUNBQyxlQUFlQyxPQUFPLEVBQUU7UUFBRSxPQUFPLElBQUksQ0FBQ2hCLElBQUksQ0FBQ1gsT0FBTyxDQUFDLElBQUksQ0FBQ1csSUFBSSxDQUFDZCxPQUFPO0lBQUc7SUFDdkUrQixTQUFTbkssS0FBSyxFQUFFb0ssS0FBSyxFQUFFO1FBQ25CLElBQUlqSSxTQUFTNkcsYUFBYSxJQUFJLENBQUNFLElBQUksRUFBRWxKLE9BQU8sR0FBR0EsTUFBTWIsR0FBRyxDQUFDeEQsTUFBTSxHQUFHb0ssU0FBUyxFQUFFO1FBQzdFLE1BQU8sQ0FBQzVELE9BQU83RixJQUFJLEdBQUdSLElBQUksQ0FBRTtZQUN4QixJQUFJaUssT0FBT3BLLE1BQU0sSUFBSXlPLE9BQ2pCLE9BQU87WUFDWHJFLE9BQU8xSSxJQUFJLENBQUM4RSxPQUFPdEcsS0FBSztRQUM1QjtRQUNBLE9BQU9rSztJQUNYO0lBQ0FzRSxVQUFVckssS0FBSyxFQUFFdkUsSUFBSSxFQUFFQyxFQUFFLEVBQUU0TyxHQUFHLEVBQUU7UUFDNUIsSUFBSW5JLFNBQVM2RyxhQUFhLElBQUksQ0FBQ0UsSUFBSSxFQUFFbEosT0FBTzhCLEtBQUtHLEdBQUcsQ0FBQyxHQUFHeEcsT0FBTyxJQUFJLENBQUN5TixJQUFJLENBQUNaLFFBQVEsQ0FBQzNNLE1BQU0sR0FBR21HLEtBQUtJLEdBQUcsQ0FBQ3hHLEtBQUssSUFBSSxDQUFDd04sSUFBSSxDQUFDWixRQUFRLENBQUMzTSxNQUFNLEVBQUVxRSxNQUFNYixHQUFHLENBQUN4RCxNQUFNO1FBQ3BKLE1BQU8sQ0FBQ3dHLE9BQU83RixJQUFJLEdBQUdSLElBQUksQ0FDdEJ3TyxJQUFJbkksT0FBT3RHLEtBQUssQ0FBQ0osSUFBSSxFQUFFMEcsT0FBT3RHLEtBQUssQ0FBQ0gsRUFBRTtJQUM5QztBQUNKO0FBQ0EsU0FBU3FOLGFBQWFHLElBQUksRUFBRWxKLEtBQUssRUFBRXZFLElBQUksRUFBRUMsRUFBRTtJQUN2QyxPQUFPLElBQUlrQyxhQUFhb0MsTUFBTWIsR0FBRyxFQUFFK0osS0FBS2xCLE1BQU0sRUFBRTtRQUM1QzlKLFlBQVksQ0FBQ2dMLEtBQUt6QixhQUFhO1FBQy9CN0wsTUFBTXNOLEtBQUt0QixTQUFTLEdBQUcyQyxlQUFldkssTUFBTW9HLGVBQWUsQ0FBQ3BHLE1BQU1DLFNBQVMsQ0FBQ0MsSUFBSSxDQUFDQyxJQUFJLEtBQUtnSjtJQUM5RixHQUFHMU4sTUFBTUM7QUFDYjtBQUNBLFNBQVMrTixXQUFXaE4sR0FBRyxFQUFFUyxLQUFLO0lBQzFCLE9BQU9ULElBQUlrQyxLQUFLLENBQUM3RCxtRUFBZ0JBLENBQUMyQixLQUFLUyxPQUFPLFFBQVFBO0FBQzFEO0FBQ0EsU0FBU3dNLFVBQVVqTixHQUFHLEVBQUVTLEtBQUs7SUFDekIsT0FBT1QsSUFBSWtDLEtBQUssQ0FBQ3pCLE9BQU9wQyxtRUFBZ0JBLENBQUMyQixLQUFLUztBQUNsRDtBQUNBLFNBQVNxTixlQUFlakIsV0FBVztJQUMvQixPQUFPLENBQUNrQixPQUFPQyxLQUFLek4sUUFBVSxDQUFDQSxLQUFLLENBQUMsRUFBRSxDQUFDckIsTUFBTSxJQUMxQyxDQUFDMk4sWUFBWUcsV0FBV3pNLE1BQU1xRCxLQUFLLEVBQUVyRCxNQUFNRSxLQUFLLE1BQU14QywyREFBWUEsQ0FBQzBLLElBQUksSUFDbkVrRSxZQUFZSSxVQUFVMU0sTUFBTXFELEtBQUssRUFBRXJELE1BQU1FLEtBQUssTUFBTXhDLDJEQUFZQSxDQUFDMEssSUFBSSxLQUNwRWtFLENBQUFBLFlBQVlJLFVBQVUxTSxNQUFNcUQsS0FBSyxFQUFFckQsTUFBTUUsS0FBSyxHQUFHRixLQUFLLENBQUMsRUFBRSxDQUFDckIsTUFBTSxNQUFNakIsMkRBQVlBLENBQUMwSyxJQUFJLElBQ3BGa0UsWUFBWUcsV0FBV3pNLE1BQU1xRCxLQUFLLEVBQUVyRCxNQUFNRSxLQUFLLEdBQUdGLEtBQUssQ0FBQyxFQUFFLENBQUNyQixNQUFNLE1BQU1qQiwyREFBWUEsQ0FBQzBLLElBQUk7QUFDeEc7QUFDQSxNQUFNdUQsb0JBQW9CTTtJQUN0QlUsVUFBVTNKLEtBQUssRUFBRTRKLE9BQU8sRUFBRUMsS0FBSyxFQUFFO1FBQzdCLElBQUkxSCxTQUFTNEcsYUFBYSxJQUFJLENBQUNHLElBQUksRUFBRWxKLE9BQU82SixPQUFPN0osTUFBTWIsR0FBRyxDQUFDeEQsTUFBTSxFQUFFVyxJQUFJO1FBQ3pFLElBQUk2RixPQUFPckcsSUFBSSxFQUNYcUcsU0FBUzRHLGFBQWEsSUFBSSxDQUFDRyxJQUFJLEVBQUVsSixPQUFPLEdBQUc0SixTQUFTdE4sSUFBSTtRQUM1RCxPQUFPNkYsT0FBT3JHLElBQUksR0FBRyxPQUFPcUcsT0FBT3RHLEtBQUs7SUFDNUM7SUFDQWlPLGlCQUFpQjlKLEtBQUssRUFBRXZFLElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQzlCLElBQUssSUFBSWdQLE9BQU8sSUFBSUEsT0FBUTtZQUN4QixJQUFJaE8sUUFBUW9GLEtBQUtHLEdBQUcsQ0FBQ3hHLE1BQU1DLEtBQUtnUCxPQUFPLE1BQU0sc0JBQXNCO1lBQ25FLElBQUl2SSxTQUFTNEcsYUFBYSxJQUFJLENBQUNHLElBQUksRUFBRWxKLE9BQU90RCxPQUFPaEIsS0FBS3VLLFFBQVE7WUFDaEUsTUFBTyxDQUFDOUQsT0FBTzdGLElBQUksR0FBR1IsSUFBSSxDQUN0Qm1LLFFBQVE5RCxPQUFPdEcsS0FBSztZQUN4QixJQUFJb0ssU0FBVXZKLENBQUFBLFNBQVNqQixRQUFRd0ssTUFBTXhLLElBQUksR0FBR2lCLFFBQVEsRUFBQyxHQUNqRCxPQUFPdUo7WUFDWCxJQUFJdkosU0FBU2pCLE1BQ1QsT0FBTztRQUNmO0lBQ0o7SUFDQXNPLFVBQVUvSixLQUFLLEVBQUU0SixPQUFPLEVBQUVDLEtBQUssRUFBRTtRQUM3QixPQUFPLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUM5SixPQUFPLEdBQUc0SixZQUNuQyxJQUFJLENBQUNFLGdCQUFnQixDQUFDOUosT0FBTzZKLE9BQU83SixNQUFNYixHQUFHLENBQUN4RCxNQUFNO0lBQzVEO0lBQ0FzTyxlQUFlVSxNQUFNLEVBQUU7UUFDbkIsT0FBTyxJQUFJLENBQUN6QixJQUFJLENBQUNYLE9BQU8sQ0FBQyxJQUFJLENBQUNXLElBQUksQ0FBQ2QsT0FBTyxFQUFFQSxPQUFPLENBQUMsaUJBQWlCLENBQUN3QyxHQUFHaE87WUFDckUsSUFBSUEsS0FBSyxLQUNMLE9BQU8rTixPQUFPM04sS0FBSyxDQUFDLEVBQUU7WUFDMUIsSUFBSUosS0FBSyxLQUNMLE9BQU87WUFDWCxJQUFLLElBQUlpTyxJQUFJak8sRUFBRWpCLE1BQU0sRUFBRWtQLElBQUksR0FBR0EsSUFBSztnQkFDL0IsSUFBSUMsSUFBSSxDQUFDbE8sRUFBRStCLEtBQUssQ0FBQyxHQUFHa007Z0JBQ3BCLElBQUlDLElBQUksS0FBS0EsSUFBSUgsT0FBTzNOLEtBQUssQ0FBQ3JCLE1BQU0sRUFDaEMsT0FBT2dQLE9BQU8zTixLQUFLLENBQUM4TixFQUFFLEdBQUdsTyxFQUFFK0IsS0FBSyxDQUFDa007WUFDekM7WUFDQSxPQUFPRDtRQUNYO0lBQ0o7SUFDQVQsU0FBU25LLEtBQUssRUFBRW9LLEtBQUssRUFBRTtRQUNuQixJQUFJakksU0FBUzRHLGFBQWEsSUFBSSxDQUFDRyxJQUFJLEVBQUVsSixPQUFPLEdBQUdBLE1BQU1iLEdBQUcsQ0FBQ3hELE1BQU0sR0FBR29LLFNBQVMsRUFBRTtRQUM3RSxNQUFPLENBQUM1RCxPQUFPN0YsSUFBSSxHQUFHUixJQUFJLENBQUU7WUFDeEIsSUFBSWlLLE9BQU9wSyxNQUFNLElBQUl5TyxPQUNqQixPQUFPO1lBQ1hyRSxPQUFPMUksSUFBSSxDQUFDOEUsT0FBT3RHLEtBQUs7UUFDNUI7UUFDQSxPQUFPa0s7SUFDWDtJQUNBc0UsVUFBVXJLLEtBQUssRUFBRXZFLElBQUksRUFBRUMsRUFBRSxFQUFFNE8sR0FBRyxFQUFFO1FBQzVCLElBQUluSSxTQUFTNEcsYUFBYSxJQUFJLENBQUNHLElBQUksRUFBRWxKLE9BQU84QixLQUFLRyxHQUFHLENBQUMsR0FBR3hHLE9BQU8sSUFBSSwwQkFBMEIsTUFBS3FHLEtBQUtJLEdBQUcsQ0FBQ3hHLEtBQUssSUFBSSwwQkFBMEIsS0FBSXNFLE1BQU1iLEdBQUcsQ0FBQ3hELE1BQU07UUFDbEssTUFBTyxDQUFDd0csT0FBTzdGLElBQUksR0FBR1IsSUFBSSxDQUN0QndPLElBQUluSSxPQUFPdEcsS0FBSyxDQUFDSixJQUFJLEVBQUUwRyxPQUFPdEcsS0FBSyxDQUFDSCxFQUFFO0lBQzlDO0FBQ0o7QUFDQTs7Ozs7O0FBTUEsR0FDQSxNQUFNcVAsaUJBQWlCLFdBQVcsR0FBRTFRLDBEQUFXQSxDQUFDaUksTUFBTTtBQUN0RCxNQUFNMEksY0FBYyxXQUFXLEdBQUUzUSwwREFBV0EsQ0FBQ2lJLE1BQU07QUFDbkQsTUFBTTJJLGNBQWMsV0FBVyxHQUFFM1EseURBQVVBLENBQUNnSSxNQUFNLENBQUM7SUFDL0NFLFFBQU94QyxLQUFLO1FBQ1IsT0FBTyxJQUFJa0wsWUFBWUMsYUFBYW5MLE9BQU93QyxNQUFNLElBQUk7SUFDekQ7SUFDQUMsUUFBTzVHLEtBQUssRUFBRTZHLEVBQUU7UUFDWixLQUFLLElBQUkwSSxVQUFVMUksR0FBRzVCLE9BQU8sQ0FBRTtZQUMzQixJQUFJc0ssT0FBT3hJLEVBQUUsQ0FBQ21JLGlCQUNWbFAsUUFBUSxJQUFJcVAsWUFBWUUsT0FBT3ZQLEtBQUssQ0FBQzJHLE1BQU0sSUFBSTNHLE1BQU1vSCxLQUFLO2lCQUN6RCxJQUFJbUksT0FBT3hJLEVBQUUsQ0FBQ29JLGNBQ2ZuUCxRQUFRLElBQUlxUCxZQUFZclAsTUFBTUwsS0FBSyxFQUFFNFAsT0FBT3ZQLEtBQUssR0FBR3dQLG9CQUFvQjtRQUNoRjtRQUNBLE9BQU94UDtJQUNYO0lBQ0FnSCxTQUFTQyxDQUFBQSxJQUFLbEosdURBQVNBLENBQUM2QixJQUFJLENBQUNxSCxHQUFHQyxDQUFBQSxNQUFPQSxJQUFJRSxLQUFLO0FBQ3BEO0FBQ0E7O0FBRUEsR0FDQSxTQUFTcUksZUFBZXRMLEtBQUs7SUFDekIsSUFBSXVMLFdBQVd2TCxNQUFNa0QsS0FBSyxDQUFDK0gsYUFBYTtJQUN4QyxPQUFPTSxXQUFXQSxTQUFTL1AsS0FBSyxDQUFDME4sSUFBSSxHQUFHaUMsYUFBYW5MO0FBQ3pEO0FBQ0E7O0FBRUEsR0FDQSxTQUFTd0wsZ0JBQWdCeEwsS0FBSztJQUMxQixJQUFJSjtJQUNKLE9BQU8sQ0FBQyxDQUFDQSxLQUFLSSxNQUFNa0QsS0FBSyxDQUFDK0gsYUFBYSxNQUFLLE1BQU8sUUFBUXJMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3FELEtBQUssS0FBSztBQUNyRztBQUNBLE1BQU1pSTtJQUNGNVAsWUFBWUUsS0FBSyxFQUFFeUgsS0FBSyxDQUFFO1FBQ3RCLElBQUksQ0FBQ3pILEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUN5SCxLQUFLLEdBQUdBO0lBQ2pCO0FBQ0o7QUFDQSxNQUFNd0ksWUFBWSxXQUFXLEdBQUUxUix3REFBVUEsQ0FBQ2dMLElBQUksQ0FBQztJQUFFekUsT0FBTztBQUFpQixJQUFJb0wsb0JBQW9CLFdBQVcsR0FBRTNSLHdEQUFVQSxDQUFDZ0wsSUFBSSxDQUFDO0lBQUV6RSxPQUFPO0FBQXlDO0FBQ2hMLE1BQU1xTCxvQkFBb0IsV0FBVyxHQUFFM1Isd0RBQVVBLENBQUNzTCxTQUFTLENBQUM7SUFDeERoSyxZQUFZeUUsSUFBSSxDQUFFO1FBQ2QsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDd0YsV0FBVyxHQUFHLElBQUksQ0FBQzhFLFNBQVMsQ0FBQ3RLLEtBQUtDLEtBQUssQ0FBQ2tELEtBQUssQ0FBQytIO0lBQ3ZEO0lBQ0F4SSxPQUFPQSxNQUFNLEVBQUU7UUFDWCxJQUFJekMsUUFBUXlDLE9BQU96QyxLQUFLLENBQUNrRCxLQUFLLENBQUMrSDtRQUMvQixJQUFJakwsU0FBU3lDLE9BQU9tSixVQUFVLENBQUMxSSxLQUFLLENBQUMrSCxnQkFBZ0J4SSxPQUFPaUQsVUFBVSxJQUFJakQsT0FBT2dELFlBQVksSUFBSWhELE9BQU9rRCxlQUFlLEVBQ25ILElBQUksQ0FBQ0osV0FBVyxHQUFHLElBQUksQ0FBQzhFLFNBQVMsQ0FBQ3JLO0lBQzFDO0lBQ0FxSyxVQUFVLEVBQUU3TyxLQUFLLEVBQUV5SCxLQUFLLEVBQUUsRUFBRTtRQUN4QixJQUFJLENBQUNBLFNBQVMsQ0FBQ3pILE1BQU0wTixJQUFJLENBQUNiLEtBQUssRUFDM0IsT0FBT3RPLHdEQUFVQSxDQUFDaU0sSUFBSTtRQUMxQixJQUFJLEVBQUVqRyxJQUFJLEVBQUUsR0FBRyxJQUFJO1FBQ25CLElBQUk4TCxVQUFVLElBQUlsUiw4REFBZUE7UUFDakMsSUFBSyxJQUFJaUMsSUFBSSxHQUFHbUosU0FBU2hHLEtBQUt5RyxhQUFhLEVBQUVxRSxJQUFJOUUsT0FBT3BLLE1BQU0sRUFBRWlCLElBQUlpTyxHQUFHak8sSUFBSztZQUN4RSxJQUFJLEVBQUVuQixJQUFJLEVBQUVDLEVBQUUsRUFBRSxHQUFHcUssTUFBTSxDQUFDbkosRUFBRTtZQUM1QixNQUFPQSxJQUFJaU8sSUFBSSxLQUFLblAsS0FBS3FLLE1BQU0sQ0FBQ25KLElBQUksRUFBRSxDQUFDbkIsSUFBSSxHQUFHLElBQUksSUFBSSwwQkFBMEIsSUFDNUVDLEtBQUtxSyxNQUFNLENBQUMsRUFBRW5KLEVBQUUsQ0FBQ2xCLEVBQUU7WUFDdkJGLE1BQU02TyxTQUFTLENBQUN0SyxLQUFLQyxLQUFLLEVBQUV2RSxNQUFNQyxJQUFJLENBQUNELE1BQU1DO2dCQUN6QyxJQUFJb1EsV0FBVy9MLEtBQUtDLEtBQUssQ0FBQ0MsU0FBUyxDQUFDOEYsTUFBTSxDQUFDbUIsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFMUwsSUFBSSxJQUFJQSxRQUFRMEwsRUFBRXpMLEVBQUUsSUFBSUE7Z0JBQy9FbVEsUUFBUXZCLEdBQUcsQ0FBQzdPLE1BQU1DLElBQUlvUSxXQUFXSixvQkFBb0JEO1lBQ3pEO1FBQ0o7UUFDQSxPQUFPSSxRQUFRRSxNQUFNO0lBQ3pCO0FBQ0osR0FBRztJQUNDeEcsYUFBYWtCLENBQUFBLElBQUtBLEVBQUVsQixXQUFXO0FBQ25DO0FBQ0EsU0FBU3lHLGNBQWNsSixDQUFDO0lBQ3BCLE9BQU8vQyxDQUFBQTtRQUNILElBQUlDLFFBQVFELEtBQUtDLEtBQUssQ0FBQ2tELEtBQUssQ0FBQytILGFBQWE7UUFDMUMsT0FBT2pMLFNBQVNBLE1BQU14RSxLQUFLLENBQUMwTixJQUFJLENBQUNiLEtBQUssR0FBR3ZGLEVBQUUvQyxNQUFNQyxTQUFTaU0sZ0JBQWdCbE07SUFDOUU7QUFDSjtBQUNBOzs7OztBQUtBLEdBQ0EsTUFBTW1NLFdBQVcsV0FBVyxHQUFFRixjQUFjLENBQUNqTSxNQUFNLEVBQUV2RSxLQUFLLEVBQUU7SUFDeEQsSUFBSSxFQUFFRSxFQUFFLEVBQUUsR0FBR3FFLEtBQUtDLEtBQUssQ0FBQ0MsU0FBUyxDQUFDQyxJQUFJO0lBQ3RDLElBQUk1RCxPQUFPZCxNQUFNbU8sU0FBUyxDQUFDNUosS0FBS0MsS0FBSyxFQUFFdEUsSUFBSUE7SUFDM0MsSUFBSSxDQUFDWSxNQUNELE9BQU87SUFDWCxJQUFJMkQsWUFBWTFGLDhEQUFlQSxDQUFDNFIsTUFBTSxDQUFDN1AsS0FBS2IsSUFBSSxFQUFFYSxLQUFLWixFQUFFO0lBQ3pELElBQUl1TSxTQUFTbEksS0FBS0MsS0FBSyxDQUFDNkYsS0FBSyxDQUFDMEI7SUFDOUJ4SCxLQUFLYyxRQUFRLENBQUM7UUFDVlo7UUFDQWEsU0FBUztZQUFDc0wsY0FBY3JNLE1BQU16RDtZQUFPMkwsT0FBT0YsYUFBYSxDQUFDOUgsVUFBVUMsSUFBSSxFQUFFSDtTQUFNO1FBQ2hGc00sV0FBVztJQUNmO0lBQ0FDLGtCQUFrQnZNO0lBQ2xCLE9BQU87QUFDWDtBQUNBOzs7O0FBSUEsR0FDQSxNQUFNd00sZUFBZSxXQUFXLEdBQUVQLGNBQWMsQ0FBQ2pNLE1BQU0sRUFBRXZFLEtBQUssRUFBRTtJQUM1RCxJQUFJLEVBQUV3RSxLQUFLLEVBQUUsR0FBR0QsTUFBTSxFQUFFdEUsSUFBSSxFQUFFLEdBQUd1RSxNQUFNQyxTQUFTLENBQUNDLElBQUk7SUFDckQsSUFBSXNNLE9BQU9oUixNQUFNdU8sU0FBUyxDQUFDL0osT0FBT3ZFLE1BQU1BO0lBQ3hDLElBQUksQ0FBQytRLE1BQ0QsT0FBTztJQUNYLElBQUl2TSxZQUFZMUYsOERBQWVBLENBQUM0UixNQUFNLENBQUNLLEtBQUsvUSxJQUFJLEVBQUUrUSxLQUFLOVEsRUFBRTtJQUN6RCxJQUFJdU0sU0FBU2xJLEtBQUtDLEtBQUssQ0FBQzZGLEtBQUssQ0FBQzBCO0lBQzlCeEgsS0FBS2MsUUFBUSxDQUFDO1FBQ1ZaO1FBQ0FhLFNBQVM7WUFBQ3NMLGNBQWNyTSxNQUFNeU07WUFBT3ZFLE9BQU9GLGFBQWEsQ0FBQzlILFVBQVVDLElBQUksRUFBRUg7U0FBTTtRQUNoRnNNLFdBQVc7SUFDZjtJQUNBQyxrQkFBa0J2TTtJQUNsQixPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU0wTSxnQkFBZ0IsV0FBVyxHQUFFVCxjQUFjLENBQUNqTSxNQUFNLEVBQUV2RSxLQUFLLEVBQUU7SUFDN0QsSUFBSXVLLFNBQVN2SyxNQUFNMk8sUUFBUSxDQUFDcEssS0FBS0MsS0FBSyxFQUFFO0lBQ3hDLElBQUksQ0FBQytGLFVBQVUsQ0FBQ0EsT0FBT3BLLE1BQU0sRUFDekIsT0FBTztJQUNYb0UsS0FBS2MsUUFBUSxDQUFDO1FBQ1ZaLFdBQVcxRiw4REFBZUEsQ0FBQ2lJLE1BQU0sQ0FBQ3VELE9BQU9hLEdBQUcsQ0FBQ08sQ0FBQUEsSUFBSzVNLDhEQUFlQSxDQUFDMEwsS0FBSyxDQUFDa0IsRUFBRTFMLElBQUksRUFBRTBMLEVBQUV6TCxFQUFFO1FBQ3BGMlEsV0FBVztJQUNmO0lBQ0EsT0FBTztBQUNYO0FBQ0E7O0FBRUEsR0FDQSxNQUFNSyx5QkFBeUIsQ0FBQyxFQUFFMU0sS0FBSyxFQUFFYSxRQUFRLEVBQUU7SUFDL0MsSUFBSWlGLE1BQU05RixNQUFNQyxTQUFTO0lBQ3pCLElBQUk2RixJQUFJQyxNQUFNLENBQUNwSyxNQUFNLEdBQUcsS0FBS21LLElBQUk1RixJQUFJLENBQUMxQyxLQUFLLEVBQ3ZDLE9BQU87SUFDWCxJQUFJLEVBQUUvQixJQUFJLEVBQUVDLEVBQUUsRUFBRSxHQUFHb0ssSUFBSTVGLElBQUk7SUFDM0IsSUFBSTZGLFNBQVMsRUFBRSxFQUFFN0YsT0FBTztJQUN4QixJQUFLLElBQUl5TSxNQUFNLElBQUl0UixhQUFhMkUsTUFBTWIsR0FBRyxFQUFFYSxNQUFNbUYsUUFBUSxDQUFDMUosTUFBTUMsTUFBTSxDQUFDaVIsSUFBSXJRLElBQUksR0FBR1IsSUFBSSxFQUFHO1FBQ3JGLElBQUlpSyxPQUFPcEssTUFBTSxHQUFHLE1BQ2hCLE9BQU87UUFDWCxJQUFJZ1IsSUFBSTlRLEtBQUssQ0FBQ0osSUFBSSxJQUFJQSxNQUNsQnlFLE9BQU82RixPQUFPcEssTUFBTTtRQUN4Qm9LLE9BQU8xSSxJQUFJLENBQUM5Qyw4REFBZUEsQ0FBQzBMLEtBQUssQ0FBQzBHLElBQUk5USxLQUFLLENBQUNKLElBQUksRUFBRWtSLElBQUk5USxLQUFLLENBQUNILEVBQUU7SUFDbEU7SUFDQW1GLFNBQVNiLE1BQU15QyxNQUFNLENBQUM7UUFDbEJ4QyxXQUFXMUYsOERBQWVBLENBQUNpSSxNQUFNLENBQUN1RCxRQUFRN0Y7UUFDMUNtTSxXQUFXO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU1PLGNBQWMsV0FBVyxHQUFFWixjQUFjLENBQUNqTSxNQUFNLEVBQUV2RSxLQUFLLEVBQUU7SUFDM0QsSUFBSSxFQUFFd0UsS0FBSyxFQUFFLEdBQUdELE1BQU0sRUFBRXRFLElBQUksRUFBRUMsRUFBRSxFQUFFLEdBQUdzRSxNQUFNQyxTQUFTLENBQUNDLElBQUk7SUFDekQsSUFBSUYsTUFBTTZNLFFBQVEsRUFDZCxPQUFPO0lBQ1gsSUFBSTdQLFFBQVF4QixNQUFNbU8sU0FBUyxDQUFDM0osT0FBT3ZFLE1BQU1BO0lBQ3pDLElBQUksQ0FBQ3VCLE9BQ0QsT0FBTztJQUNYLElBQUlWLE9BQU9VO0lBQ1gsSUFBSThQLFVBQVUsRUFBRSxFQUFFN00sV0FBVzhNO0lBQzdCLElBQUlqTSxVQUFVLEVBQUU7SUFDaEIsSUFBSXhFLEtBQUtiLElBQUksSUFBSUEsUUFBUWEsS0FBS1osRUFBRSxJQUFJQSxJQUFJO1FBQ3BDcVIsY0FBYy9NLE1BQU1nTixNQUFNLENBQUN4UixNQUFNeU8sY0FBYyxDQUFDM047UUFDaER3USxRQUFRelAsSUFBSSxDQUFDO1lBQUU1QixNQUFNYSxLQUFLYixJQUFJO1lBQUVDLElBQUlZLEtBQUtaLEVBQUU7WUFBRXVSLFFBQVFGO1FBQVk7UUFDakV6USxPQUFPZCxNQUFNbU8sU0FBUyxDQUFDM0osT0FBTzFELEtBQUtiLElBQUksRUFBRWEsS0FBS1osRUFBRTtRQUNoRG9GLFFBQVF6RCxJQUFJLENBQUN4RCx3REFBVUEsQ0FBQ3FULFFBQVEsQ0FBQ2xNLEVBQUUsQ0FBQ2hCLE1BQU1vQixNQUFNLENBQUMsNEJBQTRCcEIsTUFBTWIsR0FBRyxDQUFDZixNQUFNLENBQUMzQyxNQUFNMkUsTUFBTSxJQUFJO0lBQ2xIO0lBQ0EsSUFBSTlELE1BQU07UUFDTixJQUFJdUMsTUFBTWlPLFFBQVFuUixNQUFNLElBQUksS0FBS21SLE9BQU8sQ0FBQyxFQUFFLENBQUNyUixJQUFJLElBQUl1QixNQUFNdEIsRUFBRSxHQUFHLElBQUlzQixNQUFNdEIsRUFBRSxHQUFHc0IsTUFBTXZCLElBQUksR0FBR3NSLFlBQVlwUixNQUFNO1FBQzdHc0UsWUFBWTFGLDhEQUFlQSxDQUFDNFIsTUFBTSxDQUFDN1AsS0FBS2IsSUFBSSxHQUFHb0QsS0FBS3ZDLEtBQUtaLEVBQUUsR0FBR21EO1FBQzlEaUMsUUFBUXpELElBQUksQ0FBQytPLGNBQWNyTSxNQUFNekQ7UUFDakN3RSxRQUFRekQsSUFBSSxDQUFDMkMsTUFBTTZGLEtBQUssQ0FBQzBCLG1CQUFtQlEsYUFBYSxDQUFDOUgsVUFBVUMsSUFBSSxFQUFFSDtJQUM5RTtJQUNBQSxLQUFLYyxRQUFRLENBQUM7UUFDVmlNO1FBQVM3TTtRQUFXYTtRQUNwQnVMLFdBQVc7SUFDZjtJQUNBLE9BQU87QUFDWDtBQUNBOzs7QUFHQSxHQUNBLE1BQU1jLGFBQWEsV0FBVyxHQUFFbkIsY0FBYyxDQUFDak0sTUFBTSxFQUFFdkUsS0FBSyxFQUFFO0lBQzFELElBQUl1RSxLQUFLQyxLQUFLLENBQUM2TSxRQUFRLEVBQ25CLE9BQU87SUFDWCxJQUFJQyxVQUFVdFIsTUFBTTJPLFFBQVEsQ0FBQ3BLLEtBQUtDLEtBQUssRUFBRSxLQUFLNEcsR0FBRyxDQUFDNUosQ0FBQUE7UUFDOUMsSUFBSSxFQUFFdkIsSUFBSSxFQUFFQyxFQUFFLEVBQUUsR0FBR3NCO1FBQ25CLE9BQU87WUFBRXZCO1lBQU1DO1lBQUl1UixRQUFRelIsTUFBTXlPLGNBQWMsQ0FBQ2pOO1FBQU87SUFDM0Q7SUFDQSxJQUFJLENBQUM4UCxRQUFRblIsTUFBTSxFQUNmLE9BQU87SUFDWCxJQUFJeVIsZUFBZXJOLEtBQUtDLEtBQUssQ0FBQ29CLE1BQU0sQ0FBQyxzQkFBc0IwTCxRQUFRblIsTUFBTSxJQUFJO0lBQzdFb0UsS0FBS2MsUUFBUSxDQUFDO1FBQ1ZpTTtRQUNBaE0sU0FBU2pILHdEQUFVQSxDQUFDcVQsUUFBUSxDQUFDbE0sRUFBRSxDQUFDb007UUFDaENmLFdBQVc7SUFDZjtJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVNoQixrQkFBa0J0TCxJQUFJO0lBQzNCLE9BQU9BLEtBQUtDLEtBQUssQ0FBQzZGLEtBQUssQ0FBQzBCLG1CQUFtQk0sV0FBVyxDQUFDOUg7QUFDM0Q7QUFDQSxTQUFTb0wsYUFBYW5MLEtBQUssRUFBRXFOLFFBQVE7SUFDakMsSUFBSXpOLElBQUkwTixJQUFJQyxJQUFJQyxJQUFJQztJQUNwQixJQUFJM0gsTUFBTTlGLE1BQU1DLFNBQVMsQ0FBQ0MsSUFBSTtJQUM5QixJQUFJd04sVUFBVTVILElBQUl0SSxLQUFLLElBQUlzSSxJQUFJcEssRUFBRSxHQUFHb0ssSUFBSXJLLElBQUksR0FBRyxNQUFNLEtBQUt1RSxNQUFNbUYsUUFBUSxDQUFDVyxJQUFJckssSUFBSSxFQUFFcUssSUFBSXBLLEVBQUU7SUFDekYsSUFBSTJSLFlBQVksQ0FBQ0ssU0FDYixPQUFPTDtJQUNYLElBQUlwRixTQUFTakksTUFBTTZGLEtBQUssQ0FBQzBCO0lBQ3pCLE9BQU8sSUFBSVksWUFBWTtRQUNuQkgsUUFBUSxDQUFDLENBQUNwSSxLQUFLeU4sYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVMzRixPQUFPLE1BQU0sUUFBUTlILE9BQU8sS0FBSyxJQUFJQSxLQUFLcUksT0FBT1AsT0FBTyxJQUFJZ0csVUFBVUEsUUFBUXRGLE9BQU8sQ0FBQyxPQUFPO1FBQ3pLWCxlQUFlLENBQUM2RixLQUFLRCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBUzVGLGFBQWEsTUFBTSxRQUFRNkYsT0FBTyxLQUFLLElBQUlBLEtBQUtyRixPQUFPUixhQUFhO1FBQ3RKQyxTQUFTLENBQUM2RixLQUFLRixhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBUzNGLE9BQU8sTUFBTSxRQUFRNkYsT0FBTyxLQUFLLElBQUlBLEtBQUt0RixPQUFPUCxPQUFPO1FBQ3BJQyxRQUFRLENBQUM2RixLQUFLSCxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBUzFGLE1BQU0sTUFBTSxRQUFRNkYsT0FBTyxLQUFLLElBQUlBLEtBQUt2RixPQUFPTixNQUFNO1FBQ2pJQyxXQUFXLENBQUM2RixLQUFLSixhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU3pGLFNBQVMsTUFBTSxRQUFRNkYsT0FBTyxLQUFLLElBQUlBLEtBQUt4RixPQUFPTCxTQUFTO0lBQzlJO0FBQ0o7QUFDQSxTQUFTK0YsZUFBZTVOLElBQUk7SUFDeEIsSUFBSWtELFFBQVFuSiwwREFBUUEsQ0FBQ2lHLE1BQU1zTDtJQUMzQixPQUFPcEksU0FBU0EsTUFBTXpDLEdBQUcsQ0FBQzZDLGFBQWEsQ0FBQztBQUM1QztBQUNBLFNBQVNpSixrQkFBa0J2TSxJQUFJO0lBQzNCLElBQUlNLFFBQVFzTixlQUFlNU47SUFDM0IsSUFBSU0sU0FBU0EsU0FBU04sS0FBSzZOLElBQUksQ0FBQ0MsYUFBYSxFQUN6Q3hOLE1BQU1pRCxNQUFNO0FBQ3BCO0FBQ0E7O0FBRUEsR0FDQSxNQUFNMkksa0JBQWtCbE0sQ0FBQUE7SUFDcEIsSUFBSUMsUUFBUUQsS0FBS0MsS0FBSyxDQUFDa0QsS0FBSyxDQUFDK0gsYUFBYTtJQUMxQyxJQUFJakwsU0FBU0EsTUFBTWlELEtBQUssRUFBRTtRQUN0QixJQUFJNkssY0FBY0gsZUFBZTVOO1FBQ2pDLElBQUkrTixlQUFlQSxlQUFlL04sS0FBSzZOLElBQUksQ0FBQ0MsYUFBYSxFQUFFO1lBQ3ZELElBQUlyUyxRQUFRMlAsYUFBYXBMLEtBQUtDLEtBQUssRUFBRUEsTUFBTXhFLEtBQUssQ0FBQzBOLElBQUk7WUFDckQsSUFBSTFOLE1BQU02TSxLQUFLLEVBQ1h0SSxLQUFLYyxRQUFRLENBQUM7Z0JBQUVDLFNBQVNpSyxlQUFlL0osRUFBRSxDQUFDeEY7WUFBTztZQUN0RHNTLFlBQVk3TSxLQUFLO1lBQ2pCNk0sWUFBWXhLLE1BQU07UUFDdEI7SUFDSixPQUNLO1FBQ0R2RCxLQUFLYyxRQUFRLENBQUM7WUFBRUMsU0FBUztnQkFDakJrSyxZQUFZaEssRUFBRSxDQUFDO2dCQUNmaEIsUUFBUStLLGVBQWUvSixFQUFFLENBQUNtSyxhQUFhcEwsS0FBS0MsS0FBSyxFQUFFQSxNQUFNeEUsS0FBSyxDQUFDME4sSUFBSSxLQUFLN08sMERBQVdBLENBQUM4SSxZQUFZLENBQUNuQyxFQUFFLENBQUNrSDthQUN2RztRQUFDO0lBQ1Y7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU02RixtQkFBbUJoTyxDQUFBQTtJQUNyQixJQUFJQyxRQUFRRCxLQUFLQyxLQUFLLENBQUNrRCxLQUFLLENBQUMrSCxhQUFhO0lBQzFDLElBQUksQ0FBQ2pMLFNBQVMsQ0FBQ0EsTUFBTWlELEtBQUssRUFDdEIsT0FBTztJQUNYLElBQUlBLFFBQVFuSiwwREFBUUEsQ0FBQ2lHLE1BQU1zTDtJQUMzQixJQUFJcEksU0FBU0EsTUFBTXpDLEdBQUcsQ0FBQ3dOLFFBQVEsQ0FBQ2pPLEtBQUs2TixJQUFJLENBQUNDLGFBQWEsR0FDbkQ5TixLQUFLa0IsS0FBSztJQUNkbEIsS0FBS2MsUUFBUSxDQUFDO1FBQUVDLFNBQVNrSyxZQUFZaEssRUFBRSxDQUFDO0lBQU87SUFDL0MsT0FBTztBQUNYO0FBQ0E7Ozs7Ozs7O0FBUUEsR0FDQSxNQUFNaU4sZUFBZTtJQUNqQjtRQUFFQyxLQUFLO1FBQVNDLEtBQUtsQztRQUFpQm1DLE9BQU87SUFBc0I7SUFDbkU7UUFBRUYsS0FBSztRQUFNQyxLQUFLakM7UUFBVW1DLE9BQU85QjtRQUFjNkIsT0FBTztRQUF1QnhOLGdCQUFnQjtJQUFLO0lBQ3BHO1FBQUVzTixLQUFLO1FBQVNDLEtBQUtqQztRQUFVbUMsT0FBTzlCO1FBQWM2QixPQUFPO1FBQXVCeE4sZ0JBQWdCO0lBQUs7SUFDdkc7UUFBRXNOLEtBQUs7UUFBVUMsS0FBS0o7UUFBa0JLLE9BQU87SUFBc0I7SUFDckU7UUFBRUYsS0FBSztRQUFlQyxLQUFLekI7SUFBdUI7SUFDbEQ7UUFBRXdCLEtBQUs7UUFBYUMsS0FBS25MO0lBQVM7SUFDbEM7UUFBRWtMLEtBQUs7UUFBU0MsS0FBSy9HO1FBQXNCeEcsZ0JBQWdCO0lBQUs7Q0FDbkU7QUFDRCxNQUFNa0g7SUFDRnhNLFlBQVl5RSxJQUFJLENBQUU7UUFDZCxJQUFJLENBQUNBLElBQUksR0FBR0E7UUFDWixJQUFJdkUsUUFBUSxJQUFJLENBQUNBLEtBQUssR0FBR3VFLEtBQUtDLEtBQUssQ0FBQ2tELEtBQUssQ0FBQytILGFBQWF6UCxLQUFLLENBQUMwTixJQUFJO1FBQ2pFLElBQUksQ0FBQ29GLE1BQU0sR0FBRyxJQUFJLENBQUNBLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDLElBQUk7UUFDbkMsSUFBSSxDQUFDQyxXQUFXLEdBQUd6VCxpREFBR0EsQ0FBQyxTQUFTO1lBQzVCYyxPQUFPTCxNQUFNd00sTUFBTTtZQUNuQnlHLGFBQWFyTixPQUFPckIsTUFBTTtZQUMxQixjQUFjcUIsT0FBT3JCLE1BQU07WUFDM0JPLE9BQU87WUFDUEMsTUFBTTtZQUNObU8sTUFBTTtZQUNOLGNBQWM7WUFDZEMsVUFBVSxJQUFJLENBQUNMLE1BQU07WUFDckJNLFNBQVMsSUFBSSxDQUFDTixNQUFNO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDTyxZQUFZLEdBQUc5VCxpREFBR0EsQ0FBQyxTQUFTO1lBQzdCYyxPQUFPTCxNQUFNNE0sT0FBTztZQUNwQnFHLGFBQWFyTixPQUFPckIsTUFBTTtZQUMxQixjQUFjcUIsT0FBT3JCLE1BQU07WUFDM0JPLE9BQU87WUFDUEMsTUFBTTtZQUNObU8sTUFBTTtZQUNOQyxVQUFVLElBQUksQ0FBQ0wsTUFBTTtZQUNyQk0sU0FBUyxJQUFJLENBQUNOLE1BQU07UUFDeEI7UUFDQSxJQUFJLENBQUNRLFNBQVMsR0FBRy9ULGlEQUFHQSxDQUFDLFNBQVM7WUFDMUJzRyxNQUFNO1lBQ05kLE1BQU07WUFDTm1PLE1BQU07WUFDTkssU0FBU3ZULE1BQU1pTSxhQUFhO1lBQzVCa0gsVUFBVSxJQUFJLENBQUNMLE1BQU07UUFDekI7UUFDQSxJQUFJLENBQUNVLE9BQU8sR0FBR2pVLGlEQUFHQSxDQUFDLFNBQVM7WUFDeEJzRyxNQUFNO1lBQ05kLE1BQU07WUFDTm1PLE1BQU07WUFDTkssU0FBU3ZULE1BQU1tTSxNQUFNO1lBQ3JCZ0gsVUFBVSxJQUFJLENBQUNMLE1BQU07UUFDekI7UUFDQSxJQUFJLENBQUNXLFNBQVMsR0FBR2xVLGlEQUFHQSxDQUFDLFNBQVM7WUFDMUJzRyxNQUFNO1lBQ05kLE1BQU07WUFDTm1PLE1BQU07WUFDTkssU0FBU3ZULE1BQU1vTSxTQUFTO1lBQ3hCK0csVUFBVSxJQUFJLENBQUNMLE1BQU07UUFDekI7UUFDQSxTQUFTWSxPQUFPM08sSUFBSSxFQUFFZSxPQUFPLEVBQUU2TixPQUFPO1lBQ2xDLE9BQU9wVSxpREFBR0EsQ0FBQyxVQUFVO2dCQUFFdUYsT0FBTztnQkFBYUM7Z0JBQU1lO2dCQUFTRCxNQUFNO1lBQVMsR0FBRzhOO1FBQ2hGO1FBQ0EsSUFBSSxDQUFDM08sR0FBRyxHQUFHekYsaURBQUdBLENBQUMsT0FBTztZQUFFMEYsV0FBVyxDQUFDa0MsSUFBTSxJQUFJLENBQUN5TSxPQUFPLENBQUN6TTtZQUFJckMsT0FBTztRQUFZLEdBQUc7WUFDN0UsSUFBSSxDQUFDa08sV0FBVztZQUNoQlUsT0FBTyxRQUFRLElBQU1oRCxTQUFTbk0sT0FBTztnQkFBQ3FCLE9BQU9yQixNQUFNO2FBQVE7WUFDM0RtUCxPQUFPLFFBQVEsSUFBTTNDLGFBQWF4TSxPQUFPO2dCQUFDcUIsT0FBT3JCLE1BQU07YUFBWTtZQUNuRW1QLE9BQU8sVUFBVSxJQUFNekMsY0FBYzFNLE9BQU87Z0JBQUNxQixPQUFPckIsTUFBTTthQUFPO1lBQ2pFaEYsaURBQUdBLENBQUMsU0FBUyxNQUFNO2dCQUFDLElBQUksQ0FBQytULFNBQVM7Z0JBQUUxTixPQUFPckIsTUFBTTthQUFjO1lBQy9EaEYsaURBQUdBLENBQUMsU0FBUyxNQUFNO2dCQUFDLElBQUksQ0FBQ2lVLE9BQU87Z0JBQUU1TixPQUFPckIsTUFBTTthQUFVO1lBQ3pEaEYsaURBQUdBLENBQUMsU0FBUyxNQUFNO2dCQUFDLElBQUksQ0FBQ2tVLFNBQVM7Z0JBQUU3TixPQUFPckIsTUFBTTthQUFXO2VBQ3pEQSxLQUFLQyxLQUFLLENBQUM2TSxRQUFRLEdBQUcsRUFBRSxHQUFHO2dCQUMxQjlSLGlEQUFHQSxDQUFDO2dCQUNKLElBQUksQ0FBQzhULFlBQVk7Z0JBQ2pCSyxPQUFPLFdBQVcsSUFBTXRDLFlBQVk3TSxPQUFPO29CQUFDcUIsT0FBT3JCLE1BQU07aUJBQVc7Z0JBQ3BFbVAsT0FBTyxjQUFjLElBQU0vQixXQUFXcE4sT0FBTztvQkFBQ3FCLE9BQU9yQixNQUFNO2lCQUFlO2FBQzdFO1lBQ0RoRixpREFBR0EsQ0FBQyxVQUFVO2dCQUNWd0YsTUFBTTtnQkFDTmUsU0FBUyxJQUFNeU0saUJBQWlCaE87Z0JBQ2hDLGNBQWNxQixPQUFPckIsTUFBTTtnQkFDM0JzQixNQUFNO1lBQ1YsR0FBRztnQkFBQzthQUFJO1NBQ1g7SUFDTDtJQUNBaU4sU0FBUztRQUNMLElBQUk5UyxRQUFRLElBQUkyTSxZQUFZO1lBQ3hCSCxRQUFRLElBQUksQ0FBQ3dHLFdBQVcsQ0FBQzNTLEtBQUs7WUFDOUI0TCxlQUFlLElBQUksQ0FBQ3FILFNBQVMsQ0FBQ0MsT0FBTztZQUNyQ3BILFFBQVEsSUFBSSxDQUFDcUgsT0FBTyxDQUFDRCxPQUFPO1lBQzVCbkgsV0FBVyxJQUFJLENBQUNxSCxTQUFTLENBQUNGLE9BQU87WUFDakMzRyxTQUFTLElBQUksQ0FBQ3lHLFlBQVksQ0FBQ2hULEtBQUs7UUFDcEM7UUFDQSxJQUFJLENBQUNMLE1BQU1zTCxFQUFFLENBQUMsSUFBSSxDQUFDdEwsS0FBSyxHQUFHO1lBQ3ZCLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtZQUNiLElBQUksQ0FBQ3VFLElBQUksQ0FBQ2MsUUFBUSxDQUFDO2dCQUFFQyxTQUFTaUssZUFBZS9KLEVBQUUsQ0FBQ3hGO1lBQU87UUFDM0Q7SUFDSjtJQUNBNFQsUUFBUXpNLENBQUMsRUFBRTtRQUNQLElBQUkxSSxrRUFBZ0JBLENBQUMsSUFBSSxDQUFDOEYsSUFBSSxFQUFFNEMsR0FBRyxpQkFBaUI7WUFDaERBLEVBQUUvQixjQUFjO1FBQ3BCLE9BQ0ssSUFBSStCLEVBQUVoQyxPQUFPLElBQUksTUFBTWdDLEVBQUUwTSxNQUFNLElBQUksSUFBSSxDQUFDYixXQUFXLEVBQUU7WUFDdEQ3TCxFQUFFL0IsY0FBYztZQUNmK0IsQ0FBQUEsRUFBRTJNLFFBQVEsR0FBRy9DLGVBQWVMLFFBQU8sRUFBRyxJQUFJLENBQUNuTSxJQUFJO1FBQ3BELE9BQ0ssSUFBSTRDLEVBQUVoQyxPQUFPLElBQUksTUFBTWdDLEVBQUUwTSxNQUFNLElBQUksSUFBSSxDQUFDUixZQUFZLEVBQUU7WUFDdkRsTSxFQUFFL0IsY0FBYztZQUNoQmdNLFlBQVksSUFBSSxDQUFDN00sSUFBSTtRQUN6QjtJQUNKO0lBQ0EwQyxPQUFPQSxNQUFNLEVBQUU7UUFDWCxLQUFLLElBQUlDLE1BQU1ELE9BQU84TSxZQUFZLENBQzlCLEtBQUssSUFBSW5FLFVBQVUxSSxHQUFHNUIsT0FBTyxDQUFFO1lBQzNCLElBQUlzSyxPQUFPeEksRUFBRSxDQUFDbUksbUJBQW1CLENBQUNLLE9BQU92UCxLQUFLLENBQUNpTCxFQUFFLENBQUMsSUFBSSxDQUFDdEwsS0FBSyxHQUN4RCxJQUFJLENBQUNnVSxRQUFRLENBQUNwRSxPQUFPdlAsS0FBSztRQUNsQztJQUNSO0lBQ0EyVCxTQUFTaFUsS0FBSyxFQUFFO1FBQ1osSUFBSSxDQUFDQSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDZ1QsV0FBVyxDQUFDM1MsS0FBSyxHQUFHTCxNQUFNd00sTUFBTTtRQUNyQyxJQUFJLENBQUM2RyxZQUFZLENBQUNoVCxLQUFLLEdBQUdMLE1BQU00TSxPQUFPO1FBQ3ZDLElBQUksQ0FBQzBHLFNBQVMsQ0FBQ0MsT0FBTyxHQUFHdlQsTUFBTWlNLGFBQWE7UUFDNUMsSUFBSSxDQUFDdUgsT0FBTyxDQUFDRCxPQUFPLEdBQUd2VCxNQUFNbU0sTUFBTTtRQUNuQyxJQUFJLENBQUNzSCxTQUFTLENBQUNGLE9BQU8sR0FBR3ZULE1BQU1vTSxTQUFTO0lBQzVDO0lBQ0E2SCxRQUFRO1FBQ0osSUFBSSxDQUFDakIsV0FBVyxDQUFDbEwsTUFBTTtJQUMzQjtJQUNBLElBQUl6RyxNQUFNO1FBQUUsT0FBTztJQUFJO0lBQ3ZCLElBQUk4RyxNQUFNO1FBQUUsT0FBTyxJQUFJLENBQUM1RCxJQUFJLENBQUNDLEtBQUssQ0FBQzZGLEtBQUssQ0FBQzBCLG1CQUFtQjVELEdBQUc7SUFBRTtBQUNyRTtBQUNBLFNBQVN2QyxPQUFPckIsSUFBSSxFQUFFcUIsTUFBTTtJQUFJLE9BQU9yQixLQUFLQyxLQUFLLENBQUNvQixNQUFNLENBQUNBO0FBQVM7QUFDbEUsTUFBTXNPLGlCQUFpQjtBQUN2QixNQUFNQyxRQUFRO0FBQ2QsU0FBU3ZELGNBQWNyTSxJQUFJLEVBQUUsRUFBRXRFLElBQUksRUFBRUMsRUFBRSxFQUFFO0lBQ3JDLElBQUltRSxPQUFPRSxLQUFLQyxLQUFLLENBQUNiLEdBQUcsQ0FBQ2YsTUFBTSxDQUFDM0MsT0FBT21VLFVBQVU3UCxLQUFLQyxLQUFLLENBQUNiLEdBQUcsQ0FBQ2YsTUFBTSxDQUFDMUMsSUFBSUEsRUFBRTtJQUM5RSxJQUFJZ0IsUUFBUW9GLEtBQUtHLEdBQUcsQ0FBQ3BDLEtBQUtwRSxJQUFJLEVBQUVBLE9BQU9pVSxpQkFBaUJ6UyxNQUFNNkUsS0FBS0ksR0FBRyxDQUFDME4sU0FBU2xVLEtBQUtnVTtJQUNyRixJQUFJblUsT0FBT3dFLEtBQUtDLEtBQUssQ0FBQ21GLFFBQVEsQ0FBQ3pJLE9BQU9PO0lBQ3RDLElBQUlQLFNBQVNtRCxLQUFLcEUsSUFBSSxFQUFFO1FBQ3BCLElBQUssSUFBSW1CLElBQUksR0FBR0EsSUFBSThTLGdCQUFnQjlTLElBQ2hDLElBQUksQ0FBQytTLE1BQU0vVCxJQUFJLENBQUNMLElBQUksQ0FBQ3FCLElBQUksRUFBRSxLQUFLK1MsTUFBTS9ULElBQUksQ0FBQ0wsSUFBSSxDQUFDcUIsRUFBRSxHQUFHO1lBQ2pEckIsT0FBT0EsS0FBS29ELEtBQUssQ0FBQy9CO1lBQ2xCO1FBQ0o7SUFDUjtJQUNBLElBQUlLLE9BQU8yUyxTQUFTO1FBQ2hCLElBQUssSUFBSWhULElBQUlyQixLQUFLSSxNQUFNLEdBQUcsR0FBR2lCLElBQUlyQixLQUFLSSxNQUFNLEdBQUcrVCxnQkFBZ0I5UyxJQUM1RCxJQUFJLENBQUMrUyxNQUFNL1QsSUFBSSxDQUFDTCxJQUFJLENBQUNxQixJQUFJLEVBQUUsS0FBSytTLE1BQU0vVCxJQUFJLENBQUNMLElBQUksQ0FBQ3FCLEVBQUUsR0FBRztZQUNqRHJCLE9BQU9BLEtBQUtvRCxLQUFLLENBQUMsR0FBRy9CO1lBQ3JCO1FBQ0o7SUFDUjtJQUNBLE9BQU8vQyx3REFBVUEsQ0FBQ3FULFFBQVEsQ0FBQ2xNLEVBQUUsQ0FBQyxDQUFDLEVBQUVqQixLQUFLQyxLQUFLLENBQUNvQixNQUFNLENBQUMsaUJBQWlCLEVBQUUsRUFBRTdGLEtBQUssQ0FBQyxFQUFFd0UsS0FBS0MsS0FBSyxDQUFDb0IsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFdkIsS0FBS08sTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNsSTtBQUNBLE1BQU1tRCxZQUFZLFdBQVcsR0FBRTFKLHdEQUFVQSxDQUFDMEosU0FBUyxDQUFDO0lBQ2hELHVCQUF1QjtRQUNuQkMsU0FBUztRQUNUQyxVQUFVO1FBQ1Ysa0JBQWtCO1lBQ2RBLFVBQVU7WUFDVkUsS0FBSztZQUNMRSxPQUFPO1lBQ1BDLGlCQUFpQjtZQUNqQkMsUUFBUTtZQUNSQyxNQUFNO1lBQ05SLFNBQVM7WUFDVHFNLFFBQVE7UUFDWjtRQUNBLDhCQUE4QjtZQUMxQkEsUUFBUTtRQUNaO1FBQ0EsMEJBQTBCO1lBQ3RCQyxhQUFhO1FBQ2pCO1FBQ0EsV0FBVztZQUNQcE0sVUFBVTtZQUNWcU0sWUFBWTtRQUNoQjtJQUNKO0lBQ0EsMEJBQTBCO1FBQUVqTSxpQkFBaUI7SUFBWTtJQUN6RCx5QkFBeUI7UUFBRUEsaUJBQWlCO0lBQVk7SUFDeEQsbUNBQW1DO1FBQUVBLGlCQUFpQjtJQUFZO0lBQ2xFLGtDQUFrQztRQUFFQSxpQkFBaUI7SUFBWTtBQUNyRTtBQUNBLE1BQU1vRSxtQkFBbUI7SUFDckIrQztJQUNBLFdBQVcsR0FBRXJRLG1EQUFJQSxDQUFDb1YsR0FBRyxDQUFDckU7SUFDdEJwSTtDQUNIO0FBRStTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja25pY2hlLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3NlYXJjaC9kaXN0L2luZGV4LmpzP2NkMmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2hvd1BhbmVsLCBFZGl0b3JWaWV3LCBnZXRQYW5lbCwgRGVjb3JhdGlvbiwgVmlld1BsdWdpbiwgcnVuU2NvcGVIYW5kbGVycyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuaW1wb3J0IHsgY29kZVBvaW50QXQsIGZyb21Db2RlUG9pbnQsIGNvZGVQb2ludFNpemUsIFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBFZGl0b3JTZWxlY3Rpb24sIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBDaGFyQ2F0ZWdvcnksIFJhbmdlU2V0QnVpbGRlciwgUHJlYywgRWRpdG9yU3RhdGUsIGZpbmRDbHVzdGVyQnJlYWsgfSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSc7XG5pbXBvcnQgZWx0IGZyb20gJ2NyZWx0JztcblxuY29uc3QgYmFzaWNOb3JtYWxpemUgPSB0eXBlb2YgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemUgPT0gXCJmdW5jdGlvblwiXG4gICAgPyB4ID0+IHgubm9ybWFsaXplKFwiTkZLRFwiKSA6IHggPT4geDtcbi8qKlxuQSBzZWFyY2ggY3Vyc29yIHByb3ZpZGVzIGFuIGl0ZXJhdG9yIG92ZXIgdGV4dCBtYXRjaGVzIGluIGFcbmRvY3VtZW50LlxuKi9cbmNsYXNzIFNlYXJjaEN1cnNvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGV4dCBjdXJzb3IuIFRoZSBxdWVyeSBpcyB0aGUgc2VhcmNoIHN0cmluZywgYGZyb21gIHRvXG4gICAgYHRvYCBwcm92aWRlcyB0aGUgcmVnaW9uIHRvIHNlYXJjaC5cbiAgICBcbiAgICBXaGVuIGBub3JtYWxpemVgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIGNhbGxlZCwgb24gYm90aCB0aGUgcXVlcnlcbiAgICBzdHJpbmcgYW5kIHRoZSBjb250ZW50IGl0IGlzIG1hdGNoZWQgYWdhaW5zdCwgYmVmb3JlIGNvbXBhcmluZy5cbiAgICBZb3UgY2FuLCBmb3IgZXhhbXBsZSwgY3JlYXRlIGEgY2FzZS1pbnNlbnNpdGl2ZSBzZWFyY2ggYnlcbiAgICBwYXNzaW5nIGBzID0+IHMudG9Mb3dlckNhc2UoKWAuXG4gICAgXG4gICAgVGV4dCBpcyBhbHdheXMgbm9ybWFsaXplZCB3aXRoXG4gICAgW2Aubm9ybWFsaXplKFwiTkZLRFwiKWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9ub3JtYWxpemUpXG4gICAgKHdoZW4gc3VwcG9ydGVkKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBmcm9tID0gMCwgdG8gPSB0ZXh0Lmxlbmd0aCwgbm9ybWFsaXplLCB0ZXN0KSB7XG4gICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgY3VycmVudCBtYXRjaCAob25seSBob2xkcyBhIG1lYW5pbmdmdWwgdmFsdWUgYWZ0ZXJcbiAgICAgICAgW2BuZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLm5leHQpIGhhcyBiZWVuIGNhbGxlZCBhbmQgd2hlblxuICAgICAgICBgZG9uZWAgaXMgZmFsc2UpLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tOiAwLCB0bzogMCB9O1xuICAgICAgICAvKipcbiAgICAgICAgV2hldGhlciB0aGUgZW5kIG9mIHRoZSBpdGVyYXRlZCByZWdpb24gaGFzIGJlZW4gcmVhY2hlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IFtdO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIHRoaXMuYnVmZmVyUG9zID0gMDtcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICB0aGlzLmJ1ZmZlclN0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemUgPSBub3JtYWxpemUgPyB4ID0+IG5vcm1hbGl6ZShiYXNpY05vcm1hbGl6ZSh4KSkgOiBiYXNpY05vcm1hbGl6ZTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMubm9ybWFsaXplKHF1ZXJ5KTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyUG9zID09IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJTdGFydCArPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLml0ZXIubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXRlci5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zID0gMDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5pdGVyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnRBdCh0aGlzLmJ1ZmZlciwgdGhpcy5idWZmZXJQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBMb29rIGZvciB0aGUgbmV4dCBtYXRjaC4gVXBkYXRlcyB0aGUgaXRlcmF0b3Inc1xuICAgIFtgdmFsdWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IudmFsdWUpIGFuZFxuICAgIFtgZG9uZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci5kb25lKSBwcm9wZXJ0aWVzLiBTaG91bGQgYmUgY2FsbGVkXG4gICAgYXQgbGVhc3Qgb25jZSBiZWZvcmUgdXNpbmcgdGhlIGN1cnNvci5cbiAgICAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLm1hdGNoZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5tYXRjaGVzLnBvcCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGBuZXh0YCBtZXRob2Qgd2lsbCBpZ25vcmUgbWF0Y2hlcyB0aGF0IHBhcnRpYWxseSBvdmVybGFwIGFcbiAgICBwcmV2aW91cyBtYXRjaC4gVGhpcyBtZXRob2QgYmVoYXZlcyBsaWtlIGBuZXh0YCwgYnV0IGluY2x1ZGVzXG4gICAgc3VjaCBtYXRjaGVzLlxuICAgICovXG4gICAgbmV4dE92ZXJsYXBwaW5nKCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMucGVlaygpO1xuICAgICAgICAgICAgaWYgKG5leHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdHIgPSBmcm9tQ29kZVBvaW50KG5leHQpLCBzdGFydCA9IHRoaXMuYnVmZmVyU3RhcnQgKyB0aGlzLmJ1ZmZlclBvcztcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUG9zICs9IGNvZGVQb2ludFNpemUobmV4dCk7XG4gICAgICAgICAgICBsZXQgbm9ybSA9IHRoaXMubm9ybWFsaXplKHN0cik7XG4gICAgICAgICAgICBpZiAobm9ybS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2RlID0gbm9ybS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoKGNvZGUsIHBvcywgdGhpcy5idWZmZXJQb3MgKyB0aGlzLmJ1ZmZlclN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gbm9ybS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID09IHN0YXJ0ICYmIGkgPCBzdHIubGVuZ3RoICYmIHN0ci5jaGFyQ29kZUF0KGkpID09IGNvZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2goY29kZSwgcG9zLCBlbmQpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hdGNoZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMubWF0Y2hlc1tpXSwga2VlcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkuY2hhckNvZGVBdChpbmRleCkgPT0gY29kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLnF1ZXJ5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB7IGZyb206IHRoaXMubWF0Y2hlc1tpICsgMV0sIHRvOiBlbmQgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlc1tpXSsrO1xuICAgICAgICAgICAgICAgICAgICBrZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtlZXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWVyeS5jaGFyQ29kZUF0KDApID09IGNvZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIG1hdGNoID0geyBmcm9tOiBwb3MsIHRvOiBlbmQgfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMucHVzaCgxLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCAmJiB0aGlzLnRlc3QgJiYgIXRoaXMudGVzdChtYXRjaC5mcm9tLCBtYXRjaC50bywgdGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyU3RhcnQpKVxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxufVxuaWYgKHR5cGVvZiBTeW1ib2wgIT0gXCJ1bmRlZmluZWRcIilcbiAgICBTZWFyY2hDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5jb25zdCBlbXB0eSA9IHsgZnJvbTogLTEsIHRvOiAtMSwgbWF0Y2g6IC8qQF9fUFVSRV9fKi8vLiovLmV4ZWMoXCJcIikgfTtcbmNvbnN0IGJhc2VGbGFncyA9IFwiZ21cIiArICgveC8udW5pY29kZSA9PSBudWxsID8gXCJcIiA6IFwidVwiKTtcbi8qKlxuVGhpcyBjbGFzcyBpcyBzaW1pbGFyIHRvIFtgU2VhcmNoQ3Vyc29yYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yKVxuYnV0IHNlYXJjaGVzIGZvciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIGluc3RlYWQgb2YgYSBwbGFpblxuc3RyaW5nLlxuKi9cbmNsYXNzIFJlZ0V4cEN1cnNvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY3Vyc29yIHRoYXQgd2lsbCBzZWFyY2ggdGhlIGdpdmVuIHJhbmdlIGluIHRoZSBnaXZlblxuICAgIGRvY3VtZW50LiBgcXVlcnlgIHNob3VsZCBiZSB0aGUgcmF3IHBhdHRlcm4gKGFzIHlvdSdkIHBhc3MgaXQgdG9cbiAgICBgbmV3IFJlZ0V4cGApLlxuICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20gPSAwLCB0byA9IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgIFNldCB0byBgdHJ1ZWAgd2hlbiB0aGUgY3Vyc29yIGhhcyByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHNlYXJjaFxuICAgICAgICByYW5nZS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBXaWxsIGNvbnRhaW4gYW4gb2JqZWN0IHdpdGggdGhlIGV4dGVudCBvZiB0aGUgbWF0Y2ggYW5kIHRoZVxuICAgICAgICBtYXRjaCBvYmplY3Qgd2hlbiBbYG5leHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5SZWdFeHBDdXJzb3IubmV4dClcbiAgICAgICAgc3VjZXNzZnVsbHkgZmluZHMgYSBtYXRjaC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IGVtcHR5O1xuICAgICAgICBpZiAoL1xcXFxbc1dEbnJdfFxcbnxcXHJ8XFxbXFxeLy50ZXN0KHF1ZXJ5KSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgTXVsdGlsaW5lUmVnRXhwQ3Vyc29yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tLCB0byk7XG4gICAgICAgIHRoaXMucmUgPSBuZXcgUmVnRXhwKHF1ZXJ5LCBiYXNlRmxhZ3MgKyAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pZ25vcmVDYXNlKSA/IFwiaVwiIDogXCJcIikpO1xuICAgICAgICB0aGlzLnRlc3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGVzdDtcbiAgICAgICAgdGhpcy5pdGVyID0gdGV4dC5pdGVyKCk7XG4gICAgICAgIGxldCBzdGFydExpbmUgPSB0ZXh0LmxpbmVBdChmcm9tKTtcbiAgICAgICAgdGhpcy5jdXJMaW5lU3RhcnQgPSBzdGFydExpbmUuZnJvbTtcbiAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0ZXh0LCBmcm9tKTtcbiAgICAgICAgdGhpcy5nZXRMaW5lKHRoaXMuY3VyTGluZVN0YXJ0KTtcbiAgICB9XG4gICAgZ2V0TGluZShza2lwKSB7XG4gICAgICAgIHRoaXMuaXRlci5uZXh0KHNraXApO1xuICAgICAgICBpZiAodGhpcy5pdGVyLmxpbmVCcmVhaykge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuaXRlci52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggPiB0aGlzLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuY3VyTGluZS5zbGljZSgwLCB0aGlzLnRvIC0gdGhpcy5jdXJMaW5lU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5pdGVyLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgICAgdGhpcy5jdXJMaW5lU3RhcnQgPSB0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggKyAxO1xuICAgICAgICBpZiAodGhpcy5jdXJMaW5lU3RhcnQgPiB0aGlzLnRvKVxuICAgICAgICAgICAgdGhpcy5jdXJMaW5lID0gXCJcIjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKDApO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG1hdGNoLCBpZiB0aGVyZSBpcyBvbmUuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKGxldCBvZmYgPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5jdXJMaW5lU3RhcnQ7Oykge1xuICAgICAgICAgICAgdGhpcy5yZS5sYXN0SW5kZXggPSBvZmY7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLm1hdGNoUG9zIDw9IHRoaXMudG8gJiYgdGhpcy5yZS5leGVjKHRoaXMuY3VyTGluZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMuY3VyTGluZVN0YXJ0ICsgbWF0Y2guaW5kZXgsIHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRoaXMudGV4dCwgdG8gKyAoZnJvbSA9PSB0byA/IDEgOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gdGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgaWYgKChmcm9tIDwgdG8gfHwgZnJvbSA+IHRoaXMudmFsdWUudG8pICYmICghdGhpcy50ZXN0IHx8IHRoaXMudGVzdChmcm9tLCB0bywgbWF0Y2gpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0geyBmcm9tLCB0bywgbWF0Y2ggfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZiA9IHRoaXMubWF0Y2hQb3MgLSB0aGlzLmN1ckxpbmVTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aCA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgb2ZmID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBmbGF0dGVuZWQgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8vIFJldXNhYmxlIChwYXJ0aWFsbHkpIGZsYXR0ZW5lZCBkb2N1bWVudCBzdHJpbmdzXG5jbGFzcyBGbGF0dGVuZWREb2Mge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRleHQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIHN0YXRpYyBnZXQoZG9jLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgY2FjaGVkID0gZmxhdHRlbmVkLmdldChkb2MpO1xuICAgICAgICBpZiAoIWNhY2hlZCB8fCBjYWNoZWQuZnJvbSA+PSB0byB8fCBjYWNoZWQudG8gPD0gZnJvbSkge1xuICAgICAgICAgICAgbGV0IGZsYXQgPSBuZXcgRmxhdHRlbmVkRG9jKGZyb20sIGRvYy5zbGljZVN0cmluZyhmcm9tLCB0bykpO1xuICAgICAgICAgICAgZmxhdHRlbmVkLnNldChkb2MsIGZsYXQpO1xuICAgICAgICAgICAgcmV0dXJuIGZsYXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlZC5mcm9tID09IGZyb20gJiYgY2FjaGVkLnRvID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbTogY2FjaGVkRnJvbSB9ID0gY2FjaGVkO1xuICAgICAgICBpZiAoY2FjaGVkRnJvbSA+IGZyb20pIHtcbiAgICAgICAgICAgIHRleHQgPSBkb2Muc2xpY2VTdHJpbmcoZnJvbSwgY2FjaGVkRnJvbSkgKyB0ZXh0O1xuICAgICAgICAgICAgY2FjaGVkRnJvbSA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlZC50byA8IHRvKVxuICAgICAgICAgICAgdGV4dCArPSBkb2Muc2xpY2VTdHJpbmcoY2FjaGVkLnRvLCB0byk7XG4gICAgICAgIGZsYXR0ZW5lZC5zZXQoZG9jLCBuZXcgRmxhdHRlbmVkRG9jKGNhY2hlZEZyb20sIHRleHQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGbGF0dGVuZWREb2MoZnJvbSwgdGV4dC5zbGljZShmcm9tIC0gY2FjaGVkRnJvbSwgdG8gLSBjYWNoZWRGcm9tKSk7XG4gICAgfVxufVxuY2xhc3MgTXVsdGlsaW5lUmVnRXhwQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGVtcHR5O1xuICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRleHQsIGZyb20pO1xuICAgICAgICB0aGlzLnJlID0gbmV3IFJlZ0V4cChxdWVyeSwgYmFzZUZsYWdzICsgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWdub3JlQ2FzZSkgPyBcImlcIiA6IFwiXCIpKTtcbiAgICAgICAgdGhpcy50ZXN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRlc3Q7XG4gICAgICAgIHRoaXMuZmxhdCA9IEZsYXR0ZW5lZERvYy5nZXQodGV4dCwgZnJvbSwgdGhpcy5jaHVua0VuZChmcm9tICsgNTAwMCAvKiBDaHVuay5CYXNlICovKSk7XG4gICAgfVxuICAgIGNodW5rRW5kKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zID49IHRoaXMudG8gPyB0aGlzLnRvIDogdGhpcy50ZXh0LmxpbmVBdChwb3MpLnRvO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgb2ZmID0gdGhpcy5yZS5sYXN0SW5kZXggPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5mbGF0LmZyb207XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnJlLmV4ZWModGhpcy5mbGF0LnRleHQpO1xuICAgICAgICAgICAgLy8gU2tpcCBlbXB0eSBtYXRjaGVzIGRpcmVjdGx5IGFmdGVyIHRoZSBsYXN0IG1hdGNoXG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgIW1hdGNoWzBdICYmIG1hdGNoLmluZGV4ID09IG9mZikge1xuICAgICAgICAgICAgICAgIHRoaXMucmUubGFzdEluZGV4ID0gb2ZmICsgMTtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRoaXMucmUuZXhlYyh0aGlzLmZsYXQudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMuZmxhdC5mcm9tICsgbWF0Y2guaW5kZXgsIHRvID0gZnJvbSArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG1hdGNoIGdvZXMgYWxtb3N0IHRvIHRoZSBlbmQgb2YgYSBub25jb21wbGV0ZSBjaHVuaywgdHJ5XG4gICAgICAgICAgICAgICAgLy8gYWdhaW4sIHNpbmNlIGl0J2xsIGxpa2VseSBiZSBhYmxlIHRvIG1hdGNoIG1vcmVcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuZmxhdC50byA+PSB0aGlzLnRvIHx8IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDw9IHRoaXMuZmxhdC50ZXh0Lmxlbmd0aCAtIDEwKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIXRoaXMudGVzdCB8fCB0aGlzLnRlc3QoZnJvbSwgdG8sIG1hdGNoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbSwgdG8sIG1hdGNoIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGhpcy50ZXh0LCB0byArIChmcm9tID09IHRvID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZmxhdC50byA9PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdyb3cgdGhlIGZsYXR0ZW5lZCBkb2NcbiAgICAgICAgICAgIHRoaXMuZmxhdCA9IEZsYXR0ZW5lZERvYy5nZXQodGhpcy50ZXh0LCB0aGlzLmZsYXQuZnJvbSwgdGhpcy5jaHVua0VuZCh0aGlzLmZsYXQuZnJvbSArIHRoaXMuZmxhdC50ZXh0Lmxlbmd0aCAqIDIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBSZWdFeHBDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBNdWx0aWxpbmVSZWdFeHBDdXJzb3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPVxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xufVxuZnVuY3Rpb24gdmFsaWRSZWdFeHAoc291cmNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChzb3VyY2UsIGJhc2VGbGFncyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvQ2hhckVuZCh0ZXh0LCBwb3MpIHtcbiAgICBpZiAocG9zID49IHRleHQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGxldCBsaW5lID0gdGV4dC5saW5lQXQocG9zKSwgbmV4dDtcbiAgICB3aGlsZSAocG9zIDwgbGluZS50byAmJiAobmV4dCA9IGxpbmUudGV4dC5jaGFyQ29kZUF0KHBvcyAtIGxpbmUuZnJvbSkpID49IDB4REMwMCAmJiBuZXh0IDwgMHhFMDAwKVxuICAgICAgICBwb3MrKztcbiAgICByZXR1cm4gcG9zO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5lRGlhbG9nKHZpZXcpIHtcbiAgICBsZXQgbGluZSA9IFN0cmluZyh2aWV3LnN0YXRlLmRvYy5saW5lQXQodmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKS5udW1iZXIpO1xuICAgIGxldCBpbnB1dCA9IGVsdChcImlucHV0XCIsIHsgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsIG5hbWU6IFwibGluZVwiLCB2YWx1ZTogbGluZSB9KTtcbiAgICBsZXQgZG9tID0gZWx0KFwiZm9ybVwiLCB7XG4gICAgICAgIGNsYXNzOiBcImNtLWdvdG9MaW5lXCIsXG4gICAgICAgIG9ua2V5ZG93bjogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNykgeyAvLyBFc2NhcGVcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBkaWFsb2dFZmZlY3Qub2YoZmFsc2UpIH0pO1xuICAgICAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT0gMTMpIHsgLy8gRW50ZXJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uc3VibWl0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBnbygpO1xuICAgICAgICB9XG4gICAgfSwgZWx0KFwibGFiZWxcIiwgdmlldy5zdGF0ZS5waHJhc2UoXCJHbyB0byBsaW5lXCIpLCBcIjogXCIsIGlucHV0KSwgXCIgXCIsIGVsdChcImJ1dHRvblwiLCB7IGNsYXNzOiBcImNtLWJ1dHRvblwiLCB0eXBlOiBcInN1Ym1pdFwiIH0sIHZpZXcuc3RhdGUucGhyYXNlKFwiZ29cIikpLCBlbHQoXCJidXR0b25cIiwge1xuICAgICAgICBuYW1lOiBcImNsb3NlXCIsXG4gICAgICAgIG9uY2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBkaWFsb2dFZmZlY3Qub2YoZmFsc2UpIH0pO1xuICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICB9LFxuICAgICAgICBcImFyaWEtbGFiZWxcIjogdmlldy5zdGF0ZS5waHJhc2UoXCJjbG9zZVwiKSxcbiAgICAgICAgdHlwZTogXCJidXR0b25cIlxuICAgIH0sIFtcIsOXXCJdKSk7XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IC9eKFsrLV0pPyhcXGQrKT8oOlxcZCspPyglKT8kLy5leGVjKGlucHV0LnZhbHVlKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHN0YXJ0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQoc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgIGxldCBbLCBzaWduLCBsbiwgY2wsIHBlcmNlbnRdID0gbWF0Y2g7XG4gICAgICAgIGxldCBjb2wgPSBjbCA/ICtjbC5zbGljZSgxKSA6IDA7XG4gICAgICAgIGxldCBsaW5lID0gbG4gPyArbG4gOiBzdGFydExpbmUubnVtYmVyO1xuICAgICAgICBpZiAobG4gJiYgcGVyY2VudCkge1xuICAgICAgICAgICAgbGV0IHBjID0gbGluZSAvIDEwMDtcbiAgICAgICAgICAgIGlmIChzaWduKVxuICAgICAgICAgICAgICAgIHBjID0gcGMgKiAoc2lnbiA9PSBcIi1cIiA/IC0xIDogMSkgKyAoc3RhcnRMaW5lLm51bWJlciAvIHN0YXRlLmRvYy5saW5lcyk7XG4gICAgICAgICAgICBsaW5lID0gTWF0aC5yb3VuZChzdGF0ZS5kb2MubGluZXMgKiBwYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobG4gJiYgc2lnbikge1xuICAgICAgICAgICAgbGluZSA9IGxpbmUgKiAoc2lnbiA9PSBcIi1cIiA/IC0xIDogMSkgKyBzdGFydExpbmUubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkb2NMaW5lID0gc3RhdGUuZG9jLmxpbmUoTWF0aC5tYXgoMSwgTWF0aC5taW4oc3RhdGUuZG9jLmxpbmVzLCBsaW5lKSkpO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihkb2NMaW5lLmZyb20gKyBNYXRoLm1heCgwLCBNYXRoLm1pbihjb2wsIGRvY0xpbmUubGVuZ3RoKSkpO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGVmZmVjdHM6IFtkaWFsb2dFZmZlY3Qub2YoZmFsc2UpLCBFZGl0b3JWaWV3LnNjcm9sbEludG9WaWV3KHNlbGVjdGlvbi5mcm9tLCB7IHk6ICdjZW50ZXInIH0pXSxcbiAgICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9tIH07XG59XG5jb25zdCBkaWFsb2dFZmZlY3QgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBkaWFsb2dGaWVsZCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGUgb2YgdHIuZWZmZWN0cylcbiAgICAgICAgICAgIGlmIChlLmlzKGRpYWxvZ0VmZmVjdCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlLnZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IHNob3dQYW5lbC5mcm9tKGYsIHZhbCA9PiB2YWwgPyBjcmVhdGVMaW5lRGlhbG9nIDogbnVsbClcbn0pO1xuLyoqXG5Db21tYW5kIHRoYXQgc2hvd3MgYSBkaWFsb2cgYXNraW5nIHRoZSB1c2VyIGZvciBhIGxpbmUgbnVtYmVyLCBhbmRcbndoZW4gYSB2YWxpZCBwb3NpdGlvbiBpcyBwcm92aWRlZCwgbW92ZXMgdGhlIGN1cnNvciB0byB0aGF0IGxpbmUuXG5cblN1cHBvcnRzIGxpbmUgbnVtYmVycywgcmVsYXRpdmUgbGluZSBvZmZzZXRzIHByZWZpeGVkIHdpdGggYCtgIG9yXG5gLWAsIGRvY3VtZW50IHBlcmNlbnRhZ2VzIHN1ZmZpeGVkIHdpdGggYCVgLCBhbmQgYW4gb3B0aW9uYWxcbmNvbHVtbiBwb3NpdGlvbiBieSBhZGRpbmcgYDpgIGFuZCBhIHNlY29uZCBudW1iZXIgYWZ0ZXIgdGhlIGxpbmVcbm51bWJlci5cbiovXG5jb25zdCBnb3RvTGluZSA9IHZpZXcgPT4ge1xuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZUxpbmVEaWFsb2cpO1xuICAgIGlmICghcGFuZWwpIHtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBbZGlhbG9nRWZmZWN0Lm9mKHRydWUpXTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmllbGQoZGlhbG9nRmllbGQsIGZhbHNlKSA9PSBudWxsKVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihbZGlhbG9nRmllbGQsIGJhc2VUaGVtZSQxXSkpO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0cyB9KTtcbiAgICAgICAgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVMaW5lRGlhbG9nKTtcbiAgICB9XG4gICAgaWYgKHBhbmVsKVxuICAgICAgICBwYW5lbC5kb20ucXVlcnlTZWxlY3RvcihcImlucHV0XCIpLnNlbGVjdCgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGJhc2VUaGVtZSQxID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1wYW5lbC5jbS1nb3RvTGluZVwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMnB4IDZweCA0cHhcIixcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgXCImIGxhYmVsXCI6IHsgZm9udFNpemU6IFwiODAlXCIgfSxcbiAgICAgICAgXCImIFtuYW1lPWNsb3NlXVwiOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgdG9wOiBcIjBcIiwgYm90dG9tOiBcIjBcIixcbiAgICAgICAgICAgIHJpZ2h0OiBcIjRweFwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgICBmb250OiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIHBhZGRpbmc6IFwiMFwiXG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3QgZGVmYXVsdEhpZ2hsaWdodE9wdGlvbnMgPSB7XG4gICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogZmFsc2UsXG4gICAgbWluU2VsZWN0aW9uTGVuZ3RoOiAxLFxuICAgIG1heE1hdGNoZXM6IDEwMCxcbiAgICB3aG9sZVdvcmRzOiBmYWxzZVxufTtcbmNvbnN0IGhpZ2hsaWdodENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhvcHRpb25zLCBkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucywge1xuICAgICAgICAgICAgaGlnaGxpZ2h0V29yZEFyb3VuZEN1cnNvcjogKGEsIGIpID0+IGEgfHwgYixcbiAgICAgICAgICAgIG1pblNlbGVjdGlvbkxlbmd0aDogTWF0aC5taW4sXG4gICAgICAgICAgICBtYXhNYXRjaGVzOiBNYXRoLm1pblxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuVGhpcyBleHRlbnNpb24gaGlnaGxpZ2h0cyB0ZXh0IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0aW9uLiBJdCB1c2VzXG50aGUgYFwiY20tc2VsZWN0aW9uTWF0Y2hcImAgY2xhc3MgZm9yIHRoZSBoaWdobGlnaHRpbmcuIFdoZW5cbmBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yYCBpcyBlbmFibGVkLCB0aGUgd29yZCBhdCB0aGUgY3Vyc29yXG5pdHNlbGYgd2lsbCBiZSBoaWdobGlnaHRlZCB3aXRoIGBcImNtLXNlbGVjdGlvbk1hdGNoLW1haW5cImAuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U2VsZWN0aW9uTWF0Y2hlcyhvcHRpb25zKSB7XG4gICAgbGV0IGV4dCA9IFtkZWZhdWx0VGhlbWUsIG1hdGNoSGlnaGxpZ2h0ZXJdO1xuICAgIGlmIChvcHRpb25zKVxuICAgICAgICBleHQucHVzaChoaWdobGlnaHRDb25maWcub2Yob3B0aW9ucykpO1xuICAgIHJldHVybiBleHQ7XG59XG5jb25zdCBtYXRjaERlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2hcIiB9KTtcbmNvbnN0IG1haW5NYXRjaERlY28gPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tc2VsZWN0aW9uTWF0Y2ggY20tc2VsZWN0aW9uTWF0Y2gtbWFpblwiIH0pO1xuLy8gV2hldGhlciB0aGUgY2hhcmFjdGVycyBkaXJlY3RseSBvdXRzaWRlIHRoZSBnaXZlbiBwb3NpdGlvbnMgYXJlIG5vbi13b3JkIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gKGZyb20gPT0gMCB8fCBjaGVjayhzdGF0ZS5zbGljZURvYyhmcm9tIC0gMSwgZnJvbSkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAodG8gPT0gc3RhdGUuZG9jLmxlbmd0aCB8fCBjaGVjayhzdGF0ZS5zbGljZURvYyh0bywgdG8gKyAxKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xufVxuLy8gV2hldGhlciB0aGUgY2hhcmFjdGVycyBkaXJlY3RseSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb25zIGFyZSB3b3JkIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIGluc2lkZVdvcmQoY2hlY2ssIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBjaGVjayhzdGF0ZS5zbGljZURvYyhmcm9tLCBmcm9tICsgMSkpID09IENoYXJDYXRlZ29yeS5Xb3JkXG4gICAgICAgICYmIGNoZWNrKHN0YXRlLnNsaWNlRG9jKHRvIC0gMSwgdG8pKSA9PSBDaGFyQ2F0ZWdvcnkuV29yZDtcbn1cbmNvbnN0IG1hdGNoSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh1cGRhdGUudmlldyk7XG4gICAgfVxuICAgIGdldERlY28odmlldykge1xuICAgICAgICBsZXQgY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQoaGlnaGxpZ2h0Q29uZmlnKTtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHNlbCA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbC5tYWluLCBxdWVyeSwgY2hlY2sgPSBudWxsO1xuICAgICAgICBpZiAocmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGlmICghY29uZi5oaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChyYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIGlmICghd29yZClcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgY2hlY2sgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHdvcmQuZnJvbSwgd29yZC50byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gcmFuZ2UudG8gLSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgaWYgKGxlbiA8IGNvbmYubWluU2VsZWN0aW9uTGVuZ3RoIHx8IGxlbiA+IDIwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgaWYgKGNvbmYud2hvbGVXb3Jkcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pOyAvLyBUT0RPOiBhbGxvdyBhbmQgaW5jbHVkZSBsZWFkaW5nL3RyYWlsaW5nIHNwYWNlP1xuICAgICAgICAgICAgICAgIGNoZWNrID0gc3RhdGUuY2hhckNhdGVnb3JpemVyKHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgICAgIGlmICghKGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pICYmXG4gICAgICAgICAgICAgICAgICAgIGluc2lkZVdvcmQoY2hlY2ssIHN0YXRlLCByYW5nZS5mcm9tLCByYW5nZS50bykpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50byk7XG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcGFydC5mcm9tLCBwYXJ0LnRvKTtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrIHx8IGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBmcm9tIDw9IHJhbmdlLmZyb20gJiYgdG8gPj0gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWFpbk1hdGNoRGVjby5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmcm9tID49IHJhbmdlLnRvIHx8IHRvIDw9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWF0Y2hEZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWNvLmxlbmd0aCA+IGNvbmYubWF4TWF0Y2hlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5jb25zdCBkZWZhdWx0VGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWZmNzc4MFwiIH0sXG4gICAgXCIuY20tc2VhcmNoTWF0Y2ggLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIgfVxufSk7XG4vLyBTZWxlY3QgdGhlIHdvcmRzIGFyb3VuZCB0aGUgY3Vyc29ycy5cbmNvbnN0IHNlbGVjdFdvcmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgbGV0IG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsZWN0aW9uLnJhbmdlcy5tYXAocmFuZ2UgPT4gc3RhdGUud29yZEF0KHJhbmdlLmhlYWQpIHx8IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCkpLCBzZWxlY3Rpb24ubWFpbkluZGV4KTtcbiAgICBpZiAobmV3U2VsLmVxKHNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IG5ld1NlbCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8gRmluZCBuZXh0IG9jY3VycmVuY2Ugb2YgcXVlcnkgcmVsYXRpdmUgdG8gbGFzdCBjdXJzb3IuIFdyYXAgYXJvdW5kXG4vLyB0aGUgZG9jdW1lbnQgaWYgdGhlcmUgYXJlIG5vIG1vcmUgbWF0Y2hlcy5cbmZ1bmN0aW9uIGZpbmROZXh0T2NjdXJyZW5jZShzdGF0ZSwgcXVlcnkpIHtcbiAgICBsZXQgeyBtYWluLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChtYWluLmhlYWQpLCBmdWxsV29yZCA9IHdvcmQgJiYgd29yZC5mcm9tID09IG1haW4uZnJvbSAmJiB3b3JkLnRvID09IG1haW4udG87XG4gICAgZm9yIChsZXQgY3ljbGVkID0gZmFsc2UsIGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50byk7Oykge1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChjeWNsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIDAsIE1hdGgubWF4KDAsIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0uZnJvbSAtIDEpKTtcbiAgICAgICAgICAgIGN5Y2xlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3ljbGVkICYmIHJhbmdlcy5zb21lKHIgPT4gci5mcm9tID09IGN1cnNvci52YWx1ZS5mcm9tKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChmdWxsV29yZCkge1xuICAgICAgICAgICAgICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KGN1cnNvci52YWx1ZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmQgfHwgd29yZC5mcm9tICE9IGN1cnNvci52YWx1ZS5mcm9tIHx8IHdvcmQudG8gIT0gY3Vyc29yLnZhbHVlLnRvKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcblNlbGVjdCBuZXh0IG9jY3VycmVuY2Ugb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBFeHBhbmQgc2VsZWN0aW9uXG50byB0aGUgc3Vycm91bmRpbmcgd29yZCB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkuXG4qL1xuY29uc3Qgc2VsZWN0TmV4dE9jY3VycmVuY2UgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB7IHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChyYW5nZXMuc29tZShzZWwgPT4gc2VsLmZyb20gPT09IHNlbC50bykpXG4gICAgICAgIHJldHVybiBzZWxlY3RXb3JkKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGxldCBzZWFyY2hlZFRleHQgPSBzdGF0ZS5zbGljZURvYyhyYW5nZXNbMF0uZnJvbSwgcmFuZ2VzWzBdLnRvKTtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gc3RhdGUuc2xpY2VEb2Moci5mcm9tLCByLnRvKSAhPSBzZWFyY2hlZFRleHQpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHJhbmdlID0gZmluZE5leHRPY2N1cnJlbmNlKHN0YXRlLCBzZWFyY2hlZFRleHQpO1xuICAgIGlmICghcmFuZ2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBzZWxlY3Rpb246IHN0YXRlLnNlbGVjdGlvbi5hZGRSYW5nZShFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuZnJvbSwgcmFuZ2UudG8pLCBmYWxzZSksXG4gICAgICAgIGVmZmVjdHM6IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcocmFuZ2UudG8pXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3Qgc2VhcmNoQ29uZmlnRmFjZXQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgdG9wOiBmYWxzZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbGl0ZXJhbDogZmFsc2UsXG4gICAgICAgICAgICByZWdleHA6IGZhbHNlLFxuICAgICAgICAgICAgd2hvbGVXb3JkOiBmYWxzZSxcbiAgICAgICAgICAgIGNyZWF0ZVBhbmVsOiB2aWV3ID0+IG5ldyBTZWFyY2hQYW5lbCh2aWV3KSxcbiAgICAgICAgICAgIHNjcm9sbFRvTWF0Y2g6IHJhbmdlID0+IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcocmFuZ2UpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5BZGQgc2VhcmNoIHN0YXRlIHRvIHRoZSBlZGl0b3IgY29uZmlndXJhdGlvbiwgYW5kIG9wdGlvbmFsbHlcbmNvbmZpZ3VyZSB0aGUgc2VhcmNoIGV4dGVuc2lvbi5cbihbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbCkgd2lsbCBhdXRvbWF0aWNhbGx5XG5lbmFibGUgdGhpcyBpZiBpdCBpc24ndCBhbHJlYWR5IG9uKS5cbiovXG5mdW5jdGlvbiBzZWFyY2goY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZyA/IFtzZWFyY2hDb25maWdGYWNldC5vZihjb25maWcpLCBzZWFyY2hFeHRlbnNpb25zXSA6IHNlYXJjaEV4dGVuc2lvbnM7XG59XG4vKipcbkEgc2VhcmNoIHF1ZXJ5LiBQYXJ0IG9mIHRoZSBlZGl0b3IncyBzZWFyY2ggc3RhdGUuXG4qL1xuY2xhc3MgU2VhcmNoUXVlcnkge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHF1ZXJ5IG9iamVjdC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IGNvbmZpZy5zZWFyY2g7XG4gICAgICAgIHRoaXMuY2FzZVNlbnNpdGl2ZSA9ICEhY29uZmlnLmNhc2VTZW5zaXRpdmU7XG4gICAgICAgIHRoaXMubGl0ZXJhbCA9ICEhY29uZmlnLmxpdGVyYWw7XG4gICAgICAgIHRoaXMucmVnZXhwID0gISFjb25maWcucmVnZXhwO1xuICAgICAgICB0aGlzLnJlcGxhY2UgPSBjb25maWcucmVwbGFjZSB8fCBcIlwiO1xuICAgICAgICB0aGlzLnZhbGlkID0gISF0aGlzLnNlYXJjaCAmJiAoIXRoaXMucmVnZXhwIHx8IHZhbGlkUmVnRXhwKHRoaXMuc2VhcmNoKSk7XG4gICAgICAgIHRoaXMudW5xdW90ZWQgPSB0aGlzLnVucXVvdGUodGhpcy5zZWFyY2gpO1xuICAgICAgICB0aGlzLndob2xlV29yZCA9ICEhY29uZmlnLndob2xlV29yZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1bnF1b3RlKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGl0ZXJhbCA/IHRleHQgOlxuICAgICAgICAgICAgdGV4dC5yZXBsYWNlKC9cXFxcKFtucnRcXFxcXSkvZywgKF8sIGNoKSA9PiBjaCA9PSBcIm5cIiA/IFwiXFxuXCIgOiBjaCA9PSBcInJcIiA/IFwiXFxyXCIgOiBjaCA9PSBcInRcIiA/IFwiXFx0XCIgOiBcIlxcXFxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBxdWVyeSB0byBhbm90aGVyIHF1ZXJ5LlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoID09IG90aGVyLnNlYXJjaCAmJiB0aGlzLnJlcGxhY2UgPT0gb3RoZXIucmVwbGFjZSAmJlxuICAgICAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID09IG90aGVyLmNhc2VTZW5zaXRpdmUgJiYgdGhpcy5yZWdleHAgPT0gb3RoZXIucmVnZXhwICYmXG4gICAgICAgICAgICB0aGlzLndob2xlV29yZCA9PSBvdGhlci53aG9sZVdvcmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdleHAgPyBuZXcgUmVnRXhwUXVlcnkodGhpcykgOiBuZXcgU3RyaW5nUXVlcnkodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIHNlYXJjaCBjdXJzb3IgZm9yIHRoaXMgcXVlcnksIHNlYXJjaGluZyB0aHJvdWdoIHRoZSBnaXZlblxuICAgIHJhbmdlIGluIHRoZSBnaXZlbiBzdGF0ZS5cbiAgICAqL1xuICAgIGdldEN1cnNvcihzdGF0ZSwgZnJvbSA9IDAsIHRvKSB7XG4gICAgICAgIGxldCBzdCA9IHN0YXRlLmRvYyA/IHN0YXRlIDogRWRpdG9yU3RhdGUuY3JlYXRlKHsgZG9jOiBzdGF0ZSB9KTtcbiAgICAgICAgaWYgKHRvID09IG51bGwpXG4gICAgICAgICAgICB0byA9IHN0LmRvYy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cCA/IHJlZ2V4cEN1cnNvcih0aGlzLCBzdCwgZnJvbSwgdG8pIDogc3RyaW5nQ3Vyc29yKHRoaXMsIHN0LCBmcm9tLCB0byk7XG4gICAgfVxufVxuY2xhc3MgUXVlcnlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaW5nQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgc3BlYy51bnF1b3RlZCwgZnJvbSwgdG8sIHNwZWMuY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IHggPT4geC50b0xvd2VyQ2FzZSgpLCBzcGVjLndob2xlV29yZCA/IHN0cmluZ1dvcmRUZXN0KHN0YXRlLmRvYywgc3RhdGUuY2hhckNhdGVnb3JpemVyKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpKSA6IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBzdHJpbmdXb3JkVGVzdChkb2MsIGNhdGVnb3JpemVyKSB7XG4gICAgcmV0dXJuIChmcm9tLCB0bywgYnVmLCBidWZQb3MpID0+IHtcbiAgICAgICAgaWYgKGJ1ZlBvcyA+IGZyb20gfHwgYnVmUG9zICsgYnVmLmxlbmd0aCA8IHRvKSB7XG4gICAgICAgICAgICBidWZQb3MgPSBNYXRoLm1heCgwLCBmcm9tIC0gMik7XG4gICAgICAgICAgICBidWYgPSBkb2Muc2xpY2VTdHJpbmcoYnVmUG9zLCBNYXRoLm1pbihkb2MubGVuZ3RoLCB0byArIDIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNhdGVnb3JpemVyKGNoYXJCZWZvcmUoYnVmLCBmcm9tIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJBZnRlcihidWYsIGZyb20gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkgJiZcbiAgICAgICAgICAgIChjYXRlZ29yaXplcihjaGFyQWZ0ZXIoYnVmLCB0byAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkIHx8XG4gICAgICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShidWYsIHRvIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xuICAgIH07XG59XG5jbGFzcyBTdHJpbmdRdWVyeSBleHRlbmRzIFF1ZXJ5VHlwZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICBzdXBlcihzcGVjKTtcbiAgICB9XG4gICAgbmV4dE1hdGNoKHN0YXRlLCBjdXJGcm9tLCBjdXJUbykge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKS5uZXh0T3ZlcmxhcHBpbmcoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgY3VyRnJvbSArIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpO1xuICAgICAgICAgICAgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIGVuZCkubmV4dE92ZXJsYXBwaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnNvci5kb25lIHx8IGN1cnNvci52YWx1ZS5mcm9tID09IGN1ckZyb20gJiYgY3Vyc29yLnZhbHVlLnRvID09IGN1clRvID8gbnVsbCA6IGN1cnNvci52YWx1ZTtcbiAgICB9XG4gICAgLy8gU2VhcmNoaW5nIGluIHJldmVyc2UgaXMsIHJhdGhlciB0aGFuIGltcGxlbWVudGluZyBhbiBpbnZlcnRlZCBzZWFyY2hcbiAgICAvLyBjdXJzb3IsIGRvbmUgYnkgc2Nhbm5pbmcgY2h1bmsgYWZ0ZXIgY2h1bmsgZm9yd2FyZC5cbiAgICBwcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0bzs7KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChmcm9tLCBwb3MgLSAxMDAwMCAvKiBGaW5kUHJldi5DaHVua1NpemUgKi8gLSB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgc3RhcnQsIHBvcyksIHJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHRPdmVybGFwcGluZygpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBwb3MgLT0gMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXZNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCAwLCBjdXJGcm9tKTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIGZvdW5kID0gdGhpcy5wcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBNYXRoLm1heCgwLCBjdXJUbyAtIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpLCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kICYmIChmb3VuZC5mcm9tICE9IGN1ckZyb20gfHwgZm91bmQudG8gIT0gY3VyVG8pID8gZm91bmQgOiBudWxsO1xuICAgIH1cbiAgICBnZXRSZXBsYWNlbWVudChfcmVzdWx0KSB7IHJldHVybiB0aGlzLnNwZWMudW5xdW90ZSh0aGlzLnNwZWMucmVwbGFjZSk7IH1cbiAgICBtYXRjaEFsbChzdGF0ZSwgbGltaXQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHN0cmluZ0N1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKSwgcmFuZ2VzID0gW107XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+PSBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHN0YXRlLCBmcm9tLCB0bywgYWRkKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgTWF0aC5tYXgoMCwgZnJvbSAtIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgpLCBNYXRoLm1pbih0byArIHRoaXMuc3BlYy51bnF1b3RlZC5sZW5ndGgsIHN0YXRlLmRvYy5sZW5ndGgpKTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICBhZGQoY3Vyc29yLnZhbHVlLmZyb20sIGN1cnNvci52YWx1ZS50byk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVnZXhwQ3Vyc29yKHNwZWMsIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwQ3Vyc29yKHN0YXRlLmRvYywgc3BlYy5zZWFyY2gsIHtcbiAgICAgICAgaWdub3JlQ2FzZTogIXNwZWMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgdGVzdDogc3BlYy53aG9sZVdvcmQgPyByZWdleHBXb3JkVGVzdChzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIoc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkpIDogdW5kZWZpbmVkXG4gICAgfSwgZnJvbSwgdG8pO1xufVxuZnVuY3Rpb24gY2hhckJlZm9yZShzdHIsIGluZGV4KSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZShmaW5kQ2x1c3RlckJyZWFrKHN0ciwgaW5kZXgsIGZhbHNlKSwgaW5kZXgpO1xufVxuZnVuY3Rpb24gY2hhckFmdGVyKHN0ciwgaW5kZXgpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKGluZGV4LCBmaW5kQ2x1c3RlckJyZWFrKHN0ciwgaW5kZXgpKTtcbn1cbmZ1bmN0aW9uIHJlZ2V4cFdvcmRUZXN0KGNhdGVnb3JpemVyKSB7XG4gICAgcmV0dXJuIChfZnJvbSwgX3RvLCBtYXRjaCkgPT4gIW1hdGNoWzBdLmxlbmd0aCB8fFxuICAgICAgICAoY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckFmdGVyKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAgICAgKGNhdGVnb3JpemVyKGNoYXJBZnRlcihtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJCZWZvcmUobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpO1xufVxuY2xhc3MgUmVnRXhwUXVlcnkgZXh0ZW5kcyBRdWVyeVR5cGUge1xuICAgIG5leHRNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBjdXJUbywgc3RhdGUuZG9jLmxlbmd0aCkubmV4dCgpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpXG4gICAgICAgICAgICBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgY3VyRnJvbSkubmV4dCgpO1xuICAgICAgICByZXR1cm4gY3Vyc29yLmRvbmUgPyBudWxsIDogY3Vyc29yLnZhbHVlO1xuICAgIH1cbiAgICBwcmV2TWF0Y2hJblJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBzaXplID0gMTs7IHNpemUrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoZnJvbSwgdG8gLSBzaXplICogMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovKTtcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgc3RhcnQsIHRvKSwgcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UgJiYgKHN0YXJ0ID09IGZyb20gfHwgcmFuZ2UuZnJvbSA+IHN0YXJ0ICsgMTApKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXZNYXRjaChzdGF0ZSwgY3VyRnJvbSwgY3VyVG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgMCwgY3VyRnJvbSkgfHxcbiAgICAgICAgICAgIHRoaXMucHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIH1cbiAgICBnZXRSZXBsYWNlbWVudChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy51bnF1b3RlKHRoaXMuc3BlYy5yZXBsYWNlKS5yZXBsYWNlKC9cXCQoWyQmXXxcXGQrKS9nLCAobSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPT0gXCImXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXRjaFswXTtcbiAgICAgICAgICAgIGlmIChpID09IFwiJFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgICAgIGZvciAobGV0IGwgPSBpLmxlbmd0aDsgbCA+IDA7IGwtLSkge1xuICAgICAgICAgICAgICAgIGxldCBuID0gK2kuc2xpY2UoMCwgbCk7XG4gICAgICAgICAgICAgICAgaWYgKG4gPiAwICYmIG4gPCByZXN1bHQubWF0Y2gubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lm1hdGNoW25dICsgaS5zbGljZShsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF0Y2hBbGwoc3RhdGUsIGxpbWl0KSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgc3RhdGUuZG9jLmxlbmd0aCksIHJhbmdlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIGhpZ2hsaWdodChzdGF0ZSwgZnJvbSwgdG8sIGFkZCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIE1hdGgubWF4KDAsIGZyb20gLSAyNTAgLyogUmVnRXhwLkhpZ2hsaWdodE1hcmdpbiAqLyksIE1hdGgubWluKHRvICsgMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8sIHN0YXRlLmRvYy5sZW5ndGgpKTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpXG4gICAgICAgICAgICBhZGQoY3Vyc29yLnZhbHVlLmZyb20sIGN1cnNvci52YWx1ZS50byk7XG4gICAgfVxufVxuLyoqXG5BIHN0YXRlIGVmZmVjdCB0aGF0IHVwZGF0ZXMgdGhlIGN1cnJlbnQgc2VhcmNoIHF1ZXJ5LiBOb3RlIHRoYXRcbnRoaXMgb25seSBoYXMgYW4gZWZmZWN0IGlmIHRoZSBzZWFyY2ggc3RhdGUgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcbihieSBpbmNsdWRpbmcgW2BzZWFyY2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5zZWFyY2gpIGluIHlvdXIgY29uZmlndXJhdGlvbiBvclxuYnkgcnVubmluZyBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbCkgYXQgbGVhc3Rcbm9uY2UpLlxuKi9cbmNvbnN0IHNldFNlYXJjaFF1ZXJ5ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgdG9nZ2xlUGFuZWwgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5jb25zdCBzZWFyY2hTdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VhcmNoU3RhdGUoZGVmYXVsdFF1ZXJ5KHN0YXRlKS5jcmVhdGUoKSwgbnVsbCk7XG4gICAgfSxcbiAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBTZWFyY2hTdGF0ZShlZmZlY3QudmFsdWUuY3JlYXRlKCksIHZhbHVlLnBhbmVsKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyh0b2dnbGVQYW5lbCkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgU2VhcmNoU3RhdGUodmFsdWUucXVlcnksIGVmZmVjdC52YWx1ZSA/IGNyZWF0ZVNlYXJjaFBhbmVsIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBzaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsLnBhbmVsKVxufSk7XG4vKipcbkdldCB0aGUgY3VycmVudCBzZWFyY2ggcXVlcnkgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4qL1xuZnVuY3Rpb24gZ2V0U2VhcmNoUXVlcnkoc3RhdGUpIHtcbiAgICBsZXQgY3VyU3RhdGUgPSBzdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIHJldHVybiBjdXJTdGF0ZSA/IGN1clN0YXRlLnF1ZXJ5LnNwZWMgOiBkZWZhdWx0UXVlcnkoc3RhdGUpO1xufVxuLyoqXG5RdWVyeSB3aGV0aGVyIHRoZSBzZWFyY2ggcGFuZWwgaXMgb3BlbiBpbiB0aGUgZ2l2ZW4gZWRpdG9yIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIHNlYXJjaFBhbmVsT3BlbihzdGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYW5lbCkgIT0gbnVsbDtcbn1cbmNsYXNzIFNlYXJjaFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihxdWVyeSwgcGFuZWwpIHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLnBhbmVsID0gcGFuZWw7XG4gICAgfVxufVxuY29uc3QgbWF0Y2hNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoXCIgfSksIHNlbGVjdGVkTWF0Y2hNYXJrID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLXNlYXJjaE1hdGNoIGNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCIgfSk7XG5jb25zdCBzZWFyY2hIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5oaWdobGlnaHQodmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHVwZGF0ZS5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZSAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuaGlnaGxpZ2h0KHN0YXRlKTtcbiAgICB9XG4gICAgaGlnaGxpZ2h0KHsgcXVlcnksIHBhbmVsIH0pIHtcbiAgICAgICAgaWYgKCFwYW5lbCB8fCAhcXVlcnkuc3BlYy52YWxpZClcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcmFuZ2VzID0gdmlldy52aXNpYmxlUmFuZ2VzLCBsID0gcmFuZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbCAtIDEgJiYgdG8gPiByYW5nZXNbaSArIDFdLmZyb20gLSAyICogMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8pXG4gICAgICAgICAgICAgICAgdG8gPSByYW5nZXNbKytpXS50bztcbiAgICAgICAgICAgIHF1ZXJ5LmhpZ2hsaWdodCh2aWV3LnN0YXRlLCBmcm9tLCB0bywgKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLnNvbWUociA9PiByLmZyb20gPT0gZnJvbSAmJiByLnRvID09IHRvKTtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChmcm9tLCB0bywgc2VsZWN0ZWQgPyBzZWxlY3RlZE1hdGNoTWFyayA6IG1hdGNoTWFyayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5mdW5jdGlvbiBzZWFyY2hDb21tYW5kKGYpIHtcbiAgICByZXR1cm4gdmlldyA9PiB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLnF1ZXJ5LnNwZWMudmFsaWQgPyBmKHZpZXcsIHN0YXRlKSA6IG9wZW5TZWFyY2hQYW5lbCh2aWV3KTtcbiAgICB9O1xufVxuLyoqXG5PcGVuIHRoZSBzZWFyY2ggcGFuZWwgaWYgaXQgaXNuJ3QgYWxyZWFkeSBvcGVuLCBhbmQgbW92ZSB0aGVcbnNlbGVjdGlvbiB0byB0aGUgZmlyc3QgbWF0Y2ggYWZ0ZXIgdGhlIGN1cnJlbnQgbWFpbiBzZWxlY3Rpb24uXG5XaWxsIHdyYXAgYXJvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgd2hlbiBpdCByZWFjaGVzIHRoZVxuZW5kLlxuKi9cbmNvbnN0IGZpbmROZXh0ID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHRvIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBuZXh0ID0gcXVlcnkubmV4dE1hdGNoKHZpZXcuc3RhdGUsIHRvLCB0byk7XG4gICAgaWYgKCFuZXh0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV4dC5mcm9tLCBuZXh0LnRvKTtcbiAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCk7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgZWZmZWN0czogW2Fubm91bmNlTWF0Y2godmlldywgbmV4dCksIGNvbmZpZy5zY3JvbGxUb01hdGNoKHNlbGVjdGlvbi5tYWluLCB2aWV3KV0sXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoXCJcbiAgICB9KTtcbiAgICBzZWxlY3RTZWFyY2hJbnB1dCh2aWV3KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIHByZXZpb3VzIGluc3RhbmNlIG9mIHRoZSBzZWFyY2ggcXVlcnksXG5iZWZvcmUgdGhlIGN1cnJlbnQgbWFpbiBzZWxlY3Rpb24uIFdpbGwgd3JhcCBwYXN0IHRoZSBzdGFydFxub2YgdGhlIGRvY3VtZW50IHRvIHN0YXJ0IHNlYXJjaGluZyBhdCB0aGUgZW5kIGFnYWluLlxuKi9cbmNvbnN0IGZpbmRQcmV2aW91cyA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgeyBmcm9tIH0gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgcHJldiA9IHF1ZXJ5LnByZXZNYXRjaChzdGF0ZSwgZnJvbSwgZnJvbSk7XG4gICAgaWYgKCFwcmV2KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUocHJldi5mcm9tLCBwcmV2LnRvKTtcbiAgICBsZXQgY29uZmlnID0gdmlldy5zdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCk7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgZWZmZWN0czogW2Fubm91bmNlTWF0Y2godmlldywgcHJldiksIGNvbmZpZy5zY3JvbGxUb01hdGNoKHNlbGVjdGlvbi5tYWluLCB2aWV3KV0sXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoXCJcbiAgICB9KTtcbiAgICBzZWxlY3RTZWFyY2hJbnB1dCh2aWV3KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG5TZWxlY3QgYWxsIGluc3RhbmNlcyBvZiB0aGUgc2VhcmNoIHF1ZXJ5LlxuKi9cbmNvbnN0IHNlbGVjdE1hdGNoZXMgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHJhbmdlcyA9IHF1ZXJ5Lm1hdGNoQWxsKHZpZXcuc3RhdGUsIDEwMDApO1xuICAgIGlmICghcmFuZ2VzIHx8ICFyYW5nZXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMubWFwKHIgPT4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHIuZnJvbSwgci50bykpKSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2gubWF0Y2hlc1wiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuU2VsZWN0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0LlxuKi9cbmNvbnN0IHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoID4gMSB8fCBzZWwubWFpbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWwubWFpbjtcbiAgICBsZXQgcmFuZ2VzID0gW10sIG1haW4gPSAwO1xuICAgIGZvciAobGV0IGN1ciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBzdGF0ZS5zbGljZURvYyhmcm9tLCB0bykpOyAhY3VyLm5leHQoKS5kb25lOykge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEwMDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChjdXIudmFsdWUuZnJvbSA9PSBmcm9tKVxuICAgICAgICAgICAgbWFpbiA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShjdXIudmFsdWUuZnJvbSwgY3VyLnZhbHVlLnRvKSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIG1haW4pLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaC5tYXRjaGVzXCJcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5SZXBsYWNlIHRoZSBjdXJyZW50IG1hdGNoIG9mIHRoZSBzZWFyY2ggcXVlcnkuXG4qL1xuY29uc3QgcmVwbGFjZU5leHQgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHsgZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGlmIChzdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBtYXRjaCA9IHF1ZXJ5Lm5leHRNYXRjaChzdGF0ZSwgZnJvbSwgZnJvbSk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBuZXh0ID0gbWF0Y2g7XG4gICAgbGV0IGNoYW5nZXMgPSBbXSwgc2VsZWN0aW9uLCByZXBsYWNlbWVudDtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGlmIChuZXh0LmZyb20gPT0gZnJvbSAmJiBuZXh0LnRvID09IHRvKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gc3RhdGUudG9UZXh0KHF1ZXJ5LmdldFJlcGxhY2VtZW50KG5leHQpKTtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbmV4dC5mcm9tLCB0bzogbmV4dC50bywgaW5zZXJ0OiByZXBsYWNlbWVudCB9KTtcbiAgICAgICAgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaChzdGF0ZSwgbmV4dC5mcm9tLCBuZXh0LnRvKTtcbiAgICAgICAgZWZmZWN0cy5wdXNoKEVkaXRvclZpZXcuYW5ub3VuY2Uub2Yoc3RhdGUucGhyYXNlKFwicmVwbGFjZWQgbWF0Y2ggb24gbGluZSAkXCIsIHN0YXRlLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyKSArIFwiLlwiKSk7XG4gICAgfVxuICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGxldCBvZmYgPSBjaGFuZ2VzLmxlbmd0aCA9PSAwIHx8IGNoYW5nZXNbMF0uZnJvbSA+PSBtYXRjaC50byA/IDAgOiBtYXRjaC50byAtIG1hdGNoLmZyb20gLSByZXBsYWNlbWVudC5sZW5ndGg7XG4gICAgICAgIHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV4dC5mcm9tIC0gb2ZmLCBuZXh0LnRvIC0gb2ZmKTtcbiAgICAgICAgZWZmZWN0cy5wdXNoKGFubm91bmNlTWF0Y2godmlldywgbmV4dCkpO1xuICAgICAgICBlZmZlY3RzLnB1c2goc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpLnNjcm9sbFRvTWF0Y2goc2VsZWN0aW9uLm1haW4sIHZpZXcpKTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cyxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnJlcGxhY2VcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblJlcGxhY2UgYWxsIGluc3RhbmNlcyBvZiB0aGUgc2VhcmNoIHF1ZXJ5IHdpdGggdGhlIGdpdmVuXG5yZXBsYWNlbWVudC5cbiovXG5jb25zdCByZXBsYWNlQWxsID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBxdWVyeS5tYXRjaEFsbCh2aWV3LnN0YXRlLCAxZTkpLm1hcChtYXRjaCA9PiB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBtYXRjaDtcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIGluc2VydDogcXVlcnkuZ2V0UmVwbGFjZW1lbnQobWF0Y2gpIH07XG4gICAgfSk7XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhbm5vdW5jZVRleHQgPSB2aWV3LnN0YXRlLnBocmFzZShcInJlcGxhY2VkICQgbWF0Y2hlc1wiLCBjaGFuZ2VzLmxlbmd0aCkgKyBcIi5cIjtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgZWZmZWN0czogRWRpdG9yVmlldy5hbm5vdW5jZS5vZihhbm5vdW5jZVRleHQpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucmVwbGFjZS5hbGxcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hQYW5lbCh2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpLmNyZWF0ZVBhbmVsKHZpZXcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFF1ZXJ5KHN0YXRlLCBmYWxsYmFjaykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgIGxldCBzZWxUZXh0ID0gc2VsLmVtcHR5IHx8IHNlbC50byA+IHNlbC5mcm9tICsgMTAwID8gXCJcIiA6IHN0YXRlLnNsaWNlRG9jKHNlbC5mcm9tLCBzZWwudG8pO1xuICAgIGlmIChmYWxsYmFjayAmJiAhc2VsVGV4dClcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIGxldCBjb25maWcgPSBzdGF0ZS5mYWNldChzZWFyY2hDb25maWdGYWNldCk7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hRdWVyeSh7XG4gICAgICAgIHNlYXJjaDogKChfYSA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5saXRlcmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25maWcubGl0ZXJhbCkgPyBzZWxUZXh0IDogc2VsVGV4dC5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKSxcbiAgICAgICAgY2FzZVNlbnNpdGl2ZTogKF9iID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmNhc2VTZW5zaXRpdmUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGNvbmZpZy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICBsaXRlcmFsOiAoX2MgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2subGl0ZXJhbCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY29uZmlnLmxpdGVyYWwsXG4gICAgICAgIHJlZ2V4cDogKF9kID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLnJlZ2V4cCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogY29uZmlnLnJlZ2V4cCxcbiAgICAgICAgd2hvbGVXb3JkOiAoX2UgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2sud2hvbGVXb3JkKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBjb25maWcud2hvbGVXb3JkXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRTZWFyY2hJbnB1dCh2aWV3KSB7XG4gICAgbGV0IHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlU2VhcmNoUGFuZWwpO1xuICAgIHJldHVybiBwYW5lbCAmJiBwYW5lbC5kb20ucXVlcnlTZWxlY3RvcihcIlttYWluLWZpZWxkXVwiKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFNlYXJjaElucHV0KHZpZXcpIHtcbiAgICBsZXQgaW5wdXQgPSBnZXRTZWFyY2hJbnB1dCh2aWV3KTtcbiAgICBpZiAoaW5wdXQgJiYgaW5wdXQgPT0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQpXG4gICAgICAgIGlucHV0LnNlbGVjdCgpO1xufVxuLyoqXG5NYWtlIHN1cmUgdGhlIHNlYXJjaCBwYW5lbCBpcyBvcGVuIGFuZCBmb2N1c2VkLlxuKi9cbmNvbnN0IG9wZW5TZWFyY2hQYW5lbCA9IHZpZXcgPT4ge1xuICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoc3RhdGUgJiYgc3RhdGUucGFuZWwpIHtcbiAgICAgICAgbGV0IHNlYXJjaElucHV0ID0gZ2V0U2VhcmNoSW5wdXQodmlldyk7XG4gICAgICAgIGlmIChzZWFyY2hJbnB1dCAmJiBzZWFyY2hJbnB1dCAhPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gZGVmYXVsdFF1ZXJ5KHZpZXcuc3RhdGUsIHN0YXRlLnF1ZXJ5LnNwZWMpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LnZhbGlkKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWFyY2hRdWVyeS5vZihxdWVyeSkgfSk7XG4gICAgICAgICAgICBzZWFyY2hJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgc2VhcmNoSW5wdXQuc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBbXG4gICAgICAgICAgICAgICAgdG9nZ2xlUGFuZWwub2YodHJ1ZSksXG4gICAgICAgICAgICAgICAgc3RhdGUgPyBzZXRTZWFyY2hRdWVyeS5vZihkZWZhdWx0UXVlcnkodmlldy5zdGF0ZSwgc3RhdGUucXVlcnkuc3BlYykpIDogU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKHNlYXJjaEV4dGVuc2lvbnMpXG4gICAgICAgICAgICBdIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkNsb3NlIHRoZSBzZWFyY2ggcGFuZWwuXG4qL1xuY29uc3QgY2xvc2VTZWFyY2hQYW5lbCA9IHZpZXcgPT4ge1xuICAgIGxldCBzdGF0ZSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5wYW5lbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBwYW5lbCA9IGdldFBhbmVsKHZpZXcsIGNyZWF0ZVNlYXJjaFBhbmVsKTtcbiAgICBpZiAocGFuZWwgJiYgcGFuZWwuZG9tLmNvbnRhaW5zKHZpZXcucm9vdC5hY3RpdmVFbGVtZW50KSlcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0b2dnbGVQYW5lbC5vZihmYWxzZSkgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5EZWZhdWx0IHNlYXJjaC1yZWxhdGVkIGtleSBiaW5kaW5ncy5cblxuIC0gTW9kLWY6IFtgb3BlblNlYXJjaFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2gub3BlblNlYXJjaFBhbmVsKVxuIC0gRjMsIE1vZC1nOiBbYGZpbmROZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guZmluZE5leHQpXG4gLSBTaGlmdC1GMywgU2hpZnQtTW9kLWc6IFtgZmluZFByZXZpb3VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guZmluZFByZXZpb3VzKVxuIC0gTW9kLUFsdC1nOiBbYGdvdG9MaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guZ290b0xpbmUpXG4gLSBNb2QtZDogW2BzZWxlY3ROZXh0T2NjdXJyZW5jZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLnNlbGVjdE5leHRPY2N1cnJlbmNlKVxuKi9cbmNvbnN0IHNlYXJjaEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtZlwiLCBydW46IG9wZW5TZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXG4gICAgeyBrZXk6IFwiRjNcIiwgcnVuOiBmaW5kTmV4dCwgc2hpZnQ6IGZpbmRQcmV2aW91cywgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1nXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbG9zZVNlYXJjaFBhbmVsLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIgfSxcbiAgICB7IGtleTogXCJNb2QtU2hpZnQtbFwiLCBydW46IHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMgfSxcbiAgICB7IGtleTogXCJNb2QtQWx0LWdcIiwgcnVuOiBnb3RvTGluZSB9LFxuICAgIHsga2V5OiBcIk1vZC1kXCIsIHJ1bjogc2VsZWN0TmV4dE9jY3VycmVuY2UsIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG5dO1xuY2xhc3MgU2VhcmNoUGFuZWwge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5xdWVyeSA9IHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpLnF1ZXJ5LnNwZWM7XG4gICAgICAgIHRoaXMuY29tbWl0ID0gdGhpcy5jb21taXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBxdWVyeS5zZWFyY2gsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogcGhyYXNlKHZpZXcsIFwiRmluZFwiKSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJGaW5kXCIpLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsXG4gICAgICAgICAgICBuYW1lOiBcInNlYXJjaFwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIFwibWFpbi1maWVsZFwiOiBcInRydWVcIixcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdCxcbiAgICAgICAgICAgIG9ua2V5dXA6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlcGxhY2VGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBxdWVyeS5yZXBsYWNlLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHBocmFzZSh2aWV3LCBcIlJlcGxhY2VcIiksXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogcGhyYXNlKHZpZXcsIFwiUmVwbGFjZVwiKSxcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLXRleHRmaWVsZFwiLFxuICAgICAgICAgICAgbmFtZTogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0LFxuICAgICAgICAgICAgb25rZXl1cDogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FzZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJjYXNlXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkuY2FzZVNlbnNpdGl2ZSxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdHlwZTogXCJjaGVja2JveFwiLFxuICAgICAgICAgICAgbmFtZTogXCJyZVwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IHF1ZXJ5LnJlZ2V4cCxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53b3JkRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBuYW1lOiBcIndvcmRcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS53aG9sZVdvcmQsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGJ1dHRvbihuYW1lLCBvbmNsaWNrLCBjb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWx0KFwiYnV0dG9uXCIsIHsgY2xhc3M6IFwiY20tYnV0dG9uXCIsIG5hbWUsIG9uY2xpY2ssIHR5cGU6IFwiYnV0dG9uXCIgfSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20gPSBlbHQoXCJkaXZcIiwgeyBvbmtleWRvd246IChlKSA9PiB0aGlzLmtleWRvd24oZSksIGNsYXNzOiBcImNtLXNlYXJjaFwiIH0sIFtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoRmllbGQsXG4gICAgICAgICAgICBidXR0b24oXCJuZXh0XCIsICgpID0+IGZpbmROZXh0KHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwibmV4dFwiKV0pLFxuICAgICAgICAgICAgYnV0dG9uKFwicHJldlwiLCAoKSA9PiBmaW5kUHJldmlvdXModmlldyksIFtwaHJhc2UodmlldywgXCJwcmV2aW91c1wiKV0pLFxuICAgICAgICAgICAgYnV0dG9uKFwic2VsZWN0XCIsICgpID0+IHNlbGVjdE1hdGNoZXModmlldyksIFtwaHJhc2UodmlldywgXCJhbGxcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLmNhc2VGaWVsZCwgcGhyYXNlKHZpZXcsIFwibWF0Y2ggY2FzZVwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMucmVGaWVsZCwgcGhyYXNlKHZpZXcsIFwicmVnZXhwXCIpXSksXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy53b3JkRmllbGQsIHBocmFzZSh2aWV3LCBcImJ5IHdvcmRcIildKSxcbiAgICAgICAgICAgIC4uLnZpZXcuc3RhdGUucmVhZE9ubHkgPyBbXSA6IFtcbiAgICAgICAgICAgICAgICBlbHQoXCJiclwiKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VGaWVsZCxcbiAgICAgICAgICAgICAgICBidXR0b24oXCJyZXBsYWNlXCIsICgpID0+IHJlcGxhY2VOZXh0KHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicmVwbGFjZVwiKV0pLFxuICAgICAgICAgICAgICAgIGJ1dHRvbihcInJlcGxhY2VBbGxcIiwgKCkgPT4gcmVwbGFjZUFsbCh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInJlcGxhY2UgYWxsXCIpXSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBlbHQoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiY2xvc2VcIixcbiAgICAgICAgICAgICAgICBvbmNsaWNrOiAoKSA9PiBjbG9zZVNlYXJjaFBhbmVsKHZpZXcpLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJjbG9zZVwiKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiXG4gICAgICAgICAgICB9LCBbXCLDl1wiXSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gbmV3IFNlYXJjaFF1ZXJ5KHtcbiAgICAgICAgICAgIHNlYXJjaDogdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IHRoaXMuY2FzZUZpZWxkLmNoZWNrZWQsXG4gICAgICAgICAgICByZWdleHA6IHRoaXMucmVGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgd2hvbGVXb3JkOiB0aGlzLndvcmRGaWVsZC5jaGVja2VkLFxuICAgICAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlRmllbGQudmFsdWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXF1ZXJ5LmVxKHRoaXMucXVlcnkpKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXRTZWFyY2hRdWVyeS5vZihxdWVyeSkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5ZG93bihlKSB7XG4gICAgICAgIGlmIChydW5TY29wZUhhbmRsZXJzKHRoaXMudmlldywgZSwgXCJzZWFyY2gtcGFuZWxcIikpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5zZWFyY2hGaWVsZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgKGUuc2hpZnRLZXkgPyBmaW5kUHJldmlvdXMgOiBmaW5kTmV4dCkodGhpcy52aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlLmtleUNvZGUgPT0gMTMgJiYgZS50YXJnZXQgPT0gdGhpcy5yZXBsYWNlRmllbGQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJlcGxhY2VOZXh0KHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldFNlYXJjaFF1ZXJ5KSAmJiAhZWZmZWN0LnZhbHVlLmVxKHRoaXMucXVlcnkpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFF1ZXJ5KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHNldFF1ZXJ5KHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5zZWFyY2hGaWVsZC52YWx1ZSA9IHF1ZXJ5LnNlYXJjaDtcbiAgICAgICAgdGhpcy5yZXBsYWNlRmllbGQudmFsdWUgPSBxdWVyeS5yZXBsYWNlO1xuICAgICAgICB0aGlzLmNhc2VGaWVsZC5jaGVja2VkID0gcXVlcnkuY2FzZVNlbnNpdGl2ZTtcbiAgICAgICAgdGhpcy5yZUZpZWxkLmNoZWNrZWQgPSBxdWVyeS5yZWdleHA7XG4gICAgICAgIHRoaXMud29yZEZpZWxkLmNoZWNrZWQgPSBxdWVyeS53aG9sZVdvcmQ7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLnNlbGVjdCgpO1xuICAgIH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gODA7IH1cbiAgICBnZXQgdG9wKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KS50b3A7IH1cbn1cbmZ1bmN0aW9uIHBocmFzZSh2aWV3LCBwaHJhc2UpIHsgcmV0dXJuIHZpZXcuc3RhdGUucGhyYXNlKHBocmFzZSk7IH1cbmNvbnN0IEFubm91bmNlTWFyZ2luID0gMzA7XG5jb25zdCBCcmVhayA9IC9bXFxzXFwuLDo7PyFdLztcbmZ1bmN0aW9uIGFubm91bmNlTWF0Y2godmlldywgeyBmcm9tLCB0byB9KSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoZnJvbSksIGxpbmVFbmQgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pLnRvO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGxpbmUuZnJvbSwgZnJvbSAtIEFubm91bmNlTWFyZ2luKSwgZW5kID0gTWF0aC5taW4obGluZUVuZCwgdG8gKyBBbm5vdW5jZU1hcmdpbik7XG4gICAgbGV0IHRleHQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKHN0YXJ0LCBlbmQpO1xuICAgIGlmIChzdGFydCAhPSBsaW5lLmZyb20pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBbm5vdW5jZU1hcmdpbjsgaSsrKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSArIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmQgIT0gbGluZUVuZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGV4dC5sZW5ndGggLSAxOyBpID4gdGV4dC5sZW5ndGggLSBBbm5vdW5jZU1hcmdpbjsgaS0tKVxuICAgICAgICAgICAgaWYgKCFCcmVhay50ZXN0KHRleHRbaSAtIDFdKSAmJiBCcmVhay50ZXN0KHRleHRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JWaWV3LmFubm91bmNlLm9mKGAke3ZpZXcuc3RhdGUucGhyYXNlKFwiY3VycmVudCBtYXRjaFwiKX0uICR7dGV4dH0gJHt2aWV3LnN0YXRlLnBocmFzZShcIm9uIGxpbmVcIil9ICR7bGluZS5udW1iZXJ9LmApO1xufVxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1wYW5lbC5jbS1zZWFyY2hcIjoge1xuICAgICAgICBwYWRkaW5nOiBcIjJweCA2cHggNHB4XCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIFwiJiBbbmFtZT1jbG9zZV1cIjoge1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogXCIwXCIsXG4gICAgICAgICAgICByaWdodDogXCI0cHhcIixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBib3JkZXI6IFwibm9uZVwiLFxuICAgICAgICAgICAgZm9udDogXCJpbmhlcml0XCIsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBpbnB1dCwgJiBidXR0b24sICYgbGFiZWxcIjoge1xuICAgICAgICAgICAgbWFyZ2luOiBcIi4yZW0gLjZlbSAuMmVtIDBcIlxuICAgICAgICB9LFxuICAgICAgICBcIiYgaW5wdXRbdHlwZT1jaGVja2JveF1cIjoge1xuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IFwiLjJlbVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBsYWJlbFwiOiB7XG4gICAgICAgICAgICBmb250U2l6ZTogXCI4MCVcIixcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlYXJjaE1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZmZmMDA1NFwiIH0sXG4gICAgXCImZGFyayAuY20tc2VhcmNoTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiIzAwZmZmZjhhXCIgfSxcbiAgICBcIiZsaWdodCAuY20tc2VhcmNoTWF0Y2gtc2VsZWN0ZWRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmNmEwMDU0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmYwMGZmOGFcIiB9XG59KTtcbmNvbnN0IHNlYXJjaEV4dGVuc2lvbnMgPSBbXG4gICAgc2VhcmNoU3RhdGUsXG4gICAgLypAX19QVVJFX18qL1ByZWMubG93KHNlYXJjaEhpZ2hsaWdodGVyKSxcbiAgICBiYXNlVGhlbWVcbl07XG5cbmV4cG9ydCB7IFJlZ0V4cEN1cnNvciwgU2VhcmNoQ3Vyc29yLCBTZWFyY2hRdWVyeSwgY2xvc2VTZWFyY2hQYW5lbCwgZmluZE5leHQsIGZpbmRQcmV2aW91cywgZ2V0U2VhcmNoUXVlcnksIGdvdG9MaW5lLCBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzLCBvcGVuU2VhcmNoUGFuZWwsIHJlcGxhY2VBbGwsIHJlcGxhY2VOZXh0LCBzZWFyY2gsIHNlYXJjaEtleW1hcCwgc2VhcmNoUGFuZWxPcGVuLCBzZWxlY3RNYXRjaGVzLCBzZWxlY3ROZXh0T2NjdXJyZW5jZSwgc2VsZWN0U2VsZWN0aW9uTWF0Y2hlcywgc2V0U2VhcmNoUXVlcnkgfTtcbiJdLCJuYW1lcyI6WyJzaG93UGFuZWwiLCJFZGl0b3JWaWV3IiwiZ2V0UGFuZWwiLCJEZWNvcmF0aW9uIiwiVmlld1BsdWdpbiIsInJ1blNjb3BlSGFuZGxlcnMiLCJjb2RlUG9pbnRBdCIsImZyb21Db2RlUG9pbnQiLCJjb2RlUG9pbnRTaXplIiwiU3RhdGVFZmZlY3QiLCJTdGF0ZUZpZWxkIiwiRWRpdG9yU2VsZWN0aW9uIiwiRmFjZXQiLCJjb21iaW5lQ29uZmlnIiwiQ2hhckNhdGVnb3J5IiwiUmFuZ2VTZXRCdWlsZGVyIiwiUHJlYyIsIkVkaXRvclN0YXRlIiwiZmluZENsdXN0ZXJCcmVhayIsImVsdCIsImJhc2ljTm9ybWFsaXplIiwiU3RyaW5nIiwicHJvdG90eXBlIiwibm9ybWFsaXplIiwieCIsIlNlYXJjaEN1cnNvciIsImNvbnN0cnVjdG9yIiwidGV4dCIsInF1ZXJ5IiwiZnJvbSIsInRvIiwibGVuZ3RoIiwidGVzdCIsInZhbHVlIiwiZG9uZSIsIm1hdGNoZXMiLCJidWZmZXIiLCJidWZmZXJQb3MiLCJpdGVyIiwiaXRlclJhbmdlIiwiYnVmZmVyU3RhcnQiLCJwZWVrIiwibmV4dCIsInBvcCIsIm5leHRPdmVybGFwcGluZyIsInN0ciIsInN0YXJ0Iiwibm9ybSIsImkiLCJwb3MiLCJjb2RlIiwiY2hhckNvZGVBdCIsIm1hdGNoIiwiZW5kIiwiaW5kZXgiLCJrZWVwIiwic3BsaWNlIiwicHVzaCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZW1wdHkiLCJleGVjIiwiYmFzZUZsYWdzIiwidW5pY29kZSIsIlJlZ0V4cEN1cnNvciIsIm9wdGlvbnMiLCJjdXJMaW5lIiwiTXVsdGlsaW5lUmVnRXhwQ3Vyc29yIiwicmUiLCJSZWdFeHAiLCJpZ25vcmVDYXNlIiwic3RhcnRMaW5lIiwibGluZUF0IiwiY3VyTGluZVN0YXJ0IiwibWF0Y2hQb3MiLCJ0b0NoYXJFbmQiLCJnZXRMaW5lIiwic2tpcCIsImxpbmVCcmVhayIsInNsaWNlIiwibmV4dExpbmUiLCJvZmYiLCJsYXN0SW5kZXgiLCJmbGF0dGVuZWQiLCJXZWFrTWFwIiwiRmxhdHRlbmVkRG9jIiwiZ2V0IiwiZG9jIiwiY2FjaGVkIiwiZmxhdCIsInNsaWNlU3RyaW5nIiwic2V0IiwiY2FjaGVkRnJvbSIsImNodW5rRW5kIiwidmFsaWRSZWdFeHAiLCJzb3VyY2UiLCJfYSIsImxpbmUiLCJjcmVhdGVMaW5lRGlhbG9nIiwidmlldyIsInN0YXRlIiwic2VsZWN0aW9uIiwibWFpbiIsImhlYWQiLCJudW1iZXIiLCJpbnB1dCIsImNsYXNzIiwibmFtZSIsImRvbSIsIm9ua2V5ZG93biIsImV2ZW50Iiwia2V5Q29kZSIsInByZXZlbnREZWZhdWx0IiwiZGlzcGF0Y2giLCJlZmZlY3RzIiwiZGlhbG9nRWZmZWN0Iiwib2YiLCJmb2N1cyIsImdvIiwib25zdWJtaXQiLCJwaHJhc2UiLCJ0eXBlIiwib25jbGljayIsInNpZ24iLCJsbiIsImNsIiwicGVyY2VudCIsImNvbCIsInBjIiwibGluZXMiLCJNYXRoIiwicm91bmQiLCJkb2NMaW5lIiwibWF4IiwibWluIiwiY3Vyc29yIiwic2Nyb2xsSW50b1ZpZXciLCJ5IiwiZGVmaW5lIiwiZGlhbG9nRmllbGQiLCJjcmVhdGUiLCJ1cGRhdGUiLCJ0ciIsImUiLCJpcyIsInByb3ZpZGUiLCJmIiwidmFsIiwiZ290b0xpbmUiLCJwYW5lbCIsImZpZWxkIiwiYXBwZW5kQ29uZmlnIiwiYmFzZVRoZW1lJDEiLCJxdWVyeVNlbGVjdG9yIiwic2VsZWN0IiwiYmFzZVRoZW1lIiwicGFkZGluZyIsInBvc2l0aW9uIiwiZm9udFNpemUiLCJ0b3AiLCJib3R0b20iLCJyaWdodCIsImJhY2tncm91bmRDb2xvciIsImJvcmRlciIsImZvbnQiLCJkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucyIsImhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3IiLCJtaW5TZWxlY3Rpb25MZW5ndGgiLCJtYXhNYXRjaGVzIiwid2hvbGVXb3JkcyIsImhpZ2hsaWdodENvbmZpZyIsImNvbWJpbmUiLCJhIiwiYiIsImhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMiLCJleHQiLCJkZWZhdWx0VGhlbWUiLCJtYXRjaEhpZ2hsaWdodGVyIiwibWF0Y2hEZWNvIiwibWFyayIsIm1haW5NYXRjaERlY28iLCJpbnNpZGVXb3JkQm91bmRhcmllcyIsImNoZWNrIiwic2xpY2VEb2MiLCJXb3JkIiwiaW5zaWRlV29yZCIsImZyb21DbGFzcyIsImRlY29yYXRpb25zIiwiZ2V0RGVjbyIsInNlbGVjdGlvblNldCIsImRvY0NoYW5nZWQiLCJ2aWV3cG9ydENoYW5nZWQiLCJjb25mIiwiZmFjZXQiLCJzZWwiLCJyYW5nZXMiLCJub25lIiwicmFuZ2UiLCJ3b3JkIiwid29yZEF0IiwiY2hhckNhdGVnb3JpemVyIiwibGVuIiwiZGVjbyIsInBhcnQiLCJ2aXNpYmxlUmFuZ2VzIiwidiIsInNlbGVjdFdvcmQiLCJuZXdTZWwiLCJtYXAiLCJtYWluSW5kZXgiLCJlcSIsImZpbmROZXh0T2NjdXJyZW5jZSIsImZ1bGxXb3JkIiwiY3ljbGVkIiwic29tZSIsInIiLCJzZWxlY3ROZXh0T2NjdXJyZW5jZSIsInNlYXJjaGVkVGV4dCIsImFkZFJhbmdlIiwic2VhcmNoQ29uZmlnRmFjZXQiLCJjb25maWdzIiwiY2FzZVNlbnNpdGl2ZSIsImxpdGVyYWwiLCJyZWdleHAiLCJ3aG9sZVdvcmQiLCJjcmVhdGVQYW5lbCIsIlNlYXJjaFBhbmVsIiwic2Nyb2xsVG9NYXRjaCIsInNlYXJjaCIsImNvbmZpZyIsInNlYXJjaEV4dGVuc2lvbnMiLCJTZWFyY2hRdWVyeSIsInJlcGxhY2UiLCJ2YWxpZCIsInVucXVvdGVkIiwidW5xdW90ZSIsIl8iLCJjaCIsIm90aGVyIiwiUmVnRXhwUXVlcnkiLCJTdHJpbmdRdWVyeSIsImdldEN1cnNvciIsInN0IiwicmVnZXhwQ3Vyc29yIiwic3RyaW5nQ3Vyc29yIiwiUXVlcnlUeXBlIiwic3BlYyIsInVuZGVmaW5lZCIsInRvTG93ZXJDYXNlIiwic3RyaW5nV29yZFRlc3QiLCJjYXRlZ29yaXplciIsImJ1ZiIsImJ1ZlBvcyIsImNoYXJCZWZvcmUiLCJjaGFyQWZ0ZXIiLCJuZXh0TWF0Y2giLCJjdXJGcm9tIiwiY3VyVG8iLCJwcmV2TWF0Y2hJblJhbmdlIiwicHJldk1hdGNoIiwiZm91bmQiLCJnZXRSZXBsYWNlbWVudCIsIl9yZXN1bHQiLCJtYXRjaEFsbCIsImxpbWl0IiwiaGlnaGxpZ2h0IiwiYWRkIiwicmVnZXhwV29yZFRlc3QiLCJfZnJvbSIsIl90byIsInNpemUiLCJyZXN1bHQiLCJtIiwibCIsIm4iLCJzZXRTZWFyY2hRdWVyeSIsInRvZ2dsZVBhbmVsIiwic2VhcmNoU3RhdGUiLCJTZWFyY2hTdGF0ZSIsImRlZmF1bHRRdWVyeSIsImVmZmVjdCIsImNyZWF0ZVNlYXJjaFBhbmVsIiwiZ2V0U2VhcmNoUXVlcnkiLCJjdXJTdGF0ZSIsInNlYXJjaFBhbmVsT3BlbiIsIm1hdGNoTWFyayIsInNlbGVjdGVkTWF0Y2hNYXJrIiwic2VhcmNoSGlnaGxpZ2h0ZXIiLCJzdGFydFN0YXRlIiwiYnVpbGRlciIsInNlbGVjdGVkIiwiZmluaXNoIiwic2VhcmNoQ29tbWFuZCIsIm9wZW5TZWFyY2hQYW5lbCIsImZpbmROZXh0Iiwic2luZ2xlIiwiYW5ub3VuY2VNYXRjaCIsInVzZXJFdmVudCIsInNlbGVjdFNlYXJjaElucHV0IiwiZmluZFByZXZpb3VzIiwicHJldiIsInNlbGVjdE1hdGNoZXMiLCJzZWxlY3RTZWxlY3Rpb25NYXRjaGVzIiwiY3VyIiwicmVwbGFjZU5leHQiLCJyZWFkT25seSIsImNoYW5nZXMiLCJyZXBsYWNlbWVudCIsInRvVGV4dCIsImluc2VydCIsImFubm91bmNlIiwicmVwbGFjZUFsbCIsImFubm91bmNlVGV4dCIsImZhbGxiYWNrIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJzZWxUZXh0IiwiZ2V0U2VhcmNoSW5wdXQiLCJyb290IiwiYWN0aXZlRWxlbWVudCIsInNlYXJjaElucHV0IiwiY2xvc2VTZWFyY2hQYW5lbCIsImNvbnRhaW5zIiwic2VhcmNoS2V5bWFwIiwia2V5IiwicnVuIiwic2NvcGUiLCJzaGlmdCIsImNvbW1pdCIsImJpbmQiLCJzZWFyY2hGaWVsZCIsInBsYWNlaG9sZGVyIiwiZm9ybSIsIm9uY2hhbmdlIiwib25rZXl1cCIsInJlcGxhY2VGaWVsZCIsImNhc2VGaWVsZCIsImNoZWNrZWQiLCJyZUZpZWxkIiwid29yZEZpZWxkIiwiYnV0dG9uIiwiY29udGVudCIsImtleWRvd24iLCJ0YXJnZXQiLCJzaGlmdEtleSIsInRyYW5zYWN0aW9ucyIsInNldFF1ZXJ5IiwibW91bnQiLCJBbm5vdW5jZU1hcmdpbiIsIkJyZWFrIiwibGluZUVuZCIsIm1hcmdpbiIsIm1hcmdpblJpZ2h0Iiwid2hpdGVTcGFjZSIsImxvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/search/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/state/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Annotation: () => (/* binding */ Annotation),\n/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),\n/* harmony export */   ChangeDesc: () => (/* binding */ ChangeDesc),\n/* harmony export */   ChangeSet: () => (/* binding */ ChangeSet),\n/* harmony export */   CharCategory: () => (/* binding */ CharCategory),\n/* harmony export */   Compartment: () => (/* binding */ Compartment),\n/* harmony export */   EditorSelection: () => (/* binding */ EditorSelection),\n/* harmony export */   EditorState: () => (/* binding */ EditorState),\n/* harmony export */   Facet: () => (/* binding */ Facet),\n/* harmony export */   Line: () => (/* binding */ Line),\n/* harmony export */   MapMode: () => (/* binding */ MapMode),\n/* harmony export */   Prec: () => (/* binding */ Prec),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeSet: () => (/* binding */ RangeSet),\n/* harmony export */   RangeSetBuilder: () => (/* binding */ RangeSetBuilder),\n/* harmony export */   RangeValue: () => (/* binding */ RangeValue),\n/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),\n/* harmony export */   StateEffect: () => (/* binding */ StateEffect),\n/* harmony export */   StateEffectType: () => (/* binding */ StateEffectType),\n/* harmony export */   StateField: () => (/* binding */ StateField),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   codePointAt: () => (/* binding */ codePointAt),\n/* harmony export */   codePointSize: () => (/* binding */ codePointSize),\n/* harmony export */   combineConfig: () => (/* binding */ combineConfig),\n/* harmony export */   countColumn: () => (/* binding */ countColumn),\n/* harmony export */   findClusterBreak: () => (/* binding */ findClusterBreak),\n/* harmony export */   findColumn: () => (/* binding */ findColumn),\n/* harmony export */   fromCodePoint: () => (/* binding */ fromCodePoint)\n/* harmony export */ });\n/* harmony import */ var _marijn_find_cluster_break__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @marijn/find-cluster-break */ \"(ssr)/./node_modules/@marijn/find-cluster-break/src/index.js\");\n\n/**\nThe data structure for documents. @nonabstract\n*/ class Text {\n    /**\n    Get the line description around the given position.\n    */ lineAt(pos) {\n        if (pos < 0 || pos > this.length) throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        return this.lineInner(pos, false, 1, 0);\n    }\n    /**\n    Get the description for the given (1-based) line number.\n    */ line(n) {\n        if (n < 1 || n > this.lines) throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        return this.lineInner(n, true, 1, 0);\n    }\n    /**\n    Replace a range of the text with the given content.\n    */ replace(from, to, text) {\n        [from, to] = clip(this, from, to);\n        let parts = [];\n        this.decompose(0, from, parts, 2 /* Open.To */ );\n        if (text.length) text.decompose(0, text.length, parts, 1 /* Open.From */  | 2 /* Open.To */ );\n        this.decompose(to, this.length, parts, 1 /* Open.From */ );\n        return TextNode.from(parts, this.length - (to - from) + text.length);\n    }\n    /**\n    Append another document to this one.\n    */ append(other) {\n        return this.replace(this.length, this.length, other);\n    }\n    /**\n    Retrieve the text between the given points.\n    */ slice(from, to = this.length) {\n        [from, to] = clip(this, from, to);\n        let parts = [];\n        this.decompose(from, to, parts, 0);\n        return TextNode.from(parts, to - from);\n    }\n    /**\n    Test whether this text is equal to another instance.\n    */ eq(other) {\n        if (other == this) return true;\n        if (other.length != this.length || other.lines != this.lines) return false;\n        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);\n        let a = new RawTextCursor(this), b = new RawTextCursor(other);\n        for(let skip = start, pos = start;;){\n            a.next(skip);\n            b.next(skip);\n            skip = 0;\n            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;\n            pos += a.value.length;\n            if (a.done || pos >= end) return true;\n        }\n    }\n    /**\n    Iterate over the text. When `dir` is `-1`, iteration happens\n    from end to start. This will return lines and the breaks between\n    them as separate strings.\n    */ iter(dir = 1) {\n        return new RawTextCursor(this, dir);\n    }\n    /**\n    Iterate over a range of the text. When `from` > `to`, the\n    iterator will run in reverse.\n    */ iterRange(from, to = this.length) {\n        return new PartialTextCursor(this, from, to);\n    }\n    /**\n    Return a cursor that iterates over the given range of lines,\n    _without_ returning the line breaks between, and yielding empty\n    strings for empty lines.\n    \n    When `from` and `to` are given, they should be 1-based line numbers.\n    */ iterLines(from, to) {\n        let inner;\n        if (from == null) {\n            inner = this.iter();\n        } else {\n            if (to == null) to = this.lines + 1;\n            let start = this.line(from).from;\n            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));\n        }\n        return new LineCursor(inner);\n    }\n    /**\n    Return the document as a string, using newline characters to\n    separate lines.\n    */ toString() {\n        return this.sliceString(0);\n    }\n    /**\n    Convert the document to an array of lines (which can be\n    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).\n    */ toJSON() {\n        let lines = [];\n        this.flatten(lines);\n        return lines;\n    }\n    /**\n    @internal\n    */ constructor(){}\n    /**\n    Create a `Text` instance for the given array of lines.\n    */ static of(text) {\n        if (text.length == 0) throw new RangeError(\"A document must have at least one line\");\n        if (text.length == 1 && !text[0]) return Text.empty;\n        return text.length <= 32 /* Tree.Branch */  ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n    }\n}\n// Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)){\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() {\n        return this.text.length;\n    }\n    get children() {\n        return null;\n    }\n    lineInner(target, isLine, line, offset) {\n        for(let i = 0;; i++){\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target) return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decompose(from, to, target, open) {\n        let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n        if (open & 1 /* Open.From */ ) {\n            let prev = target.pop();\n            let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n            if (joined.length <= 32 /* Tree.Branch */ ) {\n                target.push(new TextLeaf(joined, prev.length + text.length));\n            } else {\n                let mid = joined.length >> 1;\n                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n            }\n        } else {\n            target.push(text);\n        }\n    }\n    replace(from, to, text) {\n        if (!(text instanceof TextLeaf)) return super.replace(from, to, text);\n        [from, to] = clip(this, from, to);\n        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n        let newLen = this.length + text.length - (to - from);\n        if (lines.length <= 32 /* Tree.Branch */ ) return new TextLeaf(lines, newLen);\n        return TextNode.from(TextLeaf.split(lines, []), newLen);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        [from, to] = clip(this, from, to);\n        let result = \"\";\n        for(let pos = 0, i = 0; pos <= to && i < this.text.length; i++){\n            let line = this.text[i], end = pos + line.length;\n            if (pos > from && i) result += lineSep;\n            if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let line of this.text)target.push(line);\n    }\n    scanIdentical() {\n        return 0;\n    }\n    static split(text, target) {\n        let part = [], len = -1;\n        for (let line of text){\n            part.push(line);\n            len += line.length + 1;\n            if (part.length == 32 /* Tree.Branch */ ) {\n                target.push(new TextLeaf(part, len));\n                part = [];\n                len = -1;\n            }\n        }\n        if (len > -1) target.push(new TextLeaf(part, len));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\nclass TextNode extends Text {\n    constructor(children, length){\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 0;\n        for (let child of children)this.lines += child.lines;\n    }\n    lineInner(target, isLine, line, offset) {\n        for(let i = 0;; i++){\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);\n            offset = end + 1;\n            line = endLine + 1;\n        }\n    }\n    decompose(from, to, target, open) {\n        for(let i = 0, pos = 0; pos <= to && i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (from <= end && to >= pos) {\n                let childOpen = open & ((pos <= from ? 1 /* Open.From */  : 0) | (end >= to ? 2 /* Open.To */  : 0));\n                if (pos >= from && end <= to && !childOpen) target.push(child);\n                else child.decompose(from - pos, to - pos, target, childOpen);\n            }\n            pos = end + 1;\n        }\n    }\n    replace(from, to, text) {\n        [from, to] = clip(this, from, to);\n        if (text.lines < this.lines) for(let i = 0, pos = 0; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            // Fast path: if the change only affects one child and the\n            // child's size remains in the acceptable range, only update\n            // that child\n            if (from >= pos && to <= end) {\n                let updated = child.replace(from - pos, to - pos, text);\n                let totalLines = this.lines - child.lines + updated.lines;\n                if (updated.lines < totalLines >> 5 /* Tree.BranchShift */  - 1 && updated.lines > totalLines >> 5 /* Tree.BranchShift */  + 1) {\n                    let copy = this.children.slice();\n                    copy[i] = updated;\n                    return new TextNode(copy, this.length - (to - from) + text.length);\n                }\n                return super.replace(pos, end, updated);\n            }\n            pos = end + 1;\n        }\n        return super.replace(from, to, text);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        [from, to] = clip(this, from, to);\n        let result = \"\";\n        for(let i = 0, pos = 0; i < this.children.length && pos <= to; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (pos > from && i) result += lineSep;\n            if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let child of this.children)child.flatten(target);\n    }\n    scanIdentical(other, dir) {\n        if (!(other instanceof TextNode)) return 0;\n        let length = 0;\n        let [iA, iB, eA, eB] = dir > 0 ? [\n            0,\n            0,\n            this.children.length,\n            other.children.length\n        ] : [\n            this.children.length - 1,\n            other.children.length - 1,\n            -1,\n            -1\n        ];\n        for(;; iA += dir, iB += dir){\n            if (iA == eA || iB == eB) return length;\n            let chA = this.children[iA], chB = other.children[iB];\n            if (chA != chB) return length + chA.scanIdentical(chB, dir);\n            length += chA.length + 1;\n        }\n    }\n    static from(children, length = children.reduce((l, ch)=>l + ch.length + 1, -1)) {\n        let lines = 0;\n        for (let ch of children)lines += ch.lines;\n        if (lines < 32 /* Tree.Branch */ ) {\n            let flat = [];\n            for (let ch of children)ch.flatten(flat);\n            return new TextLeaf(flat, length);\n        }\n        let chunk = Math.max(32 /* Tree.Branch */ , lines >> 5 /* Tree.BranchShift */ ), maxChunk = chunk << 1, minChunk = chunk >> 1;\n        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];\n        function add(child) {\n            let last;\n            if (child.lines > maxChunk && child instanceof TextNode) {\n                for (let node of child.children)add(node);\n            } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n                flush();\n                chunked.push(child);\n            } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32 /* Tree.Branch */ ) {\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n            } else {\n                if (currentLines + child.lines > chunk) flush();\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLines == 0) return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n            currentLen = -1;\n            currentLines = currentChunk.length = 0;\n        }\n        for (let child of children)add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = /*@__PURE__*/ new TextLeaf([\n    \"\"\n], 0);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for(let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++){\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to) line = line.slice(0, to - pos);\n            if (pos < from) line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            } else target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\n        \"\"\n    ], from, to);\n}\nclass RawTextCursor {\n    constructor(text, dir = 1){\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [\n            text\n        ];\n        this.offsets = [\n            dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1\n        ];\n    }\n    nextInner(skip, dir) {\n        this.done = this.lineBreak = false;\n        for(;;){\n            let last = this.nodes.length - 1;\n            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;\n            let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n            if (offset == (dir > 0 ? size : 0)) {\n                if (last == 0) {\n                    this.done = true;\n                    this.value = \"\";\n                    return this;\n                }\n                if (dir > 0) this.offsets[last - 1]++;\n                this.nodes.pop();\n                this.offsets.pop();\n            } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {\n                this.offsets[last] += dir;\n                if (skip == 0) {\n                    this.lineBreak = true;\n                    this.value = \"\\n\";\n                    return this;\n                }\n                skip--;\n            } else if (top instanceof TextLeaf) {\n                // Move to the next string\n                let next = top.text[offset + (dir < 0 ? -1 : 0)];\n                this.offsets[last] += dir;\n                if (next.length > Math.max(0, skip)) {\n                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            } else {\n                let next = top.children[offset + (dir < 0 ? -1 : 0)];\n                if (skip > next.length) {\n                    skip -= next.length;\n                    this.offsets[last] += dir;\n                } else {\n                    if (dir < 0) this.offsets[last]--;\n                    this.nodes.push(next);\n                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);\n                }\n            }\n        }\n    }\n    next(skip = 0) {\n        if (skip < 0) {\n            this.nextInner(-skip, -this.dir);\n            skip = this.value.length;\n        }\n        return this.nextInner(skip, this.dir);\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end){\n        this.value = \"\";\n        this.done = false;\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        this.pos = start > end ? text.length : 0;\n        this.from = Math.min(start, end);\n        this.to = Math.max(start, end);\n    }\n    nextInner(skip, dir) {\n        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {\n            this.value = \"\";\n            this.done = true;\n            return this;\n        }\n        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);\n        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;\n        if (skip > limit) skip = limit;\n        limit -= skip;\n        let { value } = this.cursor.next(skip);\n        this.pos += (value.length + skip) * dir;\n        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);\n        this.done = !this.value;\n        return this;\n    }\n    next(skip = 0) {\n        if (skip < 0) skip = Math.max(skip, this.from - this.pos);\n        else if (skip > 0) skip = Math.min(skip, this.to - this.pos);\n        return this.nextInner(skip, this.cursor.dir);\n    }\n    get lineBreak() {\n        return this.cursor.lineBreak && this.value != \"\";\n    }\n}\nclass LineCursor {\n    constructor(inner){\n        this.inner = inner;\n        this.afterBreak = true;\n        this.value = \"\";\n        this.done = false;\n    }\n    next(skip = 0) {\n        let { done, lineBreak, value } = this.inner.next(skip);\n        if (done && this.afterBreak) {\n            this.value = \"\";\n            this.afterBreak = false;\n        } else if (done) {\n            this.done = true;\n            this.value = \"\";\n        } else if (lineBreak) {\n            if (this.afterBreak) {\n                this.value = \"\";\n            } else {\n                this.afterBreak = true;\n                this.next();\n            }\n        } else {\n            this.value = value;\n            this.afterBreak = false;\n        }\n        return this;\n    }\n    get lineBreak() {\n        return false;\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    Text.prototype[Symbol.iterator] = function() {\n        return this.iter();\n    };\n    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {\n        return this;\n    };\n}\n/**\nThis type describes a line in the document. It is created\non-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).\n*/ class Line {\n    /**\n    @internal\n    */ constructor(/**\n    The position of the start of the line.\n    */ from, /**\n    The position at the end of the line (_before_ the line break,\n    or at the end of document for the last line).\n    */ to, /**\n    This line's line number (1-based).\n    */ number, /**\n    The line's content.\n    */ text){\n        this.from = from;\n        this.to = to;\n        this.number = number;\n        this.text = text;\n    }\n    /**\n    The length of the line (not including any line break after it).\n    */ get length() {\n        return this.to - this.from;\n    }\n}\nfunction clip(text, from, to) {\n    from = Math.max(0, Math.min(text.length, from));\n    return [\n        from,\n        Math.max(from, Math.min(text.length, to))\n    ];\n}\n/**\nReturns a next grapheme cluster break _after_ (not equal to)\n`pos`, if `forward` is true, or before otherwise. Returns `pos`\nitself if no further cluster break is available in the string.\nMoves across surrogate pairs, extending characters (when\n`includeExtending` is true), characters joined with zero-width\njoiners, and flag emoji.\n*/ function findClusterBreak(str, pos, forward = true, includeExtending = true) {\n    return (0,_marijn_find_cluster_break__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(str, pos, forward, includeExtending);\n}\nfunction surrogateLow(ch) {\n    return ch >= 0xDC00 && ch < 0xE000;\n}\nfunction surrogateHigh(ch) {\n    return ch >= 0xD800 && ch < 0xDC00;\n}\n/**\nFind the code point at the given position in a string (like the\n[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\nstring method).\n*/ function codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (!surrogateLow(code1)) return code0;\n    return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/**\nGiven a Unicode codepoint, return the JavaScript string that\nrespresents it (like\n[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\n*/ function fromCodePoint(code) {\n    if (code <= 0xffff) return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/**\nThe amount of positions a character takes up in a JavaScript string.\n*/ function codePointSize(code) {\n    return code < 0x10000 ? 1 : 2;\n}\nconst DefaultSplit = /\\r\\n?|\\n/;\n/**\nDistinguishes different ways in which positions can be mapped.\n*/ var MapMode = /*@__PURE__*/ function(MapMode) {\n    /**\n    Map a position to a valid new position, even when its context\n    was deleted.\n    */ MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n    /**\n    Return null if deletion happens across the position.\n    */ MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n    /**\n    Return null if the character _before_ the position is deleted.\n    */ MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n    /**\n    Return null if the character _after_ the position is deleted.\n    */ MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\n    return MapMode;\n}(MapMode || (MapMode = {}));\n/**\nA change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)\nthat doesn't store the inserted text. As such, it can't be\napplied, but is cheaper to store and manipulate.\n*/ class ChangeDesc {\n    // Sections are encoded as pairs of integers. The first is the\n    // length in the current document, and the second is -1 for\n    // unaffected sections, and the length of the replacement content\n    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n    // 0), and a replacement two positive numbers.\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ sections){\n        this.sections = sections;\n    }\n    /**\n    The length of the document before the change.\n    */ get length() {\n        let result = 0;\n        for(let i = 0; i < this.sections.length; i += 2)result += this.sections[i];\n        return result;\n    }\n    /**\n    The length of the document after the change.\n    */ get newLength() {\n        let result = 0;\n        for(let i = 0; i < this.sections.length; i += 2){\n            let ins = this.sections[i + 1];\n            result += ins < 0 ? this.sections[i] : ins;\n        }\n        return result;\n    }\n    /**\n    False when there are actual changes in this set.\n    */ get empty() {\n        return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;\n    }\n    /**\n    Iterate over the unchanged parts left by these changes. `posA`\n    provides the position of the range in the old document, `posB`\n    the new position in the changed document.\n    */ iterGaps(f) {\n        for(let i = 0, posA = 0, posB = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) {\n                f(posA, posB, len);\n                posB += len;\n            } else {\n                posB += ins;\n            }\n            posA += len;\n        }\n    }\n    /**\n    Iterate over the ranges changed by these changes. (See\n    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a\n    variant that also provides you with the inserted text.)\n    `fromA`/`toA` provides the extent of the change in the starting\n    document, `fromB`/`toB` the extent of the replacement in the\n    changed document.\n    \n    When `individual` is true, adjacent changes (which are kept\n    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are\n    reported separately.\n    */ iterChangedRanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a description of the inverted form of these changes.\n    */ get invertedDesc() {\n        let sections = [];\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            if (ins < 0) sections.push(len, ins);\n            else sections.push(ins, len);\n        }\n        return new ChangeDesc(sections);\n    }\n    /**\n    Compute the combined effect of applying another set of changes\n    after this one. The length of the document after this set should\n    match the length before `other`.\n    */ composeDesc(other) {\n        return this.empty ? other : other.empty ? this : composeSets(this, other);\n    }\n    /**\n    Map this description, which should start with the same document\n    as `other`, over another set of changes, so that it can be\n    applied after it. When `before` is true, map as if the changes\n    in `this` happened before the ones in `other`.\n    */ mapDesc(other, before = false) {\n        return other.empty ? this : mapSet(this, other, before);\n    }\n    mapPos(pos, assoc = -1, mode = MapMode.Simple) {\n        let posA = 0, posB = 0;\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;\n            if (ins < 0) {\n                if (endA > pos) return posB + (pos - posA);\n                posB += len;\n            } else {\n                if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;\n                if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;\n                posB += ins;\n            }\n            posA = endA;\n        }\n        if (pos > posA) throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);\n        return posB;\n    }\n    /**\n    Check whether these changes touch a given range. When one of the\n    changes entirely covers the range, the string `\"cover\"` is\n    returned.\n    */ touchesRange(from, to = from) {\n        for(let i = 0, pos = 0; i < this.sections.length && pos <= to;){\n            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;\n            if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? \"cover\" : true;\n            pos = end;\n        }\n        return false;\n    }\n    /**\n    @internal\n    */ toString() {\n        let result = \"\";\n        for(let i = 0; i < this.sections.length;){\n            let len = this.sections[i++], ins = this.sections[i++];\n            result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n        }\n        return result;\n    }\n    /**\n    Serialize this change desc to a JSON-representable value.\n    */ toJSON() {\n        return this.sections;\n    }\n    /**\n    Create a change desc from its JSON representation (as produced\n    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).\n    */ static fromJSON(json) {\n        if (!Array.isArray(json) || json.length % 2 || json.some((a)=>typeof a != \"number\")) throw new RangeError(\"Invalid JSON representation of ChangeDesc\");\n        return new ChangeDesc(json);\n    }\n    /**\n    @internal\n    */ static create(sections) {\n        return new ChangeDesc(sections);\n    }\n}\n/**\nA change set represents a group of modifications to a document. It\nstores the document length, and can only be applied to documents\nwith exactly that length.\n*/ class ChangeSet extends ChangeDesc {\n    constructor(sections, /**\n    @internal\n    */ inserted){\n        super(sections);\n        this.inserted = inserted;\n    }\n    /**\n    Apply the changes to a document, returning the modified\n    document.\n    */ apply(doc) {\n        if (this.length != doc.length) throw new RangeError(\"Applying change set to a document with the wrong length\");\n        iterChanges(this, (fromA, toA, fromB, _toB, text)=>doc = doc.replace(fromB, fromB + (toA - fromA), text), false);\n        return doc;\n    }\n    mapDesc(other, before = false) {\n        return mapSet(this, other, before, true);\n    }\n    /**\n    Given the document as it existed _before_ the changes, return a\n    change set that represents the inverse of this set, which could\n    be used to go from the document created by the changes back to\n    the document as it existed before the changes.\n    */ invert(doc) {\n        let sections = this.sections.slice(), inserted = [];\n        for(let i = 0, pos = 0; i < sections.length; i += 2){\n            let len = sections[i], ins = sections[i + 1];\n            if (ins >= 0) {\n                sections[i] = ins;\n                sections[i + 1] = len;\n                let index = i >> 1;\n                while(inserted.length < index)inserted.push(Text.empty);\n                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);\n            }\n            pos += len;\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    Combine two subsequent change sets into a single set. `other`\n    must start in the document produced by `this`. If `this` goes\n    `docA` → `docB` and `other` represents `docB` → `docC`, the\n    returned value will represent the change `docA` → `docC`.\n    */ compose(other) {\n        return this.empty ? other : other.empty ? this : composeSets(this, other, true);\n    }\n    /**\n    Given another change set starting in the same document, maps this\n    change set over the other, producing a new change set that can be\n    applied to the document produced by applying `other`. When\n    `before` is `true`, order changes as if `this` comes before\n    `other`, otherwise (the default) treat `other` as coming first.\n    \n    Given two changes `A` and `B`, `A.compose(B.map(A))` and\n    `B.compose(A.map(B, true))` will produce the same document. This\n    provides a basic form of [operational\n    transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n    and can be used for collaborative editing.\n    */ map(other, before = false) {\n        return other.empty ? this : mapSet(this, other, before, true);\n    }\n    /**\n    Iterate over the changed ranges in the document, calling `f` for\n    each, with the range in the original document (`fromA`-`toA`)\n    and the range that replaces it in the new document\n    (`fromB`-`toB`).\n    \n    When `individual` is true, adjacent changes are reported\n    separately.\n    */ iterChanges(f, individual = false) {\n        iterChanges(this, f, individual);\n    }\n    /**\n    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change\n    set.\n    */ get desc() {\n        return ChangeDesc.create(this.sections);\n    }\n    /**\n    @internal\n    */ filter(ranges) {\n        let resultSections = [], resultInserted = [], filteredSections = [];\n        let iter = new SectionIter(this);\n        done: for(let i = 0, pos = 0;;){\n            let next = i == ranges.length ? 1e9 : ranges[i++];\n            while(pos < next || pos == next && iter.len == 0){\n                if (iter.done) break done;\n                let len = Math.min(iter.len, next - pos);\n                addSection(filteredSections, len, -1);\n                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n                addSection(resultSections, len, ins);\n                if (ins > 0) addInsert(resultInserted, resultSections, iter.text);\n                iter.forward(len);\n                pos += len;\n            }\n            let end = ranges[i++];\n            while(pos < end){\n                if (iter.done) break done;\n                let len = Math.min(iter.len, end - pos);\n                addSection(resultSections, len, -1);\n                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n                iter.forward(len);\n                pos += len;\n            }\n        }\n        return {\n            changes: new ChangeSet(resultSections, resultInserted),\n            filtered: ChangeDesc.create(filteredSections)\n        };\n    }\n    /**\n    Serialize this change set to a JSON-representable value.\n    */ toJSON() {\n        let parts = [];\n        for(let i = 0; i < this.sections.length; i += 2){\n            let len = this.sections[i], ins = this.sections[i + 1];\n            if (ins < 0) parts.push(len);\n            else if (ins == 0) parts.push([\n                len\n            ]);\n            else parts.push([\n                len\n            ].concat(this.inserted[i >> 1].toJSON()));\n        }\n        return parts;\n    }\n    /**\n    Create a change set for the given changes, for a document of the\n    given length, using `lineSep` as line separator.\n    */ static of(changes, length, lineSep) {\n        let sections = [], inserted = [], pos = 0;\n        let total = null;\n        function flush(force = false) {\n            if (!force && !sections.length) return;\n            if (pos < length) addSection(sections, length - pos, -1);\n            let set = new ChangeSet(sections, inserted);\n            total = total ? total.compose(set.map(total)) : set;\n            sections = [];\n            inserted = [];\n            pos = 0;\n        }\n        function process(spec) {\n            if (Array.isArray(spec)) {\n                for (let sub of spec)process(sub);\n            } else if (spec instanceof ChangeSet) {\n                if (spec.length != length) throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);\n                flush();\n                total = total ? total.compose(spec.map(total)) : spec;\n            } else {\n                let { from, to = from, insert } = spec;\n                if (from > to || from < 0 || to > length) throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);\n                let insText = !insert ? Text.empty : typeof insert == \"string\" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n                let insLen = insText.length;\n                if (from == to && insLen == 0) return;\n                if (from < pos) flush();\n                if (from > pos) addSection(sections, from - pos, -1);\n                addSection(sections, to - from, insLen);\n                addInsert(inserted, sections, insText);\n                pos = to;\n            }\n        }\n        process(changes);\n        flush(!total);\n        return total;\n    }\n    /**\n    Create an empty changeset of the given length.\n    */ static empty(length) {\n        return new ChangeSet(length ? [\n            length,\n            -1\n        ] : [], []);\n    }\n    /**\n    Create a changeset from its JSON representation (as produced by\n    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).\n    */ static fromJSON(json) {\n        if (!Array.isArray(json)) throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n        let sections = [], inserted = [];\n        for(let i = 0; i < json.length; i++){\n            let part = json[i];\n            if (typeof part == \"number\") {\n                sections.push(part, -1);\n            } else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some((e, i)=>i && typeof e != \"string\")) {\n                throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n            } else if (part.length == 1) {\n                sections.push(part[0], 0);\n            } else {\n                while(inserted.length < i)inserted.push(Text.empty);\n                inserted[i] = Text.of(part.slice(1));\n                sections.push(part[0], inserted[i].length);\n            }\n        }\n        return new ChangeSet(sections, inserted);\n    }\n    /**\n    @internal\n    */ static createSet(sections, inserted) {\n        return new ChangeSet(sections, inserted);\n    }\n}\nfunction addSection(sections, len, ins, forceJoin = false) {\n    if (len == 0 && ins <= 0) return;\n    let last = sections.length - 2;\n    if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len;\n    else if (last >= 0 && len == 0 && sections[last] == 0) sections[last + 1] += ins;\n    else if (forceJoin) {\n        sections[last] += len;\n        sections[last + 1] += ins;\n    } else sections.push(len, ins);\n}\nfunction addInsert(values, sections, value) {\n    if (value.length == 0) return;\n    let index = sections.length - 2 >> 1;\n    if (index < values.length) {\n        values[values.length - 1] = values[values.length - 1].append(value);\n    } else {\n        while(values.length < index)values.push(Text.empty);\n        values.push(value);\n    }\n}\nfunction iterChanges(desc, f, individual) {\n    let inserted = desc.inserted;\n    for(let posA = 0, posB = 0, i = 0; i < desc.sections.length;){\n        let len = desc.sections[i++], ins = desc.sections[i++];\n        if (ins < 0) {\n            posA += len;\n            posB += len;\n        } else {\n            let endA = posA, endB = posB, text = Text.empty;\n            for(;;){\n                endA += len;\n                endB += ins;\n                if (ins && inserted) text = text.append(inserted[i - 2 >> 1]);\n                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0) break;\n                len = desc.sections[i++];\n                ins = desc.sections[i++];\n            }\n            f(posA, endA, posB, endB, text);\n            posA = endA;\n            posB = endB;\n        }\n    }\n}\nfunction mapSet(setA, setB, before, mkSet = false) {\n    // Produce a copy of setA that applies to the document after setB\n    // has been applied (assuming both start at the same document).\n    let sections = [], insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    // Iterate over both sets in parallel. inserted tracks, for changes\n    // in A that have to be processed piece-by-piece, whether their\n    // content has been inserted already, and refers to the section\n    // index.\n    for(let inserted = -1;;){\n        if (a.done && b.len || b.done && a.len) {\n            throw new Error(\"Mismatched change set lengths\");\n        } else if (a.ins == -1 && b.ins == -1) {\n            // Move across ranges skipped by both sets.\n            let len = Math.min(a.len, b.len);\n            addSection(sections, len, -1);\n            a.forward(len);\n            b.forward(len);\n        } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {\n            // If there's a change in B that comes before the next change in\n            // A (ordered by start pos, then len, then before flag), skip\n            // that (and process any changes in A it covers).\n            let len = b.len;\n            addSection(sections, b.ins, -1);\n            while(len){\n                let piece = Math.min(a.len, len);\n                if (a.ins >= 0 && inserted < a.i && a.len <= piece) {\n                    addSection(sections, 0, a.ins);\n                    if (insert) addInsert(insert, sections, a.text);\n                    inserted = a.i;\n                }\n                a.forward(piece);\n                len -= piece;\n            }\n            b.next();\n        } else if (a.ins >= 0) {\n            // Process the part of a change in A up to the start of the next\n            // non-deletion change in B (if overlapping).\n            let len = 0, left = a.len;\n            while(left){\n                if (b.ins == -1) {\n                    let piece = Math.min(left, b.len);\n                    len += piece;\n                    left -= piece;\n                    b.forward(piece);\n                } else if (b.ins == 0 && b.len < left) {\n                    left -= b.len;\n                    b.next();\n                } else {\n                    break;\n                }\n            }\n            addSection(sections, len, inserted < a.i ? a.ins : 0);\n            if (insert && inserted < a.i) addInsert(insert, sections, a.text);\n            inserted = a.i;\n            a.forward(a.len - left);\n        } else if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        } else {\n            throw new Error(\"Mismatched change set lengths\");\n        }\n    }\n}\nfunction composeSets(setA, setB, mkSet = false) {\n    let sections = [];\n    let insert = mkSet ? [] : null;\n    let a = new SectionIter(setA), b = new SectionIter(setB);\n    for(let open = false;;){\n        if (a.done && b.done) {\n            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);\n        } else if (a.ins == 0) {\n            addSection(sections, a.len, 0, open);\n            a.next();\n        } else if (b.len == 0 && !b.done) {\n            addSection(sections, 0, b.ins, open);\n            if (insert) addInsert(insert, sections, b.text);\n            b.next();\n        } else if (a.done || b.done) {\n            throw new Error(\"Mismatched change set lengths\");\n        } else {\n            let len = Math.min(a.len2, b.len), sectionLen = sections.length;\n            if (a.ins == -1) {\n                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n                addSection(sections, len, insB, open);\n                if (insert && insB) addInsert(insert, sections, b.text);\n            } else if (b.ins == -1) {\n                addSection(sections, a.off ? 0 : a.len, len, open);\n                if (insert) addInsert(insert, sections, a.textBit(len));\n            } else {\n                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n                if (insert && !b.off) addInsert(insert, sections, b.text);\n            }\n            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n            a.forward2(len);\n            b.forward(len);\n        }\n    }\n}\nclass SectionIter {\n    constructor(set){\n        this.set = set;\n        this.i = 0;\n        this.next();\n    }\n    next() {\n        let { sections } = this.set;\n        if (this.i < sections.length) {\n            this.len = sections[this.i++];\n            this.ins = sections[this.i++];\n        } else {\n            this.len = 0;\n            this.ins = -2;\n        }\n        this.off = 0;\n    }\n    get done() {\n        return this.ins == -2;\n    }\n    get len2() {\n        return this.ins < 0 ? this.len : this.ins;\n    }\n    get text() {\n        let { inserted } = this.set, index = this.i - 2 >> 1;\n        return index >= inserted.length ? Text.empty : inserted[index];\n    }\n    textBit(len) {\n        let { inserted } = this.set, index = this.i - 2 >> 1;\n        return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n    }\n    forward(len) {\n        if (len == this.len) this.next();\n        else {\n            this.len -= len;\n            this.off += len;\n        }\n    }\n    forward2(len) {\n        if (this.ins == -1) this.forward(len);\n        else if (len == this.ins) this.next();\n        else {\n            this.ins -= len;\n            this.off += len;\n        }\n    }\n}\n/**\nA single selection range. When\n[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\nis enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold\nmultiple ranges. By default, selections hold exactly one range.\n*/ class SelectionRange {\n    constructor(/**\n    The lower boundary of the range.\n    */ from, /**\n    The upper boundary of the range.\n    */ to, flags){\n        this.from = from;\n        this.to = to;\n        this.flags = flags;\n    }\n    /**\n    The anchor of the range—the side that doesn't move when you\n    extend it.\n    */ get anchor() {\n        return this.flags & 32 /* RangeFlag.Inverted */  ? this.to : this.from;\n    }\n    /**\n    The head of the range, which is moved when the range is\n    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).\n    */ get head() {\n        return this.flags & 32 /* RangeFlag.Inverted */  ? this.from : this.to;\n    }\n    /**\n    True when `anchor` and `head` are at the same position.\n    */ get empty() {\n        return this.from == this.to;\n    }\n    /**\n    If this is a cursor that is explicitly associated with the\n    character on one of its sides, this returns the side. -1 means\n    the character before its position, 1 the character after, and 0\n    means no association.\n    */ get assoc() {\n        return this.flags & 8 /* RangeFlag.AssocBefore */  ? -1 : this.flags & 16 /* RangeFlag.AssocAfter */  ? 1 : 0;\n    }\n    /**\n    The bidirectional text level associated with this cursor, if\n    any.\n    */ get bidiLevel() {\n        let level = this.flags & 7 /* RangeFlag.BidiLevelMask */ ;\n        return level == 7 ? null : level;\n    }\n    /**\n    The goal column (stored vertical offset) associated with a\n    cursor. This is used to preserve the vertical position when\n    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across\n    lines of different length.\n    */ get goalColumn() {\n        let value = this.flags >> 6 /* RangeFlag.GoalColumnOffset */ ;\n        return value == 16777215 /* RangeFlag.NoGoalColumn */  ? undefined : value;\n    }\n    /**\n    Map this range through a change, producing a valid range in the\n    updated document.\n    */ map(change, assoc = -1) {\n        let from, to;\n        if (this.empty) {\n            from = to = change.mapPos(this.from, assoc);\n        } else {\n            from = change.mapPos(this.from, 1);\n            to = change.mapPos(this.to, -1);\n        }\n        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n    }\n    /**\n    Extend this range to cover at least `from` to `to`.\n    */ extend(from, to = from) {\n        if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);\n        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n        return EditorSelection.range(this.anchor, head);\n    }\n    /**\n    Compare this range to another range.\n    */ eq(other, includeAssoc = false) {\n        return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);\n    }\n    /**\n    Return a JSON-serializable object representing the range.\n    */ toJSON() {\n        return {\n            anchor: this.anchor,\n            head: this.head\n        };\n    }\n    /**\n    Convert a JSON representation of a range to a `SelectionRange`\n    instance.\n    */ static fromJSON(json) {\n        if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\") throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n        return EditorSelection.range(json.anchor, json.head);\n    }\n    /**\n    @internal\n    */ static create(from, to, flags) {\n        return new SelectionRange(from, to, flags);\n    }\n}\n/**\nAn editor selection holds one or more selection ranges.\n*/ class EditorSelection {\n    constructor(/**\n    The ranges in the selection, sorted by position. Ranges cannot\n    overlap (but they may touch, if they aren't empty).\n    */ ranges, /**\n    The index of the _main_ range in the selection (which is\n    usually the range that was added last).\n    */ mainIndex){\n        this.ranges = ranges;\n        this.mainIndex = mainIndex;\n    }\n    /**\n    Map a selection through a change. Used to adjust the selection\n    position for changes.\n    */ map(change, assoc = -1) {\n        if (change.empty) return this;\n        return EditorSelection.create(this.ranges.map((r)=>r.map(change, assoc)), this.mainIndex);\n    }\n    /**\n    Compare this selection to another selection. By default, ranges\n    are compared only by position. When `includeAssoc` is true,\n    cursor ranges must also have the same\n    [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.\n    */ eq(other, includeAssoc = false) {\n        if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;\n        for(let i = 0; i < this.ranges.length; i++)if (!this.ranges[i].eq(other.ranges[i], includeAssoc)) return false;\n        return true;\n    }\n    /**\n    Get the primary selection range. Usually, you should make sure\n    your code applies to _all_ ranges, by using methods like\n    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).\n    */ get main() {\n        return this.ranges[this.mainIndex];\n    }\n    /**\n    Make sure the selection only has one range. Returns a selection\n    holding only the main range from this selection.\n    */ asSingle() {\n        return this.ranges.length == 1 ? this : new EditorSelection([\n            this.main\n        ], 0);\n    }\n    /**\n    Extend this selection with an extra range.\n    */ addRange(range, main = true) {\n        return EditorSelection.create([\n            range\n        ].concat(this.ranges), main ? 0 : this.mainIndex + 1);\n    }\n    /**\n    Replace a given range with another range, and then normalize the\n    selection to merge and sort ranges if necessary.\n    */ replaceRange(range, which = this.mainIndex) {\n        let ranges = this.ranges.slice();\n        ranges[which] = range;\n        return EditorSelection.create(ranges, this.mainIndex);\n    }\n    /**\n    Convert this selection to an object that can be serialized to\n    JSON.\n    */ toJSON() {\n        return {\n            ranges: this.ranges.map((r)=>r.toJSON()),\n            main: this.mainIndex\n        };\n    }\n    /**\n    Create a selection from a JSON representation.\n    */ static fromJSON(json) {\n        if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length) throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n        return new EditorSelection(json.ranges.map((r)=>SelectionRange.fromJSON(r)), json.main);\n    }\n    /**\n    Create a selection holding a single range.\n    */ static single(anchor, head = anchor) {\n        return new EditorSelection([\n            EditorSelection.range(anchor, head)\n        ], 0);\n    }\n    /**\n    Sort and merge the given set of ranges, creating a valid\n    selection.\n    */ static create(ranges, mainIndex = 0) {\n        if (ranges.length == 0) throw new RangeError(\"A selection needs at least one range\");\n        for(let pos = 0, i = 0; i < ranges.length; i++){\n            let range = ranges[i];\n            if (range.empty ? range.from <= pos : range.from < pos) return EditorSelection.normalized(ranges.slice(), mainIndex);\n            pos = range.to;\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n    /**\n    Create a cursor selection range at the given position. You can\n    safely ignore the optional arguments in most situations.\n    */ static cursor(pos, assoc = 0, bidiLevel, goalColumn) {\n        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 /* RangeFlag.AssocBefore */  : 16 /* RangeFlag.AssocAfter */ ) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */ ) << 6 /* RangeFlag.GoalColumnOffset */ );\n    }\n    /**\n    Create a selection range.\n    */ static range(anchor, head, goalColumn, bidiLevel) {\n        let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */ ) << 6 /* RangeFlag.GoalColumnOffset */  | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));\n        return head < anchor ? SelectionRange.create(head, anchor, 32 /* RangeFlag.Inverted */  | 16 /* RangeFlag.AssocAfter */  | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 /* RangeFlag.AssocBefore */  : 0) | flags);\n    }\n    /**\n    @internal\n    */ static normalized(ranges, mainIndex = 0) {\n        let main = ranges[mainIndex];\n        ranges.sort((a, b)=>a.from - b.from);\n        mainIndex = ranges.indexOf(main);\n        for(let i = 1; i < ranges.length; i++){\n            let range = ranges[i], prev = ranges[i - 1];\n            if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n                let from = prev.from, to = Math.max(range.to, prev.to);\n                if (i <= mainIndex) mainIndex--;\n                ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n            }\n        }\n        return new EditorSelection(ranges, mainIndex);\n    }\n}\nfunction checkSelection(selection, docLength) {\n    for (let range of selection.ranges)if (range.to > docLength) throw new RangeError(\"Selection points outside of document\");\n}\nlet nextID = 0;\n/**\nA facet is a labeled value that is associated with an editor\nstate. It takes inputs from any number of extensions, and combines\nthose into a single output value.\n\nExamples of uses of facets are the [tab\nsize](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor\nattributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update\nlisteners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).\n\nNote that `Facet` instances can be used anywhere where\n[`FacetReader`](https://codemirror.net/6/docs/ref/#state.FacetReader) is expected.\n*/ class Facet {\n    constructor(/**\n    @internal\n    */ combine, /**\n    @internal\n    */ compareInput, /**\n    @internal\n    */ compare, isStatic, enables){\n        this.combine = combine;\n        this.compareInput = compareInput;\n        this.compare = compare;\n        this.isStatic = isStatic;\n        /**\n        @internal\n        */ this.id = nextID++;\n        this.default = combine([]);\n        this.extensions = typeof enables == \"function\" ? enables(this) : enables;\n    }\n    /**\n    Returns a facet reader for this facet, which can be used to\n    [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.\n    */ get reader() {\n        return this;\n    }\n    /**\n    Define a new facet.\n    */ static define(config = {}) {\n        return new Facet(config.combine || ((a)=>a), config.compareInput || ((a, b)=>a === b), config.compare || (!config.combine ? sameArray : (a, b)=>a === b), !!config.static, config.enables);\n    }\n    /**\n    Returns an extension that adds the given value to this facet.\n    */ of(value) {\n        return new FacetProvider([], this, 0 /* Provider.Static */ , value);\n    }\n    /**\n    Create an extension that computes a value for the facet from a\n    state. You must take care to declare the parts of the state that\n    this value depends on, since your function is only called again\n    for a new state when one of those parts changed.\n    \n    In cases where your value depends only on a single field, you'll\n    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.\n    */ compute(deps, get) {\n        if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 1 /* Provider.Single */ , get);\n    }\n    /**\n    Create an extension that computes zero or more values for this\n    facet from a state.\n    */ computeN(deps, get) {\n        if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n        return new FacetProvider(deps, this, 2 /* Provider.Multi */ , get);\n    }\n    from(field, get) {\n        if (!get) get = (x)=>x;\n        return this.compute([\n            field\n        ], (state)=>get(state.field(field)));\n    }\n}\nfunction sameArray(a, b) {\n    return a == b || a.length == b.length && a.every((e, i)=>e === b[i]);\n}\nclass FacetProvider {\n    constructor(dependencies, facet, type, value){\n        this.dependencies = dependencies;\n        this.facet = facet;\n        this.type = type;\n        this.value = value;\n        this.id = nextID++;\n    }\n    dynamicSlot(addresses) {\n        var _a;\n        let getter = this.value;\n        let compare = this.facet.compareInput;\n        let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2 /* Provider.Multi */ ;\n        let depDoc = false, depSel = false, depAddrs = [];\n        for (let dep of this.dependencies){\n            if (dep == \"doc\") depDoc = true;\n            else if (dep == \"selection\") depSel = true;\n            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);\n        }\n        return {\n            create (state) {\n                state.values[idx] = getter(state);\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            update (state, tr) {\n                if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {\n                    let newVal = getter(state);\n                    if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {\n                        state.values[idx] = newVal;\n                        return 1 /* SlotStatus.Changed */ ;\n                    }\n                }\n                return 0;\n            },\n            reconfigure: (state, oldState)=>{\n                let newVal, oldAddr = oldState.config.address[id];\n                if (oldAddr != null) {\n                    let oldVal = getAddr(oldState, oldAddr);\n                    if (this.dependencies.every((dep)=>{\n                        return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;\n                    }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {\n                        state.values[idx] = oldVal;\n                        return 0;\n                    }\n                } else {\n                    newVal = getter(state);\n                }\n                state.values[idx] = newVal;\n                return 1 /* SlotStatus.Changed */ ;\n            }\n        };\n    }\n}\nfunction compareArray(a, b, compare) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!compare(a[i], b[i])) return false;\n    return true;\n}\nfunction ensureAll(state, addrs) {\n    let changed = false;\n    for (let addr of addrs)if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */ ) changed = true;\n    return changed;\n}\nfunction dynamicFacetSlot(addresses, facet, providers) {\n    let providerAddrs = providers.map((p)=>addresses[p.id]);\n    let providerTypes = providers.map((p)=>p.type);\n    let dynamic = providerAddrs.filter((p)=>!(p & 1));\n    let idx = addresses[facet.id] >> 1;\n    function get(state) {\n        let values = [];\n        for(let i = 0; i < providerAddrs.length; i++){\n            let value = getAddr(state, providerAddrs[i]);\n            if (providerTypes[i] == 2 /* Provider.Multi */ ) for (let val of value)values.push(val);\n            else values.push(value);\n        }\n        return facet.combine(values);\n    }\n    return {\n        create (state) {\n            for (let addr of providerAddrs)ensureAddr(state, addr);\n            state.values[idx] = get(state);\n            return 1 /* SlotStatus.Changed */ ;\n        },\n        update (state, tr) {\n            if (!ensureAll(state, dynamic)) return 0;\n            let value = get(state);\n            if (facet.compare(value, state.values[idx])) return 0;\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */ ;\n        },\n        reconfigure (state, oldState) {\n            let depChanged = ensureAll(state, providerAddrs);\n            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);\n            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            let value = get(state);\n            if (facet.compare(value, oldValue)) {\n                state.values[idx] = oldValue;\n                return 0;\n            }\n            state.values[idx] = value;\n            return 1 /* SlotStatus.Changed */ ;\n        }\n    };\n}\nconst initField = /*@__PURE__*/ Facet.define({\n    static: true\n});\n/**\nFields can store additional information in an editor state, and\nkeep it in sync with the rest of the state.\n*/ class StateField {\n    constructor(/**\n    @internal\n    */ id, createF, updateF, compareF, /**\n    @internal\n    */ spec){\n        this.id = id;\n        this.createF = createF;\n        this.updateF = updateF;\n        this.compareF = compareF;\n        this.spec = spec;\n        /**\n        @internal\n        */ this.provides = undefined;\n    }\n    /**\n    Define a state field.\n    */ static define(config) {\n        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b)=>a === b), config);\n        if (config.provide) field.provides = config.provide(field);\n        return field;\n    }\n    create(state) {\n        let init = state.facet(initField).find((i)=>i.field == this);\n        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\n    }\n    /**\n    @internal\n    */ slot(addresses) {\n        let idx = addresses[this.id] >> 1;\n        return {\n            create: (state)=>{\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            update: (state, tr)=>{\n                let oldVal = state.values[idx];\n                let value = this.updateF(oldVal, tr);\n                if (this.compareF(oldVal, value)) return 0;\n                state.values[idx] = value;\n                return 1 /* SlotStatus.Changed */ ;\n            },\n            reconfigure: (state, oldState)=>{\n                let init = state.facet(initField), oldInit = oldState.facet(initField), reInit;\n                if ((reInit = init.find((i)=>i.field == this)) && reInit != oldInit.find((i)=>i.field == this)) {\n                    state.values[idx] = reInit.create(state);\n                    return 1 /* SlotStatus.Changed */ ;\n                }\n                if (oldState.config.address[this.id] != null) {\n                    state.values[idx] = oldState.field(this);\n                    return 0;\n                }\n                state.values[idx] = this.create(state);\n                return 1 /* SlotStatus.Changed */ ;\n            }\n        };\n    }\n    /**\n    Returns an extension that enables this field and overrides the\n    way it is initialized. Can be useful when you need to provide a\n    non-default starting value for the field.\n    */ init(create) {\n        return [\n            this,\n            initField.of({\n                field: this,\n                create\n            })\n        ];\n    }\n    /**\n    State field instances can be used as\n    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a\n    given state.\n    */ get extension() {\n        return this;\n    }\n}\nconst Prec_ = {\n    lowest: 4,\n    low: 3,\n    default: 2,\n    high: 1,\n    highest: 0\n};\nfunction prec(value) {\n    return (ext)=>new PrecExtension(ext, value);\n}\n/**\nBy default extensions are registered in the order they are found\nin the flattened form of nested array that was provided.\nIndividual extension values can be assigned a precedence to\noverride this. Extensions that do not have a precedence set get\nthe precedence of the nearest parent with a precedence, or\n[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The\nfinal ordering of extensions is determined by first sorting by\nprecedence and then by order within each precedence.\n*/ const Prec = {\n    /**\n    The highest precedence level, for extensions that should end up\n    near the start of the precedence ordering.\n    */ highest: /*@__PURE__*/ prec(Prec_.highest),\n    /**\n    A higher-than-default precedence, for extensions that should\n    come before those with default precedence.\n    */ high: /*@__PURE__*/ prec(Prec_.high),\n    /**\n    The default precedence, which is also used for extensions\n    without an explicit precedence.\n    */ default: /*@__PURE__*/ prec(Prec_.default),\n    /**\n    A lower-than-default precedence.\n    */ low: /*@__PURE__*/ prec(Prec_.low),\n    /**\n    The lowest precedence level. Meant for things that should end up\n    near the end of the extension order.\n    */ lowest: /*@__PURE__*/ prec(Prec_.lowest)\n};\nclass PrecExtension {\n    constructor(inner, prec){\n        this.inner = inner;\n        this.prec = prec;\n    }\n}\n/**\nExtension compartments can be used to make a configuration\ndynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your\nconfiguration in a compartment, you can later\n[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a\ntransaction.\n*/ class Compartment {\n    /**\n    Create an instance of this compartment to add to your [state\n    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).\n    */ of(ext) {\n        return new CompartmentInstance(this, ext);\n    }\n    /**\n    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that\n    reconfigures this compartment.\n    */ reconfigure(content) {\n        return Compartment.reconfigure.of({\n            compartment: this,\n            extension: content\n        });\n    }\n    /**\n    Get the current content of the compartment in the state, or\n    `undefined` if it isn't present.\n    */ get(state) {\n        return state.config.compartments.get(this);\n    }\n}\nclass CompartmentInstance {\n    constructor(compartment, inner){\n        this.compartment = compartment;\n        this.inner = inner;\n    }\n}\nclass Configuration {\n    constructor(base, compartments, dynamicSlots, address, staticValues, facets){\n        this.base = base;\n        this.compartments = compartments;\n        this.dynamicSlots = dynamicSlots;\n        this.address = address;\n        this.staticValues = staticValues;\n        this.facets = facets;\n        this.statusTemplate = [];\n        while(this.statusTemplate.length < dynamicSlots.length)this.statusTemplate.push(0 /* SlotStatus.Unresolved */ );\n    }\n    staticFacet(facet) {\n        let addr = this.address[facet.id];\n        return addr == null ? facet.default : this.staticValues[addr >> 1];\n    }\n    static resolve(base, compartments, oldState) {\n        let fields = [];\n        let facets = Object.create(null);\n        let newCompartments = new Map();\n        for (let ext of flatten(base, compartments, newCompartments)){\n            if (ext instanceof StateField) fields.push(ext);\n            else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n        }\n        let address = Object.create(null);\n        let staticValues = [];\n        let dynamicSlots = [];\n        for (let field of fields){\n            address[field.id] = dynamicSlots.length << 1;\n            dynamicSlots.push((a)=>field.slot(a));\n        }\n        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;\n        for(let id in facets){\n            let providers = facets[id], facet = providers[0].facet;\n            let oldProviders = oldFacets && oldFacets[id] || [];\n            if (providers.every((p)=>p.type == 0 /* Provider.Static */ )) {\n                address[facet.id] = staticValues.length << 1 | 1;\n                if (sameArray(oldProviders, providers)) {\n                    staticValues.push(oldState.facet(facet));\n                } else {\n                    let value = facet.combine(providers.map((p)=>p.value));\n                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);\n                }\n            } else {\n                for (let p of providers){\n                    if (p.type == 0 /* Provider.Static */ ) {\n                        address[p.id] = staticValues.length << 1 | 1;\n                        staticValues.push(p.value);\n                    } else {\n                        address[p.id] = dynamicSlots.length << 1;\n                        dynamicSlots.push((a)=>p.dynamicSlot(a));\n                    }\n                }\n                address[facet.id] = dynamicSlots.length << 1;\n                dynamicSlots.push((a)=>dynamicFacetSlot(a, facet, providers));\n            }\n        }\n        let dynamic = dynamicSlots.map((f)=>f(address));\n        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);\n    }\n}\nfunction flatten(extension, compartments, newCompartments) {\n    let result = [\n        [],\n        [],\n        [],\n        [],\n        []\n    ];\n    let seen = new Map();\n    function inner(ext, prec) {\n        let known = seen.get(ext);\n        if (known != null) {\n            if (known <= prec) return;\n            let found = result[known].indexOf(ext);\n            if (found > -1) result[known].splice(found, 1);\n            if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment);\n        }\n        seen.set(ext, prec);\n        if (Array.isArray(ext)) {\n            for (let e of ext)inner(e, prec);\n        } else if (ext instanceof CompartmentInstance) {\n            if (newCompartments.has(ext.compartment)) throw new RangeError(`Duplicate use of compartment in extensions`);\n            let content = compartments.get(ext.compartment) || ext.inner;\n            newCompartments.set(ext.compartment, content);\n            inner(content, prec);\n        } else if (ext instanceof PrecExtension) {\n            inner(ext.inner, ext.prec);\n        } else if (ext instanceof StateField) {\n            result[prec].push(ext);\n            if (ext.provides) inner(ext.provides, prec);\n        } else if (ext instanceof FacetProvider) {\n            result[prec].push(ext);\n            if (ext.facet.extensions) inner(ext.facet.extensions, Prec_.default);\n        } else {\n            let content = ext.extension;\n            if (!content) throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);\n            inner(content, prec);\n        }\n    }\n    inner(extension, Prec_.default);\n    return result.reduce((a, b)=>a.concat(b));\n}\nfunction ensureAddr(state, addr) {\n    if (addr & 1) return 2 /* SlotStatus.Computed */ ;\n    let idx = addr >> 1;\n    let status = state.status[idx];\n    if (status == 4 /* SlotStatus.Computing */ ) throw new Error(\"Cyclic dependency between fields and/or facets\");\n    if (status & 2 /* SlotStatus.Computed */ ) return status;\n    state.status[idx] = 4 /* SlotStatus.Computing */ ;\n    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);\n    return state.status[idx] = 2 /* SlotStatus.Computed */  | changed;\n}\nfunction getAddr(state, addr) {\n    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\nconst languageData = /*@__PURE__*/ Facet.define();\nconst allowMultipleSelections = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.some((v)=>v),\n    static: true\n});\nconst lineSeparator = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : undefined,\n    static: true\n});\nconst changeFilter = /*@__PURE__*/ Facet.define();\nconst transactionFilter = /*@__PURE__*/ Facet.define();\nconst transactionExtender = /*@__PURE__*/ Facet.define();\nconst readOnly = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : false\n});\n/**\nAnnotations are tagged values that are used to add metadata to\ntransactions in an extensible way. They should be used to model\nthings that effect the entire transaction (such as its [time\nstamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its\n[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen\n_alongside_ the other changes made by the transaction, [state\neffects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.\n*/ class Annotation {\n    /**\n    @internal\n    */ constructor(/**\n    The annotation type.\n    */ type, /**\n    The value of this annotation.\n    */ value){\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Define a new type of annotation.\n    */ static define() {\n        return new AnnotationType();\n    }\n}\n/**\nMarker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).\n*/ class AnnotationType {\n    /**\n    Create an instance of this annotation.\n    */ of(value) {\n        return new Annotation(this, value);\n    }\n}\n/**\nRepresentation of a type of state effect. Defined with\n[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).\n*/ class StateEffectType {\n    /**\n    @internal\n    */ constructor(// The `any` types in these function types are there to work\n    // around TypeScript issue #37631, where the type guard on\n    // `StateEffect.is` mysteriously stops working when these properly\n    // have type `Value`.\n    /**\n    @internal\n    */ map){\n        this.map = map;\n    }\n    /**\n    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this\n    type.\n    */ of(value) {\n        return new StateEffect(this, value);\n    }\n}\n/**\nState effects can be used to represent additional effects\nassociated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They\nare often useful to model changes to custom [state\nfields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in\ndocument or selection changes.\n*/ class StateEffect {\n    /**\n    @internal\n    */ constructor(/**\n    @internal\n    */ type, /**\n    The value of this effect.\n    */ value){\n        this.type = type;\n        this.value = value;\n    }\n    /**\n    Map this effect through a position mapping. Will return\n    `undefined` when that ends up deleting the effect.\n    */ map(mapping) {\n        let mapped = this.type.map(this.value, mapping);\n        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n    }\n    /**\n    Tells you whether this effect object is of a given\n    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).\n    */ is(type) {\n        return this.type == type;\n    }\n    /**\n    Define a new effect type. The type parameter indicates the type\n    of values that his effect holds. It should be a type that\n    doesn't include `undefined`, since that is used in\n    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is\n    removed.\n    */ static define(spec = {}) {\n        return new StateEffectType(spec.map || ((v)=>v));\n    }\n    /**\n    Map an array of effects through a change set.\n    */ static mapEffects(effects, mapping) {\n        if (!effects.length) return effects;\n        let result = [];\n        for (let effect of effects){\n            let mapped = effect.map(mapping);\n            if (mapped) result.push(mapped);\n        }\n        return result;\n    }\n}\n/**\nThis effect can be used to reconfigure the root extensions of\nthe editor. Doing this will discard any extensions\n[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset\nthe content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)\ncompartments.\n*/ StateEffect.reconfigure = /*@__PURE__*/ StateEffect.define();\n/**\nAppend extensions to the top-level configuration of the editor.\n*/ StateEffect.appendConfig = /*@__PURE__*/ StateEffect.define();\n/**\nChanges to the editor state are grouped into transactions.\nTypically, a user action creates a single transaction, which may\ncontain any number of document changes, may change the selection,\nor have other effects. Create a transaction by calling\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately\ndispatch one by calling\n[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).\n*/ class Transaction {\n    constructor(/**\n    The state from which the transaction starts.\n    */ startState, /**\n    The document changes made by this transaction.\n    */ changes, /**\n    The selection set by this transaction, or undefined if it\n    doesn't explicitly set a selection.\n    */ selection, /**\n    The effects added to the transaction.\n    */ effects, /**\n    @internal\n    */ annotations, /**\n    Whether the selection should be scrolled into view after this\n    transaction is dispatched.\n    */ scrollIntoView){\n        this.startState = startState;\n        this.changes = changes;\n        this.selection = selection;\n        this.effects = effects;\n        this.annotations = annotations;\n        this.scrollIntoView = scrollIntoView;\n        /**\n        @internal\n        */ this._doc = null;\n        /**\n        @internal\n        */ this._state = null;\n        if (selection) checkSelection(selection, changes.newLength);\n        if (!annotations.some((a)=>a.type == Transaction.time)) this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n    }\n    /**\n    @internal\n    */ static create(startState, changes, selection, effects, annotations, scrollIntoView) {\n        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);\n    }\n    /**\n    The new document produced by the transaction. Contrary to\n    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't\n    force the entire new state to be computed right away, so it is\n    recommended that [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter\n    when they need to look at the new document.\n    */ get newDoc() {\n        return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n    }\n    /**\n    The new selection produced by the transaction. If\n    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,\n    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's\n    current selection through the changes made by the transaction.\n    */ get newSelection() {\n        return this.selection || this.startState.selection.map(this.changes);\n    }\n    /**\n    The new state created by the transaction. Computed on demand\n    (but retained for subsequent access), so it is recommended not to\n    access it in [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.\n    */ get state() {\n        if (!this._state) this.startState.applyTransaction(this);\n        return this._state;\n    }\n    /**\n    Get the value of the given annotation type, if any.\n    */ annotation(type) {\n        for (let ann of this.annotations)if (ann.type == type) return ann.value;\n        return undefined;\n    }\n    /**\n    Indicates whether the transaction changed the document.\n    */ get docChanged() {\n        return !this.changes.empty;\n    }\n    /**\n    Indicates whether this transaction reconfigures the state\n    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or\n    with a top-level configuration\n    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).\n    */ get reconfigured() {\n        return this.startState.config != this.state.config;\n    }\n    /**\n    Returns true if the transaction has a [user\n    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to\n    or more specific than `event`. For example, if the transaction\n    has `\"select.pointer\"` as user event, `\"select\"` and\n    `\"select.pointer\"` will match it.\n    */ isUserEvent(event) {\n        let e = this.annotation(Transaction.userEvent);\n        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == \".\"));\n    }\n}\n/**\nAnnotation used to store transaction timestamps. Automatically\nadded to every transaction, holding `Date.now()`.\n*/ Transaction.time = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation used to associate a transaction with a user interface\nevent. Holds a string identifying the event, using a\ndot-separated format to support attaching more specific\ninformation. The events used by the core libraries are:\n\n - `\"input\"` when content is entered\n   - `\"input.type\"` for typed input\n     - `\"input.type.compose\"` for composition\n   - `\"input.paste\"` for pasted input\n   - `\"input.drop\"` when adding content with drag-and-drop\n   - `\"input.complete\"` when autocompleting\n - `\"delete\"` when the user deletes content\n   - `\"delete.selection\"` when deleting the selection\n   - `\"delete.forward\"` when deleting forward from the selection\n   - `\"delete.backward\"` when deleting backward from the selection\n   - `\"delete.cut\"` when cutting to the clipboard\n - `\"move\"` when content is moved\n   - `\"move.drop\"` when content is moved within the editor through drag-and-drop\n - `\"select\"` when explicitly changing the selection\n   - `\"select.pointer\"` when selecting with a mouse or other pointing device\n - `\"undo\"` and `\"redo\"` for history actions\n\nUse [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check\nwhether the annotation matches a given event.\n*/ Transaction.userEvent = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation indicating whether a transaction should be added to\nthe undo history or not.\n*/ Transaction.addToHistory = /*@__PURE__*/ Annotation.define();\n/**\nAnnotation indicating (when present and true) that a transaction\nrepresents a change made by some other actor, not the user. This\nis used, for example, to tag other people's changes in\ncollaborative editing.\n*/ Transaction.remote = /*@__PURE__*/ Annotation.define();\nfunction joinRanges(a, b) {\n    let result = [];\n    for(let iA = 0, iB = 0;;){\n        let from, to;\n        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n            from = a[iA++];\n            to = a[iA++];\n        } else if (iB < b.length) {\n            from = b[iB++];\n            to = b[iB++];\n        } else return result;\n        if (!result.length || result[result.length - 1] < from) result.push(from, to);\n        else if (result[result.length - 1] < to) result[result.length - 1] = to;\n    }\n}\nfunction mergeTransaction(a, b, sequential) {\n    var _a;\n    let mapForA, mapForB, changes;\n    if (sequential) {\n        mapForA = b.changes;\n        mapForB = ChangeSet.empty(b.changes.length);\n        changes = a.changes.compose(b.changes);\n    } else {\n        mapForA = b.changes.map(a.changes);\n        mapForB = a.changes.mapDesc(b.changes, true);\n        changes = a.changes.compose(mapForA);\n    }\n    return {\n        changes,\n        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n        scrollIntoView: a.scrollIntoView || b.scrollIntoView\n    };\n}\nfunction resolveTransactionInner(state, spec, docSize) {\n    let sel = spec.selection, annotations = asArray(spec.annotations);\n    if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));\n    return {\n        changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n        selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n        effects: asArray(spec.effects),\n        annotations,\n        scrollIntoView: !!spec.scrollIntoView\n    };\n}\nfunction resolveTransaction(state, specs, filter) {\n    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n    if (specs.length && specs[0].filter === false) filter = false;\n    for(let i = 1; i < specs.length; i++){\n        if (specs[i].filter === false) filter = false;\n        let seq = !!specs[i].sequential;\n        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n    }\n    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);\n    return extendTransaction(filter ? filterTransaction(tr) : tr);\n}\n// Finish a transaction by applying filters if necessary.\nfunction filterTransaction(tr) {\n    let state = tr.startState;\n    // Change filters\n    let result = true;\n    for (let filter of state.facet(changeFilter)){\n        let value = filter(tr);\n        if (value === false) {\n            result = false;\n            break;\n        }\n        if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);\n    }\n    if (result !== true) {\n        let changes, back;\n        if (result === false) {\n            back = tr.changes.invertedDesc;\n            changes = ChangeSet.empty(state.doc.length);\n        } else {\n            let filtered = tr.changes.filter(result);\n            changes = filtered.changes;\n            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;\n        }\n        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);\n    }\n    // Transaction filters\n    let filters = state.facet(transactionFilter);\n    for(let i = filters.length - 1; i >= 0; i--){\n        let filtered = filters[i](tr);\n        if (filtered instanceof Transaction) tr = filtered;\n        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction) tr = filtered[0];\n        else tr = resolveTransaction(state, asArray(filtered), false);\n    }\n    return tr;\n}\nfunction extendTransaction(tr) {\n    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;\n    for(let i = extenders.length - 1; i >= 0; i--){\n        let extension = extenders[i](tr);\n        if (extension && Object.keys(extension).length) spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n    }\n    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);\n}\nconst none = [];\nfunction asArray(value) {\n    return value == null ? none : Array.isArray(value) ? value : [\n        value\n    ];\n}\n/**\nThe categories produced by a [character\ncategorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used\ndo things like selecting by word.\n*/ var CharCategory = /*@__PURE__*/ function(CharCategory) {\n    /**\n    Word characters.\n    */ CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n    /**\n    Whitespace.\n    */ CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n    /**\n    Anything else.\n    */ CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\n    return CharCategory;\n}(CharCategory || (CharCategory = {}));\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet wordChar;\ntry {\n    wordChar = /*@__PURE__*/ new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n} catch (_) {}\nfunction hasWordChar(str) {\n    if (wordChar) return wordChar.test(str);\n    for(let i = 0; i < str.length; i++){\n        let ch = str[i];\n        if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))) return true;\n    }\n    return false;\n}\nfunction makeCategorizer(wordChars) {\n    return (char)=>{\n        if (!/\\S/.test(char)) return CharCategory.Space;\n        if (hasWordChar(char)) return CharCategory.Word;\n        for(let i = 0; i < wordChars.length; i++)if (char.indexOf(wordChars[i]) > -1) return CharCategory.Word;\n        return CharCategory.Other;\n    };\n}\n/**\nThe editor state class is a persistent (immutable) data structure.\nTo update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a\n[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state\ninstance, without modifying the original object.\n\nAs such, _never_ mutate properties of a state directly. That'll\njust break things.\n*/ class EditorState {\n    constructor(/**\n    @internal\n    */ config, /**\n    The current document.\n    */ doc, /**\n    The current selection.\n    */ selection, /**\n    @internal\n    */ values, computeSlot, tr){\n        this.config = config;\n        this.doc = doc;\n        this.selection = selection;\n        this.values = values;\n        this.status = config.statusTemplate.slice();\n        this.computeSlot = computeSlot;\n        // Fill in the computed state immediately, so that further queries\n        // for it made during the update return this state\n        if (tr) tr._state = this;\n        for(let i = 0; i < this.config.dynamicSlots.length; i++)ensureAddr(this, i << 1);\n        this.computeSlot = null;\n    }\n    field(field, require = true) {\n        let addr = this.config.address[field.id];\n        if (addr == null) {\n            if (require) throw new RangeError(\"Field is not present in this state\");\n            return undefined;\n        }\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this\n    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)\n    can be passed. Unless\n    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the\n    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec\n    are assumed to start in the _current_ document (not the document\n    produced by previous specs), and its\n    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and\n    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer\n    to the document created by its _own_ changes. The resulting\n    transaction contains the combined effect of all the different\n    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later\n    specs take precedence over earlier ones.\n    */ update(...specs) {\n        return resolveTransaction(this, specs, true);\n    }\n    /**\n    @internal\n    */ applyTransaction(tr) {\n        let conf = this.config, { base, compartments } = conf;\n        for (let effect of tr.effects){\n            if (effect.is(Compartment.reconfigure)) {\n                if (conf) {\n                    compartments = new Map;\n                    conf.compartments.forEach((val, key)=>compartments.set(key, val));\n                    conf = null;\n                }\n                compartments.set(effect.value.compartment, effect.value.extension);\n            } else if (effect.is(StateEffect.reconfigure)) {\n                conf = null;\n                base = effect.value;\n            } else if (effect.is(StateEffect.appendConfig)) {\n                conf = null;\n                base = asArray(base).concat(effect.value);\n            }\n        }\n        let startValues;\n        if (!conf) {\n            conf = Configuration.resolve(base, compartments, this);\n            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(()=>null), (state, slot)=>slot.reconfigure(state, this), null);\n            startValues = intermediateState.values;\n        } else {\n            startValues = tr.startState.values.slice();\n        }\n        let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();\n        new EditorState(conf, tr.newDoc, selection, startValues, (state, slot)=>slot.update(state, tr), tr);\n    }\n    /**\n    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that\n    replaces every selection range with the given content.\n    */ replaceSelection(text) {\n        if (typeof text == \"string\") text = this.toText(text);\n        return this.changeByRange((range)=>({\n                changes: {\n                    from: range.from,\n                    to: range.to,\n                    insert: text\n                },\n                range: EditorSelection.cursor(range.from + text.length)\n            }));\n    }\n    /**\n    Create a set of changes and a new selection by running the given\n    function for each range in the active selection. The function\n    can return an optional set of changes (in the coordinate space\n    of the start document), plus an updated range (in the coordinate\n    space of the document produced by the call's own changes). This\n    method will merge all the changes and ranges into a single\n    changeset and selection, and return it as a [transaction\n    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to\n    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n    */ changeByRange(f) {\n        let sel = this.selection;\n        let result1 = f(sel.ranges[0]);\n        let changes = this.changes(result1.changes), ranges = [\n            result1.range\n        ];\n        let effects = asArray(result1.effects);\n        for(let i = 1; i < sel.ranges.length; i++){\n            let result = f(sel.ranges[i]);\n            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);\n            for(let j = 0; j < i; j++)ranges[j] = ranges[j].map(newMapped);\n            let mapBy = changes.mapDesc(newChanges, true);\n            ranges.push(result.range.map(mapBy));\n            changes = changes.compose(newMapped);\n            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n        }\n        return {\n            changes,\n            selection: EditorSelection.create(ranges, sel.mainIndex),\n            effects\n        };\n    }\n    /**\n    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change\n    description, taking the state's document length and line\n    separator into account.\n    */ changes(spec = []) {\n        if (spec instanceof ChangeSet) return spec;\n        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n    }\n    /**\n    Using the state's [line\n    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a\n    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.\n    */ toText(string) {\n        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n    }\n    /**\n    Return the given range of the document as a string.\n    */ sliceDoc(from = 0, to = this.doc.length) {\n        return this.doc.sliceString(from, to, this.lineBreak);\n    }\n    /**\n    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).\n    */ facet(facet) {\n        let addr = this.config.address[facet.id];\n        if (addr == null) return facet.default;\n        ensureAddr(this, addr);\n        return getAddr(this, addr);\n    }\n    /**\n    Convert this state to a JSON-serializable object. When custom\n    fields should be serialized, you can pass them in as an object\n    mapping property names (in the resulting object, which should\n    not use `doc` or `selection`) to fields.\n    */ toJSON(fields) {\n        let result = {\n            doc: this.sliceDoc(),\n            selection: this.selection.toJSON()\n        };\n        if (fields) for(let prop in fields){\n            let value = fields[prop];\n            if (value instanceof StateField && this.config.address[value.id] != null) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);\n        }\n        return result;\n    }\n    /**\n    Deserialize a state from its JSON representation. When custom\n    fields should be deserialized, pass the same object you passed\n    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as\n    third argument.\n    */ static fromJSON(json, config = {}, fields) {\n        if (!json || typeof json.doc != \"string\") throw new RangeError(\"Invalid JSON representation for EditorState\");\n        let fieldInit = [];\n        if (fields) for(let prop in fields){\n            if (Object.prototype.hasOwnProperty.call(json, prop)) {\n                let field = fields[prop], value = json[prop];\n                fieldInit.push(field.init((state)=>field.spec.fromJSON(value, state)));\n            }\n        }\n        return EditorState.create({\n            doc: json.doc,\n            selection: EditorSelection.fromJSON(json.selection),\n            extensions: config.extensions ? fieldInit.concat([\n                config.extensions\n            ]) : fieldInit\n        });\n    }\n    /**\n    Create a new state. You'll usually only need this when\n    initializing an editor—updated states are created by applying\n    transactions.\n    */ static create(config = {}) {\n        let configuration = Configuration.resolve(config.extensions || [], new Map);\n        let doc = config.doc instanceof Text ? config.doc : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n        let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);\n        checkSelection(selection, doc.length);\n        if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();\n        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(()=>null), (state, slot)=>slot.create(state), null);\n    }\n    /**\n    The size (in columns) of a tab in the document, determined by\n    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.\n    */ get tabSize() {\n        return this.facet(EditorState.tabSize);\n    }\n    /**\n    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)\n    string for this state.\n    */ get lineBreak() {\n        return this.facet(EditorState.lineSeparator) || \"\\n\";\n    }\n    /**\n    Returns true when the editor is\n    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.\n    */ get readOnly() {\n        return this.facet(readOnly);\n    }\n    /**\n    Look up a translation for the given phrase (via the\n    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the\n    original string if no translation is found.\n    \n    If additional arguments are passed, they will be inserted in\n    place of markers like `$1` (for the first value) and `$2`, etc.\n    A single `$` is equivalent to `$1`, and `$$` will produce a\n    literal dollar sign.\n    */ phrase(phrase, ...insert) {\n        for (let map of this.facet(EditorState.phrases))if (Object.prototype.hasOwnProperty.call(map, phrase)) {\n            phrase = map[phrase];\n            break;\n        }\n        if (insert.length) phrase = phrase.replace(/\\$(\\$|\\d*)/g, (m, i)=>{\n            if (i == \"$\") return \"$\";\n            let n = +(i || 1);\n            return !n || n > insert.length ? m : insert[n - 1];\n        });\n        return phrase;\n    }\n    /**\n    Find the values for a given language data field, provided by the\n    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.\n    \n    Examples of language data fields are...\n    \n    - [`\"commentTokens\"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying\n      comment syntax.\n    - [`\"autocomplete\"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)\n      for providing language-specific completion sources.\n    - [`\"wordChars\"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding\n      characters that should be considered part of words in this\n      language.\n    - [`\"closeBrackets\"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls\n      bracket closing behavior.\n    */ languageDataAt(name, pos, side = -1) {\n        let values = [];\n        for (let provider of this.facet(languageData)){\n            for (let result of provider(this, pos, side)){\n                if (Object.prototype.hasOwnProperty.call(result, name)) values.push(result[name]);\n            }\n        }\n        return values;\n    }\n    /**\n    Return a function that can categorize strings (expected to\n    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))\n    into one of:\n    \n     - Word (contains an alphanumeric character or a character\n       explicitly listed in the local language's `\"wordChars\"`\n       language data, which should be a string)\n     - Space (contains only whitespace)\n     - Other (anything else)\n    */ charCategorizer(at) {\n        return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n    }\n    /**\n    Find the word at the given position, meaning the range\n    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters\n    around it. If no word characters are adjacent to the position,\n    this returns null.\n    */ wordAt(pos) {\n        let { text, from, length } = this.doc.lineAt(pos);\n        let cat = this.charCategorizer(pos);\n        let start = pos - from, end = pos - from;\n        while(start > 0){\n            let prev = findClusterBreak(text, start, false);\n            if (cat(text.slice(prev, start)) != CharCategory.Word) break;\n            start = prev;\n        }\n        while(end < length){\n            let next = findClusterBreak(text, end);\n            if (cat(text.slice(end, next)) != CharCategory.Word) break;\n            end = next;\n        }\n        return start == end ? null : EditorSelection.range(start + from, end + from);\n    }\n}\n/**\nA facet that, when enabled, causes the editor to allow multiple\nranges to be selected. Be careful though, because by default the\neditor relies on the native DOM selection, which cannot handle\nmultiple selections. An extension like\n[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make\nsecondary selections visible to the user.\n*/ EditorState.allowMultipleSelections = allowMultipleSelections;\n/**\nConfigures the tab size to use in this state. The first\n(highest-precedence) value of the facet is used. If no value is\ngiven, this defaults to 4.\n*/ EditorState.tabSize = /*@__PURE__*/ Facet.define({\n    combine: (values)=>values.length ? values[0] : 4\n});\n/**\nThe line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\nand `\"\\r\"` is treated as a separator when splitting lines, and\nlines are joined with `\"\\n\"`.\n\nWhen you configure a value here, only that precise separator\nwill be used, allowing you to round-trip documents through the\neditor without normalizing line separators.\n*/ EditorState.lineSeparator = lineSeparator;\n/**\nThis facet controls the value of the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is\nconsulted by commands and extensions that implement editing\nfunctionality to determine whether they should apply. It\ndefaults to false, but when its highest-precedence value is\n`true`, such functionality disables itself.\n\nNot to be confused with\n[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which\ncontrols whether the editor's DOM is set to be editable (and\nthus focusable).\n*/ EditorState.readOnly = readOnly;\n/**\nRegisters translation phrases. The\n[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through\nall objects registered with this facet to find translations for\nits argument.\n*/ EditorState.phrases = /*@__PURE__*/ Facet.define({\n    compare (a, b) {\n        let kA = Object.keys(a), kB = Object.keys(b);\n        return kA.length == kB.length && kA.every((k)=>a[k] == b[k]);\n    }\n});\n/**\nA facet used to register [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.\n*/ EditorState.languageData = languageData;\n/**\nFacet used to register change filters, which are called for each\ntransaction (unless explicitly\n[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress\npart of the transaction's changes.\n\nSuch a function can return `true` to indicate that it doesn't\nwant to do anything, `false` to completely stop the changes in\nthe transaction, or a set of ranges in which changes should be\nsuppressed. Such ranges are represented as an array of numbers,\nwith each pair of two numbers indicating the start and end of a\nrange. So for example `[10, 20, 100, 110]` suppresses changes\nbetween 10 and 20, and between 100 and 110.\n*/ EditorState.changeFilter = changeFilter;\n/**\nFacet used to register a hook that gets a chance to update or\nreplace transaction specs before they are applied. This will\nonly be applied for transactions that don't have\n[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You\ncan either return a single transaction spec (possibly the input\ntransaction), or an array of specs (which will be combined in\nthe same way as the arguments to\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).\n\nWhen possible, it is recommended to avoid accessing\n[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,\nsince it will force creation of a state that will then be\ndiscarded again, if the transaction is actually filtered.\n\n(This functionality should be used with care. Indiscriminately\nmodifying transaction is likely to break something or degrade\nthe user experience.)\n*/ EditorState.transactionFilter = transactionFilter;\n/**\nThis is a more limited form of\n[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),\nwhich can only add\n[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and\n[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type\nof filter runs even if the transaction has disabled regular\n[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable\nfor effects that don't need to touch the changes or selection,\nbut do want to process every transaction.\n\nExtenders run _after_ filters, when both are present.\n*/ EditorState.transactionExtender = transactionExtender;\nCompartment.reconfigure = /*@__PURE__*/ StateEffect.define();\n/**\nUtility function for combining behaviors to fill in a config\nobject from an array of provided configs. `defaults` should hold\ndefault values for all optional fields in `Config`.\n\nThe function will, by default, error\nwhen a field gets two values that aren't `===`-equal, but you can\nprovide combine functions per field to do something else.\n*/ function combineConfig(configs, defaults, combine = {}) {\n    let result = {};\n    for (let config of configs)for (let key of Object.keys(config)){\n        let value = config[key], current = result[key];\n        if (current === undefined) result[key] = value;\n        else if (current === value || value === undefined) ; // No conflict\n        else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key](current, value);\n        else throw new Error(\"Config merge conflict for field \" + key);\n    }\n    for(let key in defaults)if (result[key] === undefined) result[key] = defaults[key];\n    return result;\n}\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/ class RangeValue {\n    /**\n    Compare this value with another value. Used when comparing\n    rangesets. The default implementation compares by identity.\n    Unless you are only creating a fixed number of unique instances\n    of your value type, it is a good idea to implement this\n    properly.\n    */ eq(other) {\n        return this == other;\n    }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.\n    */ range(from, to = from) {\n        return Range.create(from, to, this);\n    }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/ class Range {\n    constructor(/**\n    The range's start position.\n    */ from, /**\n    Its end position.\n    */ to, /**\n    The value associated with this range.\n    */ value){\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n    /**\n    @internal\n    */ static create(from, to, value) {\n        return new Range(from, to, value);\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint){\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() {\n        return this.to[this.to.length - 1];\n    }\n    // Find the index of the given position and side. Use the ranges'\n    // `from` pos when `end == false`, `to` when `end == true`.\n    findIndex(pos, side, end, startAt = 0) {\n        let arr = end ? this.to : this.from;\n        for(let lo = startAt, hi = arr.length;;){\n            if (lo == hi) return lo;\n            let mid = lo + hi >> 1;\n            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n            if (mid == lo) return diff >= 0 ? lo : hi;\n            if (diff >= 0) hi = mid;\n            else lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for(let i = this.findIndex(from, -1000000000 /* C.Far */ , true), e = this.findIndex(to, 1000000000 /* C.Far */ , false, i); i < e; i++)if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for(let i = 0; i < this.value.length; i++){\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null) continue;\n                newFrom = newTo = mapped;\n                if (val.startSide != val.endSide) {\n                    newTo = changes.mapPos(curFrom, val.endSide);\n                    if (newTo < newFrom) continue;\n                }\n            } else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;\n            if (newPos < 0) newPos = newFrom;\n            if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return {\n            mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,\n            pos: newPos\n        };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data\nstructure.\n*/ class RangeSet {\n    constructor(/**\n    @internal\n    */ chunkPos, /**\n    @internal\n    */ chunk, /**\n    @internal\n    */ nextLayer, /**\n    @internal\n    */ maxPoint){\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */ static create(chunkPos, chunk, nextLayer, maxPoint) {\n        return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);\n    }\n    /**\n    @internal\n    */ get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */ get size() {\n        if (this.isEmpty) return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */ chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (Note: The type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */ update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter) return this;\n        if (sort) add = add.slice().sort(cmpRange);\n        if (this.isEmpty) return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while(cur.value || i < add.length){\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);\n            } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            } else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(Range.create(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({\n            add: spill,\n            filter,\n            filterFrom,\n            filterTo\n        }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */ map(changes) {\n        if (changes.empty || this.isEmpty) return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for(let i = 0; i < this.chunk.length; i++){\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            } else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */ between(from, to, f) {\n        if (this.isEmpty) return;\n        for(let i = 0; i < this.chunk.length; i++){\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */ iter(from = 0) {\n        return HeapCursor.from([\n            this\n        ]).goto(from);\n    }\n    /**\n    @internal\n    */ get isEmpty() {\n        return this.nextLayer == this;\n    }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */ static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */ static compare(oldSets, newSets, /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration.\n    */ textDiff, comparator, /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */ minPointSize = -1) {\n        let a = oldSets.filter((set)=>set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let b = newSets.filter((set)=>set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b, textDiff);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length)=>compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Compare the contents of two groups of range sets, returning true\n    if they are equivalent in the given range.\n    */ static eq(oldSets, newSets, from = 0, to) {\n        if (to == null) to = 1000000000 /* C.Far */  - 1;\n        let a = oldSets.filter((set)=>!set.isEmpty && newSets.indexOf(set) < 0);\n        let b = newSets.filter((set)=>!set.isEmpty && oldSets.indexOf(set) < 0);\n        if (a.length != b.length) return false;\n        if (!a.length) return true;\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n        for(;;){\n            if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;\n            if (sideA.to > to) return true;\n            sideA.next();\n            sideB.next();\n        }\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end\n    of the iteration.\n    */ static spans(sets, from, to, iterator, /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */ minPointSize = -1) {\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n        let openRanges = cursor.openStart;\n        for(;;){\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                let active = cursor.activeForPoint(cursor.to);\n                let openCount = cursor.pointFrom < from ? active.length + 1 : cursor.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);\n                iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);\n                openRanges = Math.min(cursor.openEnd(curTo), active.length);\n            } else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, openRanges);\n                openRanges = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to) return openRanges + (cursor.point && cursor.to > to ? 1 : 0);\n            pos = cursor.to;\n            cursor.next();\n        }\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */ static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [\n            ranges\n        ] : sort ? lazySort(ranges) : ranges)build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n    /**\n    Join an array of range sets into a single set.\n    */ static join(sets) {\n        if (!sets.length) return RangeSet.empty;\n        let result = sets[sets.length - 1];\n        for(let i = sets.length - 2; i >= 0; i--){\n            for(let layer = sets[i]; layer != RangeSet.empty; layer = layer.nextLayer)result = new RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));\n        }\n        return result;\n    }\n}\n/**\nThe empty set of ranges.\n*/ RangeSet.empty = /*@__PURE__*/ new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n    if (ranges.length > 1) for(let prev = ranges[0], i = 1; i < ranges.length; i++){\n        let cur = ranges[i];\n        if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange);\n        prev = cur;\n    }\n    return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.\n*/ class RangeSetBuilder {\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Create an empty builder.\n    */ constructor(){\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* C.Far */ ;\n        this.lastTo = -1000000000 /* C.Far */ ;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */ add(from, to, value) {\n        if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */ addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0) return false;\n        if (this.from.length == 250 /* C.ChunkSize */ ) this.finishChunk(true);\n        if (this.chunkStart < 0) this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */ addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;\n        if (this.from.length) this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */ finish() {\n        return this.finishInner(RangeSet.empty);\n    }\n    /**\n    @internal\n    */ finishInner(next) {\n        if (this.from.length) this.finishChunk(false);\n        if (this.chunks.length == 0) return next;\n        let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b, textDiff) {\n    let inA = new Map();\n    for (let set of a)for(let i = 0; i < set.chunk.length; i++)if (set.chunk[i].maxPoint <= 0) inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)for(let i = 0; i < set.chunk.length; i++){\n        let known = inA.get(set.chunk[i]);\n        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length))) shared.add(set.chunk[i]);\n    }\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0){\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() {\n        return this.value ? this.value.startSide : 0;\n    }\n    get endSide() {\n        return this.value ? this.value.endSide : 0;\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while(this.chunkIndex < this.layer.chunk.length){\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        if (this.chunkIndex < this.layer.chunk.length) {\n            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n            if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);\n        }\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);\n    }\n    next() {\n        for(;;){\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* C.Far */ ;\n                this.value = null;\n                break;\n            } else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                this.setRangeIndex(this.rangeIndex + 1);\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;\n            }\n        }\n    }\n    setRangeIndex(index) {\n        if (index == this.layer.chunk[this.chunkIndex].value.length) {\n            this.chunkIndex++;\n            if (this.skip) {\n                while(this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))this.chunkIndex++;\n            }\n            this.rangeIndex = 0;\n        } else {\n            this.rangeIndex = index;\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap){\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for(let i = 0; i < sets.length; i++){\n            for(let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer){\n                if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() {\n        return this.value ? this.value.startSide : 0;\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        for (let cur of this.heap)cur.goto(pos, side);\n        for(let i = this.heap.length >> 1; i >= 0; i--)heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)cur.forward(pos, side);\n        for(let i = this.heap.length >> 1; i >= 0; i--)heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0) this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* C.Far */ ;\n            this.value = null;\n            this.rank = -1;\n        } else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value) top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for(let cur = heap[index];;){\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length) break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0) break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint){\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* C.Far */ ;\n        this.endSide = 0;\n        // The amount of open active ranges at the start of the iterator.\n        // Not including points.\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* C.Far */ ) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while(this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        // Organize active marks by rank first, then by size\n        while(i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0)i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen) insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null;\n        for(;;){\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen) remove(trackOpen, a);\n            } else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* C.Far */ ;\n                break;\n            } else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            } else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) {\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                } else {\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    this.cursor.next();\n                    this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            this.openStart = 0;\n            for(let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)this.openStart++;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length) return this.active;\n        let active = [];\n        for(let i = this.active.length - 1; i >= 0; i--){\n            if (this.activeRank[i] < this.pointRank) break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide) active.push(this.active[i]);\n        }\n        return active.reverse();\n    }\n    openEnd(to) {\n        let open = 0;\n        for(let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for(;;){\n        let dEnd = a.to + dPos - b.to, diff = dEnd || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        } else {\n            if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB) break;\n        if ((dEnd || a.openEnd != b.openEnd) && comparator.boundChange) comparator.boundChange(end);\n        pos = end;\n        if (diff <= 0) a.next();\n        if (diff >= 0) b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (a[i] != b[i] && !a[i].eq(b[i])) return false;\n    return true;\n}\nfunction remove(array, index) {\n    for(let i = index, e = array.length - 1; i < e; i++)array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for(let i = array.length - 1; i >= index; i--)array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* C.Far */ ;\n    for(let i = 0; i < array.length; i++)if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n        found = i;\n        foundPos = array[i];\n    }\n    return found;\n}\n/**\nCount the column position at the given offset into the string,\ntaking extending characters and tab size into account.\n*/ function countColumn(string, tabSize, to = string.length) {\n    let n = 0;\n    for(let i = 0; i < to && i < string.length;){\n        if (string.charCodeAt(i) == 9) {\n            n += tabSize - n % tabSize;\n            i++;\n        } else {\n            n++;\n            i = findClusterBreak(string, i);\n        }\n    }\n    return n;\n}\n/**\nFind the offset that corresponds to the given column position in a\nstring, taking extending characters and tab size into account. By\ndefault, the string length is returned when it is too short to\nreach the column. Pass `strict` true to make it return -1 in that\nsituation.\n*/ function findColumn(string, col, tabSize, strict) {\n    for(let i = 0, n = 0;;){\n        if (n >= col) return i;\n        if (i == string.length) break;\n        n += string.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;\n        i = findClusterBreak(string, i);\n    }\n    return strict === true ? -1 : string.length;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc3RhdGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0Y7QUFFcEY7O0FBRUEsR0FDQSxNQUFNRTtJQUNGOztJQUVBLEdBQ0FDLE9BQU9DLEdBQUcsRUFBRTtRQUNSLElBQUlBLE1BQU0sS0FBS0EsTUFBTSxJQUFJLENBQUNDLE1BQU0sRUFDNUIsTUFBTSxJQUFJQyxXQUFXLENBQUMsaUJBQWlCLEVBQUVGLElBQUksdUJBQXVCLEVBQUUsSUFBSSxDQUFDQyxNQUFNLENBQUMsQ0FBQztRQUN2RixPQUFPLElBQUksQ0FBQ0UsU0FBUyxDQUFDSCxLQUFLLE9BQU8sR0FBRztJQUN6QztJQUNBOztJQUVBLEdBQ0FJLEtBQUtDLENBQUMsRUFBRTtRQUNKLElBQUlBLElBQUksS0FBS0EsSUFBSSxJQUFJLENBQUNDLEtBQUssRUFDdkIsTUFBTSxJQUFJSixXQUFXLENBQUMsb0JBQW9CLEVBQUVHLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQ0MsS0FBSyxDQUFDLGNBQWMsQ0FBQztRQUNsRixPQUFPLElBQUksQ0FBQ0gsU0FBUyxDQUFDRSxHQUFHLE1BQU0sR0FBRztJQUN0QztJQUNBOztJQUVBLEdBQ0FFLFFBQVFDLElBQUksRUFBRUMsRUFBRSxFQUFFQyxJQUFJLEVBQUU7UUFDcEIsQ0FBQ0YsTUFBTUMsR0FBRyxHQUFHRSxLQUFLLElBQUksRUFBRUgsTUFBTUM7UUFDOUIsSUFBSUcsUUFBUSxFQUFFO1FBQ2QsSUFBSSxDQUFDQyxTQUFTLENBQUMsR0FBR0wsTUFBTUksT0FBTyxFQUFFLFdBQVc7UUFDNUMsSUFBSUYsS0FBS1QsTUFBTSxFQUNYUyxLQUFLRyxTQUFTLENBQUMsR0FBR0gsS0FBS1QsTUFBTSxFQUFFVyxPQUFPLEVBQUUsYUFBYSxNQUFLLEVBQUUsV0FBVztRQUMzRSxJQUFJLENBQUNDLFNBQVMsQ0FBQ0osSUFBSSxJQUFJLENBQUNS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LE1BQU0sSUFBSXNZLFVBQVd0YixJQUFJc2IsVUFBVztRQUMzRHRZLElBQUl6RCxpQkFBaUIwRCxRQUFRRDtJQUNqQztJQUNBLE9BQU93Z0IsV0FBVyxPQUFPLENBQUMsSUFBSXZnQixPQUFPckQsTUFBTTtBQUMvQztBQUVrWCIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2tuaWNoZS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zdGF0ZS9kaXN0L2luZGV4LmpzPzhjOGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZmluZENsdXN0ZXJCcmVhayBhcyBmaW5kQ2x1c3RlckJyZWFrJDEgfSBmcm9tICdAbWFyaWpuL2ZpbmQtY2x1c3Rlci1icmVhayc7XG5cbi8qKlxuVGhlIGRhdGEgc3RydWN0dXJlIGZvciBkb2N1bWVudHMuIEBub25hYnN0cmFjdFxuKi9cbmNsYXNzIFRleHQge1xuICAgIC8qKlxuICAgIEdldCB0aGUgbGluZSBkZXNjcmlwdGlvbiBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbGluZUF0KHBvcykge1xuICAgICAgICBpZiAocG9zIDwgMCB8fCBwb3MgPiB0aGlzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHBvc2l0aW9uICR7cG9zfSBpbiBkb2N1bWVudCBvZiBsZW5ndGggJHt0aGlzLmxlbmd0aH1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUlubmVyKHBvcywgZmFsc2UsIDEsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGRlc2NyaXB0aW9uIGZvciB0aGUgZ2l2ZW4gKDEtYmFzZWQpIGxpbmUgbnVtYmVyLlxuICAgICovXG4gICAgbGluZShuKSB7XG4gICAgICAgIGlmIChuIDwgMSB8fCBuID4gdGhpcy5saW5lcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGxpbmUgbnVtYmVyICR7bn0gaW4gJHt0aGlzLmxpbmVzfS1saW5lIGRvY3VtZW50YCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbm5lcihuLCB0cnVlLCAxLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSBhIHJhbmdlIG9mIHRoZSB0ZXh0IHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuXG4gICAgKi9cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIHRoaXMuZGVjb21wb3NlKDAsIGZyb20sIHBhcnRzLCAyIC8qIE9wZW4uVG8gKi8pO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGgpXG4gICAgICAgICAgICB0ZXh0LmRlY29tcG9zZSgwLCB0ZXh0Lmxlbmd0aCwgcGFydHMsIDEgLyogT3Blbi5Gcm9tICovIHwgMiAvKiBPcGVuLlRvICovKTtcbiAgICAgICAgdGhpcy5kZWNvbXBvc2UodG8sIHRoaXMubGVuZ3RoLCBwYXJ0cywgMSAvKiBPcGVuLkZyb20gKi8pO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHRleHQubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwZW5kIGFub3RoZXIgZG9jdW1lbnQgdG8gdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhcHBlbmQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmxlbmd0aCwgdGhpcy5sZW5ndGgsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmUgdGhlIHRleHQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnRzLlxuICAgICovXG4gICAgc2xpY2UoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICBbZnJvbSwgdG9dID0gY2xpcCh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLmRlY29tcG9zZShmcm9tLCB0bywgcGFydHMsIDApO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdG8gLSBmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgdGV4dCBpcyBlcXVhbCB0byBhbm90aGVyIGluc3RhbmNlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG90aGVyLmxlbmd0aCAhPSB0aGlzLmxlbmd0aCB8fCBvdGhlci5saW5lcyAhPSB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnNjYW5JZGVudGljYWwob3RoZXIsIDEpLCBlbmQgPSB0aGlzLmxlbmd0aCAtIHRoaXMuc2NhbklkZW50aWNhbChvdGhlciwgLTEpO1xuICAgICAgICBsZXQgYSA9IG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMpLCBiID0gbmV3IFJhd1RleHRDdXJzb3Iob3RoZXIpO1xuICAgICAgICBmb3IgKGxldCBza2lwID0gc3RhcnQsIHBvcyA9IHN0YXJ0OzspIHtcbiAgICAgICAgICAgIGEubmV4dChza2lwKTtcbiAgICAgICAgICAgIGIubmV4dChza2lwKTtcbiAgICAgICAgICAgIHNraXAgPSAwO1xuICAgICAgICAgICAgaWYgKGEubGluZUJyZWFrICE9IGIubGluZUJyZWFrIHx8IGEuZG9uZSAhPSBiLmRvbmUgfHwgYS52YWx1ZSAhPSBiLnZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHBvcyArPSBhLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhLmRvbmUgfHwgcG9zID49IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHRleHQuIFdoZW4gYGRpcmAgaXMgYC0xYCwgaXRlcmF0aW9uIGhhcHBlbnNcbiAgICBmcm9tIGVuZCB0byBzdGFydC4gVGhpcyB3aWxsIHJldHVybiBsaW5lcyBhbmQgdGhlIGJyZWFrcyBiZXR3ZWVuXG4gICAgdGhlbSBhcyBzZXBhcmF0ZSBzdHJpbmdzLlxuICAgICovXG4gICAgaXRlcihkaXIgPSAxKSB7IHJldHVybiBuZXcgUmF3VGV4dEN1cnNvcih0aGlzLCBkaXIpOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIGEgcmFuZ2Ugb2YgdGhlIHRleHQuIFdoZW4gYGZyb21gID4gYHRvYCwgdGhlXG4gICAgaXRlcmF0b3Igd2lsbCBydW4gaW4gcmV2ZXJzZS5cbiAgICAqL1xuICAgIGl0ZXJSYW5nZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7IHJldHVybiBuZXcgUGFydGlhbFRleHRDdXJzb3IodGhpcywgZnJvbSwgdG8pOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgY3Vyc29yIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgbGluZXMsXG4gICAgX3dpdGhvdXRfIHJldHVybmluZyB0aGUgbGluZSBicmVha3MgYmV0d2VlbiwgYW5kIHlpZWxkaW5nIGVtcHR5XG4gICAgc3RyaW5ncyBmb3IgZW1wdHkgbGluZXMuXG4gICAgXG4gICAgV2hlbiBgZnJvbWAgYW5kIGB0b2AgYXJlIGdpdmVuLCB0aGV5IHNob3VsZCBiZSAxLWJhc2VkIGxpbmUgbnVtYmVycy5cbiAgICAqL1xuICAgIGl0ZXJMaW5lcyhmcm9tLCB0bykge1xuICAgICAgICBsZXQgaW5uZXI7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5pdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0byA9IHRoaXMubGluZXMgKyAxO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5saW5lKGZyb20pLmZyb207XG4gICAgICAgICAgICBpbm5lciA9IHRoaXMuaXRlclJhbmdlKHN0YXJ0LCBNYXRoLm1heChzdGFydCwgdG8gPT0gdGhpcy5saW5lcyArIDEgPyB0aGlzLmxlbmd0aCA6IHRvIDw9IDEgPyAwIDogdGhpcy5saW5lKHRvIC0gMSkudG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpbmVDdXJzb3IoaW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgc3RyaW5nLCB1c2luZyBuZXdsaW5lIGNoYXJhY3RlcnMgdG9cbiAgICBzZXBhcmF0ZSBsaW5lcy5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5zbGljZVN0cmluZygwKTsgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhlIGRvY3VtZW50IHRvIGFuIGFycmF5IG9mIGxpbmVzICh3aGljaCBjYW4gYmVcbiAgICBkZXNlcmlhbGl6ZWQgYWdhaW4gdmlhIFtgVGV4dC5vZmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dF5vZikpLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mbGF0dGVuKGxpbmVzKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgYFRleHRgIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgb2YodGV4dCkge1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBkb2N1bWVudCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGxpbmVcIik7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAxICYmICF0ZXh0WzBdKVxuICAgICAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLyA/IG5ldyBUZXh0TGVhZih0ZXh0KSA6IFRleHROb2RlLmZyb20oVGV4dExlYWYuc3BsaXQodGV4dCwgW10pKTtcbiAgICB9XG59XG4vLyBMZWF2ZXMgc3RvcmUgYW4gYXJyYXkgb2YgbGluZSBzdHJpbmdzLiBUaGVyZSBhcmUgYWx3YXlzIGxpbmUgYnJlYWtzXG4vLyBiZXR3ZWVuIHRoZXNlIHN0cmluZ3MuIExlYXZlcyBhcmUgbGltaXRlZCBpbiBzaXplIGFuZCBoYXZlIHRvIGJlXG4vLyBjb250YWluZWQgaW4gVGV4dE5vZGUgaW5zdGFuY2VzIGZvciBiaWdnZXIgZG9jdW1lbnRzLlxuY2xhc3MgVGV4dExlYWYgZXh0ZW5kcyBUZXh0IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBsZW5ndGggPSB0ZXh0TGVuZ3RoKHRleHQpKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgbGluZXMoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGxpbmVJbm5lcih0YXJnZXQsIGlzTGluZSwgbGluZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RyaW5nID0gdGhpcy50ZXh0W2ldLCBlbmQgPSBvZmZzZXQgKyBzdHJpbmcubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChpc0xpbmUgPyBsaW5lIDogZW5kKSA+PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lKG9mZnNldCwgZW5kLCBsaW5lLCBzdHJpbmcpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBsZXQgdGV4dCA9IGZyb20gPD0gMCAmJiB0byA+PSB0aGlzLmxlbmd0aCA/IHRoaXNcbiAgICAgICAgICAgIDogbmV3IFRleHRMZWFmKHNsaWNlVGV4dCh0aGlzLnRleHQsIGZyb20sIHRvKSwgTWF0aC5taW4odG8sIHRoaXMubGVuZ3RoKSAtIE1hdGgubWF4KDAsIGZyb20pKTtcbiAgICAgICAgaWYgKG9wZW4gJiAxIC8qIE9wZW4uRnJvbSAqLykge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0YXJnZXQucG9wKCk7XG4gICAgICAgICAgICBsZXQgam9pbmVkID0gYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHByZXYudGV4dC5zbGljZSgpLCAwLCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoam9pbmVkLmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihqb2luZWQsIHByZXYubGVuZ3RoICsgdGV4dC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtaWQgPSBqb2luZWQubGVuZ3RoID4+IDE7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZSgwLCBtaWQpKSwgbmV3IFRleHRMZWFmKGpvaW5lZC5zbGljZShtaWQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIGlmICghKHRleHQgaW5zdGFuY2VvZiBUZXh0TGVhZikpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShmcm9tLCB0bywgdGV4dCk7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IGxpbmVzID0gYXBwZW5kVGV4dCh0aGlzLnRleHQsIGFwcGVuZFRleHQodGV4dC50ZXh0LCBzbGljZVRleHQodGhpcy50ZXh0LCAwLCBmcm9tKSksIHRvKTtcbiAgICAgICAgbGV0IG5ld0xlbiA9IHRoaXMubGVuZ3RoICsgdGV4dC5sZW5ndGggLSAodG8gLSBmcm9tKTtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLylcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYobGluZXMsIG5ld0xlbik7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKFRleHRMZWFmLnNwbGl0KGxpbmVzLCBbXSksIG5ld0xlbik7XG4gICAgfVxuICAgIHNsaWNlU3RyaW5nKGZyb20sIHRvID0gdGhpcy5sZW5ndGgsIGxpbmVTZXAgPSBcIlxcblwiKSB7XG4gICAgICAgIFtmcm9tLCB0b10gPSBjbGlwKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGkgPSAwOyBwb3MgPD0gdG8gJiYgaSA8IHRoaXMudGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnRleHRbaV0sIGVuZCA9IHBvcyArIGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgaSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZVNlcDtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgZW5kICYmIHRvID4gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lLnNsaWNlKE1hdGgubWF4KDAsIGZyb20gLSBwb3MpLCB0byAtIHBvcyk7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZsYXR0ZW4odGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy50ZXh0KVxuICAgICAgICAgICAgdGFyZ2V0LnB1c2gobGluZSk7XG4gICAgfVxuICAgIHNjYW5JZGVudGljYWwoKSB7IHJldHVybiAwOyB9XG4gICAgc3RhdGljIHNwbGl0KHRleHQsIHRhcmdldCkge1xuICAgICAgICBsZXQgcGFydCA9IFtdLCBsZW4gPSAtMTtcbiAgICAgICAgZm9yIChsZXQgbGluZSBvZiB0ZXh0KSB7XG4gICAgICAgICAgICBwYXJ0LnB1c2gobGluZSk7XG4gICAgICAgICAgICBsZW4gKz0gbGluZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgaWYgKHBhcnQubGVuZ3RoID09IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobmV3IFRleHRMZWFmKHBhcnQsIGxlbikpO1xuICAgICAgICAgICAgICAgIHBhcnQgPSBbXTtcbiAgICAgICAgICAgICAgICBsZW4gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID4gLTEpXG4gICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxufVxuLy8gTm9kZXMgcHJvdmlkZSB0aGUgdHJlZSBzdHJ1Y3R1cmUgb2YgdGhlIGBUZXh0YCB0eXBlLiBUaGV5IHN0b3JlIGFcbi8vIG51bWJlciBvZiBvdGhlciBub2RlcyBvciBsZWF2ZXMsIHRha2luZyBjYXJlIHRvIGJhbGFuY2UgdGhlbXNlbHZlc1xuLy8gb24gY2hhbmdlcy4gVGhlcmUgYXJlIGltcGxpZWQgbGluZSBicmVha3MgX2JldHdlZW5fIHRoZSBjaGlsZHJlbiBvZlxuLy8gYSBub2RlIChidXQgbm90IGJlZm9yZSB0aGUgZmlyc3Qgb3IgYWZ0ZXIgdGhlIGxhc3QgY2hpbGQpLlxuY2xhc3MgVGV4dE5vZGUgZXh0ZW5kcyBUZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiwgbGVuZ3RoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMubGluZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIHRoaXMubGluZXMgKz0gY2hpbGQubGluZXM7XG4gICAgfVxuICAgIGxpbmVJbm5lcih0YXJnZXQsIGlzTGluZSwgbGluZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5sZW5ndGgsIGVuZExpbmUgPSBsaW5lICsgY2hpbGQubGluZXMgLSAxO1xuICAgICAgICAgICAgaWYgKChpc0xpbmUgPyBlbmRMaW5lIDogZW5kKSA+PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmxpbmVJbm5lcih0YXJnZXQsIGlzTGluZSwgbGluZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZCArIDE7XG4gICAgICAgICAgICBsaW5lID0gZW5kTGluZSArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVjb21wb3NlKGZyb20sIHRvLCB0YXJnZXQsIG9wZW4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IHBvcyA8PSB0byAmJiBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGZyb20gPD0gZW5kICYmIHRvID49IHBvcykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZE9wZW4gPSBvcGVuICYgKChwb3MgPD0gZnJvbSA/IDEgLyogT3Blbi5Gcm9tICovIDogMCkgfCAoZW5kID49IHRvID8gMiAvKiBPcGVuLlRvICovIDogMCkpO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZnJvbSAmJiBlbmQgPD0gdG8gJiYgIWNoaWxkT3BlbilcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGVjb21wb3NlKGZyb20gLSBwb3MsIHRvIC0gcG9zLCB0YXJnZXQsIGNoaWxkT3Blbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHRleHQpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBpZiAodGV4dC5saW5lcyA8IHRoaXMubGluZXMpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiBpZiB0aGUgY2hhbmdlIG9ubHkgYWZmZWN0cyBvbmUgY2hpbGQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNoaWxkJ3Mgc2l6ZSByZW1haW5zIGluIHRoZSBhY2NlcHRhYmxlIHJhbmdlLCBvbmx5IHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIHRoYXQgY2hpbGRcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBwb3MgJiYgdG8gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkID0gY2hpbGQucmVwbGFjZShmcm9tIC0gcG9zLCB0byAtIHBvcywgdGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbExpbmVzID0gdGhpcy5saW5lcyAtIGNoaWxkLmxpbmVzICsgdXBkYXRlZC5saW5lcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWQubGluZXMgPCAodG90YWxMaW5lcyA+PiAoNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovIC0gMSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmxpbmVzID4gKHRvdGFsTGluZXMgPj4gKDUgLyogVHJlZS5CcmFuY2hTaGlmdCAqLyArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5W2ldID0gdXBkYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUoY29weSwgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShwb3MsIGVuZCwgdXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKGZyb20sIHRvLCB0ZXh0KTtcbiAgICB9XG4gICAgc2xpY2VTdHJpbmcoZnJvbSwgdG8gPSB0aGlzLmxlbmd0aCwgbGluZVNlcCA9IFwiXFxuXCIpIHtcbiAgICAgICAgW2Zyb20sIHRvXSA9IGNsaXAodGhpcywgZnJvbSwgdG8pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiBwb3MgPD0gdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA+IGZyb20gJiYgaSlcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZVNlcDtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgZW5kICYmIHRvID4gcG9zKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaGlsZC5zbGljZVN0cmluZyhmcm9tIC0gcG9zLCB0byAtIHBvcywgbGluZVNlcCk7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZsYXR0ZW4odGFyZ2V0KSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICBjaGlsZC5mbGF0dGVuKHRhcmdldCk7XG4gICAgfVxuICAgIHNjYW5JZGVudGljYWwob3RoZXIsIGRpcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFRleHROb2RlKSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IFtpQSwgaUIsIGVBLCBlQl0gPSBkaXIgPiAwID8gWzAsIDAsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoLCBvdGhlci5jaGlsZHJlbi5sZW5ndGhdXG4gICAgICAgICAgICA6IFt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEsIG90aGVyLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAtMV07XG4gICAgICAgIGZvciAoOzsgaUEgKz0gZGlyLCBpQiArPSBkaXIpIHtcbiAgICAgICAgICAgIGlmIChpQSA9PSBlQSB8fCBpQiA9PSBlQilcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGNoQSA9IHRoaXMuY2hpbGRyZW5baUFdLCBjaEIgPSBvdGhlci5jaGlsZHJlbltpQl07XG4gICAgICAgICAgICBpZiAoY2hBICE9IGNoQilcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoICsgY2hBLnNjYW5JZGVudGljYWwoY2hCLCBkaXIpO1xuICAgICAgICAgICAgbGVuZ3RoICs9IGNoQS5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKGNoaWxkcmVuLCBsZW5ndGggPSBjaGlsZHJlbi5yZWR1Y2UoKGwsIGNoKSA9PiBsICsgY2gubGVuZ3RoICsgMSwgLTEpKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgbGluZXMgKz0gY2gubGluZXM7XG4gICAgICAgIGlmIChsaW5lcyA8IDMyIC8qIFRyZWUuQnJhbmNoICovKSB7XG4gICAgICAgICAgICBsZXQgZmxhdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2guZmxhdHRlbihmbGF0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYoZmxhdCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2h1bmsgPSBNYXRoLm1heCgzMiAvKiBUcmVlLkJyYW5jaCAqLywgbGluZXMgPj4gNSAvKiBUcmVlLkJyYW5jaFNoaWZ0ICovKSwgbWF4Q2h1bmsgPSBjaHVuayA8PCAxLCBtaW5DaHVuayA9IGNodW5rID4+IDE7XG4gICAgICAgIGxldCBjaHVua2VkID0gW10sIGN1cnJlbnRMaW5lcyA9IDAsIGN1cnJlbnRMZW4gPSAtMSwgY3VycmVudENodW5rID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGFkZChjaGlsZCkge1xuICAgICAgICAgICAgbGV0IGxhc3Q7XG4gICAgICAgICAgICBpZiAoY2hpbGQubGluZXMgPiBtYXhDaHVuayAmJiBjaGlsZCBpbnN0YW5jZW9mIFRleHROb2RlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBjaGlsZC5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgYWRkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQubGluZXMgPiBtaW5DaHVuayAmJiAoY3VycmVudExpbmVzID4gbWluQ2h1bmsgfHwgIWN1cnJlbnRMaW5lcykpIHtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIGNodW5rZWQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRleHRMZWFmICYmIGN1cnJlbnRMaW5lcyAmJlxuICAgICAgICAgICAgICAgIChsYXN0ID0gY3VycmVudENodW5rW2N1cnJlbnRDaHVuay5sZW5ndGggLSAxXSkgaW5zdGFuY2VvZiBUZXh0TGVhZiAmJlxuICAgICAgICAgICAgICAgIGNoaWxkLmxpbmVzICsgbGFzdC5saW5lcyA8PSAzMiAvKiBUcmVlLkJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcyArPSBjaGlsZC5saW5lcztcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuICs9IGNoaWxkLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rW2N1cnJlbnRDaHVuay5sZW5ndGggLSAxXSA9IG5ldyBUZXh0TGVhZihsYXN0LnRleHQuY29uY2F0KGNoaWxkLnRleHQpLCBsYXN0Lmxlbmd0aCArIDEgKyBjaGlsZC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lcyArIGNoaWxkLmxpbmVzID4gY2h1bmspXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW4gKz0gY2hpbGQubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmsucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudExpbmVzID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2h1bmtlZC5wdXNoKGN1cnJlbnRDaHVuay5sZW5ndGggPT0gMSA/IGN1cnJlbnRDaHVua1swXSA6IFRleHROb2RlLmZyb20oY3VycmVudENodW5rLCBjdXJyZW50TGVuKSk7XG4gICAgICAgICAgICBjdXJyZW50TGVuID0gLTE7XG4gICAgICAgICAgICBjdXJyZW50TGluZXMgPSBjdXJyZW50Q2h1bmsubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGFkZChjaGlsZCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgICAgIHJldHVybiBjaHVua2VkLmxlbmd0aCA9PSAxID8gY2h1bmtlZFswXSA6IG5ldyBUZXh0Tm9kZShjaHVua2VkLCBsZW5ndGgpO1xuICAgIH1cbn1cblRleHQuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IFRleHRMZWFmKFtcIlwiXSwgMCk7XG5mdW5jdGlvbiB0ZXh0TGVuZ3RoKHRleHQpIHtcbiAgICBsZXQgbGVuZ3RoID0gLTE7XG4gICAgZm9yIChsZXQgbGluZSBvZiB0ZXh0KVxuICAgICAgICBsZW5ndGggKz0gbGluZS5sZW5ndGggKyAxO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG5mdW5jdGlvbiBhcHBlbmRUZXh0KHRleHQsIHRhcmdldCwgZnJvbSA9IDAsIHRvID0gMWU5KSB7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDAsIGZpcnN0ID0gdHJ1ZTsgaSA8IHRleHQubGVuZ3RoICYmIHBvcyA8PSB0bzsgaSsrKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgIGlmIChlbmQgPj0gZnJvbSkge1xuICAgICAgICAgICAgaWYgKGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKGZyb20gLSBwb3MpO1xuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3RhcmdldC5sZW5ndGggLSAxXSArPSBsaW5lO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHNsaWNlVGV4dCh0ZXh0LCBmcm9tLCB0bykge1xuICAgIHJldHVybiBhcHBlbmRUZXh0KHRleHQsIFtcIlwiXSwgZnJvbSwgdG8pO1xufVxuY2xhc3MgUmF3VGV4dEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgZGlyID0gMSkge1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLm5vZGVzID0gW3RleHRdO1xuICAgICAgICB0aGlzLm9mZnNldHMgPSBbZGlyID4gMCA/IDEgOiAodGV4dCBpbnN0YW5jZW9mIFRleHRMZWFmID8gdGV4dC50ZXh0Lmxlbmd0aCA6IHRleHQuY2hpbGRyZW4ubGVuZ3RoKSA8PCAxXTtcbiAgICB9XG4gICAgbmV4dElubmVyKHNraXAsIGRpcikge1xuICAgICAgICB0aGlzLmRvbmUgPSB0aGlzLmxpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLm5vZGVzW2xhc3RdLCBvZmZzZXRWYWx1ZSA9IHRoaXMub2Zmc2V0c1tsYXN0XSwgb2Zmc2V0ID0gb2Zmc2V0VmFsdWUgPj4gMTtcbiAgICAgICAgICAgIGxldCBzaXplID0gdG9wIGluc3RhbmNlb2YgVGV4dExlYWYgPyB0b3AudGV4dC5sZW5ndGggOiB0b3AuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSAoZGlyID4gMCA/IHNpemUgOiAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3QgLSAxXSsrO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKG9mZnNldFZhbHVlICYgMSkgPT0gKGRpciA+IDAgPyAwIDogMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIGlmIChza2lwID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXAtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvcCBpbnN0YW5jZW9mIFRleHRMZWFmKSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBzdHJpbmdcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC50ZXh0W29mZnNldCArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5sZW5ndGggPiBNYXRoLm1heCgwLCBza2lwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gc2tpcCA9PSAwID8gbmV4dCA6IGRpciA+IDAgPyBuZXh0LnNsaWNlKHNraXApIDogbmV4dC5zbGljZSgwLCBuZXh0Lmxlbmd0aCAtIHNraXApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcCAtPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW29mZnNldCArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICAgICAgaWYgKHNraXAgPiBuZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBza2lwIC09IG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0tLTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHMucHVzaChkaXIgPiAwID8gMSA6IChuZXh0IGluc3RhbmNlb2YgVGV4dExlYWYgPyBuZXh0LnRleHQubGVuZ3RoIDogbmV4dC5jaGlsZHJlbi5sZW5ndGgpIDw8IDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGlmIChza2lwIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0SW5uZXIoLXNraXAsICgtdGhpcy5kaXIpKTtcbiAgICAgICAgICAgIHNraXAgPSB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW5uZXIoc2tpcCwgdGhpcy5kaXIpO1xuICAgIH1cbn1cbmNsYXNzIFBhcnRpYWxUZXh0Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBuZXcgUmF3VGV4dEN1cnNvcih0ZXh0LCBzdGFydCA+IGVuZCA/IC0xIDogMSk7XG4gICAgICAgIHRoaXMucG9zID0gc3RhcnQgPiBlbmQgPyB0ZXh0Lmxlbmd0aCA6IDA7XG4gICAgICAgIHRoaXMuZnJvbSA9IE1hdGgubWluKHN0YXJ0LCBlbmQpO1xuICAgICAgICB0aGlzLnRvID0gTWF0aC5tYXgoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIG5leHRJbm5lcihza2lwLCBkaXIpIHtcbiAgICAgICAgaWYgKGRpciA8IDAgPyB0aGlzLnBvcyA8PSB0aGlzLmZyb20gOiB0aGlzLnBvcyA+PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBza2lwICs9IE1hdGgubWF4KDAsIGRpciA8IDAgPyB0aGlzLnBvcyAtIHRoaXMudG8gOiB0aGlzLmZyb20gLSB0aGlzLnBvcyk7XG4gICAgICAgIGxldCBsaW1pdCA9IGRpciA8IDAgPyB0aGlzLnBvcyAtIHRoaXMuZnJvbSA6IHRoaXMudG8gLSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHNraXAgPiBsaW1pdClcbiAgICAgICAgICAgIHNraXAgPSBsaW1pdDtcbiAgICAgICAgbGltaXQgLT0gc2tpcDtcbiAgICAgICAgbGV0IHsgdmFsdWUgfSA9IHRoaXMuY3Vyc29yLm5leHQoc2tpcCk7XG4gICAgICAgIHRoaXMucG9zICs9ICh2YWx1ZS5sZW5ndGggKyBza2lwKSAqIGRpcjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLmxlbmd0aCA8PSBsaW1pdCA/IHZhbHVlIDogZGlyIDwgMCA/IHZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIGxpbWl0KSA6IHZhbHVlLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgICAgdGhpcy5kb25lID0gIXRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGlmIChza2lwIDwgMClcbiAgICAgICAgICAgIHNraXAgPSBNYXRoLm1heChza2lwLCB0aGlzLmZyb20gLSB0aGlzLnBvcyk7XG4gICAgICAgIGVsc2UgaWYgKHNraXAgPiAwKVxuICAgICAgICAgICAgc2tpcCA9IE1hdGgubWluKHNraXAsIHRoaXMudG8gLSB0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJbm5lcihza2lwLCB0aGlzLmN1cnNvci5kaXIpO1xuICAgIH1cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gdGhpcy5jdXJzb3IubGluZUJyZWFrICYmIHRoaXMudmFsdWUgIT0gXCJcIjsgfVxufVxuY2xhc3MgTGluZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaW5uZXIpIHtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSB0cnVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgbGV0IHsgZG9uZSwgbGluZUJyZWFrLCB2YWx1ZSB9ID0gdGhpcy5pbm5lci5uZXh0KHNraXApO1xuICAgICAgICBpZiAoZG9uZSAmJiB0aGlzLmFmdGVyQnJlYWspIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9uZSkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmVCcmVhaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWZ0ZXJCcmVhaykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBUZXh0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pdGVyKCk7IH07XG4gICAgUmF3VGV4dEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IFBhcnRpYWxUZXh0Q3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID1cbiAgICAgICAgTGluZUN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG59XG4vKipcblRoaXMgdHlwZSBkZXNjcmliZXMgYSBsaW5lIGluIHRoZSBkb2N1bWVudC4gSXQgaXMgY3JlYXRlZFxub24tZGVtYW5kIHdoZW4gbGluZXMgYXJlIFtxdWVyaWVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHQubGluZUF0KS5cbiovXG5jbGFzcyBMaW5lIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGluZSAoX2JlZm9yZV8gdGhlIGxpbmUgYnJlYWssXG4gICAgb3IgYXQgdGhlIGVuZCBvZiBkb2N1bWVudCBmb3IgdGhlIGxhc3QgbGluZSkuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhpcyBsaW5lJ3MgbGluZSBudW1iZXIgKDEtYmFzZWQpLlxuICAgICovXG4gICAgbnVtYmVyLCBcbiAgICAvKipcbiAgICBUaGUgbGluZSdzIGNvbnRlbnQuXG4gICAgKi9cbiAgICB0ZXh0KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGxpbmUgKG5vdCBpbmNsdWRpbmcgYW55IGxpbmUgYnJlYWsgYWZ0ZXIgaXQpLlxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudG8gLSB0aGlzLmZyb207IH1cbn1cbmZ1bmN0aW9uIGNsaXAodGV4dCwgZnJvbSwgdG8pIHtcbiAgICBmcm9tID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGV4dC5sZW5ndGgsIGZyb20pKTtcbiAgICByZXR1cm4gW2Zyb20sIE1hdGgubWF4KGZyb20sIE1hdGgubWluKHRleHQubGVuZ3RoLCB0bykpXTtcbn1cblxuLyoqXG5SZXR1cm5zIGEgbmV4dCBncmFwaGVtZSBjbHVzdGVyIGJyZWFrIF9hZnRlcl8gKG5vdCBlcXVhbCB0bylcbmBwb3NgLCBpZiBgZm9yd2FyZGAgaXMgdHJ1ZSwgb3IgYmVmb3JlIG90aGVyd2lzZS4gUmV0dXJucyBgcG9zYFxuaXRzZWxmIGlmIG5vIGZ1cnRoZXIgY2x1c3RlciBicmVhayBpcyBhdmFpbGFibGUgaW4gdGhlIHN0cmluZy5cbk1vdmVzIGFjcm9zcyBzdXJyb2dhdGUgcGFpcnMsIGV4dGVuZGluZyBjaGFyYWN0ZXJzICh3aGVuXG5gaW5jbHVkZUV4dGVuZGluZ2AgaXMgdHJ1ZSksIGNoYXJhY3RlcnMgam9pbmVkIHdpdGggemVyby13aWR0aFxuam9pbmVycywgYW5kIGZsYWcgZW1vamkuXG4qL1xuZnVuY3Rpb24gZmluZENsdXN0ZXJCcmVhayhzdHIsIHBvcywgZm9yd2FyZCA9IHRydWUsIGluY2x1ZGVFeHRlbmRpbmcgPSB0cnVlKSB7XG4gICAgcmV0dXJuIGZpbmRDbHVzdGVyQnJlYWskMShzdHIsIHBvcywgZm9yd2FyZCwgaW5jbHVkZUV4dGVuZGluZyk7XG59XG5mdW5jdGlvbiBzdXJyb2dhdGVMb3coY2gpIHsgcmV0dXJuIGNoID49IDB4REMwMCAmJiBjaCA8IDB4RTAwMDsgfVxuZnVuY3Rpb24gc3Vycm9nYXRlSGlnaChjaCkgeyByZXR1cm4gY2ggPj0gMHhEODAwICYmIGNoIDwgMHhEQzAwOyB9XG4vKipcbkZpbmQgdGhlIGNvZGUgcG9pbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGluIGEgc3RyaW5nIChsaWtlIHRoZVxuW2Bjb2RlUG9pbnRBdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9jb2RlUG9pbnRBdClcbnN0cmluZyBtZXRob2QpLlxuKi9cbmZ1bmN0aW9uIGNvZGVQb2ludEF0KHN0ciwgcG9zKSB7XG4gICAgbGV0IGNvZGUwID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIXN1cnJvZ2F0ZUhpZ2goY29kZTApIHx8IHBvcyArIDEgPT0gc3RyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGNvZGUwO1xuICAgIGxldCBjb2RlMSA9IHN0ci5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgIGlmICghc3Vycm9nYXRlTG93KGNvZGUxKSlcbiAgICAgICAgcmV0dXJuIGNvZGUwO1xuICAgIHJldHVybiAoKGNvZGUwIC0gMHhkODAwKSA8PCAxMCkgKyAoY29kZTEgLSAweGRjMDApICsgMHgxMDAwMDtcbn1cbi8qKlxuR2l2ZW4gYSBVbmljb2RlIGNvZGVwb2ludCwgcmV0dXJuIHRoZSBKYXZhU2NyaXB0IHN0cmluZyB0aGF0XG5yZXNwcmVzZW50cyBpdCAobGlrZVxuW2BTdHJpbmcuZnJvbUNvZGVQb2ludGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9mcm9tQ29kZVBvaW50KSkuXG4qL1xuZnVuY3Rpb24gZnJvbUNvZGVQb2ludChjb2RlKSB7XG4gICAgaWYgKGNvZGUgPD0gMHhmZmZmKVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICBjb2RlIC09IDB4MTAwMDA7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgPj4gMTApICsgMHhkODAwLCAoY29kZSAmIDEwMjMpICsgMHhkYzAwKTtcbn1cbi8qKlxuVGhlIGFtb3VudCBvZiBwb3NpdGlvbnMgYSBjaGFyYWN0ZXIgdGFrZXMgdXAgaW4gYSBKYXZhU2NyaXB0IHN0cmluZy5cbiovXG5mdW5jdGlvbiBjb2RlUG9pbnRTaXplKGNvZGUpIHsgcmV0dXJuIGNvZGUgPCAweDEwMDAwID8gMSA6IDI7IH1cblxuY29uc3QgRGVmYXVsdFNwbGl0ID0gL1xcclxcbj98XFxuLztcbi8qKlxuRGlzdGluZ3Vpc2hlcyBkaWZmZXJlbnQgd2F5cyBpbiB3aGljaCBwb3NpdGlvbnMgY2FuIGJlIG1hcHBlZC5cbiovXG52YXIgTWFwTW9kZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKE1hcE1vZGUpIHtcbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0byBhIHZhbGlkIG5ldyBwb3NpdGlvbiwgZXZlbiB3aGVuIGl0cyBjb250ZXh0XG4gICAgd2FzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJTaW1wbGVcIl0gPSAwXSA9IFwiU2ltcGxlXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgZGVsZXRpb24gaGFwcGVucyBhY3Jvc3MgdGhlIHBvc2l0aW9uLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiVHJhY2tEZWxcIl0gPSAxXSA9IFwiVHJhY2tEZWxcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiB0aGUgY2hhcmFjdGVyIF9iZWZvcmVfIHRoZSBwb3NpdGlvbiBpcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiVHJhY2tCZWZvcmVcIl0gPSAyXSA9IFwiVHJhY2tCZWZvcmVcIjtcbiAgICAvKipcbiAgICBSZXR1cm4gbnVsbCBpZiB0aGUgY2hhcmFjdGVyIF9hZnRlcl8gdGhlIHBvc2l0aW9uIGlzIGRlbGV0ZWQuXG4gICAgKi9cbiAgICBNYXBNb2RlW01hcE1vZGVbXCJUcmFja0FmdGVyXCJdID0gM10gPSBcIlRyYWNrQWZ0ZXJcIjtcbnJldHVybiBNYXBNb2RlfSkoTWFwTW9kZSB8fCAoTWFwTW9kZSA9IHt9KSk7XG4vKipcbkEgY2hhbmdlIGRlc2NyaXB0aW9uIGlzIGEgdmFyaWFudCBvZiBbY2hhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQpXG50aGF0IGRvZXNuJ3Qgc3RvcmUgdGhlIGluc2VydGVkIHRleHQuIEFzIHN1Y2gsIGl0IGNhbid0IGJlXG5hcHBsaWVkLCBidXQgaXMgY2hlYXBlciB0byBzdG9yZSBhbmQgbWFuaXB1bGF0ZS5cbiovXG5jbGFzcyBDaGFuZ2VEZXNjIHtcbiAgICAvLyBTZWN0aW9ucyBhcmUgZW5jb2RlZCBhcyBwYWlycyBvZiBpbnRlZ2Vycy4gVGhlIGZpcnN0IGlzIHRoZVxuICAgIC8vIGxlbmd0aCBpbiB0aGUgY3VycmVudCBkb2N1bWVudCwgYW5kIHRoZSBzZWNvbmQgaXMgLTEgZm9yXG4gICAgLy8gdW5hZmZlY3RlZCBzZWN0aW9ucywgYW5kIHRoZSBsZW5ndGggb2YgdGhlIHJlcGxhY2VtZW50IGNvbnRlbnRcbiAgICAvLyBvdGhlcndpc2UuIFNvIGFuIGluc2VydGlvbiB3b3VsZCBiZSAoMCwgbj4wKSwgYSBkZWxldGlvbiAobj4wLFxuICAgIC8vIDApLCBhbmQgYSByZXBsYWNlbWVudCB0d28gcG9zaXRpdmUgbnVtYmVycy5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zZWN0aW9ucyA9IHNlY3Rpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbGVuZ3RoIG9mIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5zZWN0aW9uc1tpXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgdGhlIGNoYW5nZS5cbiAgICAqL1xuICAgIGdldCBuZXdMZW5ndGgoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBpbnMgPSB0aGlzLnNlY3Rpb25zW2kgKyAxXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBpbnMgPCAwID8gdGhpcy5zZWN0aW9uc1tpXSA6IGlucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBGYWxzZSB3aGVuIHRoZXJlIGFyZSBhY3R1YWwgY2hhbmdlcyBpbiB0aGlzIHNldC5cbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuc2VjdGlvbnMubGVuZ3RoID09IDAgfHwgdGhpcy5zZWN0aW9ucy5sZW5ndGggPT0gMiAmJiB0aGlzLnNlY3Rpb25zWzFdIDwgMDsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgdW5jaGFuZ2VkIHBhcnRzIGxlZnQgYnkgdGhlc2UgY2hhbmdlcy4gYHBvc0FgXG4gICAgcHJvdmlkZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSByYW5nZSBpbiB0aGUgb2xkIGRvY3VtZW50LCBgcG9zQmBcbiAgICB0aGUgbmV3IHBvc2l0aW9uIGluIHRoZSBjaGFuZ2VkIGRvY3VtZW50LlxuICAgICovXG4gICAgaXRlckdhcHMoZikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zQSA9IDAsIHBvc0IgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpKytdLCBpbnMgPSB0aGlzLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgICAgIGYocG9zQSwgcG9zQiwgbGVuKTtcbiAgICAgICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gaW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zQSArPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgY2hhbmdlZCBieSB0aGVzZSBjaGFuZ2VzLiAoU2VlXG4gICAgW2BDaGFuZ2VTZXQuaXRlckNoYW5nZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldC5pdGVyQ2hhbmdlcykgZm9yIGFcbiAgICB2YXJpYW50IHRoYXQgYWxzbyBwcm92aWRlcyB5b3Ugd2l0aCB0aGUgaW5zZXJ0ZWQgdGV4dC4pXG4gICAgYGZyb21BYC9gdG9BYCBwcm92aWRlcyB0aGUgZXh0ZW50IG9mIHRoZSBjaGFuZ2UgaW4gdGhlIHN0YXJ0aW5nXG4gICAgZG9jdW1lbnQsIGBmcm9tQmAvYHRvQmAgdGhlIGV4dGVudCBvZiB0aGUgcmVwbGFjZW1lbnQgaW4gdGhlXG4gICAgY2hhbmdlZCBkb2N1bWVudC5cbiAgICBcbiAgICBXaGVuIGBpbmRpdmlkdWFsYCBpcyB0cnVlLCBhZGphY2VudCBjaGFuZ2VzICh3aGljaCBhcmUga2VwdFxuICAgIHNlcGFyYXRlIGZvciBbcG9zaXRpb24gbWFwcGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjLm1hcFBvcykpIGFyZVxuICAgIHJlcG9ydGVkIHNlcGFyYXRlbHkuXG4gICAgKi9cbiAgICBpdGVyQ2hhbmdlZFJhbmdlcyhmLCBpbmRpdmlkdWFsID0gZmFsc2UpIHtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgZiwgaW5kaXZpZHVhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIGRlc2NyaXB0aW9uIG9mIHRoZSBpbnZlcnRlZCBmb3JtIG9mIHRoZXNlIGNoYW5nZXMuXG4gICAgKi9cbiAgICBnZXQgaW52ZXJ0ZWREZXNjKCkge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gobGVuLCBpbnMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goaW5zLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGVzYyhzZWN0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGNvbWJpbmVkIGVmZmVjdCBvZiBhcHBseWluZyBhbm90aGVyIHNldCBvZiBjaGFuZ2VzXG4gICAgYWZ0ZXIgdGhpcyBvbmUuIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGFmdGVyIHRoaXMgc2V0IHNob3VsZFxuICAgIG1hdGNoIHRoZSBsZW5ndGggYmVmb3JlIGBvdGhlcmAuXG4gICAgKi9cbiAgICBjb21wb3NlRGVzYyhvdGhlcikgeyByZXR1cm4gdGhpcy5lbXB0eSA/IG90aGVyIDogb3RoZXIuZW1wdHkgPyB0aGlzIDogY29tcG9zZVNldHModGhpcywgb3RoZXIpOyB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgZGVzY3JpcHRpb24sIHdoaWNoIHNob3VsZCBzdGFydCB3aXRoIHRoZSBzYW1lIGRvY3VtZW50XG4gICAgYXMgYG90aGVyYCwgb3ZlciBhbm90aGVyIHNldCBvZiBjaGFuZ2VzLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgIGFwcGxpZWQgYWZ0ZXIgaXQuIFdoZW4gYGJlZm9yZWAgaXMgdHJ1ZSwgbWFwIGFzIGlmIHRoZSBjaGFuZ2VzXG4gICAgaW4gYHRoaXNgIGhhcHBlbmVkIGJlZm9yZSB0aGUgb25lcyBpbiBgb3RoZXJgLlxuICAgICovXG4gICAgbWFwRGVzYyhvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG90aGVyLmVtcHR5ID8gdGhpcyA6IG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlKTsgfVxuICAgIG1hcFBvcyhwb3MsIGFzc29jID0gLTEsIG1vZGUgPSBNYXBNb2RlLlNpbXBsZSkge1xuICAgICAgICBsZXQgcG9zQSA9IDAsIHBvc0IgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdLCBlbmRBID0gcG9zQSArIGxlbjtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZEEgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3NCICsgKHBvcyAtIHBvc0EpO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgIT0gTWFwTW9kZS5TaW1wbGUgJiYgZW5kQSA+PSBwb3MgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1vZGUgPT0gTWFwTW9kZS5UcmFja0RlbCAmJiBwb3NBIDwgcG9zICYmIGVuZEEgPiBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gTWFwTW9kZS5UcmFja0JlZm9yZSAmJiBwb3NBIDwgcG9zIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID09IE1hcE1vZGUuVHJhY2tBZnRlciAmJiBlbmRBID4gcG9zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGVuZEEgPiBwb3MgfHwgZW5kQSA9PSBwb3MgJiYgYXNzb2MgPCAwICYmICFsZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3MgPT0gcG9zQSB8fCBhc3NvYyA8IDAgPyBwb3NCIDogcG9zQiArIGlucztcbiAgICAgICAgICAgICAgICBwb3NCICs9IGlucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc0EgPSBlbmRBO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPiBwb3NBKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBvc2l0aW9uICR7cG9zfSBpcyBvdXQgb2YgcmFuZ2UgZm9yIGNoYW5nZXNldCBvZiBsZW5ndGggJHtwb3NBfWApO1xuICAgICAgICByZXR1cm4gcG9zQjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGVzZSBjaGFuZ2VzIHRvdWNoIGEgZ2l2ZW4gcmFuZ2UuIFdoZW4gb25lIG9mIHRoZVxuICAgIGNoYW5nZXMgZW50aXJlbHkgY292ZXJzIHRoZSByYW5nZSwgdGhlIHN0cmluZyBgXCJjb3ZlclwiYCBpc1xuICAgIHJldHVybmVkLlxuICAgICovXG4gICAgdG91Y2hlc1JhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoICYmIHBvcyA8PSB0bzspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgZW5kID0gcG9zICsgbGVuO1xuICAgICAgICAgICAgaWYgKGlucyA+PSAwICYmIHBvcyA8PSB0byAmJiBlbmQgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zIDwgZnJvbSAmJiBlbmQgPiB0byA/IFwiY292ZXJcIiA6IHRydWU7XG4gICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSAocmVzdWx0ID8gXCIgXCIgOiBcIlwiKSArIGxlbiArIChpbnMgPj0gMCA/IFwiOlwiICsgaW5zIDogXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgY2hhbmdlIGRlc2MgdG8gYSBKU09OLXJlcHJlc2VudGFibGUgdmFsdWUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7IHJldHVybiB0aGlzLnNlY3Rpb25zOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlIGRlc2MgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiAoYXMgcHJvZHVjZWRcbiAgICBieSBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYy50b0pTT04pLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24pIHx8IGpzb24ubGVuZ3RoICUgMiB8fCBqc29uLnNvbWUoYSA9PiB0eXBlb2YgYSAhPSBcIm51bWJlclwiKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZURlc2NcIik7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGVzYyhqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHNlY3Rpb25zKSB7IHJldHVybiBuZXcgQ2hhbmdlRGVzYyhzZWN0aW9ucyk7IH1cbn1cbi8qKlxuQSBjaGFuZ2Ugc2V0IHJlcHJlc2VudHMgYSBncm91cCBvZiBtb2RpZmljYXRpb25zIHRvIGEgZG9jdW1lbnQuIEl0XG5zdG9yZXMgdGhlIGRvY3VtZW50IGxlbmd0aCwgYW5kIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gZG9jdW1lbnRzXG53aXRoIGV4YWN0bHkgdGhhdCBsZW5ndGguXG4qL1xuY2xhc3MgQ2hhbmdlU2V0IGV4dGVuZHMgQ2hhbmdlRGVzYyB7XG4gICAgY29uc3RydWN0b3Ioc2VjdGlvbnMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5zZXJ0ZWQpIHtcbiAgICAgICAgc3VwZXIoc2VjdGlvbnMpO1xuICAgICAgICB0aGlzLmluc2VydGVkID0gaW5zZXJ0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGx5IHRoZSBjaGFuZ2VzIHRvIGEgZG9jdW1lbnQsIHJldHVybmluZyB0aGUgbW9kaWZpZWRcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT0gZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXBwbHlpbmcgY2hhbmdlIHNldCB0byBhIGRvY3VtZW50IHdpdGggdGhlIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgKGZyb21BLCB0b0EsIGZyb21CLCBfdG9CLCB0ZXh0KSA9PiBkb2MgPSBkb2MucmVwbGFjZShmcm9tQiwgZnJvbUIgKyAodG9BIC0gZnJvbUEpLCB0ZXh0KSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgIH1cbiAgICBtYXBEZXNjKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgR2l2ZW4gdGhlIGRvY3VtZW50IGFzIGl0IGV4aXN0ZWQgX2JlZm9yZV8gdGhlIGNoYW5nZXMsIHJldHVybiBhXG4gICAgY2hhbmdlIHNldCB0aGF0IHJlcHJlc2VudHMgdGhlIGludmVyc2Ugb2YgdGhpcyBzZXQsIHdoaWNoIGNvdWxkXG4gICAgYmUgdXNlZCB0byBnbyBmcm9tIHRoZSBkb2N1bWVudCBjcmVhdGVkIGJ5IHRoZSBjaGFuZ2VzIGJhY2sgdG9cbiAgICB0aGUgZG9jdW1lbnQgYXMgaXQgZXhpc3RlZCBiZWZvcmUgdGhlIGNoYW5nZXMuXG4gICAgKi9cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IHRoaXMuc2VjdGlvbnMuc2xpY2UoKSwgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHNlY3Rpb25zW2ldLCBpbnMgPSBzZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICBpZiAoaW5zID49IDApIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uc1tpXSA9IGlucztcbiAgICAgICAgICAgICAgICBzZWN0aW9uc1tpICsgMV0gPSBsZW47XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gaSA+PiAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbnNlcnRlZC5sZW5ndGggPCBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKGxlbiA/IGRvYy5zbGljZShwb3MsIHBvcyArIGxlbikgOiBUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tYmluZSB0d28gc3Vic2VxdWVudCBjaGFuZ2Ugc2V0cyBpbnRvIGEgc2luZ2xlIHNldC4gYG90aGVyYFxuICAgIG11c3Qgc3RhcnQgaW4gdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IGB0aGlzYC4gSWYgYHRoaXNgIGdvZXNcbiAgICBgZG9jQWAg4oaSIGBkb2NCYCBhbmQgYG90aGVyYCByZXByZXNlbnRzIGBkb2NCYCDihpIgYGRvY0NgLCB0aGVcbiAgICByZXR1cm5lZCB2YWx1ZSB3aWxsIHJlcHJlc2VudCB0aGUgY2hhbmdlIGBkb2NBYCDihpIgYGRvY0NgLlxuICAgICovXG4gICAgY29tcG9zZShvdGhlcikgeyByZXR1cm4gdGhpcy5lbXB0eSA/IG90aGVyIDogb3RoZXIuZW1wdHkgPyB0aGlzIDogY29tcG9zZVNldHModGhpcywgb3RoZXIsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYW5vdGhlciBjaGFuZ2Ugc2V0IHN0YXJ0aW5nIGluIHRoZSBzYW1lIGRvY3VtZW50LCBtYXBzIHRoaXNcbiAgICBjaGFuZ2Ugc2V0IG92ZXIgdGhlIG90aGVyLCBwcm9kdWNpbmcgYSBuZXcgY2hhbmdlIHNldCB0aGF0IGNhbiBiZVxuICAgIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IGFwcGx5aW5nIGBvdGhlcmAuIFdoZW5cbiAgICBgYmVmb3JlYCBpcyBgdHJ1ZWAsIG9yZGVyIGNoYW5nZXMgYXMgaWYgYHRoaXNgIGNvbWVzIGJlZm9yZVxuICAgIGBvdGhlcmAsIG90aGVyd2lzZSAodGhlIGRlZmF1bHQpIHRyZWF0IGBvdGhlcmAgYXMgY29taW5nIGZpcnN0LlxuICAgIFxuICAgIEdpdmVuIHR3byBjaGFuZ2VzIGBBYCBhbmQgYEJgLCBgQS5jb21wb3NlKEIubWFwKEEpKWAgYW5kXG4gICAgYEIuY29tcG9zZShBLm1hcChCLCB0cnVlKSlgIHdpbGwgcHJvZHVjZSB0aGUgc2FtZSBkb2N1bWVudC4gVGhpc1xuICAgIHByb3ZpZGVzIGEgYmFzaWMgZm9ybSBvZiBbb3BlcmF0aW9uYWxcbiAgICB0cmFuc2Zvcm1hdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3BlcmF0aW9uYWxfdHJhbnNmb3JtYXRpb24pLFxuICAgIGFuZCBjYW4gYmUgdXNlZCBmb3IgY29sbGFib3JhdGl2ZSBlZGl0aW5nLlxuICAgICovXG4gICAgbWFwKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gb3RoZXIuZW1wdHkgPyB0aGlzIDogbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSBjaGFuZ2VkIHJhbmdlcyBpbiB0aGUgZG9jdW1lbnQsIGNhbGxpbmcgYGZgIGZvclxuICAgIGVhY2gsIHdpdGggdGhlIHJhbmdlIGluIHRoZSBvcmlnaW5hbCBkb2N1bWVudCAoYGZyb21BYC1gdG9BYClcbiAgICBhbmQgdGhlIHJhbmdlIHRoYXQgcmVwbGFjZXMgaXQgaW4gdGhlIG5ldyBkb2N1bWVudFxuICAgIChgZnJvbUJgLWB0b0JgKS5cbiAgICBcbiAgICBXaGVuIGBpbmRpdmlkdWFsYCBpcyB0cnVlLCBhZGphY2VudCBjaGFuZ2VzIGFyZSByZXBvcnRlZFxuICAgIHNlcGFyYXRlbHkuXG4gICAgKi9cbiAgICBpdGVyQ2hhbmdlcyhmLCBpbmRpdmlkdWFsID0gZmFsc2UpIHtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgZiwgaW5kaXZpZHVhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFtjaGFuZ2UgZGVzY3JpcHRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYykgZm9yIHRoaXMgY2hhbmdlXG4gICAgc2V0LlxuICAgICovXG4gICAgZ2V0IGRlc2MoKSB7IHJldHVybiBDaGFuZ2VEZXNjLmNyZWF0ZSh0aGlzLnNlY3Rpb25zKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmlsdGVyKHJhbmdlcykge1xuICAgICAgICBsZXQgcmVzdWx0U2VjdGlvbnMgPSBbXSwgcmVzdWx0SW5zZXJ0ZWQgPSBbXSwgZmlsdGVyZWRTZWN0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgaXRlciA9IG5ldyBTZWN0aW9uSXRlcih0aGlzKTtcbiAgICAgICAgZG9uZTogZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID09IHJhbmdlcy5sZW5ndGggPyAxZTkgOiByYW5nZXNbaSsrXTtcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBuZXh0IHx8IHBvcyA9PSBuZXh0ICYmIGl0ZXIubGVuID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlci5kb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBkb25lO1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihpdGVyLmxlbiwgbmV4dCAtIHBvcyk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihmaWx0ZXJlZFNlY3Rpb25zLCBsZW4sIC0xKTtcbiAgICAgICAgICAgICAgICBsZXQgaW5zID0gaXRlci5pbnMgPT0gLTEgPyAtMSA6IGl0ZXIub2ZmID09IDAgPyBpdGVyLmlucyA6IDA7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihyZXN1bHRTZWN0aW9ucywgbGVuLCBpbnMpO1xuICAgICAgICAgICAgICAgIGlmIChpbnMgPiAwKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQocmVzdWx0SW5zZXJ0ZWQsIHJlc3VsdFNlY3Rpb25zLCBpdGVyLnRleHQpO1xuICAgICAgICAgICAgICAgIGl0ZXIuZm9yd2FyZChsZW4pO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZW5kID0gcmFuZ2VzW2krK107XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZG9uZTtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oaXRlci5sZW4sIGVuZCAtIHBvcyk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihyZXN1bHRTZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICAgICAgYWRkU2VjdGlvbihmaWx0ZXJlZFNlY3Rpb25zLCBsZW4sIGl0ZXIuaW5zID09IC0xID8gLTEgOiBpdGVyLm9mZiA9PSAwID8gaXRlci5pbnMgOiAwKTtcbiAgICAgICAgICAgICAgICBpdGVyLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IG5ldyBDaGFuZ2VTZXQocmVzdWx0U2VjdGlvbnMsIHJlc3VsdEluc2VydGVkKSxcbiAgICAgICAgICAgIGZpbHRlcmVkOiBDaGFuZ2VEZXNjLmNyZWF0ZShmaWx0ZXJlZFNlY3Rpb25zKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhpcyBjaGFuZ2Ugc2V0IHRvIGEgSlNPTi1yZXByZXNlbnRhYmxlIHZhbHVlLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gdGhpcy5zZWN0aW9uc1tpXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICBpZiAoaW5zIDwgMClcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGxlbik7XG4gICAgICAgICAgICBlbHNlIGlmIChpbnMgPT0gMClcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFtsZW5dKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFtsZW5dLmNvbmNhdCh0aGlzLmluc2VydGVkW2kgPj4gMV0udG9KU09OKCkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZSBzZXQgZm9yIHRoZSBnaXZlbiBjaGFuZ2VzLCBmb3IgYSBkb2N1bWVudCBvZiB0aGVcbiAgICBnaXZlbiBsZW5ndGgsIHVzaW5nIGBsaW5lU2VwYCBhcyBsaW5lIHNlcGFyYXRvci5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihjaGFuZ2VzLCBsZW5ndGgsIGxpbmVTZXApIHtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydGVkID0gW10sIHBvcyA9IDA7XG4gICAgICAgIGxldCB0b3RhbCA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoKGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICghZm9yY2UgJiYgIXNlY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAocG9zIDwgbGVuZ3RoKVxuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbmd0aCAtIHBvcywgLTEpO1xuICAgICAgICAgICAgbGV0IHNldCA9IG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICAgICAgICAgIHRvdGFsID0gdG90YWwgPyB0b3RhbC5jb21wb3NlKHNldC5tYXAodG90YWwpKSA6IHNldDtcbiAgICAgICAgICAgIHNlY3Rpb25zID0gW107XG4gICAgICAgICAgICBpbnNlcnRlZCA9IFtdO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzKHNwZWMpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNwZWMpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc3ViIG9mIHNwZWMpXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3Moc3ViKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNwZWMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlYy5sZW5ndGggIT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aCAoZ290ICR7c3BlYy5sZW5ndGh9LCBleHBlY3RlZCAke2xlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHRvdGFsID8gdG90YWwuY29tcG9zZShzcGVjLm1hcCh0b3RhbCkpIDogc3BlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB7IGZyb20sIHRvID0gZnJvbSwgaW5zZXJ0IH0gPSBzcGVjO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID4gdG8gfHwgZnJvbSA8IDAgfHwgdG8gPiBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNoYW5nZSByYW5nZSAke2Zyb219IHRvICR7dG99IChpbiBkb2Mgb2YgbGVuZ3RoICR7bGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICBsZXQgaW5zVGV4dCA9ICFpbnNlcnQgPyBUZXh0LmVtcHR5IDogdHlwZW9mIGluc2VydCA9PSBcInN0cmluZ1wiID8gVGV4dC5vZihpbnNlcnQuc3BsaXQobGluZVNlcCB8fCBEZWZhdWx0U3BsaXQpKSA6IGluc2VydDtcbiAgICAgICAgICAgICAgICBsZXQgaW5zTGVuID0gaW5zVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gdG8gJiYgaW5zTGVuID09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHBvcylcbiAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IHBvcylcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgZnJvbSAtIHBvcywgLTEpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIHRvIC0gZnJvbSwgaW5zTGVuKTtcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0ZWQsIHNlY3Rpb25zLCBpbnNUZXh0KTtcbiAgICAgICAgICAgICAgICBwb3MgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzKGNoYW5nZXMpO1xuICAgICAgICBmbHVzaCghdG90YWwpO1xuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBlbXB0eSBjaGFuZ2VzZXQgb2YgdGhlIGdpdmVuIGxlbmd0aC5cbiAgICAqL1xuICAgIHN0YXRpYyBlbXB0eShsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQobGVuZ3RoID8gW2xlbmd0aCwgLTFdIDogW10sIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlc2V0IGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24gKGFzIHByb2R1Y2VkIGJ5XG4gICAgW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldC50b0pTT04pLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlU2V0XCIpO1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcGFydCA9IGpzb25baV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocGFydCkgfHwgdHlwZW9mIHBhcnRbMF0gIT0gXCJudW1iZXJcIiB8fCBwYXJ0LnNvbWUoKGUsIGkpID0+IGkgJiYgdHlwZW9mIGUgIT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VTZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0WzBdLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbnNlcnRlZC5sZW5ndGggPCBpKVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICAgICAgICAgIGluc2VydGVkW2ldID0gVGV4dC5vZihwYXJ0LnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnRbMF0sIGluc2VydGVkW2ldLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZVNldChzZWN0aW9ucywgaW5zZXJ0ZWQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zLCBmb3JjZUpvaW4gPSBmYWxzZSkge1xuICAgIGlmIChsZW4gPT0gMCAmJiBpbnMgPD0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBsYXN0ID0gc2VjdGlvbnMubGVuZ3RoIC0gMjtcbiAgICBpZiAobGFzdCA+PSAwICYmIGlucyA8PSAwICYmIGlucyA9PSBzZWN0aW9uc1tsYXN0ICsgMV0pXG4gICAgICAgIHNlY3Rpb25zW2xhc3RdICs9IGxlbjtcbiAgICBlbHNlIGlmIChsYXN0ID49IDAgJiYgbGVuID09IDAgJiYgc2VjdGlvbnNbbGFzdF0gPT0gMClcbiAgICAgICAgc2VjdGlvbnNbbGFzdCArIDFdICs9IGlucztcbiAgICBlbHNlIGlmIChmb3JjZUpvaW4pIHtcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xuICAgICAgICBzZWN0aW9uc1tsYXN0ICsgMV0gKz0gaW5zO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHNlY3Rpb25zLnB1c2gobGVuLCBpbnMpO1xufVxuZnVuY3Rpb24gYWRkSW5zZXJ0KHZhbHVlcywgc2VjdGlvbnMsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGluZGV4ID0gKHNlY3Rpb25zLmxlbmd0aCAtIDIpID4+IDE7XG4gICAgaWYgKGluZGV4IDwgdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXS5hcHBlbmQodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2hpbGUgKHZhbHVlcy5sZW5ndGggPCBpbmRleClcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKFRleHQuZW1wdHkpO1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXRlckNoYW5nZXMoZGVzYywgZiwgaW5kaXZpZHVhbCkge1xuICAgIGxldCBpbnNlcnRlZCA9IGRlc2MuaW5zZXJ0ZWQ7XG4gICAgZm9yIChsZXQgcG9zQSA9IDAsIHBvc0IgPSAwLCBpID0gMDsgaSA8IGRlc2Muc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICBsZXQgbGVuID0gZGVzYy5zZWN0aW9uc1tpKytdLCBpbnMgPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcbiAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGVuZEEgPSBwb3NBLCBlbmRCID0gcG9zQiwgdGV4dCA9IFRleHQuZW1wdHk7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgZW5kQSArPSBsZW47XG4gICAgICAgICAgICAgICAgZW5kQiArPSBpbnM7XG4gICAgICAgICAgICAgICAgaWYgKGlucyAmJiBpbnNlcnRlZClcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuYXBwZW5kKGluc2VydGVkWyhpIC0gMikgPj4gMV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRpdmlkdWFsIHx8IGkgPT0gZGVzYy5zZWN0aW9ucy5sZW5ndGggfHwgZGVzYy5zZWN0aW9uc1tpICsgMV0gPCAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZW4gPSBkZXNjLnNlY3Rpb25zW2krK107XG4gICAgICAgICAgICAgICAgaW5zID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZihwb3NBLCBlbmRBLCBwb3NCLCBlbmRCLCB0ZXh0KTtcbiAgICAgICAgICAgIHBvc0EgPSBlbmRBO1xuICAgICAgICAgICAgcG9zQiA9IGVuZEI7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtYXBTZXQoc2V0QSwgc2V0QiwgYmVmb3JlLCBta1NldCA9IGZhbHNlKSB7XG4gICAgLy8gUHJvZHVjZSBhIGNvcHkgb2Ygc2V0QSB0aGF0IGFwcGxpZXMgdG8gdGhlIGRvY3VtZW50IGFmdGVyIHNldEJcbiAgICAvLyBoYXMgYmVlbiBhcHBsaWVkIChhc3N1bWluZyBib3RoIHN0YXJ0IGF0IHRoZSBzYW1lIGRvY3VtZW50KS5cbiAgICBsZXQgc2VjdGlvbnMgPSBbXSwgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGJvdGggc2V0cyBpbiBwYXJhbGxlbC4gaW5zZXJ0ZWQgdHJhY2tzLCBmb3IgY2hhbmdlc1xuICAgIC8vIGluIEEgdGhhdCBoYXZlIHRvIGJlIHByb2Nlc3NlZCBwaWVjZS1ieS1waWVjZSwgd2hldGhlciB0aGVpclxuICAgIC8vIGNvbnRlbnQgaGFzIGJlZW4gaW5zZXJ0ZWQgYWxyZWFkeSwgYW5kIHJlZmVycyB0byB0aGUgc2VjdGlvblxuICAgIC8vIGluZGV4LlxuICAgIGZvciAobGV0IGluc2VydGVkID0gLTE7Oykge1xuICAgICAgICBpZiAoYS5kb25lICYmIGIubGVuIHx8IGIuZG9uZSAmJiBhLmxlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5pbnMgPT0gLTEgJiYgYi5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE1vdmUgYWNyb3NzIHJhbmdlcyBza2lwcGVkIGJ5IGJvdGggc2V0cy5cbiAgICAgICAgICAgIGxldCBsZW4gPSBNYXRoLm1pbihhLmxlbiwgYi5sZW4pO1xuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICBhLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgIGIuZm9yd2FyZChsZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIuaW5zID49IDAgJiYgKGEuaW5zIDwgMCB8fCBpbnNlcnRlZCA9PSBhLmkgfHwgYS5vZmYgPT0gMCAmJiAoYi5sZW4gPCBhLmxlbiB8fCBiLmxlbiA9PSBhLmxlbiAmJiAhYmVmb3JlKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBjaGFuZ2UgaW4gQiB0aGF0IGNvbWVzIGJlZm9yZSB0aGUgbmV4dCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIEEgKG9yZGVyZWQgYnkgc3RhcnQgcG9zLCB0aGVuIGxlbiwgdGhlbiBiZWZvcmUgZmxhZyksIHNraXBcbiAgICAgICAgICAgIC8vIHRoYXQgKGFuZCBwcm9jZXNzIGFueSBjaGFuZ2VzIGluIEEgaXQgY292ZXJzKS5cbiAgICAgICAgICAgIGxldCBsZW4gPSBiLmxlbjtcbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGIuaW5zLCAtMSk7XG4gICAgICAgICAgICB3aGlsZSAobGVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBpZWNlID0gTWF0aC5taW4oYS5sZW4sIGxlbik7XG4gICAgICAgICAgICAgICAgaWYgKGEuaW5zID49IDAgJiYgaW5zZXJ0ZWQgPCBhLmkgJiYgYS5sZW4gPD0gcGllY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgMCwgYS5pbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkID0gYS5pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhLmZvcndhcmQocGllY2UpO1xuICAgICAgICAgICAgICAgIGxlbiAtPSBwaWVjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID49IDApIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHBhcnQgb2YgYSBjaGFuZ2UgaW4gQSB1cCB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHRcbiAgICAgICAgICAgIC8vIG5vbi1kZWxldGlvbiBjaGFuZ2UgaW4gQiAoaWYgb3ZlcmxhcHBpbmcpLlxuICAgICAgICAgICAgbGV0IGxlbiA9IDAsIGxlZnQgPSBhLmxlbjtcbiAgICAgICAgICAgIHdoaWxlIChsZWZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGIuaW5zID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwaWVjZSA9IE1hdGgubWluKGxlZnQsIGIubGVuKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuICs9IHBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IHBpZWNlO1xuICAgICAgICAgICAgICAgICAgICBiLmZvcndhcmQocGllY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAwICYmIGIubGVuIDwgbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IGIubGVuO1xuICAgICAgICAgICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGxlbiwgaW5zZXJ0ZWQgPCBhLmkgPyBhLmlucyA6IDApO1xuICAgICAgICAgICAgaWYgKGluc2VydCAmJiBpbnNlcnRlZCA8IGEuaSlcbiAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYS50ZXh0KTtcbiAgICAgICAgICAgIGluc2VydGVkID0gYS5pO1xuICAgICAgICAgICAgYS5mb3J3YXJkKGEubGVuIC0gbGVmdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kb25lICYmIGIuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydCA/IENoYW5nZVNldC5jcmVhdGVTZXQoc2VjdGlvbnMsIGluc2VydCkgOiBDaGFuZ2VEZXNjLmNyZWF0ZShzZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VTZXRzKHNldEEsIHNldEIsIG1rU2V0ID0gZmFsc2UpIHtcbiAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICBsZXQgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XG4gICAgZm9yIChsZXQgb3BlbiA9IGZhbHNlOzspIHtcbiAgICAgICAgaWYgKGEuZG9uZSAmJiBiLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBDaGFuZ2VTZXQuY3JlYXRlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogQ2hhbmdlRGVzYy5jcmVhdGUoc2VjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID09IDApIHsgLy8gRGVsZXRpb24gaW4gQVxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5sZW4sIDAsIG9wZW4pO1xuICAgICAgICAgICAgYS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5sZW4gPT0gMCAmJiAhYi5kb25lKSB7IC8vIEluc2VydGlvbiBpbiBCXG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCAwLCBiLmlucywgb3Blbik7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kb25lIHx8IGIuZG9uZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oYS5sZW4yLCBiLmxlbiksIHNlY3Rpb25MZW4gPSBzZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYS5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zQiA9IGIuaW5zID09IC0xID8gLTEgOiBiLm9mZiA/IDAgOiBiLmlucztcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGluc0IsIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgaW5zQilcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEub2ZmID8gMCA6IGEubGVuLCBsZW4sIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHRCaXQobGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLm9mZiA/IDAgOiBhLmxlbiwgYi5vZmYgPyAwIDogYi5pbnMsIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgIWIub2ZmKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wZW4gPSAoYS5pbnMgPiBsZW4gfHwgYi5pbnMgPj0gMCAmJiBiLmxlbiA+IGxlbikgJiYgKG9wZW4gfHwgc2VjdGlvbnMubGVuZ3RoID4gc2VjdGlvbkxlbik7XG4gICAgICAgICAgICBhLmZvcndhcmQyKGxlbik7XG4gICAgICAgICAgICBiLmZvcndhcmQobGVuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNlY3Rpb25JdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgeyBzZWN0aW9ucyB9ID0gdGhpcy5zZXQ7XG4gICAgICAgIGlmICh0aGlzLmkgPCBzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubGVuID0gc2VjdGlvbnNbdGhpcy5pKytdO1xuICAgICAgICAgICAgdGhpcy5pbnMgPSBzZWN0aW9uc1t0aGlzLmkrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbiA9IDA7XG4gICAgICAgICAgICB0aGlzLmlucyA9IC0yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2ZmID0gMDtcbiAgICB9XG4gICAgZ2V0IGRvbmUoKSB7IHJldHVybiB0aGlzLmlucyA9PSAtMjsgfVxuICAgIGdldCBsZW4yKCkgeyByZXR1cm4gdGhpcy5pbnMgPCAwID8gdGhpcy5sZW4gOiB0aGlzLmluczsgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggPyBUZXh0LmVtcHR5IDogaW5zZXJ0ZWRbaW5kZXhdO1xuICAgIH1cbiAgICB0ZXh0Qml0KGxlbikge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggJiYgIWxlbiA/IFRleHQuZW1wdHlcbiAgICAgICAgICAgIDogaW5zZXJ0ZWRbaW5kZXhdLnNsaWNlKHRoaXMub2ZmLCBsZW4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRoaXMub2ZmICsgbGVuKTtcbiAgICB9XG4gICAgZm9yd2FyZChsZW4pIHtcbiAgICAgICAgaWYgKGxlbiA9PSB0aGlzLmxlbilcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVuIC09IGxlbjtcbiAgICAgICAgICAgIHRoaXMub2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3J3YXJkMihsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zID09IC0xKVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PSB0aGlzLmlucylcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5zIC09IGxlbjtcbiAgICAgICAgICAgIHRoaXMub2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG5BIHNpbmdsZSBzZWxlY3Rpb24gcmFuZ2UuIFdoZW5cbltgYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKVxuaXMgZW5hYmxlZCwgYSBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbikgbWF5IGhvbGRcbm11bHRpcGxlIHJhbmdlcy4gQnkgZGVmYXVsdCwgc2VsZWN0aW9ucyBob2xkIGV4YWN0bHkgb25lIHJhbmdlLlxuKi9cbmNsYXNzIFNlbGVjdGlvblJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBmbGFncykge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGFuY2hvciBvZiB0aGUgcmFuZ2XigJR0aGUgc2lkZSB0aGF0IGRvZXNuJ3QgbW92ZSB3aGVuIHlvdVxuICAgIGV4dGVuZCBpdC5cbiAgICAqL1xuICAgIGdldCBhbmNob3IoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMzIgLyogUmFuZ2VGbGFnLkludmVydGVkICovID8gdGhpcy50byA6IHRoaXMuZnJvbTsgfVxuICAgIC8qKlxuICAgIFRoZSBoZWFkIG9mIHRoZSByYW5nZSwgd2hpY2ggaXMgbW92ZWQgd2hlbiB0aGUgcmFuZ2UgaXNcbiAgICBbZXh0ZW5kZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uUmFuZ2UuZXh0ZW5kKS5cbiAgICAqL1xuICAgIGdldCBoZWFkKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDMyIC8qIFJhbmdlRmxhZy5JbnZlcnRlZCAqLyA/IHRoaXMuZnJvbSA6IHRoaXMudG87IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gYGFuY2hvcmAgYW5kIGBoZWFkYCBhcmUgYXQgdGhlIHNhbWUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLmZyb20gPT0gdGhpcy50bzsgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSBjdXJzb3IgdGhhdCBpcyBleHBsaWNpdGx5IGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICBjaGFyYWN0ZXIgb24gb25lIG9mIGl0cyBzaWRlcywgdGhpcyByZXR1cm5zIHRoZSBzaWRlLiAtMSBtZWFuc1xuICAgIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIGl0cyBwb3NpdGlvbiwgMSB0aGUgY2hhcmFjdGVyIGFmdGVyLCBhbmQgMFxuICAgIG1lYW5zIG5vIGFzc29jaWF0aW9uLlxuICAgICovXG4gICAgZ2V0IGFzc29jKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDggLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovID8gLTEgOiB0aGlzLmZsYWdzICYgMTYgLyogUmFuZ2VGbGFnLkFzc29jQWZ0ZXIgKi8gPyAxIDogMDsgfVxuICAgIC8qKlxuICAgIFRoZSBiaWRpcmVjdGlvbmFsIHRleHQgbGV2ZWwgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY3Vyc29yLCBpZlxuICAgIGFueS5cbiAgICAqL1xuICAgIGdldCBiaWRpTGV2ZWwoKSB7XG4gICAgICAgIGxldCBsZXZlbCA9IHRoaXMuZmxhZ3MgJiA3IC8qIFJhbmdlRmxhZy5CaWRpTGV2ZWxNYXNrICovO1xuICAgICAgICByZXR1cm4gbGV2ZWwgPT0gNyA/IG51bGwgOiBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGdvYWwgY29sdW1uIChzdG9yZWQgdmVydGljYWwgb2Zmc2V0KSBhc3NvY2lhdGVkIHdpdGggYVxuICAgIGN1cnNvci4gVGhpcyBpcyB1c2VkIHRvIHByZXNlcnZlIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiB3aGVuXG4gICAgW21vdmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIGFjcm9zc1xuICAgIGxpbmVzIG9mIGRpZmZlcmVudCBsZW5ndGguXG4gICAgKi9cbiAgICBnZXQgZ29hbENvbHVtbigpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5mbGFncyA+PiA2IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovO1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gMTY3NzcyMTUgLyogUmFuZ2VGbGFnLk5vR29hbENvbHVtbiAqLyA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyByYW5nZSB0aHJvdWdoIGEgY2hhbmdlLCBwcm9kdWNpbmcgYSB2YWxpZCByYW5nZSBpbiB0aGVcbiAgICB1cGRhdGVkIGRvY3VtZW50LlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBsZXQgZnJvbSwgdG87XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KSB7XG4gICAgICAgICAgICBmcm9tID0gdG8gPSBjaGFuZ2UubWFwUG9zKHRoaXMuZnJvbSwgYXNzb2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IGNoYW5nZS5tYXBQb3ModGhpcy5mcm9tLCAxKTtcbiAgICAgICAgICAgIHRvID0gY2hhbmdlLm1hcFBvcyh0aGlzLnRvLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyb20gPT0gdGhpcy5mcm9tICYmIHRvID09IHRoaXMudG8gPyB0aGlzIDogbmV3IFNlbGVjdGlvblJhbmdlKGZyb20sIHRvLCB0aGlzLmZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0ZW5kIHRoaXMgcmFuZ2UgdG8gY292ZXIgYXQgbGVhc3QgYGZyb21gIHRvIGB0b2AuXG4gICAgKi9cbiAgICBleHRlbmQoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmIChmcm9tIDw9IHRoaXMuYW5jaG9yICYmIHRvID49IHRoaXMuYW5jaG9yKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgICAgIGxldCBoZWFkID0gTWF0aC5hYnMoZnJvbSAtIHRoaXMuYW5jaG9yKSA+IE1hdGguYWJzKHRvIC0gdGhpcy5hbmNob3IpID8gZnJvbSA6IHRvO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRoaXMuYW5jaG9yLCBoZWFkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHJhbmdlIHRvIGFub3RoZXIgcmFuZ2UuXG4gICAgKi9cbiAgICBlcShvdGhlciwgaW5jbHVkZUFzc29jID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yID09IG90aGVyLmFuY2hvciAmJiB0aGlzLmhlYWQgPT0gb3RoZXIuaGVhZCAmJlxuICAgICAgICAgICAgKCFpbmNsdWRlQXNzb2MgfHwgIXRoaXMuZW1wdHkgfHwgdGhpcy5hc3NvYyA9PSBvdGhlci5hc3NvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJhbmdlLlxuICAgICovXG4gICAgdG9KU09OKCkgeyByZXR1cm4geyBhbmNob3I6IHRoaXMuYW5jaG9yLCBoZWFkOiB0aGlzLmhlYWQgfTsgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgcmFuZ2UgdG8gYSBgU2VsZWN0aW9uUmFuZ2VgXG4gICAgaW5zdGFuY2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgdHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaGVhZCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIFNlbGVjdGlvblJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGpzb24uYW5jaG9yLCBqc29uLmhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZnJvbSwgdG8sIGZsYWdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uUmFuZ2UoZnJvbSwgdG8sIGZsYWdzKTtcbiAgICB9XG59XG4vKipcbkFuIGVkaXRvciBzZWxlY3Rpb24gaG9sZHMgb25lIG9yIG1vcmUgc2VsZWN0aW9uIHJhbmdlcy5cbiovXG5jbGFzcyBFZGl0b3JTZWxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByYW5nZXMgaW4gdGhlIHNlbGVjdGlvbiwgc29ydGVkIGJ5IHBvc2l0aW9uLiBSYW5nZXMgY2Fubm90XG4gICAgb3ZlcmxhcCAoYnV0IHRoZXkgbWF5IHRvdWNoLCBpZiB0aGV5IGFyZW4ndCBlbXB0eSkuXG4gICAgKi9cbiAgICByYW5nZXMsIFxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBvZiB0aGUgX21haW5fIHJhbmdlIGluIHRoZSBzZWxlY3Rpb24gKHdoaWNoIGlzXG4gICAgdXN1YWxseSB0aGUgcmFuZ2UgdGhhdCB3YXMgYWRkZWQgbGFzdCkuXG4gICAgKi9cbiAgICBtYWluSW5kZXgpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMubWFpbkluZGV4ID0gbWFpbkluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBzZWxlY3Rpb24gdGhyb3VnaCBhIGNoYW5nZS4gVXNlZCB0byBhZGp1c3QgdGhlIHNlbGVjdGlvblxuICAgIHBvc2l0aW9uIGZvciBjaGFuZ2VzLlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBpZiAoY2hhbmdlLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHRoaXMucmFuZ2VzLm1hcChyID0+IHIubWFwKGNoYW5nZSwgYXNzb2MpKSwgdGhpcy5tYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgc2VsZWN0aW9uIHRvIGFub3RoZXIgc2VsZWN0aW9uLiBCeSBkZWZhdWx0LCByYW5nZXNcbiAgICBhcmUgY29tcGFyZWQgb25seSBieSBwb3NpdGlvbi4gV2hlbiBgaW5jbHVkZUFzc29jYCBpcyB0cnVlLFxuICAgIGN1cnNvciByYW5nZXMgbXVzdCBhbHNvIGhhdmUgdGhlIHNhbWVcbiAgICBbYGFzc29jYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5hc3NvYykgdmFsdWUuXG4gICAgKi9cbiAgICBlcShvdGhlciwgaW5jbHVkZUFzc29jID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2VzLmxlbmd0aCAhPSBvdGhlci5yYW5nZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLm1haW5JbmRleCAhPSBvdGhlci5tYWluSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMucmFuZ2VzW2ldLmVxKG90aGVyLnJhbmdlc1tpXSwgaW5jbHVkZUFzc29jKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHByaW1hcnkgc2VsZWN0aW9uIHJhbmdlLiBVc3VhbGx5LCB5b3Ugc2hvdWxkIG1ha2Ugc3VyZVxuICAgIHlvdXIgY29kZSBhcHBsaWVzIHRvIF9hbGxfIHJhbmdlcywgYnkgdXNpbmcgbWV0aG9kcyBsaWtlXG4gICAgW2BjaGFuZ2VCeVJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFuZ2VCeVJhbmdlKS5cbiAgICAqL1xuICAgIGdldCBtYWluKCkgeyByZXR1cm4gdGhpcy5yYW5nZXNbdGhpcy5tYWluSW5kZXhdOyB9XG4gICAgLyoqXG4gICAgTWFrZSBzdXJlIHRoZSBzZWxlY3Rpb24gb25seSBoYXMgb25lIHJhbmdlLiBSZXR1cm5zIGEgc2VsZWN0aW9uXG4gICAgaG9sZGluZyBvbmx5IHRoZSBtYWluIHJhbmdlIGZyb20gdGhpcyBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBhc1NpbmdsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzLmxlbmd0aCA9PSAxID8gdGhpcyA6IG5ldyBFZGl0b3JTZWxlY3Rpb24oW3RoaXMubWFpbl0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRlbmQgdGhpcyBzZWxlY3Rpb24gd2l0aCBhbiBleHRyYSByYW5nZS5cbiAgICAqL1xuICAgIGFkZFJhbmdlKHJhbmdlLCBtYWluID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShbcmFuZ2VdLmNvbmNhdCh0aGlzLnJhbmdlcyksIG1haW4gPyAwIDogdGhpcy5tYWluSW5kZXggKyAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSBhIGdpdmVuIHJhbmdlIHdpdGggYW5vdGhlciByYW5nZSwgYW5kIHRoZW4gbm9ybWFsaXplIHRoZVxuICAgIHNlbGVjdGlvbiB0byBtZXJnZSBhbmQgc29ydCByYW5nZXMgaWYgbmVjZXNzYXJ5LlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlKHJhbmdlLCB3aGljaCA9IHRoaXMubWFpbkluZGV4KSB7XG4gICAgICAgIGxldCByYW5nZXMgPSB0aGlzLnJhbmdlcy5zbGljZSgpO1xuICAgICAgICByYW5nZXNbd2hpY2hdID0gcmFuZ2U7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgdGhpcy5tYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoaXMgc2VsZWN0aW9uIHRvIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBzZXJpYWxpemVkIHRvXG4gICAgSlNPTi5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2VzOiB0aGlzLnJhbmdlcy5tYXAociA9PiByLnRvSlNPTigpKSwgbWFpbjogdGhpcy5tYWluSW5kZXggfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIGZyb20gYSBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8ICFBcnJheS5pc0FycmF5KGpzb24ucmFuZ2VzKSB8fCB0eXBlb2YganNvbi5tYWluICE9IFwibnVtYmVyXCIgfHwganNvbi5tYWluID49IGpzb24ucmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBFZGl0b3JTZWxlY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKGpzb24ucmFuZ2VzLm1hcCgocikgPT4gU2VsZWN0aW9uUmFuZ2UuZnJvbUpTT04ocikpLCBqc29uLm1haW4pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gaG9sZGluZyBhIHNpbmdsZSByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyBzaW5nbGUoYW5jaG9yLCBoZWFkID0gYW5jaG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKFtFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoYW5jaG9yLCBoZWFkKV0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBTb3J0IGFuZCBtZXJnZSB0aGUgZ2l2ZW4gc2V0IG9mIHJhbmdlcywgY3JlYXRpbmcgYSB2YWxpZFxuICAgIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocmFuZ2VzLCBtYWluSW5kZXggPSAwKSB7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgc2VsZWN0aW9uIG5lZWRzIGF0IGxlYXN0IG9uZSByYW5nZVwiKTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSA/IHJhbmdlLmZyb20gPD0gcG9zIDogcmFuZ2UuZnJvbSA8IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLm5vcm1hbGl6ZWQocmFuZ2VzLnNsaWNlKCksIG1haW5JbmRleCk7XG4gICAgICAgICAgICBwb3MgPSByYW5nZS50bztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihyYW5nZXMsIG1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGN1cnNvciBzZWxlY3Rpb24gcmFuZ2UgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLiBZb3UgY2FuXG4gICAgc2FmZWx5IGlnbm9yZSB0aGUgb3B0aW9uYWwgYXJndW1lbnRzIGluIG1vc3Qgc2l0dWF0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBjdXJzb3IocG9zLCBhc3NvYyA9IDAsIGJpZGlMZXZlbCwgZ29hbENvbHVtbikge1xuICAgICAgICByZXR1cm4gU2VsZWN0aW9uUmFuZ2UuY3JlYXRlKHBvcywgcG9zLCAoYXNzb2MgPT0gMCA/IDAgOiBhc3NvYyA8IDAgPyA4IC8qIFJhbmdlRmxhZy5Bc3NvY0JlZm9yZSAqLyA6IDE2IC8qIFJhbmdlRmxhZy5Bc3NvY0FmdGVyICovKSB8XG4gICAgICAgICAgICAoYmlkaUxldmVsID09IG51bGwgPyA3IDogTWF0aC5taW4oNiwgYmlkaUxldmVsKSkgfFxuICAgICAgICAgICAgKChnb2FsQ29sdW1uICE9PSBudWxsICYmIGdvYWxDb2x1bW4gIT09IHZvaWQgMCA/IGdvYWxDb2x1bW4gOiAxNjc3NzIxNSAvKiBSYW5nZUZsYWcuTm9Hb2FsQ29sdW1uICovKSA8PCA2IC8qIFJhbmdlRmxhZy5Hb2FsQ29sdW1uT2Zmc2V0ICovKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiByYW5nZS5cbiAgICAqL1xuICAgIHN0YXRpYyByYW5nZShhbmNob3IsIGhlYWQsIGdvYWxDb2x1bW4sIGJpZGlMZXZlbCkge1xuICAgICAgICBsZXQgZmxhZ3MgPSAoKGdvYWxDb2x1bW4gIT09IG51bGwgJiYgZ29hbENvbHVtbiAhPT0gdm9pZCAwID8gZ29hbENvbHVtbiA6IDE2Nzc3MjE1IC8qIFJhbmdlRmxhZy5Ob0dvYWxDb2x1bW4gKi8pIDw8IDYgLyogUmFuZ2VGbGFnLkdvYWxDb2x1bW5PZmZzZXQgKi8pIHxcbiAgICAgICAgICAgIChiaWRpTGV2ZWwgPT0gbnVsbCA/IDcgOiBNYXRoLm1pbig2LCBiaWRpTGV2ZWwpKTtcbiAgICAgICAgcmV0dXJuIGhlYWQgPCBhbmNob3IgPyBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoaGVhZCwgYW5jaG9yLCAzMiAvKiBSYW5nZUZsYWcuSW52ZXJ0ZWQgKi8gfCAxNiAvKiBSYW5nZUZsYWcuQXNzb2NBZnRlciAqLyB8IGZsYWdzKVxuICAgICAgICAgICAgOiBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoYW5jaG9yLCBoZWFkLCAoaGVhZCA+IGFuY2hvciA/IDggLyogUmFuZ2VGbGFnLkFzc29jQmVmb3JlICovIDogMCkgfCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZWQocmFuZ2VzLCBtYWluSW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBtYWluID0gcmFuZ2VzW21haW5JbmRleF07XG4gICAgICAgIHJhbmdlcy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICBtYWluSW5kZXggPSByYW5nZXMuaW5kZXhPZihtYWluKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW1wdHkgPyByYW5nZS5mcm9tIDw9IHByZXYudG8gOiByYW5nZS5mcm9tIDwgcHJldi50bykge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gcHJldi5mcm9tLCB0byA9IE1hdGgubWF4KHJhbmdlLnRvLCBwcmV2LnRvKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBtYWluSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIG1haW5JbmRleC0tO1xuICAgICAgICAgICAgICAgIHJhbmdlcy5zcGxpY2UoLS1pLCAyLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHRvLCBmcm9tKSA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU2VsZWN0aW9uKHJhbmdlcywgbWFpbkluZGV4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvY0xlbmd0aCkge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHNlbGVjdGlvbi5yYW5nZXMpXG4gICAgICAgIGlmIChyYW5nZS50byA+IGRvY0xlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBvaW50cyBvdXRzaWRlIG9mIGRvY3VtZW50XCIpO1xufVxuXG5sZXQgbmV4dElEID0gMDtcbi8qKlxuQSBmYWNldCBpcyBhIGxhYmVsZWQgdmFsdWUgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggYW4gZWRpdG9yXG5zdGF0ZS4gSXQgdGFrZXMgaW5wdXRzIGZyb20gYW55IG51bWJlciBvZiBleHRlbnNpb25zLCBhbmQgY29tYmluZXNcbnRob3NlIGludG8gYSBzaW5nbGUgb3V0cHV0IHZhbHVlLlxuXG5FeGFtcGxlcyBvZiB1c2VzIG9mIGZhY2V0cyBhcmUgdGhlIFt0YWJcbnNpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSksIFtlZGl0b3JcbmF0dHJpYnV0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmVkaXRvckF0dHJpYnV0ZXMpLCBhbmQgW3VwZGF0ZVxubGlzdGVuZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld151cGRhdGVMaXN0ZW5lcikuXG5cbk5vdGUgdGhhdCBgRmFjZXRgIGluc3RhbmNlcyBjYW4gYmUgdXNlZCBhbnl3aGVyZSB3aGVyZVxuW2BGYWNldFJlYWRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXRSZWFkZXIpIGlzIGV4cGVjdGVkLlxuKi9cbmNsYXNzIEZhY2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbWJpbmUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZUlucHV0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhcmUsIGlzU3RhdGljLCBlbmFibGVzKSB7XG4gICAgICAgIHRoaXMuY29tYmluZSA9IGNvbWJpbmU7XG4gICAgICAgIHRoaXMuY29tcGFyZUlucHV0ID0gY29tcGFyZUlucHV0O1xuICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB0aGlzLmlzU3RhdGljID0gaXNTdGF0aWM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZCA9IG5leHRJRCsrO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBjb21iaW5lKFtdKTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gdHlwZW9mIGVuYWJsZXMgPT0gXCJmdW5jdGlvblwiID8gZW5hYmxlcyh0aGlzKSA6IGVuYWJsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSBmYWNldCByZWFkZXIgZm9yIHRoaXMgZmFjZXQsIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG4gICAgW3JlYWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuZmFjZXQpIGl0IGJ1dCBub3QgdG8gZGVmaW5lIHZhbHVlcyBmb3IgaXQuXG4gICAgKi9cbiAgICBnZXQgcmVhZGVyKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBmYWNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldChjb25maWcuY29tYmluZSB8fCAoKGEpID0+IGEpLCBjb25maWcuY29tcGFyZUlucHV0IHx8ICgoYSwgYikgPT4gYSA9PT0gYiksIGNvbmZpZy5jb21wYXJlIHx8ICghY29uZmlnLmNvbWJpbmUgPyBzYW1lQXJyYXkgOiAoYSwgYikgPT4gYSA9PT0gYiksICEhY29uZmlnLnN0YXRpYywgY29uZmlnLmVuYWJsZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgdGhlIGdpdmVuIHZhbHVlIHRvIHRoaXMgZmFjZXQuXG4gICAgKi9cbiAgICBvZih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoW10sIHRoaXMsIDAgLyogUHJvdmlkZXIuU3RhdGljICovLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb21wdXRlcyBhIHZhbHVlIGZvciB0aGUgZmFjZXQgZnJvbSBhXG4gICAgc3RhdGUuIFlvdSBtdXN0IHRha2UgY2FyZSB0byBkZWNsYXJlIHRoZSBwYXJ0cyBvZiB0aGUgc3RhdGUgdGhhdFxuICAgIHRoaXMgdmFsdWUgZGVwZW5kcyBvbiwgc2luY2UgeW91ciBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBhZ2FpblxuICAgIGZvciBhIG5ldyBzdGF0ZSB3aGVuIG9uZSBvZiB0aG9zZSBwYXJ0cyBjaGFuZ2VkLlxuICAgIFxuICAgIEluIGNhc2VzIHdoZXJlIHlvdXIgdmFsdWUgZGVwZW5kcyBvbmx5IG9uIGEgc2luZ2xlIGZpZWxkLCB5b3UnbGxcbiAgICB3YW50IHRvIHVzZSB0aGUgW2Bmcm9tYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldC5mcm9tKSBtZXRob2QgaW5zdGVhZC5cbiAgICAqL1xuICAgIGNvbXB1dGUoZGVwcywgZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKGRlcHMsIHRoaXMsIDEgLyogUHJvdmlkZXIuU2luZ2xlICovLCBnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29tcHV0ZXMgemVybyBvciBtb3JlIHZhbHVlcyBmb3IgdGhpc1xuICAgIGZhY2V0IGZyb20gYSBzdGF0ZS5cbiAgICAqL1xuICAgIGNvbXB1dGVOKGRlcHMsIGdldCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXRpYylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbXB1dGUgYSBzdGF0aWMgZmFjZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihkZXBzLCB0aGlzLCAyIC8qIFByb3ZpZGVyLk11bHRpICovLCBnZXQpO1xuICAgIH1cbiAgICBmcm9tKGZpZWxkLCBnZXQpIHtcbiAgICAgICAgaWYgKCFnZXQpXG4gICAgICAgICAgICBnZXQgPSB4ID0+IHg7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGUoW2ZpZWxkXSwgc3RhdGUgPT4gZ2V0KHN0YXRlLmZpZWxkKGZpZWxkKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVBcnJheShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiB8fCBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KChlLCBpKSA9PiBlID09PSBiW2ldKTtcbn1cbmNsYXNzIEZhY2V0UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlcGVuZGVuY2llcywgZmFjZXQsIHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICB0aGlzLmZhY2V0ID0gZmFjZXQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRJRCsrO1xuICAgIH1cbiAgICBkeW5hbWljU2xvdChhZGRyZXNzZXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZ2V0dGVyID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IGNvbXBhcmUgPSB0aGlzLmZhY2V0LmNvbXBhcmVJbnB1dDtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5pZCwgaWR4ID0gYWRkcmVzc2VzW2lkXSA+PiAxLCBtdWx0aSA9IHRoaXMudHlwZSA9PSAyIC8qIFByb3ZpZGVyLk11bHRpICovO1xuICAgICAgICBsZXQgZGVwRG9jID0gZmFsc2UsIGRlcFNlbCA9IGZhbHNlLCBkZXBBZGRycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBkZXAgb2YgdGhpcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGlmIChkZXAgPT0gXCJkb2NcIilcbiAgICAgICAgICAgICAgICBkZXBEb2MgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGVwID09IFwic2VsZWN0aW9uXCIpXG4gICAgICAgICAgICAgICAgZGVwU2VsID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCgoKF9hID0gYWRkcmVzc2VzW2RlcC5pZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpICYgMSkgPT0gMClcbiAgICAgICAgICAgICAgICBkZXBBZGRycy5wdXNoKGFkZHJlc3Nlc1tkZXAuaWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGUoc3RhdGUsIHRyKSB7XG4gICAgICAgICAgICAgICAgaWYgKChkZXBEb2MgJiYgdHIuZG9jQ2hhbmdlZCkgfHwgKGRlcFNlbCAmJiAodHIuZG9jQ2hhbmdlZCB8fCB0ci5zZWxlY3Rpb24pKSB8fCBlbnN1cmVBbGwoc3RhdGUsIGRlcEFkZHJzKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsID0gZ2V0dGVyKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpID8gIWNvbXBhcmVBcnJheShuZXdWYWwsIHN0YXRlLnZhbHVlc1tpZHhdLCBjb21wYXJlKSA6ICFjb21wYXJlKG5ld1ZhbCwgc3RhdGUudmFsdWVzW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWNvbmZpZ3VyZTogKHN0YXRlLCBvbGRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBuZXdWYWwsIG9sZEFkZHIgPSBvbGRTdGF0ZS5jb25maWcuYWRkcmVzc1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKG9sZEFkZHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb2xkVmFsID0gZ2V0QWRkcihvbGRTdGF0ZSwgb2xkQWRkcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlcGVuZGVuY2llcy5ldmVyeShkZXAgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcCBpbnN0YW5jZW9mIEZhY2V0ID8gb2xkU3RhdGUuZmFjZXQoZGVwKSA9PT0gc3RhdGUuZmFjZXQoZGVwKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwIGluc3RhbmNlb2YgU3RhdGVGaWVsZCA/IG9sZFN0YXRlLmZpZWxkKGRlcCwgZmFsc2UpID09IHN0YXRlLmZpZWxkKGRlcCwgZmFsc2UpIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSkgfHwgKG11bHRpID8gY29tcGFyZUFycmF5KG5ld1ZhbCA9IGdldHRlcihzdGF0ZSksIG9sZFZhbCwgY29tcGFyZSkgOiBjb21wYXJlKG5ld1ZhbCA9IGdldHRlcihzdGF0ZSksIG9sZFZhbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWwgPSBnZXR0ZXIoc3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMSAvKiBTbG90U3RhdHVzLkNoYW5nZWQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZUFycmF5KGEsIGIsIGNvbXBhcmUpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghY29tcGFyZShhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUFsbChzdGF0ZSwgYWRkcnMpIHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGFkZHIgb2YgYWRkcnMpXG4gICAgICAgIGlmIChlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKSAmIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovKVxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBkeW5hbWljRmFjZXRTbG90KGFkZHJlc3NlcywgZmFjZXQsIHByb3ZpZGVycykge1xuICAgIGxldCBwcm92aWRlckFkZHJzID0gcHJvdmlkZXJzLm1hcChwID0+IGFkZHJlc3Nlc1twLmlkXSk7XG4gICAgbGV0IHByb3ZpZGVyVHlwZXMgPSBwcm92aWRlcnMubWFwKHAgPT4gcC50eXBlKTtcbiAgICBsZXQgZHluYW1pYyA9IHByb3ZpZGVyQWRkcnMuZmlsdGVyKHAgPT4gIShwICYgMSkpO1xuICAgIGxldCBpZHggPSBhZGRyZXNzZXNbZmFjZXQuaWRdID4+IDE7XG4gICAgZnVuY3Rpb24gZ2V0KHN0YXRlKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm92aWRlckFkZHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRBZGRyKHN0YXRlLCBwcm92aWRlckFkZHJzW2ldKTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlclR5cGVzW2ldID09IDIgLyogUHJvdmlkZXIuTXVsdGkgKi8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdmFsIG9mIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFjZXQuY29tYmluZSh2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGFkZHIgb2YgcHJvdmlkZXJBZGRycylcbiAgICAgICAgICAgICAgICBlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKTtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlKHN0YXRlLCB0cikge1xuICAgICAgICAgICAgaWYgKCFlbnN1cmVBbGwoc3RhdGUsIGR5bmFtaWMpKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmYWNldC5jb21wYXJlKHZhbHVlLCBzdGF0ZS52YWx1ZXNbaWR4XSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICB9LFxuICAgICAgICByZWNvbmZpZ3VyZShzdGF0ZSwgb2xkU3RhdGUpIHtcbiAgICAgICAgICAgIGxldCBkZXBDaGFuZ2VkID0gZW5zdXJlQWxsKHN0YXRlLCBwcm92aWRlckFkZHJzKTtcbiAgICAgICAgICAgIGxldCBvbGRQcm92aWRlcnMgPSBvbGRTdGF0ZS5jb25maWcuZmFjZXRzW2ZhY2V0LmlkXSwgb2xkVmFsdWUgPSBvbGRTdGF0ZS5mYWNldChmYWNldCk7XG4gICAgICAgICAgICBpZiAob2xkUHJvdmlkZXJzICYmICFkZXBDaGFuZ2VkICYmIHNhbWVBcnJheShwcm92aWRlcnMsIG9sZFByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0KHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChmYWNldC5jb21wYXJlKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNsb3RTdGF0dXMuQ2hhbmdlZCAqLztcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBpbml0RmllbGQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgc3RhdGljOiB0cnVlIH0pO1xuLyoqXG5GaWVsZHMgY2FuIHN0b3JlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gaW4gYW4gZWRpdG9yIHN0YXRlLCBhbmRcbmtlZXAgaXQgaW4gc3luYyB3aXRoIHRoZSByZXN0IG9mIHRoZSBzdGF0ZS5cbiovXG5jbGFzcyBTdGF0ZUZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlkLCBjcmVhdGVGLCB1cGRhdGVGLCBjb21wYXJlRiwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5jcmVhdGVGID0gY3JlYXRlRjtcbiAgICAgICAgdGhpcy51cGRhdGVGID0gdXBkYXRlRjtcbiAgICAgICAgdGhpcy5jb21wYXJlRiA9IGNvbXBhcmVGO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucHJvdmlkZXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHN0YXRlIGZpZWxkLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShjb25maWcpIHtcbiAgICAgICAgbGV0IGZpZWxkID0gbmV3IFN0YXRlRmllbGQobmV4dElEKyssIGNvbmZpZy5jcmVhdGUsIGNvbmZpZy51cGRhdGUsIGNvbmZpZy5jb21wYXJlIHx8ICgoYSwgYikgPT4gYSA9PT0gYiksIGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcucHJvdmlkZSlcbiAgICAgICAgICAgIGZpZWxkLnByb3ZpZGVzID0gY29uZmlnLnByb3ZpZGUoZmllbGQpO1xuICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgfVxuICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICBsZXQgaW5pdCA9IHN0YXRlLmZhY2V0KGluaXRGaWVsZCkuZmluZChpID0+IGkuZmllbGQgPT0gdGhpcyk7XG4gICAgICAgIHJldHVybiAoKGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5jcmVhdGUpIHx8IHRoaXMuY3JlYXRlRikoc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNsb3QoYWRkcmVzc2VzKSB7XG4gICAgICAgIGxldCBpZHggPSBhZGRyZXNzZXNbdGhpcy5pZF0gPj4gMTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZTogKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogKHN0YXRlLCB0cikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBvbGRWYWwgPSBzdGF0ZS52YWx1ZXNbaWR4XTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLnVwZGF0ZUYob2xkVmFsLCB0cik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZUYob2xkVmFsLCB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlY29uZmlndXJlOiAoc3RhdGUsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGluaXQgPSBzdGF0ZS5mYWNldChpbml0RmllbGQpLCBvbGRJbml0ID0gb2xkU3RhdGUuZmFjZXQoaW5pdEZpZWxkKSwgcmVJbml0O1xuICAgICAgICAgICAgICAgIGlmICgocmVJbml0ID0gaW5pdC5maW5kKGkgPT4gaS5maWVsZCA9PSB0aGlzKSkgJiYgcmVJbml0ICE9IG9sZEluaXQuZmluZChpID0+IGkuZmllbGQgPT0gdGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSByZUluaXQuY3JlYXRlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob2xkU3RhdGUuY29uZmlnLmFkZHJlc3NbdGhpcy5pZF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG9sZFN0YXRlLmZpZWxkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogU2xvdFN0YXR1cy5DaGFuZ2VkICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgdGhpcyBmaWVsZCBhbmQgb3ZlcnJpZGVzIHRoZVxuICAgIHdheSBpdCBpcyBpbml0aWFsaXplZC4gQ2FuIGJlIHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIHByb3ZpZGUgYVxuICAgIG5vbi1kZWZhdWx0IHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgZmllbGQuXG4gICAgKi9cbiAgICBpbml0KGNyZWF0ZSkge1xuICAgICAgICByZXR1cm4gW3RoaXMsIGluaXRGaWVsZC5vZih7IGZpZWxkOiB0aGlzLCBjcmVhdGUgfSldO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGF0ZSBmaWVsZCBpbnN0YW5jZXMgY2FuIGJlIHVzZWQgYXNcbiAgICBbYEV4dGVuc2lvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRXh0ZW5zaW9uKSB2YWx1ZXMgdG8gZW5hYmxlIHRoZSBmaWVsZCBpbiBhXG4gICAgZ2l2ZW4gc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgZXh0ZW5zaW9uKCkgeyByZXR1cm4gdGhpczsgfVxufVxuY29uc3QgUHJlY18gPSB7IGxvd2VzdDogNCwgbG93OiAzLCBkZWZhdWx0OiAyLCBoaWdoOiAxLCBoaWdoZXN0OiAwIH07XG5mdW5jdGlvbiBwcmVjKHZhbHVlKSB7XG4gICAgcmV0dXJuIChleHQpID0+IG5ldyBQcmVjRXh0ZW5zaW9uKGV4dCwgdmFsdWUpO1xufVxuLyoqXG5CeSBkZWZhdWx0IGV4dGVuc2lvbnMgYXJlIHJlZ2lzdGVyZWQgaW4gdGhlIG9yZGVyIHRoZXkgYXJlIGZvdW5kXG5pbiB0aGUgZmxhdHRlbmVkIGZvcm0gb2YgbmVzdGVkIGFycmF5IHRoYXQgd2FzIHByb3ZpZGVkLlxuSW5kaXZpZHVhbCBleHRlbnNpb24gdmFsdWVzIGNhbiBiZSBhc3NpZ25lZCBhIHByZWNlZGVuY2UgdG9cbm92ZXJyaWRlIHRoaXMuIEV4dGVuc2lvbnMgdGhhdCBkbyBub3QgaGF2ZSBhIHByZWNlZGVuY2Ugc2V0IGdldFxudGhlIHByZWNlZGVuY2Ugb2YgdGhlIG5lYXJlc3QgcGFyZW50IHdpdGggYSBwcmVjZWRlbmNlLCBvclxuW2BkZWZhdWx0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5QcmVjLmRlZmF1bHQpIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcGFyZW50LiBUaGVcbmZpbmFsIG9yZGVyaW5nIG9mIGV4dGVuc2lvbnMgaXMgZGV0ZXJtaW5lZCBieSBmaXJzdCBzb3J0aW5nIGJ5XG5wcmVjZWRlbmNlIGFuZCB0aGVuIGJ5IG9yZGVyIHdpdGhpbiBlYWNoIHByZWNlZGVuY2UuXG4qL1xuY29uc3QgUHJlYyA9IHtcbiAgICAvKipcbiAgICBUaGUgaGlnaGVzdCBwcmVjZWRlbmNlIGxldmVsLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZCBlbmQgdXBcbiAgICBuZWFyIHRoZSBzdGFydCBvZiB0aGUgcHJlY2VkZW5jZSBvcmRlcmluZy5cbiAgICAqL1xuICAgIGhpZ2hlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmhpZ2hlc3QpLFxuICAgIC8qKlxuICAgIEEgaGlnaGVyLXRoYW4tZGVmYXVsdCBwcmVjZWRlbmNlLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZFxuICAgIGNvbWUgYmVmb3JlIHRob3NlIHdpdGggZGVmYXVsdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgaGlnaDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uaGlnaCksXG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgcHJlY2VkZW5jZSwgd2hpY2ggaXMgYWxzbyB1c2VkIGZvciBleHRlbnNpb25zXG4gICAgd2l0aG91dCBhbiBleHBsaWNpdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgZGVmYXVsdDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uZGVmYXVsdCksXG4gICAgLyoqXG4gICAgQSBsb3dlci10aGFuLWRlZmF1bHQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGxvdzogLypAX19QVVJFX18qL3ByZWMoUHJlY18ubG93KSxcbiAgICAvKipcbiAgICBUaGUgbG93ZXN0IHByZWNlZGVuY2UgbGV2ZWwuIE1lYW50IGZvciB0aGluZ3MgdGhhdCBzaG91bGQgZW5kIHVwXG4gICAgbmVhciB0aGUgZW5kIG9mIHRoZSBleHRlbnNpb24gb3JkZXIuXG4gICAgKi9cbiAgICBsb3dlc3Q6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmxvd2VzdClcbn07XG5jbGFzcyBQcmVjRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihpbm5lciwgcHJlYykge1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgICAgIHRoaXMucHJlYyA9IHByZWM7XG4gICAgfVxufVxuLyoqXG5FeHRlbnNpb24gY29tcGFydG1lbnRzIGNhbiBiZSB1c2VkIHRvIG1ha2UgYSBjb25maWd1cmF0aW9uXG5keW5hbWljLiBCeSBbd3JhcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQub2YpIHBhcnQgb2YgeW91clxuY29uZmlndXJhdGlvbiBpbiBhIGNvbXBhcnRtZW50LCB5b3UgY2FuIGxhdGVyXG5bcmVwbGFjZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSkgdGhhdCBwYXJ0IHRocm91Z2ggYVxudHJhbnNhY3Rpb24uXG4qL1xuY2xhc3MgQ29tcGFydG1lbnQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNvbXBhcnRtZW50IHRvIGFkZCB0byB5b3VyIFtzdGF0ZVxuICAgIGNvbmZpZ3VyYXRpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVDb25maWcuZXh0ZW5zaW9ucykuXG4gICAgKi9cbiAgICBvZihleHQpIHsgcmV0dXJuIG5ldyBDb21wYXJ0bWVudEluc3RhbmNlKHRoaXMsIGV4dCk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gW2VmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgdGhhdFxuICAgIHJlY29uZmlndXJlcyB0aGlzIGNvbXBhcnRtZW50LlxuICAgICovXG4gICAgcmVjb25maWd1cmUoY29udGVudCkge1xuICAgICAgICByZXR1cm4gQ29tcGFydG1lbnQucmVjb25maWd1cmUub2YoeyBjb21wYXJ0bWVudDogdGhpcywgZXh0ZW5zaW9uOiBjb250ZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgY29tcGFydG1lbnQgaW4gdGhlIHN0YXRlLCBvclxuICAgIGB1bmRlZmluZWRgIGlmIGl0IGlzbid0IHByZXNlbnQuXG4gICAgKi9cbiAgICBnZXQoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbmZpZy5jb21wYXJ0bWVudHMuZ2V0KHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIENvbXBhcnRtZW50SW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBhcnRtZW50LCBpbm5lcikge1xuICAgICAgICB0aGlzLmNvbXBhcnRtZW50ID0gY29tcGFydG1lbnQ7XG4gICAgICAgIHRoaXMuaW5uZXIgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlLCBjb21wYXJ0bWVudHMsIGR5bmFtaWNTbG90cywgYWRkcmVzcywgc3RhdGljVmFsdWVzLCBmYWNldHMpIHtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudHMgPSBjb21wYXJ0bWVudHM7XG4gICAgICAgIHRoaXMuZHluYW1pY1Nsb3RzID0gZHluYW1pY1Nsb3RzO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLnN0YXRpY1ZhbHVlcyA9IHN0YXRpY1ZhbHVlcztcbiAgICAgICAgdGhpcy5mYWNldHMgPSBmYWNldHM7XG4gICAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhdHVzVGVtcGxhdGUubGVuZ3RoIDwgZHluYW1pY1Nsb3RzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUucHVzaCgwIC8qIFNsb3RTdGF0dXMuVW5yZXNvbHZlZCAqLyk7XG4gICAgfVxuICAgIHN0YXRpY0ZhY2V0KGZhY2V0KSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5hZGRyZXNzW2ZhY2V0LmlkXTtcbiAgICAgICAgcmV0dXJuIGFkZHIgPT0gbnVsbCA/IGZhY2V0LmRlZmF1bHQgOiB0aGlzLnN0YXRpY1ZhbHVlc1thZGRyID4+IDFdO1xuICAgIH1cbiAgICBzdGF0aWMgcmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIG9sZFN0YXRlKSB7XG4gICAgICAgIGxldCBmaWVsZHMgPSBbXTtcbiAgICAgICAgbGV0IGZhY2V0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBuZXdDb21wYXJ0bWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGV4dCBvZiBmbGF0dGVuKGJhc2UsIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSkge1xuICAgICAgICAgICAgaWYgKGV4dCBpbnN0YW5jZW9mIFN0YXRlRmllbGQpXG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAoZmFjZXRzW2V4dC5mYWNldC5pZF0gfHwgKGZhY2V0c1tleHQuZmFjZXQuaWRdID0gW10pKS5wdXNoKGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFkZHJlc3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgc3RhdGljVmFsdWVzID0gW107XG4gICAgICAgIGxldCBkeW5hbWljU2xvdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBhZGRyZXNzW2ZpZWxkLmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gZmllbGQuc2xvdChhKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9sZEZhY2V0cyA9IG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5jb25maWcuZmFjZXRzO1xuICAgICAgICBmb3IgKGxldCBpZCBpbiBmYWNldHMpIHtcbiAgICAgICAgICAgIGxldCBwcm92aWRlcnMgPSBmYWNldHNbaWRdLCBmYWNldCA9IHByb3ZpZGVyc1swXS5mYWNldDtcbiAgICAgICAgICAgIGxldCBvbGRQcm92aWRlcnMgPSBvbGRGYWNldHMgJiYgb2xkRmFjZXRzW2lkXSB8fCBbXTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlcnMuZXZlcnkocCA9PiBwLnR5cGUgPT0gMCAvKiBQcm92aWRlci5TdGF0aWMgKi8pKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1tmYWNldC5pZF0gPSAoc3RhdGljVmFsdWVzLmxlbmd0aCA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgaWYgKHNhbWVBcnJheShvbGRQcm92aWRlcnMsIHByb3ZpZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gob2xkU3RhdGUuZmFjZXQoZmFjZXQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGZhY2V0LmNvbWJpbmUocHJvdmlkZXJzLm1hcChwID0+IHAudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gob2xkU3RhdGUgJiYgZmFjZXQuY29tcGFyZSh2YWx1ZSwgb2xkU3RhdGUuZmFjZXQoZmFjZXQpKSA/IG9sZFN0YXRlLmZhY2V0KGZhY2V0KSA6IHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIG9mIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09IDAgLyogUHJvdmlkZXIuU3RhdGljICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gocC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBwLmR5bmFtaWNTbG90KGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRyZXNzW2ZhY2V0LmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgICAgICBkeW5hbWljU2xvdHMucHVzaChhID0+IGR5bmFtaWNGYWNldFNsb3QoYSwgZmFjZXQsIHByb3ZpZGVycykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkeW5hbWljID0gZHluYW1pY1Nsb3RzLm1hcChmID0+IGYoYWRkcmVzcykpO1xuICAgICAgICByZXR1cm4gbmV3IENvbmZpZ3VyYXRpb24oYmFzZSwgbmV3Q29tcGFydG1lbnRzLCBkeW5hbWljLCBhZGRyZXNzLCBzdGF0aWNWYWx1ZXMsIGZhY2V0cyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmxhdHRlbihleHRlbnNpb24sIGNvbXBhcnRtZW50cywgbmV3Q29tcGFydG1lbnRzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtbXSwgW10sIFtdLCBbXSwgW11dO1xuICAgIGxldCBzZWVuID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGlubmVyKGV4dCwgcHJlYykge1xuICAgICAgICBsZXQga25vd24gPSBzZWVuLmdldChleHQpO1xuICAgICAgICBpZiAoa25vd24gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGtub3duIDw9IHByZWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gcmVzdWx0W2tub3duXS5pbmRleE9mKGV4dCk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSlcbiAgICAgICAgICAgICAgICByZXN1bHRba25vd25dLnNwbGljZShmb3VuZCwgMSk7XG4gICAgICAgICAgICBpZiAoZXh0IGluc3RhbmNlb2YgQ29tcGFydG1lbnRJbnN0YW5jZSlcbiAgICAgICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuZGVsZXRlKGV4dC5jb21wYXJ0bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5zZXQoZXh0LCBwcmVjKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXh0KSkge1xuICAgICAgICAgICAgZm9yIChsZXQgZSBvZiBleHQpXG4gICAgICAgICAgICAgICAgaW5uZXIoZSwgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgQ29tcGFydG1lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKG5ld0NvbXBhcnRtZW50cy5oYXMoZXh0LmNvbXBhcnRtZW50KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRHVwbGljYXRlIHVzZSBvZiBjb21wYXJ0bWVudCBpbiBleHRlbnNpb25zYCk7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGNvbXBhcnRtZW50cy5nZXQoZXh0LmNvbXBhcnRtZW50KSB8fCBleHQuaW5uZXI7XG4gICAgICAgICAgICBuZXdDb21wYXJ0bWVudHMuc2V0KGV4dC5jb21wYXJ0bWVudCwgY29udGVudCk7XG4gICAgICAgICAgICBpbm5lcihjb250ZW50LCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBQcmVjRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBpbm5lcihleHQuaW5uZXIsIGV4dC5wcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkKSB7XG4gICAgICAgICAgICByZXN1bHRbcHJlY10ucHVzaChleHQpO1xuICAgICAgICAgICAgaWYgKGV4dC5wcm92aWRlcylcbiAgICAgICAgICAgICAgICBpbm5lcihleHQucHJvdmlkZXMsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIEZhY2V0UHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVjXS5wdXNoKGV4dCk7XG4gICAgICAgICAgICBpZiAoZXh0LmZhY2V0LmV4dGVuc2lvbnMpXG4gICAgICAgICAgICAgICAgaW5uZXIoZXh0LmZhY2V0LmV4dGVuc2lvbnMsIFByZWNfLmRlZmF1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBleHQuZXh0ZW5zaW9uO1xuICAgICAgICAgICAgaWYgKCFjb250ZW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGV4dGVuc2lvbiB2YWx1ZSBpbiBleHRlbnNpb24gc2V0ICgke2V4dH0pLiBUaGlzIHNvbWV0aW1lcyBoYXBwZW5zIGJlY2F1c2UgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIEBjb2RlbWlycm9yL3N0YXRlIGFyZSBsb2FkZWQsIGJyZWFraW5nIGluc3RhbmNlb2YgY2hlY2tzLmApO1xuICAgICAgICAgICAgaW5uZXIoY29udGVudCwgcHJlYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5uZXIoZXh0ZW5zaW9uLCBQcmVjXy5kZWZhdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpO1xufVxuZnVuY3Rpb24gZW5zdXJlQWRkcihzdGF0ZSwgYWRkcikge1xuICAgIGlmIChhZGRyICYgMSlcbiAgICAgICAgcmV0dXJuIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLztcbiAgICBsZXQgaWR4ID0gYWRkciA+PiAxO1xuICAgIGxldCBzdGF0dXMgPSBzdGF0ZS5zdGF0dXNbaWR4XTtcbiAgICBpZiAoc3RhdHVzID09IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN5Y2xpYyBkZXBlbmRlbmN5IGJldHdlZW4gZmllbGRzIGFuZC9vciBmYWNldHNcIik7XG4gICAgaWYgKHN0YXR1cyAmIDIgLyogU2xvdFN0YXR1cy5Db21wdXRlZCAqLylcbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICBzdGF0ZS5zdGF0dXNbaWR4XSA9IDQgLyogU2xvdFN0YXR1cy5Db21wdXRpbmcgKi87XG4gICAgbGV0IGNoYW5nZWQgPSBzdGF0ZS5jb21wdXRlU2xvdChzdGF0ZSwgc3RhdGUuY29uZmlnLmR5bmFtaWNTbG90c1tpZHhdKTtcbiAgICByZXR1cm4gc3RhdGUuc3RhdHVzW2lkeF0gPSAyIC8qIFNsb3RTdGF0dXMuQ29tcHV0ZWQgKi8gfCBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZ2V0QWRkcihzdGF0ZSwgYWRkcikge1xuICAgIHJldHVybiBhZGRyICYgMSA/IHN0YXRlLmNvbmZpZy5zdGF0aWNWYWx1ZXNbYWRkciA+PiAxXSA6IHN0YXRlLnZhbHVlc1thZGRyID4+IDFdO1xufVxuXG5jb25zdCBsYW5ndWFnZURhdGEgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBhbGxvd011bHRpcGxlU2VsZWN0aW9ucyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMuc29tZSh2ID0+IHYpLFxuICAgIHN0YXRpYzogdHJ1ZVxufSk7XG5jb25zdCBsaW5lU2VwYXJhdG9yID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB1bmRlZmluZWQsXG4gICAgc3RhdGljOiB0cnVlXG59KTtcbmNvbnN0IGNoYW5nZUZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRmlsdGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgdHJhbnNhY3Rpb25FeHRlbmRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHJlYWRPbmx5ID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiBmYWxzZVxufSk7XG5cbi8qKlxuQW5ub3RhdGlvbnMgYXJlIHRhZ2dlZCB2YWx1ZXMgdGhhdCBhcmUgdXNlZCB0byBhZGQgbWV0YWRhdGEgdG9cbnRyYW5zYWN0aW9ucyBpbiBhbiBleHRlbnNpYmxlIHdheS4gVGhleSBzaG91bGQgYmUgdXNlZCB0byBtb2RlbFxudGhpbmdzIHRoYXQgZWZmZWN0IHRoZSBlbnRpcmUgdHJhbnNhY3Rpb24gKHN1Y2ggYXMgaXRzIFt0aW1lXG5zdGFtcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl50aW1lKSBvciBpbmZvcm1hdGlvbiBhYm91dCBpdHNcbltvcmlnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSkuIEZvciBlZmZlY3RzIHRoYXQgaGFwcGVuXG5fYWxvbmdzaWRlXyB0aGUgb3RoZXIgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbiwgW3N0YXRlXG5lZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0KSBhcmUgbW9yZSBhcHByb3ByaWF0ZS5cbiovXG5jbGFzcyBBbm5vdGF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBhbm5vdGF0aW9uIHR5cGUuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBUaGUgdmFsdWUgb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgdHlwZSBvZiBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZSgpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uVHlwZSgpOyB9XG59XG4vKipcbk1hcmtlciB0aGF0IGlkZW50aWZpZXMgYSB0eXBlIG9mIFthbm5vdGF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkFubm90YXRpb24pLlxuKi9cbmNsYXNzIEFubm90YXRpb25UeXBlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBBbm5vdGF0aW9uKHRoaXMsIHZhbHVlKTsgfVxufVxuLyoqXG5SZXByZXNlbnRhdGlvbiBvZiBhIHR5cGUgb2Ygc3RhdGUgZWZmZWN0LiBEZWZpbmVkIHdpdGhcbltgU3RhdGVFZmZlY3QuZGVmaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5kZWZpbmUpLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0VHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgYGFueWAgdHlwZXMgaW4gdGhlc2UgZnVuY3Rpb24gdHlwZXMgYXJlIHRoZXJlIHRvIHdvcmtcbiAgICAvLyBhcm91bmQgVHlwZVNjcmlwdCBpc3N1ZSAjMzc2MzEsIHdoZXJlIHRoZSB0eXBlIGd1YXJkIG9uXG4gICAgLy8gYFN0YXRlRWZmZWN0LmlzYCBteXN0ZXJpb3VzbHkgc3RvcHMgd29ya2luZyB3aGVuIHRoZXNlIHByb3Blcmx5XG4gICAgLy8gaGF2ZSB0eXBlIGBWYWx1ZWAuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtzdGF0ZSBlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QpIGluc3RhbmNlIG9mIHRoaXNcbiAgICB0eXBlLlxuICAgICovXG4gICAgb2YodmFsdWUpIHsgcmV0dXJuIG5ldyBTdGF0ZUVmZmVjdCh0aGlzLCB2YWx1ZSk7IH1cbn1cbi8qKlxuU3RhdGUgZWZmZWN0cyBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYWRkaXRpb25hbCBlZmZlY3RzXG5hc3NvY2lhdGVkIHdpdGggYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uZWZmZWN0cykuIFRoZXlcbmFyZSBvZnRlbiB1c2VmdWwgdG8gbW9kZWwgY2hhbmdlcyB0byBjdXN0b20gW3N0YXRlXG5maWVsZHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZCksIHdoZW4gdGhvc2UgY2hhbmdlcyBhcmVuJ3QgaW1wbGljaXQgaW5cbmRvY3VtZW50IG9yIHNlbGVjdGlvbiBjaGFuZ2VzLlxuKi9cbmNsYXNzIFN0YXRlRWZmZWN0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIG9mIHRoaXMgZWZmZWN0LlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyBlZmZlY3QgdGhyb3VnaCBhIHBvc2l0aW9uIG1hcHBpbmcuIFdpbGwgcmV0dXJuXG4gICAgYHVuZGVmaW5lZGAgd2hlbiB0aGF0IGVuZHMgdXAgZGVsZXRpbmcgdGhlIGVmZmVjdC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBtYXBwZWQgPSB0aGlzLnR5cGUubWFwKHRoaXMudmFsdWUsIG1hcHBpbmcpO1xuICAgICAgICByZXR1cm4gbWFwcGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtYXBwZWQgPT0gdGhpcy52YWx1ZSA/IHRoaXMgOiBuZXcgU3RhdGVFZmZlY3QodGhpcy50eXBlLCBtYXBwZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGlzIGVmZmVjdCBvYmplY3QgaXMgb2YgYSBnaXZlblxuICAgIFt0eXBlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0VHlwZSkuXG4gICAgKi9cbiAgICBpcyh0eXBlKSB7IHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZTsgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBlZmZlY3QgdHlwZS4gVGhlIHR5cGUgcGFyYW1ldGVyIGluZGljYXRlcyB0aGUgdHlwZVxuICAgIG9mIHZhbHVlcyB0aGF0IGhpcyBlZmZlY3QgaG9sZHMuIEl0IHNob3VsZCBiZSBhIHR5cGUgdGhhdFxuICAgIGRvZXNuJ3QgaW5jbHVkZSBgdW5kZWZpbmVkYCwgc2luY2UgdGhhdCBpcyB1c2VkIGluXG4gICAgW21hcHBpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QubWFwKSB0byBpbmRpY2F0ZSB0aGF0IGFuIGVmZmVjdCBpc1xuICAgIHJlbW92ZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRlRWZmZWN0VHlwZShzcGVjLm1hcCB8fCAodiA9PiB2KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhbiBhcnJheSBvZiBlZmZlY3RzIHRocm91Z2ggYSBjaGFuZ2Ugc2V0LlxuICAgICovXG4gICAgc3RhdGljIG1hcEVmZmVjdHMoZWZmZWN0cywgbWFwcGluZykge1xuICAgICAgICBpZiAoIWVmZmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgICAgIGxldCBtYXBwZWQgPSBlZmZlY3QubWFwKG1hcHBpbmcpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtYXBwZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGlzIGVmZmVjdCBjYW4gYmUgdXNlZCB0byByZWNvbmZpZ3VyZSB0aGUgcm9vdCBleHRlbnNpb25zIG9mXG50aGUgZWRpdG9yLiBEb2luZyB0aGlzIHdpbGwgZGlzY2FyZCBhbnkgZXh0ZW5zaW9uc1xuW2FwcGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0XmFwcGVuZENvbmZpZyksIGJ1dCBkb2VzIG5vdCByZXNldFxudGhlIGNvbnRlbnQgb2YgW3JlY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSlcbmNvbXBhcnRtZW50cy5cbiovXG5TdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuQXBwZW5kIGV4dGVuc2lvbnMgdG8gdGhlIHRvcC1sZXZlbCBjb25maWd1cmF0aW9uIG9mIHRoZSBlZGl0b3IuXG4qL1xuU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5DaGFuZ2VzIHRvIHRoZSBlZGl0b3Igc3RhdGUgYXJlIGdyb3VwZWQgaW50byB0cmFuc2FjdGlvbnMuXG5UeXBpY2FsbHksIGEgdXNlciBhY3Rpb24gY3JlYXRlcyBhIHNpbmdsZSB0cmFuc2FjdGlvbiwgd2hpY2ggbWF5XG5jb250YWluIGFueSBudW1iZXIgb2YgZG9jdW1lbnQgY2hhbmdlcywgbWF5IGNoYW5nZSB0aGUgc2VsZWN0aW9uLFxub3IgaGF2ZSBvdGhlciBlZmZlY3RzLiBDcmVhdGUgYSB0cmFuc2FjdGlvbiBieSBjYWxsaW5nXG5bYEVkaXRvclN0YXRlLnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSwgb3IgaW1tZWRpYXRlbHlcbmRpc3BhdGNoIG9uZSBieSBjYWxsaW5nXG5bYEVkaXRvclZpZXcuZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkuXG4qL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGF0ZSBmcm9tIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiBzdGFydHMuXG4gICAgKi9cbiAgICBzdGFydFN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgZG9jdW1lbnQgY2hhbmdlcyBtYWRlIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBjaGFuZ2VzLCBcbiAgICAvKipcbiAgICBUaGUgc2VsZWN0aW9uIHNldCBieSB0aGlzIHRyYW5zYWN0aW9uLCBvciB1bmRlZmluZWQgaWYgaXRcbiAgICBkb2Vzbid0IGV4cGxpY2l0bHkgc2V0IGEgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvKipcbiAgICBUaGUgZWZmZWN0cyBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBlZmZlY3RzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFubm90YXRpb25zLCBcbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIHNjcm9sbGVkIGludG8gdmlldyBhZnRlciB0aGlzXG4gICAgdHJhbnNhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cbiAgICAqL1xuICAgIHNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHN0YXJ0U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25zID0gYW5ub3RhdGlvbnM7XG4gICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcgPSBzY3JvbGxJbnRvVmlldztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kb2MgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgY2hhbmdlcy5uZXdMZW5ndGgpO1xuICAgICAgICBpZiAoIWFubm90YXRpb25zLnNvbWUoKGEpID0+IGEudHlwZSA9PSBUcmFuc2FjdGlvbi50aW1lKSlcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucy5jb25jYXQoVHJhbnNhY3Rpb24udGltZS5vZihEYXRlLm5vdygpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShzdGFydFN0YXRlLCBjaGFuZ2VzLCBzZWxlY3Rpb24sIGVmZmVjdHMsIGFubm90YXRpb25zLCBzY3JvbGxJbnRvVmlldykge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKHN0YXJ0U3RhdGUsIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cywgYW5ub3RhdGlvbnMsIHNjcm9sbEludG9WaWV3KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb24uIENvbnRyYXJ5IHRvXG4gICAgW2Auc3RhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnN0YXRlKWAuZG9jYCwgYWNjZXNzaW5nIHRoaXMgd29uJ3RcbiAgICBmb3JjZSB0aGUgZW50aXJlIG5ldyBzdGF0ZSB0byBiZSBjb21wdXRlZCByaWdodCBhd2F5LCBzbyBpdCBpc1xuICAgIHJlY29tbWVuZGVkIHRoYXQgW3RyYW5zYWN0aW9uXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgdXNlIHRoaXMgZ2V0dGVyXG4gICAgd2hlbiB0aGV5IG5lZWQgdG8gbG9vayBhdCB0aGUgbmV3IGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IG5ld0RvYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvYyB8fCAodGhpcy5fZG9jID0gdGhpcy5jaGFuZ2VzLmFwcGx5KHRoaXMuc3RhcnRTdGF0ZS5kb2MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBzZWxlY3Rpb24gcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBJZlxuICAgIFtgdGhpcy5zZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNlbGVjdGlvbikgaXMgdW5kZWZpbmVkLFxuICAgIHRoaXMgd2lsbCBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbi5tYXApIHRoZSBzdGFydCBzdGF0ZSdzXG4gICAgY3VycmVudCBzZWxlY3Rpb24gdGhyb3VnaCB0aGUgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGdldCBuZXdTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbiB8fCB0aGlzLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1hcCh0aGlzLmNoYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IHN0YXRlIGNyZWF0ZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBDb21wdXRlZCBvbiBkZW1hbmRcbiAgICAoYnV0IHJldGFpbmVkIGZvciBzdWJzZXF1ZW50IGFjY2VzcyksIHNvIGl0IGlzIHJlY29tbWVuZGVkIG5vdCB0b1xuICAgIGFjY2VzcyBpdCBpbiBbdHJhbnNhY3Rpb25cbiAgICBmaWx0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSB3aGVuIHBvc3NpYmxlLlxuICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlKVxuICAgICAgICAgICAgdGhpcy5zdGFydFN0YXRlLmFwcGx5VHJhbnNhY3Rpb24odGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYW5ub3RhdGlvbiB0eXBlLCBpZiBhbnkuXG4gICAgKi9cbiAgICBhbm5vdGF0aW9uKHR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgYW5uIG9mIHRoaXMuYW5ub3RhdGlvbnMpXG4gICAgICAgICAgICBpZiAoYW5uLnR5cGUgPT0gdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5uLnZhbHVlO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdHJhbnNhY3Rpb24gY2hhbmdlZCB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHsgcmV0dXJuICF0aGlzLmNoYW5nZXMuZW1wdHk7IH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHRyYW5zYWN0aW9uIHJlY29uZmlndXJlcyB0aGUgc3RhdGVcbiAgICAodGhyb3VnaCBhIFtjb25maWd1cmF0aW9uIGNvbXBhcnRtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50KSBvclxuICAgIHdpdGggYSB0b3AtbGV2ZWwgY29uZmlndXJhdGlvblxuICAgIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3RecmVjb25maWd1cmUpLlxuICAgICovXG4gICAgZ2V0IHJlY29uZmlndXJlZCgpIHsgcmV0dXJuIHRoaXMuc3RhcnRTdGF0ZS5jb25maWcgIT0gdGhpcy5zdGF0ZS5jb25maWc7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBhIFt1c2VyXG4gICAgZXZlbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edXNlckV2ZW50KSBhbm5vdGF0aW9uIHRoYXQgaXMgZXF1YWwgdG9cbiAgICBvciBtb3JlIHNwZWNpZmljIHRoYW4gYGV2ZW50YC4gRm9yIGV4YW1wbGUsIGlmIHRoZSB0cmFuc2FjdGlvblxuICAgIGhhcyBgXCJzZWxlY3QucG9pbnRlclwiYCBhcyB1c2VyIGV2ZW50LCBgXCJzZWxlY3RcImAgYW5kXG4gICAgYFwic2VsZWN0LnBvaW50ZXJcImAgd2lsbCBtYXRjaCBpdC5cbiAgICAqL1xuICAgIGlzVXNlckV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCBlID0gdGhpcy5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnVzZXJFdmVudCk7XG4gICAgICAgIHJldHVybiAhIShlICYmIChlID09IGV2ZW50IHx8IGUubGVuZ3RoID4gZXZlbnQubGVuZ3RoICYmIGUuc2xpY2UoMCwgZXZlbnQubGVuZ3RoKSA9PSBldmVudCAmJiBlW2V2ZW50Lmxlbmd0aF0gPT0gXCIuXCIpKTtcbiAgICB9XG59XG4vKipcbkFubm90YXRpb24gdXNlZCB0byBzdG9yZSB0cmFuc2FjdGlvbiB0aW1lc3RhbXBzLiBBdXRvbWF0aWNhbGx5XG5hZGRlZCB0byBldmVyeSB0cmFuc2FjdGlvbiwgaG9sZGluZyBgRGF0ZS5ub3coKWAuXG4qL1xuVHJhbnNhY3Rpb24udGltZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gYXNzb2NpYXRlIGEgdHJhbnNhY3Rpb24gd2l0aCBhIHVzZXIgaW50ZXJmYWNlXG5ldmVudC4gSG9sZHMgYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIGV2ZW50LCB1c2luZyBhXG5kb3Qtc2VwYXJhdGVkIGZvcm1hdCB0byBzdXBwb3J0IGF0dGFjaGluZyBtb3JlIHNwZWNpZmljXG5pbmZvcm1hdGlvbi4gVGhlIGV2ZW50cyB1c2VkIGJ5IHRoZSBjb3JlIGxpYnJhcmllcyBhcmU6XG5cbiAtIGBcImlucHV0XCJgIHdoZW4gY29udGVudCBpcyBlbnRlcmVkXG4gICAtIGBcImlucHV0LnR5cGVcImAgZm9yIHR5cGVkIGlucHV0XG4gICAgIC0gYFwiaW5wdXQudHlwZS5jb21wb3NlXCJgIGZvciBjb21wb3NpdGlvblxuICAgLSBgXCJpbnB1dC5wYXN0ZVwiYCBmb3IgcGFzdGVkIGlucHV0XG4gICAtIGBcImlucHV0LmRyb3BcImAgd2hlbiBhZGRpbmcgY29udGVudCB3aXRoIGRyYWctYW5kLWRyb3BcbiAgIC0gYFwiaW5wdXQuY29tcGxldGVcImAgd2hlbiBhdXRvY29tcGxldGluZ1xuIC0gYFwiZGVsZXRlXCJgIHdoZW4gdGhlIHVzZXIgZGVsZXRlcyBjb250ZW50XG4gICAtIGBcImRlbGV0ZS5zZWxlY3Rpb25cImAgd2hlbiBkZWxldGluZyB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5mb3J3YXJkXCJgIHdoZW4gZGVsZXRpbmcgZm9yd2FyZCBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmJhY2t3YXJkXCJgIHdoZW4gZGVsZXRpbmcgYmFja3dhcmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5jdXRcImAgd2hlbiBjdXR0aW5nIHRvIHRoZSBjbGlwYm9hcmRcbiAtIGBcIm1vdmVcImAgd2hlbiBjb250ZW50IGlzIG1vdmVkXG4gICAtIGBcIm1vdmUuZHJvcFwiYCB3aGVuIGNvbnRlbnQgaXMgbW92ZWQgd2l0aGluIHRoZSBlZGl0b3IgdGhyb3VnaCBkcmFnLWFuZC1kcm9wXG4gLSBgXCJzZWxlY3RcImAgd2hlbiBleHBsaWNpdGx5IGNoYW5naW5nIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwic2VsZWN0LnBvaW50ZXJcImAgd2hlbiBzZWxlY3Rpbmcgd2l0aCBhIG1vdXNlIG9yIG90aGVyIHBvaW50aW5nIGRldmljZVxuIC0gYFwidW5kb1wiYCBhbmQgYFwicmVkb1wiYCBmb3IgaGlzdG9yeSBhY3Rpb25zXG5cblVzZSBbYGlzVXNlckV2ZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5pc1VzZXJFdmVudCkgdG8gY2hlY2tcbndoZXRoZXIgdGhlIGFubm90YXRpb24gbWF0Y2hlcyBhIGdpdmVuIGV2ZW50LlxuKi9cblRyYW5zYWN0aW9uLnVzZXJFdmVudCA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIGluZGljYXRpbmcgd2hldGhlciBhIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhZGRlZCB0b1xudGhlIHVuZG8gaGlzdG9yeSBvciBub3QuXG4qL1xuVHJhbnNhY3Rpb24uYWRkVG9IaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gaW5kaWNhdGluZyAod2hlbiBwcmVzZW50IGFuZCB0cnVlKSB0aGF0IGEgdHJhbnNhY3Rpb25cbnJlcHJlc2VudHMgYSBjaGFuZ2UgbWFkZSBieSBzb21lIG90aGVyIGFjdG9yLCBub3QgdGhlIHVzZXIuIFRoaXNcbmlzIHVzZWQsIGZvciBleGFtcGxlLCB0byB0YWcgb3RoZXIgcGVvcGxlJ3MgY2hhbmdlcyBpblxuY29sbGFib3JhdGl2ZSBlZGl0aW5nLlxuKi9cblRyYW5zYWN0aW9uLnJlbW90ZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuZnVuY3Rpb24gam9pblJhbmdlcyhhLCBiKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgbGV0IGZyb20sIHRvO1xuICAgICAgICBpZiAoaUEgPCBhLmxlbmd0aCAmJiAoaUIgPT0gYi5sZW5ndGggfHwgYltpQl0gPj0gYVtpQV0pKSB7XG4gICAgICAgICAgICBmcm9tID0gYVtpQSsrXTtcbiAgICAgICAgICAgIHRvID0gYVtpQSsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpQiA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmcm9tID0gYltpQisrXTtcbiAgICAgICAgICAgIHRvID0gYltpQisrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGggfHwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA8IGZyb20pXG4gICAgICAgICAgICByZXN1bHQucHVzaChmcm9tLCB0byk7XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPCB0bylcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSB0bztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVRyYW5zYWN0aW9uKGEsIGIsIHNlcXVlbnRpYWwpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG1hcEZvckEsIG1hcEZvckIsIGNoYW5nZXM7XG4gICAgaWYgKHNlcXVlbnRpYWwpIHtcbiAgICAgICAgbWFwRm9yQSA9IGIuY2hhbmdlcztcbiAgICAgICAgbWFwRm9yQiA9IENoYW5nZVNldC5lbXB0eShiLmNoYW5nZXMubGVuZ3RoKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKGIuY2hhbmdlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXBGb3JBID0gYi5jaGFuZ2VzLm1hcChhLmNoYW5nZXMpO1xuICAgICAgICBtYXBGb3JCID0gYS5jaGFuZ2VzLm1hcERlc2MoYi5jaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKG1hcEZvckEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IGIuc2VsZWN0aW9uID8gYi5zZWxlY3Rpb24ubWFwKG1hcEZvckIpIDogKF9hID0gYS5zZWxlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAobWFwRm9yQSksXG4gICAgICAgIGVmZmVjdHM6IFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYS5lZmZlY3RzLCBtYXBGb3JBKS5jb25jYXQoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhiLmVmZmVjdHMsIG1hcEZvckIpKSxcbiAgICAgICAgYW5ub3RhdGlvbnM6IGEuYW5ub3RhdGlvbnMubGVuZ3RoID8gYS5hbm5vdGF0aW9ucy5jb25jYXQoYi5hbm5vdGF0aW9ucykgOiBiLmFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogYS5zY3JvbGxJbnRvVmlldyB8fCBiLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjLCBkb2NTaXplKSB7XG4gICAgbGV0IHNlbCA9IHNwZWMuc2VsZWN0aW9uLCBhbm5vdGF0aW9ucyA9IGFzQXJyYXkoc3BlYy5hbm5vdGF0aW9ucyk7XG4gICAgaWYgKHNwZWMudXNlckV2ZW50KVxuICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmNvbmNhdChUcmFuc2FjdGlvbi51c2VyRXZlbnQub2Yoc3BlYy51c2VyRXZlbnQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzOiBzcGVjLmNoYW5nZXMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQgPyBzcGVjLmNoYW5nZXNcbiAgICAgICAgICAgIDogQ2hhbmdlU2V0Lm9mKHNwZWMuY2hhbmdlcyB8fCBbXSwgZG9jU2l6ZSwgc3RhdGUuZmFjZXQobGluZVNlcGFyYXRvcikpLFxuICAgICAgICBzZWxlY3Rpb246IHNlbCAmJiAoc2VsIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gc2VsIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShzZWwuYW5jaG9yLCBzZWwuaGVhZCkpLFxuICAgICAgICBlZmZlY3RzOiBhc0FycmF5KHNwZWMuZWZmZWN0cyksXG4gICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogISFzcGVjLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbihzdGF0ZSwgc3BlY3MsIGZpbHRlcikge1xuICAgIGxldCBzID0gcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWNzLmxlbmd0aCA/IHNwZWNzWzBdIDoge30sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIGlmIChzcGVjcy5sZW5ndGggJiYgc3BlY3NbMF0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgZmlsdGVyID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3BlY3NbaV0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgICAgIGZpbHRlciA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VxID0gISFzcGVjc1tpXS5zZXF1ZW50aWFsO1xuICAgICAgICBzID0gbWVyZ2VUcmFuc2FjdGlvbihzLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlY3NbaV0sIHNlcSA/IHMuY2hhbmdlcy5uZXdMZW5ndGggOiBzdGF0ZS5kb2MubGVuZ3RoKSwgc2VxKTtcbiAgICB9XG4gICAgbGV0IHRyID0gVHJhbnNhY3Rpb24uY3JlYXRlKHN0YXRlLCBzLmNoYW5nZXMsIHMuc2VsZWN0aW9uLCBzLmVmZmVjdHMsIHMuYW5ub3RhdGlvbnMsIHMuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIHJldHVybiBleHRlbmRUcmFuc2FjdGlvbihmaWx0ZXIgPyBmaWx0ZXJUcmFuc2FjdGlvbih0cikgOiB0cik7XG59XG4vLyBGaW5pc2ggYSB0cmFuc2FjdGlvbiBieSBhcHBseWluZyBmaWx0ZXJzIGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIGZpbHRlclRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZTtcbiAgICAvLyBDaGFuZ2UgZmlsdGVyc1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGZvciAobGV0IGZpbHRlciBvZiBzdGF0ZS5mYWNldChjaGFuZ2VGaWx0ZXIpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGZpbHRlcih0cik7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB0cnVlID8gdmFsdWUgOiBqb2luUmFuZ2VzKHJlc3VsdCwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzLCBiYWNrO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYmFjayA9IHRyLmNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgICAgICAgICAgY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eShzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHRyLmNoYW5nZXMuZmlsdGVyKHJlc3VsdCk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gZmlsdGVyZWQuY2hhbmdlcztcbiAgICAgICAgICAgIGJhY2sgPSBmaWx0ZXJlZC5maWx0ZXJlZC5tYXBEZXNjKGZpbHRlcmVkLmNoYW5nZXMpLmludmVydGVkRGVzYztcbiAgICAgICAgfVxuICAgICAgICB0ciA9IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgY2hhbmdlcywgdHIuc2VsZWN0aW9uICYmIHRyLnNlbGVjdGlvbi5tYXAoYmFjayksIFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHModHIuZWZmZWN0cywgYmFjayksIHRyLmFubm90YXRpb25zLCB0ci5zY3JvbGxJbnRvVmlldyk7XG4gICAgfVxuICAgIC8vIFRyYW5zYWN0aW9uIGZpbHRlcnNcbiAgICBsZXQgZmlsdGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRmlsdGVyKTtcbiAgICBmb3IgKGxldCBpID0gZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZmlsdGVyZWQgPSBmaWx0ZXJzW2ldKHRyKTtcbiAgICAgICAgaWYgKGZpbHRlcmVkIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pXG4gICAgICAgICAgICB0ciA9IGZpbHRlcmVkO1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcmVkKSAmJiBmaWx0ZXJlZC5sZW5ndGggPT0gMSAmJiBmaWx0ZXJlZFswXSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZFswXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIgPSByZXNvbHZlVHJhbnNhY3Rpb24oc3RhdGUsIGFzQXJyYXkoZmlsdGVyZWQpLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIGV4dGVuZFRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZSwgZXh0ZW5kZXJzID0gc3RhdGUuZmFjZXQodHJhbnNhY3Rpb25FeHRlbmRlciksIHNwZWMgPSB0cjtcbiAgICBmb3IgKGxldCBpID0gZXh0ZW5kZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBleHRlbnNpb24gPSBleHRlbmRlcnNbaV0odHIpO1xuICAgICAgICBpZiAoZXh0ZW5zaW9uICYmIE9iamVjdC5rZXlzKGV4dGVuc2lvbikubGVuZ3RoKVxuICAgICAgICAgICAgc3BlYyA9IG1lcmdlVHJhbnNhY3Rpb24oc3BlYywgcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIGV4dGVuc2lvbiwgdHIuY2hhbmdlcy5uZXdMZW5ndGgpLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWMgPT0gdHIgPyB0ciA6IFRyYW5zYWN0aW9uLmNyZWF0ZShzdGF0ZSwgdHIuY2hhbmdlcywgdHIuc2VsZWN0aW9uLCBzcGVjLmVmZmVjdHMsIHNwZWMuYW5ub3RhdGlvbnMsIHNwZWMuc2Nyb2xsSW50b1ZpZXcpO1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuZnVuY3Rpb24gYXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gbm9uZSA6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuXG4vKipcblRoZSBjYXRlZ29yaWVzIHByb2R1Y2VkIGJ5IGEgW2NoYXJhY3RlclxuY2F0ZWdvcml6ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKS4gVGhlc2UgYXJlIHVzZWRcbmRvIHRoaW5ncyBsaWtlIHNlbGVjdGluZyBieSB3b3JkLlxuKi9cbnZhciBDaGFyQ2F0ZWdvcnkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChDaGFyQ2F0ZWdvcnkpIHtcbiAgICAvKipcbiAgICBXb3JkIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiV29yZFwiXSA9IDBdID0gXCJXb3JkXCI7XG4gICAgLyoqXG4gICAgV2hpdGVzcGFjZS5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJTcGFjZVwiXSA9IDFdID0gXCJTcGFjZVwiO1xuICAgIC8qKlxuICAgIEFueXRoaW5nIGVsc2UuXG4gICAgKi9cbiAgICBDaGFyQ2F0ZWdvcnlbQ2hhckNhdGVnb3J5W1wiT3RoZXJcIl0gPSAyXSA9IFwiT3RoZXJcIjtcbnJldHVybiBDaGFyQ2F0ZWdvcnl9KShDaGFyQ2F0ZWdvcnkgfHwgKENoYXJDYXRlZ29yeSA9IHt9KSk7XG5jb25zdCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcbmxldCB3b3JkQ2hhcjtcbnRyeSB7XG4gICAgd29yZENoYXIgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXFxccHtBbHBoYWJldGljfVxcXFxwe051bWJlcn1fXVwiLCBcInVcIik7XG59XG5jYXRjaCAoXykgeyB9XG5mdW5jdGlvbiBoYXNXb3JkQ2hhcihzdHIpIHtcbiAgICBpZiAod29yZENoYXIpXG4gICAgICAgIHJldHVybiB3b3JkQ2hhci50ZXN0KHN0cik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoID0gc3RyW2ldO1xuICAgICAgICBpZiAoL1xcdy8udGVzdChjaCkgfHwgY2ggPiBcIlxceDgwXCIgJiYgKGNoLnRvVXBwZXJDYXNlKCkgIT0gY2gudG9Mb3dlckNhc2UoKSB8fCBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhci50ZXN0KGNoKSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWFrZUNhdGVnb3JpemVyKHdvcmRDaGFycykge1xuICAgIHJldHVybiAoY2hhcikgPT4ge1xuICAgICAgICBpZiAoIS9cXFMvLnRlc3QoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LlNwYWNlO1xuICAgICAgICBpZiAoaGFzV29yZENoYXIoY2hhcikpXG4gICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LldvcmQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZENoYXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNoYXIuaW5kZXhPZih3b3JkQ2hhcnNbaV0pID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIENoYXJDYXRlZ29yeS5Xb3JkO1xuICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5Lk90aGVyO1xuICAgIH07XG59XG5cbi8qKlxuVGhlIGVkaXRvciBzdGF0ZSBjbGFzcyBpcyBhIHBlcnNpc3RlbnQgKGltbXV0YWJsZSkgZGF0YSBzdHJ1Y3R1cmUuXG5UbyB1cGRhdGUgYSBzdGF0ZSwgeW91IFtjcmVhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSBhXG5bdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pLCB3aGljaCBwcm9kdWNlcyBhIF9uZXdfIHN0YXRlXG5pbnN0YW5jZSwgd2l0aG91dCBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsIG9iamVjdC5cblxuQXMgc3VjaCwgX25ldmVyXyBtdXRhdGUgcHJvcGVydGllcyBvZiBhIHN0YXRlIGRpcmVjdGx5LiBUaGF0J2xsXG5qdXN0IGJyZWFrIHRoaW5ncy5cbiovXG5jbGFzcyBFZGl0b3JTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25maWcsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGRvY3VtZW50LlxuICAgICovXG4gICAgZG9jLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzZWxlY3Rpb24sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdmFsdWVzLCBjb21wdXRlU2xvdCwgdHIpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gY29uZmlnLnN0YXR1c1RlbXBsYXRlLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuY29tcHV0ZVNsb3QgPSBjb21wdXRlU2xvdDtcbiAgICAgICAgLy8gRmlsbCBpbiB0aGUgY29tcHV0ZWQgc3RhdGUgaW1tZWRpYXRlbHksIHNvIHRoYXQgZnVydGhlciBxdWVyaWVzXG4gICAgICAgIC8vIGZvciBpdCBtYWRlIGR1cmluZyB0aGUgdXBkYXRlIHJldHVybiB0aGlzIHN0YXRlXG4gICAgICAgIGlmICh0cilcbiAgICAgICAgICAgIHRyLl9zdGF0ZSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25maWcuZHluYW1pY1Nsb3RzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBpIDw8IDEpO1xuICAgICAgICB0aGlzLmNvbXB1dGVTbG90ID0gbnVsbDtcbiAgICB9XG4gICAgZmllbGQoZmllbGQsIHJlcXVpcmUgPSB0cnVlKSB7XG4gICAgICAgIGxldCBhZGRyID0gdGhpcy5jb25maWcuYWRkcmVzc1tmaWVsZC5pZF07XG4gICAgICAgIGlmIChhZGRyID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRmllbGQgaXMgbm90IHByZXNlbnQgaW4gdGhpcyBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlQWRkcih0aGlzLCBhZGRyKTtcbiAgICAgICAgcmV0dXJuIGdldEFkZHIodGhpcywgYWRkcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgdGhhdCB1cGRhdGVzIHRoaXNcbiAgICBzdGF0ZS4gQW55IG51bWJlciBvZiBbdHJhbnNhY3Rpb24gc3BlY3NdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKVxuICAgIGNhbiBiZSBwYXNzZWQuIFVubGVzc1xuICAgIFtgc2VxdWVudGlhbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlcXVlbnRpYWwpIGlzIHNldCwgdGhlXG4gICAgW2NoYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmNoYW5nZXMpIChpZiBhbnkpIG9mIGVhY2ggc3BlY1xuICAgIGFyZSBhc3N1bWVkIHRvIHN0YXJ0IGluIHRoZSBfY3VycmVudF8gZG9jdW1lbnQgKG5vdCB0aGUgZG9jdW1lbnRcbiAgICBwcm9kdWNlZCBieSBwcmV2aW91cyBzcGVjcyksIGFuZCBpdHNcbiAgICBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pIGFuZFxuICAgIFtlZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSBhcmUgYXNzdW1lZCB0byByZWZlclxuICAgIHRvIHRoZSBkb2N1bWVudCBjcmVhdGVkIGJ5IGl0cyBfb3duXyBjaGFuZ2VzLiBUaGUgcmVzdWx0aW5nXG4gICAgdHJhbnNhY3Rpb24gY29udGFpbnMgdGhlIGNvbWJpbmVkIGVmZmVjdCBvZiBhbGwgdGhlIGRpZmZlcmVudFxuICAgIHNwZWNzLiBGb3IgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSwgbGF0ZXJcbiAgICBzcGVjcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBlYXJsaWVyIG9uZXMuXG4gICAgKi9cbiAgICB1cGRhdGUoLi4uc3BlY3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVUcmFuc2FjdGlvbih0aGlzLCBzcGVjcywgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYXBwbHlUcmFuc2FjdGlvbih0cikge1xuICAgICAgICBsZXQgY29uZiA9IHRoaXMuY29uZmlnLCB7IGJhc2UsIGNvbXBhcnRtZW50cyB9ID0gY29uZjtcbiAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoQ29tcGFydG1lbnQucmVjb25maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFydG1lbnRzID0gbmV3IE1hcDtcbiAgICAgICAgICAgICAgICAgICAgY29uZi5jb21wYXJ0bWVudHMuZm9yRWFjaCgodmFsLCBrZXkpID0+IGNvbXBhcnRtZW50cy5zZXQoa2V5LCB2YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXBhcnRtZW50cy5zZXQoZWZmZWN0LnZhbHVlLmNvbXBhcnRtZW50LCBlZmZlY3QudmFsdWUuZXh0ZW5zaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5yZWNvbmZpZ3VyZSkpIHtcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYXNlID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWZmZWN0LmlzKFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb25mID0gbnVsbDtcbiAgICAgICAgICAgICAgICBiYXNlID0gYXNBcnJheShiYXNlKS5jb25jYXQoZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRWYWx1ZXM7XG4gICAgICAgIGlmICghY29uZikge1xuICAgICAgICAgICAgY29uZiA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIHRoaXMpO1xuICAgICAgICAgICAgbGV0IGludGVybWVkaWF0ZVN0YXRlID0gbmV3IEVkaXRvclN0YXRlKGNvbmYsIHRoaXMuZG9jLCB0aGlzLnNlbGVjdGlvbiwgY29uZi5keW5hbWljU2xvdHMubWFwKCgpID0+IG51bGwpLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QucmVjb25maWd1cmUoc3RhdGUsIHRoaXMpLCBudWxsKTtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0gaW50ZXJtZWRpYXRlU3RhdGUudmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRWYWx1ZXMgPSB0ci5zdGFydFN0YXRlLnZhbHVlcy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSB0ci5zdGFydFN0YXRlLmZhY2V0KGFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSA/IHRyLm5ld1NlbGVjdGlvbiA6IHRyLm5ld1NlbGVjdGlvbi5hc1NpbmdsZSgpO1xuICAgICAgICBuZXcgRWRpdG9yU3RhdGUoY29uZiwgdHIubmV3RG9jLCBzZWxlY3Rpb24sIHN0YXJ0VmFsdWVzLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QudXBkYXRlKHN0YXRlLCB0ciksIHRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3RyYW5zYWN0aW9uIHNwZWNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKSB0aGF0XG4gICAgcmVwbGFjZXMgZXZlcnkgc2VsZWN0aW9uIHJhbmdlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuXG4gICAgKi9cbiAgICByZXBsYWNlU2VsZWN0aW9uKHRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy50b1RleHQodGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4gKHsgY2hhbmdlczogeyBmcm9tOiByYW5nZS5mcm9tLCB0bzogcmFuZ2UudG8sIGluc2VydDogdGV4dCB9LFxuICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIHRleHQubGVuZ3RoKSB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBjaGFuZ2VzIGFuZCBhIG5ldyBzZWxlY3Rpb24gYnkgcnVubmluZyB0aGUgZ2l2ZW5cbiAgICBmdW5jdGlvbiBmb3IgZWFjaCByYW5nZSBpbiB0aGUgYWN0aXZlIHNlbGVjdGlvbi4gVGhlIGZ1bmN0aW9uXG4gICAgY2FuIHJldHVybiBhbiBvcHRpb25hbCBzZXQgb2YgY2hhbmdlcyAoaW4gdGhlIGNvb3JkaW5hdGUgc3BhY2VcbiAgICBvZiB0aGUgc3RhcnQgZG9jdW1lbnQpLCBwbHVzIGFuIHVwZGF0ZWQgcmFuZ2UgKGluIHRoZSBjb29yZGluYXRlXG4gICAgc3BhY2Ugb2YgdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IHRoZSBjYWxsJ3Mgb3duIGNoYW5nZXMpLiBUaGlzXG4gICAgbWV0aG9kIHdpbGwgbWVyZ2UgYWxsIHRoZSBjaGFuZ2VzIGFuZCByYW5nZXMgaW50byBhIHNpbmdsZVxuICAgIGNoYW5nZXNldCBhbmQgc2VsZWN0aW9uLCBhbmQgcmV0dXJuIGl0IGFzIGEgW3RyYW5zYWN0aW9uXG4gICAgc3BlY10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpLCB3aGljaCBjYW4gYmUgcGFzc2VkIHRvXG4gICAgW2B1cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkuXG4gICAgKi9cbiAgICBjaGFuZ2VCeVJhbmdlKGYpIHtcbiAgICAgICAgbGV0IHNlbCA9IHRoaXMuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmVzdWx0MSA9IGYoc2VsLnJhbmdlc1swXSk7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gdGhpcy5jaGFuZ2VzKHJlc3VsdDEuY2hhbmdlcyksIHJhbmdlcyA9IFtyZXN1bHQxLnJhbmdlXTtcbiAgICAgICAgbGV0IGVmZmVjdHMgPSBhc0FycmF5KHJlc3VsdDEuZWZmZWN0cyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGYoc2VsLnJhbmdlc1tpXSk7XG4gICAgICAgICAgICBsZXQgbmV3Q2hhbmdlcyA9IHRoaXMuY2hhbmdlcyhyZXN1bHQuY2hhbmdlcyksIG5ld01hcHBlZCA9IG5ld0NoYW5nZXMubWFwKGNoYW5nZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyBqKyspXG4gICAgICAgICAgICAgICAgcmFuZ2VzW2pdID0gcmFuZ2VzW2pdLm1hcChuZXdNYXBwZWQpO1xuICAgICAgICAgICAgbGV0IG1hcEJ5ID0gY2hhbmdlcy5tYXBEZXNjKG5ld0NoYW5nZXMsIHRydWUpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gocmVzdWx0LnJhbmdlLm1hcChtYXBCeSkpO1xuICAgICAgICAgICAgY2hhbmdlcyA9IGNoYW5nZXMuY29tcG9zZShuZXdNYXBwZWQpO1xuICAgICAgICAgICAgZWZmZWN0cyA9IFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoZWZmZWN0cywgbmV3TWFwcGVkKS5jb25jYXQoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhhc0FycmF5KHJlc3VsdC5lZmZlY3RzKSwgbWFwQnkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMsIHNlbC5tYWluSW5kZXgpLFxuICAgICAgICAgICAgZWZmZWN0c1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbY2hhbmdlIHNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQpIGZyb20gdGhlIGdpdmVuIGNoYW5nZVxuICAgIGRlc2NyaXB0aW9uLCB0YWtpbmcgdGhlIHN0YXRlJ3MgZG9jdW1lbnQgbGVuZ3RoIGFuZCBsaW5lXG4gICAgc2VwYXJhdG9yIGludG8gYWNjb3VudC5cbiAgICAqL1xuICAgIGNoYW5nZXMoc3BlYyA9IFtdKSB7XG4gICAgICAgIGlmIChzcGVjIGluc3RhbmNlb2YgQ2hhbmdlU2V0KVxuICAgICAgICAgICAgcmV0dXJuIHNwZWM7XG4gICAgICAgIHJldHVybiBDaGFuZ2VTZXQub2Yoc3BlYywgdGhpcy5kb2MubGVuZ3RoLCB0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXNpbmcgdGhlIHN0YXRlJ3MgW2xpbmVcbiAgICBzZXBhcmF0b3JdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVebGluZVNlcGFyYXRvciksIGNyZWF0ZSBhXG4gICAgW2BUZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0KSBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuXG4gICAgKi9cbiAgICB0b1RleHQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBUZXh0Lm9mKHN0cmluZy5zcGxpdCh0aGlzLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IERlZmF1bHRTcGxpdCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIGdpdmVuIHJhbmdlIG9mIHRoZSBkb2N1bWVudCBhcyBhIHN0cmluZy5cbiAgICAqL1xuICAgIHNsaWNlRG9jKGZyb20gPSAwLCB0byA9IHRoaXMuZG9jLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8sIHRoaXMubGluZUJyZWFrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiBhIHN0YXRlIFtmYWNldF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5GYWNldCkuXG4gICAgKi9cbiAgICBmYWNldChmYWNldCkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuY29uZmlnLmFkZHJlc3NbZmFjZXQuaWRdO1xuICAgICAgICBpZiAoYWRkciA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhY2V0LmRlZmF1bHQ7XG4gICAgICAgIGVuc3VyZUFkZHIodGhpcywgYWRkcik7XG4gICAgICAgIHJldHVybiBnZXRBZGRyKHRoaXMsIGFkZHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoaXMgc3RhdGUgdG8gYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QuIFdoZW4gY3VzdG9tXG4gICAgZmllbGRzIHNob3VsZCBiZSBzZXJpYWxpemVkLCB5b3UgY2FuIHBhc3MgdGhlbSBpbiBhcyBhbiBvYmplY3RcbiAgICBtYXBwaW5nIHByb3BlcnR5IG5hbWVzIChpbiB0aGUgcmVzdWx0aW5nIG9iamVjdCwgd2hpY2ggc2hvdWxkXG4gICAgbm90IHVzZSBgZG9jYCBvciBgc2VsZWN0aW9uYCkgdG8gZmllbGRzLlxuICAgICovXG4gICAgdG9KU09OKGZpZWxkcykge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgZG9jOiB0aGlzLnNsaWNlRG9jKCksXG4gICAgICAgICAgICBzZWxlY3Rpb246IHRoaXMuc2VsZWN0aW9uLnRvSlNPTigpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaWVsZHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGZpZWxkc1twcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdGF0ZUZpZWxkICYmIHRoaXMuY29uZmlnLmFkZHJlc3NbdmFsdWUuaWRdICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHZhbHVlLnNwZWMudG9KU09OKHRoaXMuZmllbGQoZmllbGRzW3Byb3BdKSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgc3RhdGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gV2hlbiBjdXN0b21cbiAgICBmaWVsZHMgc2hvdWxkIGJlIGRlc2VyaWFsaXplZCwgcGFzcyB0aGUgc2FtZSBvYmplY3QgeW91IHBhc3NlZFxuICAgIHRvIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIHdoZW4gc2VyaWFsaXppbmcgYXNcbiAgICB0aGlyZCBhcmd1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uLCBjb25maWcgPSB7fSwgZmllbGRzKSB7XG4gICAgICAgIGlmICghanNvbiB8fCB0eXBlb2YganNvbi5kb2MgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIGZvciBFZGl0b3JTdGF0ZVwiKTtcbiAgICAgICAgbGV0IGZpZWxkSW5pdCA9IFtdO1xuICAgICAgICBpZiAoZmllbGRzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGpzb24sIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IGZpZWxkc1twcm9wXSwgdmFsdWUgPSBqc29uW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEluaXQucHVzaChmaWVsZC5pbml0KHN0YXRlID0+IGZpZWxkLnNwZWMuZnJvbUpTT04odmFsdWUsIHN0YXRlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVkaXRvclN0YXRlLmNyZWF0ZSh7XG4gICAgICAgICAgICBkb2M6IGpzb24uZG9jLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uZnJvbUpTT04oanNvbi5zZWxlY3Rpb24pLFxuICAgICAgICAgICAgZXh0ZW5zaW9uczogY29uZmlnLmV4dGVuc2lvbnMgPyBmaWVsZEluaXQuY29uY2F0KFtjb25maWcuZXh0ZW5zaW9uc10pIDogZmllbGRJbml0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgc3RhdGUuIFlvdSdsbCB1c3VhbGx5IG9ubHkgbmVlZCB0aGlzIHdoZW5cbiAgICBpbml0aWFsaXppbmcgYW4gZWRpdG9y4oCUdXBkYXRlZCBzdGF0ZXMgYXJlIGNyZWF0ZWQgYnkgYXBwbHlpbmdcbiAgICB0cmFuc2FjdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIGxldCBjb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbi5yZXNvbHZlKGNvbmZpZy5leHRlbnNpb25zIHx8IFtdLCBuZXcgTWFwKTtcbiAgICAgICAgbGV0IGRvYyA9IGNvbmZpZy5kb2MgaW5zdGFuY2VvZiBUZXh0ID8gY29uZmlnLmRvY1xuICAgICAgICAgICAgOiBUZXh0Lm9mKChjb25maWcuZG9jIHx8IFwiXCIpLnNwbGl0KGNvbmZpZ3VyYXRpb24uc3RhdGljRmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgRGVmYXVsdFNwbGl0KSk7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSAhY29uZmlnLnNlbGVjdGlvbiA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoMClcbiAgICAgICAgICAgIDogY29uZmlnLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEVkaXRvclNlbGVjdGlvbiA/IGNvbmZpZy5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICA6IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoY29uZmlnLnNlbGVjdGlvbi5hbmNob3IsIGNvbmZpZy5zZWxlY3Rpb24uaGVhZCk7XG4gICAgICAgIGNoZWNrU2VsZWN0aW9uKHNlbGVjdGlvbiwgZG9jLmxlbmd0aCk7XG4gICAgICAgIGlmICghY29uZmlndXJhdGlvbi5zdGF0aWNGYWNldChhbGxvd011bHRpcGxlU2VsZWN0aW9ucykpXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24uYXNTaW5nbGUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTdGF0ZShjb25maWd1cmF0aW9uLCBkb2MsIHNlbGVjdGlvbiwgY29uZmlndXJhdGlvbi5keW5hbWljU2xvdHMubWFwKCgpID0+IG51bGwpLCAoc3RhdGUsIHNsb3QpID0+IHNsb3QuY3JlYXRlKHN0YXRlKSwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIChpbiBjb2x1bW5zKSBvZiBhIHRhYiBpbiB0aGUgZG9jdW1lbnQsIGRldGVybWluZWQgYnlcbiAgICB0aGUgW2B0YWJTaXplYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSBmYWNldC5cbiAgICAqL1xuICAgIGdldCB0YWJTaXplKCkgeyByZXR1cm4gdGhpcy5mYWNldChFZGl0b3JTdGF0ZS50YWJTaXplKTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJvcGVyIFtsaW5lLWJyZWFrXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxpbmVTZXBhcmF0b3IpXG4gICAgc3RyaW5nIGZvciB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgXCJcXG5cIjsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICBbY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5yZWFkT25seSkgdG8gYmUgcmVhZC1vbmx5LlxuICAgICovXG4gICAgZ2V0IHJlYWRPbmx5KCkgeyByZXR1cm4gdGhpcy5mYWNldChyZWFkT25seSk7IH1cbiAgICAvKipcbiAgICBMb29rIHVwIGEgdHJhbnNsYXRpb24gZm9yIHRoZSBnaXZlbiBwaHJhc2UgKHZpYSB0aGVcbiAgICBbYHBocmFzZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnBocmFzZXMpIGZhY2V0KSwgb3IgcmV0dXJuIHRoZVxuICAgIG9yaWdpbmFsIHN0cmluZyBpZiBubyB0cmFuc2xhdGlvbiBpcyBmb3VuZC5cbiAgICBcbiAgICBJZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcGFzc2VkLCB0aGV5IHdpbGwgYmUgaW5zZXJ0ZWQgaW5cbiAgICBwbGFjZSBvZiBtYXJrZXJzIGxpa2UgYCQxYCAoZm9yIHRoZSBmaXJzdCB2YWx1ZSkgYW5kIGAkMmAsIGV0Yy5cbiAgICBBIHNpbmdsZSBgJGAgaXMgZXF1aXZhbGVudCB0byBgJDFgLCBhbmQgYCQkYCB3aWxsIHByb2R1Y2UgYVxuICAgIGxpdGVyYWwgZG9sbGFyIHNpZ24uXG4gICAgKi9cbiAgICBwaHJhc2UocGhyYXNlLCAuLi5pbnNlcnQpIHtcbiAgICAgICAgZm9yIChsZXQgbWFwIG9mIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgcGhyYXNlKSkge1xuICAgICAgICAgICAgICAgIHBocmFzZSA9IG1hcFtwaHJhc2VdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoaW5zZXJ0Lmxlbmd0aClcbiAgICAgICAgICAgIHBocmFzZSA9IHBocmFzZS5yZXBsYWNlKC9cXCQoXFwkfFxcZCopL2csIChtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gXCIkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgICAgICAgICBsZXQgbiA9ICsoaSB8fCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW4gfHwgbiA+IGluc2VydC5sZW5ndGggPyBtIDogaW5zZXJ0W24gLSAxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGhyYXNlO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB2YWx1ZXMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2UgZGF0YSBmaWVsZCwgcHJvdmlkZWQgYnkgdGhlXG4gICAgdGhlIFtgbGFuZ3VhZ2VEYXRhYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5sYW5ndWFnZURhdGEpIGZhY2V0LlxuICAgIFxuICAgIEV4YW1wbGVzIG9mIGxhbmd1YWdlIGRhdGEgZmllbGRzIGFyZS4uLlxuICAgIFxuICAgIC0gW2BcImNvbW1lbnRUb2tlbnNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jY29tbWFuZHMuQ29tbWVudFRva2VucykgZm9yIHNwZWNpZnlpbmdcbiAgICAgIGNvbW1lbnQgc3ludGF4LlxuICAgIC0gW2BcImF1dG9jb21wbGV0ZVwiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuYXV0b2NvbXBsZXRpb25eY29uZmlnLm92ZXJyaWRlKVxuICAgICAgZm9yIHByb3ZpZGluZyBsYW5ndWFnZS1zcGVjaWZpYyBjb21wbGV0aW9uIHNvdXJjZXMuXG4gICAgLSBbYFwid29yZENoYXJzXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgZm9yIGFkZGluZ1xuICAgICAgY2hhcmFjdGVycyB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIHBhcnQgb2Ygd29yZHMgaW4gdGhpc1xuICAgICAgbGFuZ3VhZ2UuXG4gICAgLSBbYFwiY2xvc2VCcmFja2V0c1wiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuQ2xvc2VCcmFja2V0Q29uZmlnKSBjb250cm9sc1xuICAgICAgYnJhY2tldCBjbG9zaW5nIGJlaGF2aW9yLlxuICAgICovXG4gICAgbGFuZ3VhZ2VEYXRhQXQobmFtZSwgcG9zLCBzaWRlID0gLTEpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwcm92aWRlciBvZiB0aGlzLmZhY2V0KGxhbmd1YWdlRGF0YSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJlc3VsdCBvZiBwcm92aWRlcih0aGlzLCBwb3MsIHNpZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChyZXN1bHRbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGNhdGVnb3JpemUgc3RyaW5ncyAoZXhwZWN0ZWQgdG9cbiAgICByZXByZXNlbnQgYSBzaW5nbGUgW2dyYXBoZW1lIGNsdXN0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuZmluZENsdXN0ZXJCcmVhaykpXG4gICAgaW50byBvbmUgb2Y6XG4gICAgXG4gICAgIC0gV29yZCAoY29udGFpbnMgYW4gYWxwaGFudW1lcmljIGNoYXJhY3RlciBvciBhIGNoYXJhY3RlclxuICAgICAgIGV4cGxpY2l0bHkgbGlzdGVkIGluIHRoZSBsb2NhbCBsYW5ndWFnZSdzIGBcIndvcmRDaGFyc1wiYFxuICAgICAgIGxhbmd1YWdlIGRhdGEsIHdoaWNoIHNob3VsZCBiZSBhIHN0cmluZylcbiAgICAgLSBTcGFjZSAoY29udGFpbnMgb25seSB3aGl0ZXNwYWNlKVxuICAgICAtIE90aGVyIChhbnl0aGluZyBlbHNlKVxuICAgICovXG4gICAgY2hhckNhdGVnb3JpemVyKGF0KSB7XG4gICAgICAgIHJldHVybiBtYWtlQ2F0ZWdvcml6ZXIodGhpcy5sYW5ndWFnZURhdGFBdChcIndvcmRDaGFyc1wiLCBhdCkuam9pbihcIlwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHdvcmQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBtZWFuaW5nIHRoZSByYW5nZVxuICAgIGNvbnRhaW5pbmcgYWxsIFt3b3JkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYXJDYXRlZ29yeS5Xb3JkKSBjaGFyYWN0ZXJzXG4gICAgYXJvdW5kIGl0LiBJZiBubyB3b3JkIGNoYXJhY3RlcnMgYXJlIGFkamFjZW50IHRvIHRoZSBwb3NpdGlvbixcbiAgICB0aGlzIHJldHVybnMgbnVsbC5cbiAgICAqL1xuICAgIHdvcmRBdChwb3MpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSwgbGVuZ3RoIH0gPSB0aGlzLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgbGV0IGNhdCA9IHRoaXMuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgICAgIGxldCBzdGFydCA9IHBvcyAtIGZyb20sIGVuZCA9IHBvcyAtIGZyb207XG4gICAgICAgIHdoaWxlIChzdGFydCA+IDApIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gZmluZENsdXN0ZXJCcmVhayh0ZXh0LCBzdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNhdCh0ZXh0LnNsaWNlKHByZXYsIHN0YXJ0KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdGFydCA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGVuZCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmaW5kQ2x1c3RlckJyZWFrKHRleHQsIGVuZCk7XG4gICAgICAgICAgICBpZiAoY2F0KHRleHQuc2xpY2UoZW5kLCBuZXh0KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBlbmQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydCA9PSBlbmQgPyBudWxsIDogRWRpdG9yU2VsZWN0aW9uLnJhbmdlKHN0YXJ0ICsgZnJvbSwgZW5kICsgZnJvbSk7XG4gICAgfVxufVxuLyoqXG5BIGZhY2V0IHRoYXQsIHdoZW4gZW5hYmxlZCwgY2F1c2VzIHRoZSBlZGl0b3IgdG8gYWxsb3cgbXVsdGlwbGVcbnJhbmdlcyB0byBiZSBzZWxlY3RlZC4gQmUgY2FyZWZ1bCB0aG91Z2gsIGJlY2F1c2UgYnkgZGVmYXVsdCB0aGVcbmVkaXRvciByZWxpZXMgb24gdGhlIG5hdGl2ZSBET00gc2VsZWN0aW9uLCB3aGljaCBjYW5ub3QgaGFuZGxlXG5tdWx0aXBsZSBzZWxlY3Rpb25zLiBBbiBleHRlbnNpb24gbGlrZVxuW2BkcmF3U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyYXdTZWxlY3Rpb24pIGNhbiBiZSB1c2VkIHRvIG1ha2VcbnNlY29uZGFyeSBzZWxlY3Rpb25zIHZpc2libGUgdG8gdGhlIHVzZXIuXG4qL1xuRWRpdG9yU3RhdGUuYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMgPSBhbGxvd011bHRpcGxlU2VsZWN0aW9ucztcbi8qKlxuQ29uZmlndXJlcyB0aGUgdGFiIHNpemUgdG8gdXNlIGluIHRoaXMgc3RhdGUuIFRoZSBmaXJzdFxuKGhpZ2hlc3QtcHJlY2VkZW5jZSkgdmFsdWUgb2YgdGhlIGZhY2V0IGlzIHVzZWQuIElmIG5vIHZhbHVlIGlzXG5naXZlbiwgdGhpcyBkZWZhdWx0cyB0byA0LlxuKi9cbkVkaXRvclN0YXRlLnRhYlNpemUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmxlbmd0aCA/IHZhbHVlc1swXSA6IDRcbn0pO1xuLyoqXG5UaGUgbGluZSBzZXBhcmF0b3IgdG8gdXNlLiBCeSBkZWZhdWx0LCBhbnkgb2YgYFwiXFxuXCJgLCBgXCJcXHJcXG5cImBcbmFuZCBgXCJcXHJcImAgaXMgdHJlYXRlZCBhcyBhIHNlcGFyYXRvciB3aGVuIHNwbGl0dGluZyBsaW5lcywgYW5kXG5saW5lcyBhcmUgam9pbmVkIHdpdGggYFwiXFxuXCJgLlxuXG5XaGVuIHlvdSBjb25maWd1cmUgYSB2YWx1ZSBoZXJlLCBvbmx5IHRoYXQgcHJlY2lzZSBzZXBhcmF0b3JcbndpbGwgYmUgdXNlZCwgYWxsb3dpbmcgeW91IHRvIHJvdW5kLXRyaXAgZG9jdW1lbnRzIHRocm91Z2ggdGhlXG5lZGl0b3Igd2l0aG91dCBub3JtYWxpemluZyBsaW5lIHNlcGFyYXRvcnMuXG4qL1xuRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvciA9IGxpbmVTZXBhcmF0b3I7XG4vKipcblRoaXMgZmFjZXQgY29udHJvbHMgdGhlIHZhbHVlIG9mIHRoZVxuW2ByZWFkT25seWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucmVhZE9ubHkpIGdldHRlciwgd2hpY2ggaXNcbmNvbnN1bHRlZCBieSBjb21tYW5kcyBhbmQgZXh0ZW5zaW9ucyB0aGF0IGltcGxlbWVudCBlZGl0aW5nXG5mdW5jdGlvbmFsaXR5IHRvIGRldGVybWluZSB3aGV0aGVyIHRoZXkgc2hvdWxkIGFwcGx5LiBJdFxuZGVmYXVsdHMgdG8gZmFsc2UsIGJ1dCB3aGVuIGl0cyBoaWdoZXN0LXByZWNlZGVuY2UgdmFsdWUgaXNcbmB0cnVlYCwgc3VjaCBmdW5jdGlvbmFsaXR5IGRpc2FibGVzIGl0c2VsZi5cblxuTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGhcbltgRWRpdG9yVmlldy5lZGl0YWJsZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmVkaXRhYmxlKSwgd2hpY2hcbmNvbnRyb2xzIHdoZXRoZXIgdGhlIGVkaXRvcidzIERPTSBpcyBzZXQgdG8gYmUgZWRpdGFibGUgKGFuZFxudGh1cyBmb2N1c2FibGUpLlxuKi9cbkVkaXRvclN0YXRlLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4vKipcblJlZ2lzdGVycyB0cmFuc2xhdGlvbiBwaHJhc2VzLiBUaGVcbltgcGhyYXNlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5waHJhc2UpIG1ldGhvZCB3aWxsIGxvb2sgdGhyb3VnaFxuYWxsIG9iamVjdHMgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgZmFjZXQgdG8gZmluZCB0cmFuc2xhdGlvbnMgZm9yXG5pdHMgYXJndW1lbnQuXG4qL1xuRWRpdG9yU3RhdGUucGhyYXNlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbXBhcmUoYSwgYikge1xuICAgICAgICBsZXQga0EgPSBPYmplY3Qua2V5cyhhKSwga0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtBLmxlbmd0aCA9PSBrQi5sZW5ndGggJiYga0EuZXZlcnkoayA9PiBhW2tdID09IGJba10pO1xuICAgIH1cbn0pO1xuLyoqXG5BIGZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgW2xhbmd1YWdlXG5kYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSBwcm92aWRlcnMuXG4qL1xuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhID0gbGFuZ3VhZ2VEYXRhO1xuLyoqXG5GYWNldCB1c2VkIHRvIHJlZ2lzdGVyIGNoYW5nZSBmaWx0ZXJzLCB3aGljaCBhcmUgY2FsbGVkIGZvciBlYWNoXG50cmFuc2FjdGlvbiAodW5sZXNzIGV4cGxpY2l0bHlcbltkaXNhYmxlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSksIGFuZCBjYW4gc3VwcHJlc3NcbnBhcnQgb2YgdGhlIHRyYW5zYWN0aW9uJ3MgY2hhbmdlcy5cblxuU3VjaCBhIGZ1bmN0aW9uIGNhbiByZXR1cm4gYHRydWVgIHRvIGluZGljYXRlIHRoYXQgaXQgZG9lc24ndFxud2FudCB0byBkbyBhbnl0aGluZywgYGZhbHNlYCB0byBjb21wbGV0ZWx5IHN0b3AgdGhlIGNoYW5nZXMgaW5cbnRoZSB0cmFuc2FjdGlvbiwgb3IgYSBzZXQgb2YgcmFuZ2VzIGluIHdoaWNoIGNoYW5nZXMgc2hvdWxkIGJlXG5zdXBwcmVzc2VkLiBTdWNoIHJhbmdlcyBhcmUgcmVwcmVzZW50ZWQgYXMgYW4gYXJyYXkgb2YgbnVtYmVycyxcbndpdGggZWFjaCBwYWlyIG9mIHR3byBudW1iZXJzIGluZGljYXRpbmcgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgYVxucmFuZ2UuIFNvIGZvciBleGFtcGxlIGBbMTAsIDIwLCAxMDAsIDExMF1gIHN1cHByZXNzZXMgY2hhbmdlc1xuYmV0d2VlbiAxMCBhbmQgMjAsIGFuZCBiZXR3ZWVuIDEwMCBhbmQgMTEwLlxuKi9cbkVkaXRvclN0YXRlLmNoYW5nZUZpbHRlciA9IGNoYW5nZUZpbHRlcjtcbi8qKlxuRmFjZXQgdXNlZCB0byByZWdpc3RlciBhIGhvb2sgdGhhdCBnZXRzIGEgY2hhbmNlIHRvIHVwZGF0ZSBvclxucmVwbGFjZSB0cmFuc2FjdGlvbiBzcGVjcyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZC4gVGhpcyB3aWxsXG5vbmx5IGJlIGFwcGxpZWQgZm9yIHRyYW5zYWN0aW9ucyB0aGF0IGRvbid0IGhhdmVcbltgZmlsdGVyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZmlsdGVyKSBzZXQgdG8gYGZhbHNlYC4gWW91XG5jYW4gZWl0aGVyIHJldHVybiBhIHNpbmdsZSB0cmFuc2FjdGlvbiBzcGVjIChwb3NzaWJseSB0aGUgaW5wdXRcbnRyYW5zYWN0aW9uKSwgb3IgYW4gYXJyYXkgb2Ygc3BlY3MgKHdoaWNoIHdpbGwgYmUgY29tYmluZWQgaW5cbnRoZSBzYW1lIHdheSBhcyB0aGUgYXJndW1lbnRzIHRvXG5bYEVkaXRvclN0YXRlLnVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKSkuXG5cbldoZW4gcG9zc2libGUsIGl0IGlzIHJlY29tbWVuZGVkIHRvIGF2b2lkIGFjY2Vzc2luZ1xuW2BUcmFuc2FjdGlvbi5zdGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc3RhdGUpIGluIGEgZmlsdGVyLFxuc2luY2UgaXQgd2lsbCBmb3JjZSBjcmVhdGlvbiBvZiBhIHN0YXRlIHRoYXQgd2lsbCB0aGVuIGJlXG5kaXNjYXJkZWQgYWdhaW4sIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhY3R1YWxseSBmaWx0ZXJlZC5cblxuKFRoaXMgZnVuY3Rpb25hbGl0eSBzaG91bGQgYmUgdXNlZCB3aXRoIGNhcmUuIEluZGlzY3JpbWluYXRlbHlcbm1vZGlmeWluZyB0cmFuc2FjdGlvbiBpcyBsaWtlbHkgdG8gYnJlYWsgc29tZXRoaW5nIG9yIGRlZ3JhZGVcbnRoZSB1c2VyIGV4cGVyaWVuY2UuKVxuKi9cbkVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRmlsdGVyID0gdHJhbnNhY3Rpb25GaWx0ZXI7XG4vKipcblRoaXMgaXMgYSBtb3JlIGxpbWl0ZWQgZm9ybSBvZlxuW2B0cmFuc2FjdGlvbkZpbHRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpLFxud2hpY2ggY2FuIG9ubHkgYWRkXG5bYW5ub3RhdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmFubm90YXRpb25zKSBhbmRcbltlZmZlY3RzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKS4gX0J1dF8sIHRoaXMgdHlwZVxub2YgZmlsdGVyIHJ1bnMgZXZlbiBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGRpc2FibGVkIHJlZ3VsYXJcbltmaWx0ZXJpbmddKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlciksIG1ha2luZyBpdCBzdWl0YWJsZVxuZm9yIGVmZmVjdHMgdGhhdCBkb24ndCBuZWVkIHRvIHRvdWNoIHRoZSBjaGFuZ2VzIG9yIHNlbGVjdGlvbixcbmJ1dCBkbyB3YW50IHRvIHByb2Nlc3MgZXZlcnkgdHJhbnNhY3Rpb24uXG5cbkV4dGVuZGVycyBydW4gX2FmdGVyXyBmaWx0ZXJzLCB3aGVuIGJvdGggYXJlIHByZXNlbnQuXG4qL1xuRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25FeHRlbmRlciA9IHRyYW5zYWN0aW9uRXh0ZW5kZXI7XG5Db21wYXJ0bWVudC5yZWNvbmZpZ3VyZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcblxuLyoqXG5VdGlsaXR5IGZ1bmN0aW9uIGZvciBjb21iaW5pbmcgYmVoYXZpb3JzIHRvIGZpbGwgaW4gYSBjb25maWdcbm9iamVjdCBmcm9tIGFuIGFycmF5IG9mIHByb3ZpZGVkIGNvbmZpZ3MuIGBkZWZhdWx0c2Agc2hvdWxkIGhvbGRcbmRlZmF1bHQgdmFsdWVzIGZvciBhbGwgb3B0aW9uYWwgZmllbGRzIGluIGBDb25maWdgLlxuXG5UaGUgZnVuY3Rpb24gd2lsbCwgYnkgZGVmYXVsdCwgZXJyb3JcbndoZW4gYSBmaWVsZCBnZXRzIHR3byB2YWx1ZXMgdGhhdCBhcmVuJ3QgYD09PWAtZXF1YWwsIGJ1dCB5b3UgY2FuXG5wcm92aWRlIGNvbWJpbmUgZnVuY3Rpb25zIHBlciBmaWVsZCB0byBkbyBzb21ldGhpbmcgZWxzZS5cbiovXG5mdW5jdGlvbiBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIGRlZmF1bHRzLCAvLyBTaG91bGQgaG9sZCBvbmx5IHRoZSBvcHRpb25hbCBwcm9wZXJ0aWVzIG9mIENvbmZpZywgYnV0IEkgaGF2ZW4ndCBtYW5hZ2VkIHRvIGV4cHJlc3MgdGhhdFxuY29tYmluZSA9IHt9KSB7XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKVxuICAgICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXMoY29uZmlnKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gY29uZmlnW2tleV0sIGN1cnJlbnQgPSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnQgPT09IHZhbHVlIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIDsgLy8gTm8gY29uZmxpY3RcbiAgICAgICAgICAgIGVsc2UgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbWJpbmUsIGtleSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBjb21iaW5lW2tleV0oY3VycmVudCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbmZpZyBtZXJnZSBjb25mbGljdCBmb3IgZmllbGQgXCIgKyBrZXkpO1xuICAgICAgICB9XG4gICAgZm9yIChsZXQga2V5IGluIGRlZmF1bHRzKVxuICAgICAgICBpZiAocmVzdWx0W2tleV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbkVhY2ggcmFuZ2UgaXMgYXNzb2NpYXRlZCB3aXRoIGEgdmFsdWUsIHdoaWNoIG11c3QgaW5oZXJpdCBmcm9tXG50aGlzIGNsYXNzLlxuKi9cbmNsYXNzIFJhbmdlVmFsdWUge1xuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyB2YWx1ZSB3aXRoIGFub3RoZXIgdmFsdWUuIFVzZWQgd2hlbiBjb21wYXJpbmdcbiAgICByYW5nZXNldHMuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGNvbXBhcmVzIGJ5IGlkZW50aXR5LlxuICAgIFVubGVzcyB5b3UgYXJlIG9ubHkgY3JlYXRpbmcgYSBmaXhlZCBudW1iZXIgb2YgdW5pcXVlIGluc3RhbmNlc1xuICAgIG9mIHlvdXIgdmFsdWUgdHlwZSwgaXQgaXMgYSBnb29kIGlkZWEgdG8gaW1wbGVtZW50IHRoaXNcbiAgICBwcm9wZXJseS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiB0aGlzID09IG90aGVyOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgW3JhbmdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSB3aXRoIHRoaXMgdmFsdWUuXG4gICAgKi9cbiAgICByYW5nZShmcm9tLCB0byA9IGZyb20pIHsgcmV0dXJuIFJhbmdlLmNyZWF0ZShmcm9tLCB0bywgdGhpcyk7IH1cbn1cblJhbmdlVmFsdWUucHJvdG90eXBlLnN0YXJ0U2lkZSA9IFJhbmdlVmFsdWUucHJvdG90eXBlLmVuZFNpZGUgPSAwO1xuUmFuZ2VWYWx1ZS5wcm90b3R5cGUucG9pbnQgPSBmYWxzZTtcblJhbmdlVmFsdWUucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrRGVsO1xuLyoqXG5BIHJhbmdlIGFzc29jaWF0ZXMgYSB2YWx1ZSB3aXRoIGEgcmFuZ2Ugb2YgcG9zaXRpb25zLlxuKi9cbmNsYXNzIFJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcmFuZ2UncyBzdGFydCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIEl0cyBlbmQgcG9zaXRpb24uXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJhbmdlLlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShmcm9tLCB0bywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShmcm9tLCB0bywgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNtcFJhbmdlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5mcm9tIC0gYi5mcm9tIHx8IGEudmFsdWUuc3RhcnRTaWRlIC0gYi52YWx1ZS5zdGFydFNpZGU7XG59XG5jbGFzcyBDaHVuayB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHZhbHVlLCBcbiAgICAvLyBDaHVua3MgYXJlIG1hcmtlZCB3aXRoIHRoZSBsYXJnZXN0IHBvaW50IHRoYXQgb2NjdXJzXG4gICAgLy8gaW4gdGhlbSAob3IgLTEgZm9yIG5vIHBvaW50cyksIHNvIHRoYXQgc2NhbnMgdGhhdCBhcmVcbiAgICAvLyBvbmx5IGludGVyZXN0ZWQgaW4gcG9pbnRzIChzdWNoIGFzIHRoZVxuICAgIC8vIGhlaWdodG1hcC1yZWxhdGVkIGxvZ2ljKSBjYW4gc2tpcCByYW5nZS1vbmx5IGNodW5rcy5cbiAgICBtYXhQb2ludCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IG1heFBvaW50O1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50b1t0aGlzLnRvLmxlbmd0aCAtIDFdOyB9XG4gICAgLy8gRmluZCB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHBvc2l0aW9uIGFuZCBzaWRlLiBVc2UgdGhlIHJhbmdlcydcbiAgICAvLyBgZnJvbWAgcG9zIHdoZW4gYGVuZCA9PSBmYWxzZWAsIGB0b2Agd2hlbiBgZW5kID09IHRydWVgLlxuICAgIGZpbmRJbmRleChwb3MsIHNpZGUsIGVuZCwgc3RhcnRBdCA9IDApIHtcbiAgICAgICAgbGV0IGFyciA9IGVuZCA/IHRoaXMudG8gOiB0aGlzLmZyb207XG4gICAgICAgIGZvciAobGV0IGxvID0gc3RhcnRBdCwgaGkgPSBhcnIubGVuZ3RoOzspIHtcbiAgICAgICAgICAgIGlmIChsbyA9PSBoaSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbG87XG4gICAgICAgICAgICBsZXQgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgICAgICAgICBsZXQgZGlmZiA9IGFyclttaWRdIC0gcG9zIHx8IChlbmQgPyB0aGlzLnZhbHVlW21pZF0uZW5kU2lkZSA6IHRoaXMudmFsdWVbbWlkXS5zdGFydFNpZGUpIC0gc2lkZTtcbiAgICAgICAgICAgIGlmIChtaWQgPT0gbG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgPj0gMCA/IGxvIDogaGk7XG4gICAgICAgICAgICBpZiAoZGlmZiA+PSAwKVxuICAgICAgICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBiZXR3ZWVuKG9mZnNldCwgZnJvbSwgdG8sIGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmluZEluZGV4KGZyb20sIC0xMDAwMDAwMDAwIC8qIEMuRmFyICovLCB0cnVlKSwgZSA9IHRoaXMuZmluZEluZGV4KHRvLCAxMDAwMDAwMDAwIC8qIEMuRmFyICovLCBmYWxzZSwgaSk7IGkgPCBlOyBpKyspXG4gICAgICAgICAgICBpZiAoZih0aGlzLmZyb21baV0gKyBvZmZzZXQsIHRoaXMudG9baV0gKyBvZmZzZXQsIHRoaXMudmFsdWVbaV0pID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1hcChvZmZzZXQsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gW10sIGZyb20gPSBbXSwgdG8gPSBbXSwgbmV3UG9zID0gLTEsIG1heFBvaW50ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbCA9IHRoaXMudmFsdWVbaV0sIGN1ckZyb20gPSB0aGlzLmZyb21baV0gKyBvZmZzZXQsIGN1clRvID0gdGhpcy50b1tpXSArIG9mZnNldCwgbmV3RnJvbSwgbmV3VG87XG4gICAgICAgICAgICBpZiAoY3VyRnJvbSA9PSBjdXJUbykge1xuICAgICAgICAgICAgICAgIGxldCBtYXBwZWQgPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuc3RhcnRTaWRlLCB2YWwubWFwTW9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBuZXdGcm9tID0gbmV3VG8gPSBtYXBwZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5zdGFydFNpZGUgIT0gdmFsLmVuZFNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VG8gPSBjaGFuZ2VzLm1hcFBvcyhjdXJGcm9tLCB2YWwuZW5kU2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdUbyA8IG5ld0Zyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdGcm9tID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLnN0YXJ0U2lkZSk7XG4gICAgICAgICAgICAgICAgbmV3VG8gPSBjaGFuZ2VzLm1hcFBvcyhjdXJUbywgdmFsLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdGcm9tID4gbmV3VG8gfHwgbmV3RnJvbSA9PSBuZXdUbyAmJiB2YWwuc3RhcnRTaWRlID4gMCAmJiB2YWwuZW5kU2lkZSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobmV3VG8gLSBuZXdGcm9tIHx8IHZhbC5lbmRTaWRlIC0gdmFsLnN0YXJ0U2lkZSkgPCAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKG5ld1BvcyA8IDApXG4gICAgICAgICAgICAgICAgbmV3UG9zID0gbmV3RnJvbTtcbiAgICAgICAgICAgIGlmICh2YWwucG9pbnQpXG4gICAgICAgICAgICAgICAgbWF4UG9pbnQgPSBNYXRoLm1heChtYXhQb2ludCwgbmV3VG8gLSBuZXdGcm9tKTtcbiAgICAgICAgICAgIHZhbHVlLnB1c2godmFsKTtcbiAgICAgICAgICAgIGZyb20ucHVzaChuZXdGcm9tIC0gbmV3UG9zKTtcbiAgICAgICAgICAgIHRvLnB1c2gobmV3VG8gLSBuZXdQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hcHBlZDogdmFsdWUubGVuZ3RoID8gbmV3IENodW5rKGZyb20sIHRvLCB2YWx1ZSwgbWF4UG9pbnQpIDogbnVsbCwgcG9zOiBuZXdQb3MgfTtcbiAgICB9XG59XG4vKipcbkEgcmFuZ2Ugc2V0IHN0b3JlcyBhIGNvbGxlY3Rpb24gb2YgW3Jhbmdlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgaW4gYVxud2F5IHRoYXQgbWFrZXMgdGhlbSBlZmZpY2llbnQgdG8gW21hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldC5tYXApIGFuZFxuW3VwZGF0ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZVNldC51cGRhdGUpLiBUaGlzIGlzIGFuIGltbXV0YWJsZSBkYXRhXG5zdHJ1Y3R1cmUuXG4qL1xuY2xhc3MgUmFuZ2VTZXQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmtQb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmssIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbmV4dExheWVyLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1heFBvaW50KSB7XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBjaHVua1BvcztcbiAgICAgICAgdGhpcy5jaHVuayA9IGNodW5rO1xuICAgICAgICB0aGlzLm5leHRMYXllciA9IG5leHRMYXllcjtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IG1heFBvaW50O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoY2h1bmtQb3MsIGNodW5rLCBuZXh0TGF5ZXIsIG1heFBvaW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2VTZXQoY2h1bmtQb3MsIGNodW5rLCBuZXh0TGF5ZXIsIG1heFBvaW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY2h1bmsubGVuZ3RoIC0gMTtcbiAgICAgICAgcmV0dXJuIGxhc3QgPCAwID8gMCA6IE1hdGgubWF4KHRoaXMuY2h1bmtFbmQobGFzdCksIHRoaXMubmV4dExheWVyLmxlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgcmFuZ2VzIGluIHRoZSBzZXQuXG4gICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMubmV4dExheWVyLnNpemU7XG4gICAgICAgIGZvciAobGV0IGNodW5rIG9mIHRoaXMuY2h1bmspXG4gICAgICAgICAgICBzaXplICs9IGNodW5rLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmtFbmQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2h1bmtQb3NbaW5kZXhdICsgdGhpcy5jaHVua1tpbmRleF0ubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHJhbmdlIHNldCwgb3B0aW9uYWxseSBhZGRpbmcgbmV3IHJhbmdlcyBvciBmaWx0ZXJpbmdcbiAgICBvdXQgZXhpc3Rpbmcgb25lcy5cbiAgICBcbiAgICAoTm90ZTogVGhlIHR5cGUgcGFyYW1ldGVyIGlzIGp1c3QgdGhlcmUgYXMgYSBrbHVkZ2UgdG8gd29ya1xuICAgIGFyb3VuZCBUeXBlU2NyaXB0IHZhcmlhbmNlIGlzc3VlcyB0aGF0IHByZXZlbnRlZCBgUmFuZ2VTZXQ8WD5gXG4gICAgZnJvbSBiZWluZyBhIHN1YnR5cGUgb2YgYFJhbmdlU2V0PFk+YCB3aGVuIGBYYCBpcyBhIHN1YnR5cGUgb2ZcbiAgICBgWWAuKVxuICAgICovXG4gICAgdXBkYXRlKHVwZGF0ZVNwZWMpIHtcbiAgICAgICAgbGV0IHsgYWRkID0gW10sIHNvcnQgPSBmYWxzZSwgZmlsdGVyRnJvbSA9IDAsIGZpbHRlclRvID0gdGhpcy5sZW5ndGggfSA9IHVwZGF0ZVNwZWM7XG4gICAgICAgIGxldCBmaWx0ZXIgPSB1cGRhdGVTcGVjLmZpbHRlcjtcbiAgICAgICAgaWYgKGFkZC5sZW5ndGggPT0gMCAmJiAhZmlsdGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChzb3J0KVxuICAgICAgICAgICAgYWRkID0gYWRkLnNsaWNlKCkuc29ydChjbXBSYW5nZSk7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gYWRkLmxlbmd0aCA/IFJhbmdlU2V0Lm9mKGFkZCkgOiB0aGlzO1xuICAgICAgICBsZXQgY3VyID0gbmV3IExheWVyQ3Vyc29yKHRoaXMsIG51bGwsIC0xKS5nb3RvKDApLCBpID0gMCwgc3BpbGwgPSBbXTtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIHdoaWxlIChjdXIudmFsdWUgfHwgaSA8IGFkZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIDwgYWRkLmxlbmd0aCAmJiAoY3VyLmZyb20gLSBhZGRbaV0uZnJvbSB8fCBjdXIuc3RhcnRTaWRlIC0gYWRkW2ldLnZhbHVlLnN0YXJ0U2lkZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGFkZFtpKytdO1xuICAgICAgICAgICAgICAgIGlmICghYnVpbGRlci5hZGRJbm5lcihyYW5nZS5mcm9tLCByYW5nZS50bywgcmFuZ2UudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICBzcGlsbC5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1ci5yYW5nZUluZGV4ID09IDEgJiYgY3VyLmNodW5rSW5kZXggPCB0aGlzLmNodW5rLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIChpID09IGFkZC5sZW5ndGggfHwgdGhpcy5jaHVua0VuZChjdXIuY2h1bmtJbmRleCkgPCBhZGRbaV0uZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAoIWZpbHRlciB8fCBmaWx0ZXJGcm9tID4gdGhpcy5jaHVua0VuZChjdXIuY2h1bmtJbmRleCkgfHwgZmlsdGVyVG8gPCB0aGlzLmNodW5rUG9zW2N1ci5jaHVua0luZGV4XSkgJiZcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZENodW5rKHRoaXMuY2h1bmtQb3NbY3VyLmNodW5rSW5kZXhdLCB0aGlzLmNodW5rW2N1ci5jaHVua0luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBjdXIubmV4dENodW5rKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXJGcm9tID4gY3VyLnRvIHx8IGZpbHRlclRvIDwgY3VyLmZyb20gfHwgZmlsdGVyKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFidWlsZGVyLmFkZElubmVyKGN1ci5mcm9tLCBjdXIudG8sIGN1ci52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGlsbC5wdXNoKFJhbmdlLmNyZWF0ZShjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2hJbm5lcih0aGlzLm5leHRMYXllci5pc0VtcHR5ICYmICFzcGlsbC5sZW5ndGggPyBSYW5nZVNldC5lbXB0eVxuICAgICAgICAgICAgOiB0aGlzLm5leHRMYXllci51cGRhdGUoeyBhZGQ6IHNwaWxsLCBmaWx0ZXIsIGZpbHRlckZyb20sIGZpbHRlclRvIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgcmFuZ2Ugc2V0IHRocm91Z2ggYSBzZXQgb2YgY2hhbmdlcywgcmV0dXJuIHRoZSBuZXcgc2V0LlxuICAgICovXG4gICAgbWFwKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuZW1wdHkgfHwgdGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBjaHVua3MgPSBbXSwgY2h1bmtQb3MgPSBbXSwgbWF4UG9pbnQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLmNodW5rUG9zW2ldLCBjaHVuayA9IHRoaXMuY2h1bmtbaV07XG4gICAgICAgICAgICBsZXQgdG91Y2ggPSBjaGFuZ2VzLnRvdWNoZXNSYW5nZShzdGFydCwgc3RhcnQgKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHRvdWNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIGNodW5rLm1heFBvaW50KTtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgY2h1bmtQb3MucHVzaChjaGFuZ2VzLm1hcFBvcyhzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG91Y2ggPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBtYXBwZWQsIHBvcyB9ID0gY2h1bmsubWFwKHN0YXJ0LCBjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIG1hcHBlZC5tYXhQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rUG9zLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLm5leHRMYXllci5tYXAoY2hhbmdlcyk7XG4gICAgICAgIHJldHVybiBjaHVua3MubGVuZ3RoID09IDAgPyBuZXh0IDogbmV3IFJhbmdlU2V0KGNodW5rUG9zLCBjaHVua3MsIG5leHQgfHwgUmFuZ2VTZXQuZW1wdHksIG1heFBvaW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgdGhhdCB0b3VjaCB0aGUgcmVnaW9uIGBmcm9tYCB0byBgdG9gLFxuICAgIGNhbGxpbmcgYGZgIGZvciBlYWNoLiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgcmFuZ2VzIHdpbGxcbiAgICBiZSByZXBvcnRlZCBpbiBhbnkgc3BlY2lmaWMgb3JkZXIuIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgICBgZmFsc2VgLCBpdGVyYXRpb24gc3RvcHMuXG4gICAgKi9cbiAgICBiZXR3ZWVuKGZyb20sIHRvLCBmKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jaHVua1Bvc1tpXSwgY2h1bmsgPSB0aGlzLmNodW5rW2ldO1xuICAgICAgICAgICAgaWYgKHRvID49IHN0YXJ0ICYmIGZyb20gPD0gc3RhcnQgKyBjaHVuay5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBjaHVuay5iZXR3ZWVuKHN0YXJ0LCBmcm9tIC0gc3RhcnQsIHRvIC0gc3RhcnQsIGYpID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0TGF5ZXIuYmV0d2Vlbihmcm9tLCB0bywgZik7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIGluIHRoaXMgc2V0LCBpbiBvcmRlciwgaW5jbHVkaW5nIGFsbFxuICAgIHJhbmdlcyB0aGF0IGVuZCBhdCBvciBhZnRlciBgZnJvbWAuXG4gICAgKi9cbiAgICBpdGVyKGZyb20gPSAwKSB7XG4gICAgICAgIHJldHVybiBIZWFwQ3Vyc29yLmZyb20oW3RoaXNdKS5nb3RvKGZyb20pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpc0VtcHR5KCkgeyByZXR1cm4gdGhpcy5uZXh0TGF5ZXIgPT0gdGhpczsgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIGluIGEgY29sbGVjdGlvbiBvZiBzZXRzLCBpbiBvcmRlcixcbiAgICBzdGFydGluZyBmcm9tIGBmcm9tYC5cbiAgICAqL1xuICAgIHN0YXRpYyBpdGVyKHNldHMsIGZyb20gPSAwKSB7XG4gICAgICAgIHJldHVybiBIZWFwQ3Vyc29yLmZyb20oc2V0cykuZ290byhmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHR3byBncm91cHMgb2Ygc2V0cywgY2FsbGluZyBtZXRob2RzIG9uIGBjb21wYXJhdG9yYFxuICAgIHRvIG5vdGlmeSBpdCBvZiBwb3NzaWJsZSBkaWZmZXJlbmNlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlKG9sZFNldHMsIG5ld1NldHMsIFxuICAgIC8qKlxuICAgIFRoaXMgaW5kaWNhdGVzIGhvdyB0aGUgdW5kZXJseWluZyBkYXRhIGNoYW5nZWQgYmV0d2VlbiB0aGVzZVxuICAgIHJhbmdlcywgYW5kIGlzIG5lZWRlZCB0byBzeW5jaHJvbml6ZSB0aGUgaXRlcmF0aW9uLlxuICAgICovXG4gICAgdGV4dERpZmYsIGNvbXBhcmF0b3IsIFxuICAgIC8qKlxuICAgIENhbiBiZSB1c2VkIHRvIGlnbm9yZSBhbGwgbm9uLXBvaW50IHJhbmdlcywgYW5kIHBvaW50cyBiZWxvd1xuICAgIHRoZSBnaXZlbiBzaXplLiBXaGVuIC0xLCBhbGwgcmFuZ2VzIGFyZSBjb21wYXJlZC5cbiAgICAqL1xuICAgIG1pblBvaW50U2l6ZSA9IC0xKSB7XG4gICAgICAgIGxldCBhID0gb2xkU2V0cy5maWx0ZXIoc2V0ID0+IHNldC5tYXhQb2ludCA+IDAgfHwgIXNldC5pc0VtcHR5ICYmIHNldC5tYXhQb2ludCA+PSBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgYiA9IG5ld1NldHMuZmlsdGVyKHNldCA9PiBzZXQubWF4UG9pbnQgPiAwIHx8ICFzZXQuaXNFbXB0eSAmJiBzZXQubWF4UG9pbnQgPj0gbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IHNoYXJlZENodW5rcyA9IGZpbmRTaGFyZWRDaHVua3MoYSwgYiwgdGV4dERpZmYpO1xuICAgICAgICBsZXQgc2lkZUEgPSBuZXcgU3BhbkN1cnNvcihhLCBzaGFyZWRDaHVua3MsIG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBzaWRlQiA9IG5ldyBTcGFuQ3Vyc29yKGIsIHNoYXJlZENodW5rcywgbWluUG9pbnRTaXplKTtcbiAgICAgICAgdGV4dERpZmYuaXRlckdhcHMoKGZyb21BLCBmcm9tQiwgbGVuZ3RoKSA9PiBjb21wYXJlKHNpZGVBLCBmcm9tQSwgc2lkZUIsIGZyb21CLCBsZW5ndGgsIGNvbXBhcmF0b3IpKTtcbiAgICAgICAgaWYgKHRleHREaWZmLmVtcHR5ICYmIHRleHREaWZmLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgY29tcGFyZShzaWRlQSwgMCwgc2lkZUIsIDAsIDAsIGNvbXBhcmF0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoZSBjb250ZW50cyBvZiB0d28gZ3JvdXBzIG9mIHJhbmdlIHNldHMsIHJldHVybmluZyB0cnVlXG4gICAgaWYgdGhleSBhcmUgZXF1aXZhbGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAgKi9cbiAgICBzdGF0aWMgZXEob2xkU2V0cywgbmV3U2V0cywgZnJvbSA9IDAsIHRvKSB7XG4gICAgICAgIGlmICh0byA9PSBudWxsKVxuICAgICAgICAgICAgdG8gPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovIC0gMTtcbiAgICAgICAgbGV0IGEgPSBvbGRTZXRzLmZpbHRlcihzZXQgPT4gIXNldC5pc0VtcHR5ICYmIG5ld1NldHMuaW5kZXhPZihzZXQpIDwgMCk7XG4gICAgICAgIGxldCBiID0gbmV3U2V0cy5maWx0ZXIoc2V0ID0+ICFzZXQuaXNFbXB0eSAmJiBvbGRTZXRzLmluZGV4T2Yoc2V0KSA8IDApO1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghYS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IHNoYXJlZENodW5rcyA9IGZpbmRTaGFyZWRDaHVua3MoYSwgYik7XG4gICAgICAgIGxldCBzaWRlQSA9IG5ldyBTcGFuQ3Vyc29yKGEsIHNoYXJlZENodW5rcywgMCkuZ290byhmcm9tKSwgc2lkZUIgPSBuZXcgU3BhbkN1cnNvcihiLCBzaGFyZWRDaHVua3MsIDApLmdvdG8oZnJvbSk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChzaWRlQS50byAhPSBzaWRlQi50byB8fFxuICAgICAgICAgICAgICAgICFzYW1lVmFsdWVzKHNpZGVBLmFjdGl2ZSwgc2lkZUIuYWN0aXZlKSB8fFxuICAgICAgICAgICAgICAgIHNpZGVBLnBvaW50ICYmICghc2lkZUIucG9pbnQgfHwgIXNpZGVBLnBvaW50LmVxKHNpZGVCLnBvaW50KSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNpZGVBLnRvID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzaWRlQS5uZXh0KCk7XG4gICAgICAgICAgICBzaWRlQi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIGEgZ3JvdXAgb2YgcmFuZ2Ugc2V0cyBhdCB0aGUgc2FtZSB0aW1lLCBub3RpZnlpbmdcbiAgICB0aGUgaXRlcmF0b3IgYWJvdXQgdGhlIHJhbmdlcyBjb3ZlcmluZyBldmVyeSBnaXZlbiBwaWVjZSBvZlxuICAgIGNvbnRlbnQuIFJldHVybnMgdGhlIG9wZW4gY291bnQgKHNlZVxuICAgIFtgU3Bhbkl0ZXJhdG9yLnNwYW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNwYW5JdGVyYXRvci5zcGFuKSkgYXQgdGhlIGVuZFxuICAgIG9mIHRoZSBpdGVyYXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgc3BhbnMoc2V0cywgZnJvbSwgdG8sIGl0ZXJhdG9yLCBcbiAgICAvKipcbiAgICBXaGVuIGdpdmVuIGFuZCBncmVhdGVyIHRoYW4gLTEsIG9ubHkgcG9pbnRzIG9mIGF0IGxlYXN0IHRoaXNcbiAgICBzaXplIGFyZSB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAgKi9cbiAgICBtaW5Qb2ludFNpemUgPSAtMSkge1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFNwYW5DdXJzb3Ioc2V0cywgbnVsbCwgbWluUG9pbnRTaXplKS5nb3RvKGZyb20pLCBwb3MgPSBmcm9tO1xuICAgICAgICBsZXQgb3BlblJhbmdlcyA9IGN1cnNvci5vcGVuU3RhcnQ7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBjdXJUbyA9IE1hdGgubWluKGN1cnNvci50bywgdG8pO1xuICAgICAgICAgICAgaWYgKGN1cnNvci5wb2ludCkge1xuICAgICAgICAgICAgICAgIGxldCBhY3RpdmUgPSBjdXJzb3IuYWN0aXZlRm9yUG9pbnQoY3Vyc29yLnRvKTtcbiAgICAgICAgICAgICAgICBsZXQgb3BlbkNvdW50ID0gY3Vyc29yLnBvaW50RnJvbSA8IGZyb20gPyBhY3RpdmUubGVuZ3RoICsgMVxuICAgICAgICAgICAgICAgICAgICA6IGN1cnNvci5wb2ludC5zdGFydFNpZGUgPCAwID8gYWN0aXZlLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbihhY3RpdmUubGVuZ3RoLCBvcGVuUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5wb2ludChwb3MsIGN1clRvLCBjdXJzb3IucG9pbnQsIGFjdGl2ZSwgb3BlbkNvdW50LCBjdXJzb3IucG9pbnRSYW5rKTtcbiAgICAgICAgICAgICAgICBvcGVuUmFuZ2VzID0gTWF0aC5taW4oY3Vyc29yLm9wZW5FbmQoY3VyVG8pLCBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1clRvID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iuc3Bhbihwb3MsIGN1clRvLCBjdXJzb3IuYWN0aXZlLCBvcGVuUmFuZ2VzKTtcbiAgICAgICAgICAgICAgICBvcGVuUmFuZ2VzID0gY3Vyc29yLm9wZW5FbmQoY3VyVG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnNvci50byA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcGVuUmFuZ2VzICsgKGN1cnNvci5wb2ludCAmJiBjdXJzb3IudG8gPiB0byA/IDEgOiAwKTtcbiAgICAgICAgICAgIHBvcyA9IGN1cnNvci50bztcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmFuZ2Ugc2V0IGZvciB0aGUgZ2l2ZW4gcmFuZ2Ugb3IgYXJyYXkgb2YgcmFuZ2VzLiBCeVxuICAgIGRlZmF1bHQsIHRoaXMgZXhwZWN0cyB0aGUgcmFuZ2VzIHRvIGJlIF9zb3J0ZWRfIChieSBzdGFydFxuICAgIHBvc2l0aW9uIGFuZCwgaWYgdHdvIHN0YXJ0IGF0IHRoZSBzYW1lIHBvc2l0aW9uLFxuICAgIGB2YWx1ZS5zdGFydFNpZGVgKS4gWW91IGNhbiBwYXNzIGB0cnVlYCBhcyBzZWNvbmQgYXJndW1lbnQgdG9cbiAgICBjYXVzZSB0aGUgbWV0aG9kIHRvIHNvcnQgdGhlbS5cbiAgICAqL1xuICAgIHN0YXRpYyBvZihyYW5nZXMsIHNvcnQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgYnVpbGQgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHJhbmdlIG9mIHJhbmdlcyBpbnN0YW5jZW9mIFJhbmdlID8gW3Jhbmdlc10gOiBzb3J0ID8gbGF6eVNvcnQocmFuZ2VzKSA6IHJhbmdlcylcbiAgICAgICAgICAgIGJ1aWxkLmFkZChyYW5nZS5mcm9tLCByYW5nZS50bywgcmFuZ2UudmFsdWUpO1xuICAgICAgICByZXR1cm4gYnVpbGQuZmluaXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEpvaW4gYW4gYXJyYXkgb2YgcmFuZ2Ugc2V0cyBpbnRvIGEgc2luZ2xlIHNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBqb2luKHNldHMpIHtcbiAgICAgICAgaWYgKCFzZXRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBSYW5nZVNldC5lbXB0eTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNldHNbc2V0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHNldHMubGVuZ3RoIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGxheWVyID0gc2V0c1tpXTsgbGF5ZXIgIT0gUmFuZ2VTZXQuZW1wdHk7IGxheWVyID0gbGF5ZXIubmV4dExheWVyKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBSYW5nZVNldChsYXllci5jaHVua1BvcywgbGF5ZXIuY2h1bmssIHJlc3VsdCwgTWF0aC5tYXgobGF5ZXIubWF4UG9pbnQsIHJlc3VsdC5tYXhQb2ludCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIHJhbmdlcy5cbiovXG5SYW5nZVNldC5lbXB0eSA9IC8qQF9fUFVSRV9fKi9uZXcgUmFuZ2VTZXQoW10sIFtdLCBudWxsLCAtMSk7XG5mdW5jdGlvbiBsYXp5U29ydChyYW5nZXMpIHtcbiAgICBpZiAocmFuZ2VzLmxlbmd0aCA+IDEpXG4gICAgICAgIGZvciAobGV0IHByZXYgPSByYW5nZXNbMF0sIGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKGNtcFJhbmdlKHByZXYsIGN1cikgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZXMuc2xpY2UoKS5zb3J0KGNtcFJhbmdlKTtcbiAgICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuUmFuZ2VTZXQuZW1wdHkubmV4dExheWVyID0gUmFuZ2VTZXQuZW1wdHk7XG4vKipcbkEgcmFuZ2Ugc2V0IGJ1aWxkZXIgaXMgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGhlbHBzIGJ1aWxkIHVwIGFcbltyYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2VTZXQpIGRpcmVjdGx5LCB3aXRob3V0IGZpcnN0IGFsbG9jYXRpbmdcbmFuIGFycmF5IG9mIFtgUmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlKSBvYmplY3RzLlxuKi9cbmNsYXNzIFJhbmdlU2V0QnVpbGRlciB7XG4gICAgZmluaXNoQ2h1bmsobmV3QXJyYXlzKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IENodW5rKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy52YWx1ZSwgdGhpcy5tYXhQb2ludCkpO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCB0aGlzLm1heFBvaW50KTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IC0xO1xuICAgICAgICBpZiAobmV3QXJyYXlzKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSBbXTtcbiAgICAgICAgICAgIHRoaXMudG8gPSBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZW1wdHkgYnVpbGRlci5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rUG9zID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3QgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgIHRoaXMubGFzdFRvID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgIHRoaXMuZnJvbSA9IFtdO1xuICAgICAgICB0aGlzLnRvID0gW107XG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcbiAgICAgICAgdGhpcy5tYXhQb2ludCA9IC0xO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gLTE7XG4gICAgICAgIHRoaXMubmV4dExheWVyID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgcmFuZ2UuIFJhbmdlcyBzaG91bGQgYmUgYWRkZWQgaW4gc29ydGVkIChieSBgZnJvbWAgYW5kXG4gICAgYHZhbHVlLnN0YXJ0U2lkZWApIG9yZGVyLlxuICAgICovXG4gICAgYWRkKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSlcbiAgICAgICAgICAgICh0aGlzLm5leHRMYXllciB8fCAodGhpcy5uZXh0TGF5ZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKSkuYWRkKGZyb20sIHRvLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIGxldCBkaWZmID0gZnJvbSAtIHRoaXMubGFzdFRvIHx8IHZhbHVlLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5lbmRTaWRlO1xuICAgICAgICBpZiAoZGlmZiA8PSAwICYmIChmcm9tIC0gdGhpcy5sYXN0RnJvbSB8fCB2YWx1ZS5zdGFydFNpZGUgLSB0aGlzLmxhc3Quc3RhcnRTaWRlKSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZXMgbXVzdCBiZSBhZGRlZCBzb3J0ZWQgYnkgYGZyb21gIHBvc2l0aW9uIGFuZCBgc3RhcnRTaWRlYFwiKTtcbiAgICAgICAgaWYgKGRpZmYgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aCA9PSAyNTAgLyogQy5DaHVua1NpemUgKi8pXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5jaHVua1N0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMuZnJvbS5wdXNoKGZyb20gLSB0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLnRvLnB1c2godG8gLSB0aGlzLmNodW5rU3RhcnQpO1xuICAgICAgICB0aGlzLmxhc3QgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5sYXN0RnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMubGFzdFRvID0gdG87XG4gICAgICAgIHRoaXMudmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZS5wb2ludClcbiAgICAgICAgICAgIHRoaXMubWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLm1heFBvaW50LCB0byAtIGZyb20pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRDaHVuayhmcm9tLCBjaHVuaykge1xuICAgICAgICBpZiAoKGZyb20gLSB0aGlzLmxhc3RUbyB8fCBjaHVuay52YWx1ZVswXS5zdGFydFNpZGUgLSB0aGlzLmxhc3QuZW5kU2lkZSkgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsodHJ1ZSk7XG4gICAgICAgIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCBjaHVuay5tYXhQb2ludCk7XG4gICAgICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2goZnJvbSk7XG4gICAgICAgIGxldCBsYXN0ID0gY2h1bmsudmFsdWUubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5sYXN0ID0gY2h1bmsudmFsdWVbbGFzdF07XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSBjaHVuay5mcm9tW2xhc3RdICsgZnJvbTtcbiAgICAgICAgdGhpcy5sYXN0VG8gPSBjaHVuay50b1tsYXN0XSArIGZyb207XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5pc2ggdGhlIHJhbmdlIHNldC4gUmV0dXJucyB0aGUgbmV3IHNldC4gVGhlIGJ1aWxkZXIgY2FuJ3QgYmVcbiAgICB1c2VkIGFueW1vcmUgYWZ0ZXIgdGhpcyBoYXMgYmVlbiBjYWxsZWQuXG4gICAgKi9cbiAgICBmaW5pc2goKSB7IHJldHVybiB0aGlzLmZpbmlzaElubmVyKFJhbmdlU2V0LmVtcHR5KTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluaXNoSW5uZXIobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5jaHVua3MubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFJhbmdlU2V0LmNyZWF0ZSh0aGlzLmNodW5rUG9zLCB0aGlzLmNodW5rcywgdGhpcy5uZXh0TGF5ZXIgPyB0aGlzLm5leHRMYXllci5maW5pc2hJbm5lcihuZXh0KSA6IG5leHQsIHRoaXMuc2V0TWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmZyb20gPSBudWxsOyAvLyBNYWtlIHN1cmUgZnVydGhlciBgYWRkYCBjYWxscyBwcm9kdWNlIGVycm9yc1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRTaGFyZWRDaHVua3MoYSwgYiwgdGV4dERpZmYpIHtcbiAgICBsZXQgaW5BID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IHNldCBvZiBhKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXQuY2h1bmtbaV0ubWF4UG9pbnQgPD0gMClcbiAgICAgICAgICAgICAgICBpbkEuc2V0KHNldC5jaHVua1tpXSwgc2V0LmNodW5rUG9zW2ldKTtcbiAgICBsZXQgc2hhcmVkID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IHNldCBvZiBiKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGtub3duID0gaW5BLmdldChzZXQuY2h1bmtbaV0pO1xuICAgICAgICAgICAgaWYgKGtub3duICE9IG51bGwgJiYgKHRleHREaWZmID8gdGV4dERpZmYubWFwUG9zKGtub3duKSA6IGtub3duKSA9PSBzZXQuY2h1bmtQb3NbaV0gJiZcbiAgICAgICAgICAgICAgICAhKHRleHREaWZmID09PSBudWxsIHx8IHRleHREaWZmID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0RGlmZi50b3VjaGVzUmFuZ2Uoa25vd24sIGtub3duICsgc2V0LmNodW5rW2ldLmxlbmd0aCkpKVxuICAgICAgICAgICAgICAgIHNoYXJlZC5hZGQoc2V0LmNodW5rW2ldKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBzaGFyZWQ7XG59XG5jbGFzcyBMYXllckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IobGF5ZXIsIHNraXAsIG1pblBvaW50LCByYW5rID0gMCkge1xuICAgICAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuc2tpcCA9IHNraXA7XG4gICAgICAgIHRoaXMubWluUG9pbnQgPSBtaW5Qb2ludDtcbiAgICAgICAgdGhpcy5yYW5rID0gcmFuaztcbiAgICB9XG4gICAgZ2V0IHN0YXJ0U2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnN0YXJ0U2lkZSA6IDA7IH1cbiAgICBnZXQgZW5kU2lkZSgpIHsgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLmVuZFNpZGUgOiAwOyB9XG4gICAgZ290byhwb3MsIHNpZGUgPSAtMTAwMDAwMDAwMCAvKiBDLkZhciAqLykge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXggPSB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB0aGlzLmdvdG9Jbm5lcihwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdvdG9Jbm5lcihwb3MsIHNpZGUsIGZvcndhcmQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XTtcbiAgICAgICAgICAgIGlmICghKHRoaXMuc2tpcCAmJiB0aGlzLnNraXAuaGFzKG5leHQpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sYXllci5jaHVua0VuZCh0aGlzLmNodW5rSW5kZXgpIDwgcG9zIHx8XG4gICAgICAgICAgICAgICAgbmV4dC5tYXhQb2ludCA8IHRoaXMubWluUG9pbnQpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBmb3J3YXJkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VJbmRleCA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS5maW5kSW5kZXgocG9zIC0gdGhpcy5sYXllci5jaHVua1Bvc1t0aGlzLmNodW5rSW5kZXhdLCBzaWRlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghZm9yd2FyZCB8fCB0aGlzLnJhbmdlSW5kZXggPCByYW5nZUluZGV4KVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmFuZ2VJbmRleChyYW5nZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMuZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMuZ290b0lubmVyKHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rSW5kZXggPT0gdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjaHVua1BvcyA9IHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgY2h1bmsgPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF07XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaHVua1BvcyArIGNodW5rLmZyb21bdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSBjaHVua1BvcyArIGNodW5rLnRvW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGNodW5rLnZhbHVlW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluZGV4KHRoaXMucmFuZ2VJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pblBvaW50IDwgMCB8fCB0aGlzLnZhbHVlLnBvaW50ICYmIHRoaXMudG8gLSB0aGlzLmZyb20gPj0gdGhpcy5taW5Qb2ludClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UmFuZ2VJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoICYmIHRoaXMuc2tpcC5oYXModGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dENodW5rKCkge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbSAtIG90aGVyLmZyb20gfHwgdGhpcy5zdGFydFNpZGUgLSBvdGhlci5zdGFydFNpZGUgfHwgdGhpcy5yYW5rIC0gb3RoZXIucmFuayB8fFxuICAgICAgICAgICAgdGhpcy50byAtIG90aGVyLnRvIHx8IHRoaXMuZW5kU2lkZSAtIG90aGVyLmVuZFNpZGU7XG4gICAgfVxufVxuY2xhc3MgSGVhcEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaGVhcCkge1xuICAgICAgICB0aGlzLmhlYXAgPSBoZWFwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzZXRzLCBza2lwID0gbnVsbCwgbWluUG9pbnQgPSAtMSkge1xuICAgICAgICBsZXQgaGVhcCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGN1ciA9IHNldHNbaV07ICFjdXIuaXNFbXB0eTsgY3VyID0gY3VyLm5leHRMYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChjdXIubWF4UG9pbnQgPj0gbWluUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGhlYXAucHVzaChuZXcgTGF5ZXJDdXJzb3IoY3VyLCBza2lwLCBtaW5Qb2ludCwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFwLmxlbmd0aCA9PSAxID8gaGVhcFswXSA6IG5ldyBIZWFwQ3Vyc29yKGhlYXApO1xuICAgIH1cbiAgICBnZXQgc3RhcnRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuc3RhcnRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogQy5GYXIgKi8pIHtcbiAgICAgICAgZm9yIChsZXQgY3VyIG9mIHRoaXMuaGVhcClcbiAgICAgICAgICAgIGN1ci5nb3RvKHBvcywgc2lkZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmhlYXAubGVuZ3RoID4+IDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIGkpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZvcndhcmQocG9zLCBzaWRlKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXG4gICAgICAgICAgICBjdXIuZm9yd2FyZChwb3MsIHNpZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcbiAgICAgICAgaWYgKCh0aGlzLnRvIC0gcG9zIHx8IHRoaXMudmFsdWUuZW5kU2lkZSAtIHNpZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5oZWFwLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB0aGlzLnRvID0gMTAwMDAwMDAwMCAvKiBDLkZhciAqLztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yYW5rID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5oZWFwWzBdO1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdG9wLmZyb207XG4gICAgICAgICAgICB0aGlzLnRvID0gdG9wLnRvO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRvcC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucmFuayA9IHRvcC5yYW5rO1xuICAgICAgICAgICAgaWYgKHRvcC52YWx1ZSlcbiAgICAgICAgICAgICAgICB0b3AubmV4dCgpO1xuICAgICAgICAgICAgaGVhcEJ1YmJsZSh0aGlzLmhlYXAsIDApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaGVhcEJ1YmJsZShoZWFwLCBpbmRleCkge1xuICAgIGZvciAobGV0IGN1ciA9IGhlYXBbaW5kZXhdOzspIHtcbiAgICAgICAgbGV0IGNoaWxkSW5kZXggPSAoaW5kZXggPDwgMSkgKyAxO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCA+PSBoZWFwLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgY2hpbGQgPSBoZWFwW2NoaWxkSW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGRJbmRleCArIDEgPCBoZWFwLmxlbmd0aCAmJiBjaGlsZC5jb21wYXJlKGhlYXBbY2hpbGRJbmRleCArIDFdKSA+PSAwKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGhlYXBbY2hpbGRJbmRleCArIDFdO1xuICAgICAgICAgICAgY2hpbGRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXIuY29tcGFyZShjaGlsZCkgPCAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGhlYXBbY2hpbGRJbmRleF0gPSBjdXI7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gY2hpbGQ7XG4gICAgICAgIGluZGV4ID0gY2hpbGRJbmRleDtcbiAgICB9XG59XG5jbGFzcyBTcGFuQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzZXRzLCBza2lwLCBtaW5Qb2ludCkge1xuICAgICAgICB0aGlzLm1pblBvaW50ID0gbWluUG9pbnQ7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlVG8gPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVSYW5rID0gW107XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gLTE7XG4gICAgICAgIC8vIEEgY3VycmVudGx5IGFjdGl2ZSBwb2ludCByYW5nZSwgaWYgYW55XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnBvaW50RnJvbSA9IDA7XG4gICAgICAgIHRoaXMucG9pbnRSYW5rID0gMDtcbiAgICAgICAgdGhpcy50byA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSAwO1xuICAgICAgICAvLyBUaGUgYW1vdW50IG9mIG9wZW4gYWN0aXZlIHJhbmdlcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAvLyBOb3QgaW5jbHVkaW5nIHBvaW50cy5cbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBIZWFwQ3Vyc29yLmZyb20oc2V0cywgc2tpcCwgbWluUG9pbnQpO1xuICAgIH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEMuRmFyICovKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yLmdvdG8ocG9zLCBzaWRlKTtcbiAgICAgICAgdGhpcy5hY3RpdmUubGVuZ3RoID0gdGhpcy5hY3RpdmVUby5sZW5ndGggPSB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5taW5BY3RpdmUgPSAtMTtcbiAgICAgICAgdGhpcy50byA9IHBvcztcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gc2lkZTtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5taW5BY3RpdmUgPiAtMSAmJiAodGhpcy5hY3RpdmVUb1t0aGlzLm1pbkFjdGl2ZV0gLSBwb3MgfHwgdGhpcy5hY3RpdmVbdGhpcy5taW5BY3RpdmVdLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZSh0aGlzLm1pbkFjdGl2ZSk7XG4gICAgICAgIHRoaXMuY3Vyc29yLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICB9XG4gICAgcmVtb3ZlQWN0aXZlKGluZGV4KSB7XG4gICAgICAgIHJlbW92ZSh0aGlzLmFjdGl2ZSwgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVUbywgaW5kZXgpO1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmVSYW5rLCBpbmRleCk7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gZmluZE1pbkluZGV4KHRoaXMuYWN0aXZlLCB0aGlzLmFjdGl2ZVRvKTtcbiAgICB9XG4gICAgYWRkQWN0aXZlKHRyYWNrT3Blbikge1xuICAgICAgICBsZXQgaSA9IDAsIHsgdmFsdWUsIHRvLCByYW5rIH0gPSB0aGlzLmN1cnNvcjtcbiAgICAgICAgLy8gT3JnYW5pemUgYWN0aXZlIG1hcmtzIGJ5IHJhbmsgZmlyc3QsIHRoZW4gYnkgc2l6ZVxuICAgICAgICB3aGlsZSAoaSA8IHRoaXMuYWN0aXZlUmFuay5sZW5ndGggJiYgKHJhbmsgLSB0aGlzLmFjdGl2ZVJhbmtbaV0gfHwgdG8gLSB0aGlzLmFjdGl2ZVRvW2ldKSA+IDApXG4gICAgICAgICAgICBpKys7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZSwgaSwgdmFsdWUpO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmVUbywgaSwgdG8pO1xuICAgICAgICBpbnNlcnQodGhpcy5hY3RpdmVSYW5rLCBpLCByYW5rKTtcbiAgICAgICAgaWYgKHRyYWNrT3BlbilcbiAgICAgICAgICAgIGluc2VydCh0cmFja09wZW4sIGksIHRoaXMuY3Vyc29yLmZyb20pO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IGZpbmRNaW5JbmRleCh0aGlzLmFjdGl2ZSwgdGhpcy5hY3RpdmVUbyk7XG4gICAgfVxuICAgIC8vIEFmdGVyIGNhbGxpbmcgdGhpcywgaWYgYHRoaXMucG9pbnRgICE9IG51bGwsIHRoZSBuZXh0IHJhbmdlIGlzIGFcbiAgICAvLyBwb2ludC4gT3RoZXJ3aXNlLCBpdCdzIGEgcmVndWxhciByYW5nZSwgY292ZXJlZCBieSBgdGhpcy5hY3RpdmVgLlxuICAgIG5leHQoKSB7XG4gICAgICAgIGxldCBmcm9tID0gdGhpcy50bywgd2FzUG9pbnQgPSB0aGlzLnBvaW50O1xuICAgICAgICB0aGlzLnBvaW50ID0gbnVsbDtcbiAgICAgICAgbGV0IHRyYWNrT3BlbiA9IHRoaXMub3BlblN0YXJ0IDwgMCA/IFtdIDogbnVsbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGEgPSB0aGlzLm1pbkFjdGl2ZTtcbiAgICAgICAgICAgIGlmIChhID4gLTEgJiYgKHRoaXMuYWN0aXZlVG9bYV0gLSB0aGlzLmN1cnNvci5mcm9tIHx8IHRoaXMuYWN0aXZlW2FdLmVuZFNpZGUgLSB0aGlzLmN1cnNvci5zdGFydFNpZGUpIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRvW2FdID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5hY3RpdmVUb1thXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gdGhpcy5hY3RpdmVbYV0uZW5kU2lkZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlKGEpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja09wZW4pXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZSh0cmFja09wZW4sIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY3Vyc29yLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuZW5kU2lkZSA9IDEwMDAwMDAwMDAgLyogQy5GYXIgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmN1cnNvci5mcm9tID4gZnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmN1cnNvci5mcm9tO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kU2lkZSA9IHRoaXMuY3Vyc29yLnN0YXJ0U2lkZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0VmFsID0gdGhpcy5jdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0VmFsLnBvaW50KSB7IC8vIE9wZW5pbmcgYSByYW5nZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEFjdGl2ZSh0cmFja09wZW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdhc1BvaW50ICYmIHRoaXMuY3Vyc29yLnRvID09IHRoaXMudG8gJiYgdGhpcy5jdXJzb3IuZnJvbSA8IHRoaXMuY3Vyc29yLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgbm9uLWVtcHR5IHBvaW50cyB0aGF0IGVuZCBwcmVjaXNlbHkgYXQgdGhlIGVuZCBvZiB0aGUgcHJldiBwb2ludFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBOZXcgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludCA9IG5leHRWYWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRGcm9tID0gdGhpcy5jdXJzb3IuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludFJhbmsgPSB0aGlzLmN1cnNvci5yYW5rO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5jdXJzb3IudG87XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kU2lkZSA9IG5leHRWYWwuZW5kU2lkZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmQodGhpcy50bywgdGhpcy5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFja09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0cmFja09wZW4ubGVuZ3RoIC0gMTsgaSA+PSAwICYmIHRyYWNrT3BlbltpXSA8IGZyb207IGktLSlcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5TdGFydCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjdGl2ZUZvclBvaW50KHRvKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICAgICAgICBsZXQgYWN0aXZlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFjdGl2ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlUmFua1tpXSA8IHRoaXMucG9pbnRSYW5rKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9baV0gPiB0byB8fCB0aGlzLmFjdGl2ZVRvW2ldID09IHRvICYmIHRoaXMuYWN0aXZlW2ldLmVuZFNpZGUgPj0gdGhpcy5wb2ludC5lbmRTaWRlKVxuICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKHRoaXMuYWN0aXZlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG4gICAgb3BlbkVuZCh0bykge1xuICAgICAgICBsZXQgb3BlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFjdGl2ZVRvLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiB0aGlzLmFjdGl2ZVRvW2ldID4gdG87IGktLSlcbiAgICAgICAgICAgIG9wZW4rKztcbiAgICAgICAgcmV0dXJuIG9wZW47XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZShhLCBzdGFydEEsIGIsIHN0YXJ0QiwgbGVuZ3RoLCBjb21wYXJhdG9yKSB7XG4gICAgYS5nb3RvKHN0YXJ0QSk7XG4gICAgYi5nb3RvKHN0YXJ0Qik7XG4gICAgbGV0IGVuZEIgPSBzdGFydEIgKyBsZW5ndGg7XG4gICAgbGV0IHBvcyA9IHN0YXJ0QiwgZFBvcyA9IHN0YXJ0QiAtIHN0YXJ0QTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBkRW5kID0gKGEudG8gKyBkUG9zKSAtIGIudG8sIGRpZmYgPSBkRW5kIHx8IGEuZW5kU2lkZSAtIGIuZW5kU2lkZTtcbiAgICAgICAgbGV0IGVuZCA9IGRpZmYgPCAwID8gYS50byArIGRQb3MgOiBiLnRvLCBjbGlwRW5kID0gTWF0aC5taW4oZW5kLCBlbmRCKTtcbiAgICAgICAgaWYgKGEucG9pbnQgfHwgYi5wb2ludCkge1xuICAgICAgICAgICAgaWYgKCEoYS5wb2ludCAmJiBiLnBvaW50ICYmIChhLnBvaW50ID09IGIucG9pbnQgfHwgYS5wb2ludC5lcShiLnBvaW50KSkgJiZcbiAgICAgICAgICAgICAgICBzYW1lVmFsdWVzKGEuYWN0aXZlRm9yUG9pbnQoYS50byksIGIuYWN0aXZlRm9yUG9pbnQoYi50bykpKSlcbiAgICAgICAgICAgICAgICBjb21wYXJhdG9yLmNvbXBhcmVQb2ludChwb3MsIGNsaXBFbmQsIGEucG9pbnQsIGIucG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNsaXBFbmQgPiBwb3MgJiYgIXNhbWVWYWx1ZXMoYS5hY3RpdmUsIGIuYWN0aXZlKSlcbiAgICAgICAgICAgICAgICBjb21wYXJhdG9yLmNvbXBhcmVSYW5nZShwb3MsIGNsaXBFbmQsIGEuYWN0aXZlLCBiLmFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA+IGVuZEIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKChkRW5kIHx8IGEub3BlbkVuZCAhPSBiLm9wZW5FbmQpICYmIGNvbXBhcmF0b3IuYm91bmRDaGFuZ2UpXG4gICAgICAgICAgICBjb21wYXJhdG9yLmJvdW5kQ2hhbmdlKGVuZCk7XG4gICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgaWYgKGRpZmYgPD0gMClcbiAgICAgICAgICAgIGEubmV4dCgpO1xuICAgICAgICBpZiAoZGlmZiA+PSAwKVxuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2FtZVZhbHVlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYVtpXSAhPSBiW2ldICYmICFhW2ldLmVxKGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBpbmRleCkge1xuICAgIGZvciAobGV0IGkgPSBpbmRleCwgZSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPCBlOyBpKyspXG4gICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSArIDFdO1xuICAgIGFycmF5LnBvcCgpO1xufVxuZnVuY3Rpb24gaW5zZXJ0KGFycmF5LCBpbmRleCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSBpbmRleDsgaS0tKVxuICAgICAgICBhcnJheVtpICsgMV0gPSBhcnJheVtpXTtcbiAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRNaW5JbmRleCh2YWx1ZSwgYXJyYXkpIHtcbiAgICBsZXQgZm91bmQgPSAtMSwgZm91bmRQb3MgPSAxMDAwMDAwMDAwIC8qIEMuRmFyICovO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICgoYXJyYXlbaV0gLSBmb3VuZFBvcyB8fCB2YWx1ZVtpXS5lbmRTaWRlIC0gdmFsdWVbZm91bmRdLmVuZFNpZGUpIDwgMCkge1xuICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgZm91bmRQb3MgPSBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuLyoqXG5Db3VudCB0aGUgY29sdW1uIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQgaW50byB0aGUgc3RyaW5nLFxudGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuXG4qL1xuZnVuY3Rpb24gY291bnRDb2x1bW4oc3RyaW5nLCB0YWJTaXplLCB0byA9IHN0cmluZy5sZW5ndGgpIHtcbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0byAmJiBpIDwgc3RyaW5nLmxlbmd0aDspIHtcbiAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkpIHtcbiAgICAgICAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuKys7XG4gICAgICAgICAgICBpID0gZmluZENsdXN0ZXJCcmVhayhzdHJpbmcsIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuLyoqXG5GaW5kIHRoZSBvZmZzZXQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gY29sdW1uIHBvc2l0aW9uIGluIGFcbnN0cmluZywgdGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuIEJ5XG5kZWZhdWx0LCB0aGUgc3RyaW5nIGxlbmd0aCBpcyByZXR1cm5lZCB3aGVuIGl0IGlzIHRvbyBzaG9ydCB0b1xucmVhY2ggdGhlIGNvbHVtbi4gUGFzcyBgc3RyaWN0YCB0cnVlIHRvIG1ha2UgaXQgcmV0dXJuIC0xIGluIHRoYXRcbnNpdHVhdGlvbi5cbiovXG5mdW5jdGlvbiBmaW5kQ29sdW1uKHN0cmluZywgY29sLCB0YWJTaXplLCBzdHJpY3QpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IDA7Oykge1xuICAgICAgICBpZiAobiA+PSBjb2wpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgaWYgKGkgPT0gc3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBuICs9IHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkgPyB0YWJTaXplIC0gKG4gJSB0YWJTaXplKSA6IDE7XG4gICAgICAgIGkgPSBmaW5kQ2x1c3RlckJyZWFrKHN0cmluZywgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpY3QgPT09IHRydWUgPyAtMSA6IHN0cmluZy5sZW5ndGg7XG59XG5cbmV4cG9ydCB7IEFubm90YXRpb24sIEFubm90YXRpb25UeXBlLCBDaGFuZ2VEZXNjLCBDaGFuZ2VTZXQsIENoYXJDYXRlZ29yeSwgQ29tcGFydG1lbnQsIEVkaXRvclNlbGVjdGlvbiwgRWRpdG9yU3RhdGUsIEZhY2V0LCBMaW5lLCBNYXBNb2RlLCBQcmVjLCBSYW5nZSwgUmFuZ2VTZXQsIFJhbmdlU2V0QnVpbGRlciwgUmFuZ2VWYWx1ZSwgU2VsZWN0aW9uUmFuZ2UsIFN0YXRlRWZmZWN0LCBTdGF0ZUVmZmVjdFR5cGUsIFN0YXRlRmllbGQsIFRleHQsIFRyYW5zYWN0aW9uLCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgY29tYmluZUNvbmZpZywgY291bnRDb2x1bW4sIGZpbmRDbHVzdGVyQnJlYWssIGZpbmRDb2x1bW4sIGZyb21Db2RlUG9pbnQgfTtcbiJdLCJuYW1lcyI6WyJmaW5kQ2x1c3RlckJyZWFrIiwiZmluZENsdXN0ZXJCcmVhayQxIiwiVGV4dCIsImxpbmVBdCIsInBvcyIsImxlbmd0aCIsIlJhbmdlRXJyb3IiLCJsaW5lSW5uZXIiLCJsaW5lIiwibiIsImxpbmVzIiwicmVwbGFjZSIsImZyb20iLCJ0byIsInRleHQiLCJjbGlwIiwicGFydHMiLCJkZWNvbXBvc2UiLCJUZXh0Tm9kZSIsImFwcGVuZCIsIm90aGVyIiwic2xpY2UiLCJlcSIsInN0YXJ0Iiwic2NhbklkZW50aWNhbCIsImVuZCIsImEiLCJSYXdUZXh0Q3Vyc29yIiwiYiIsInNraXAiLCJuZXh0IiwibGluZUJyZWFrIiwiZG9uZSIsInZhbHVlIiwiaXRlciIsImRpciIsIml0ZXJSYW5nZSIsIlBhcnRpYWxUZXh0Q3Vyc29yIiwiaXRlckxpbmVzIiwiaW5uZXIiLCJNYXRoIiwibWF4IiwiTGluZUN1cnNvciIsInRvU3RyaW5nIiwic2xpY2VTdHJpbmciLCJ0b0pTT04iLCJmbGF0dGVuIiwiY29uc3RydWN0b3IiLCJvZiIsImVtcHR5IiwiVGV4dExlYWYiLCJzcGxpdCIsInRleHRMZW5ndGgiLCJjaGlsZHJlbiIsInRhcmdldCIsImlzTGluZSIsIm9mZnNldCIsImkiLCJzdHJpbmciLCJMaW5lIiwib3BlbiIsInNsaWNlVGV4dCIsIm1pbiIsInByZXYiLCJwb3AiLCJqb2luZWQiLCJhcHBlbmRUZXh0IiwicHVzaCIsIm1pZCIsIm5ld0xlbiIsImxpbmVTZXAiLCJyZXN1bHQiLCJwYXJ0IiwibGVuIiwiY2hpbGQiLCJlbmRMaW5lIiwiY2hpbGRPcGVuIiwidXBkYXRlZCIsInRvdGFsTGluZXMiLCJjb3B5IiwiaUEiLCJpQiIsImVBIiwiZUIiLCJjaEEiLCJjaEIiLCJyZWR1Y2UiLCJsIiwiY2giLCJmbGF0IiwiY2h1bmsiLCJtYXhDaHVuayIsIm1pbkNodW5rIiwiY2h1bmtlZCIsImN1cnJlbnRMaW5lcyIsImN1cnJlbnRMZW4iLCJjdXJyZW50Q2h1bmsiLCJhZGQiLCJsYXN0Iiwibm9kZSIsImZsdXNoIiwiY29uY2F0IiwiZmlyc3QiLCJub2RlcyIsIm9mZnNldHMiLCJuZXh0SW5uZXIiLCJ0b3AiLCJvZmZzZXRWYWx1ZSIsInNpemUiLCJjdXJzb3IiLCJsaW1pdCIsImFmdGVyQnJlYWsiLCJTeW1ib2wiLCJwcm90b3R5cGUiLCJpdGVyYXRvciIsIm51bWJlciIsInN0ciIsImZvcndhcmQiLCJpbmNsdWRlRXh0ZW5kaW5nIiwic3Vycm9nYXRlTG93Iiwic3Vycm9nYXRlSGlnaCIsImNvZGVQb2ludEF0IiwiY29kZTAiLCJjaGFyQ29kZUF0IiwiY29kZTEiLCJmcm9tQ29kZVBvaW50IiwiY29kZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImNvZGVQb2ludFNpemUiLCJEZWZhdWx0U3BsaXQiLCJNYXBNb2RlIiwiQ2hhbmdlRGVzYyIsInNlY3Rpb25zIiwibmV3TGVuZ3RoIiwiaW5zIiwiaXRlckdhcHMiLCJmIiwicG9zQSIsInBvc0IiLCJpdGVyQ2hhbmdlZFJhbmdlcyIsImluZGl2aWR1YWwiLCJpdGVyQ2hhbmdlcyIsImludmVydGVkRGVzYyIsImNvbXBvc2VEZXNjIiwiY29tcG9zZVNldHMiLCJtYXBEZXNjIiwiYmVmb3JlIiwibWFwU2V0IiwibWFwUG9zIiwiYXNzb2MiLCJtb2RlIiwiU2ltcGxlIiwiZW5kQSIsIlRyYWNrRGVsIiwiVHJhY2tCZWZvcmUiLCJUcmFja0FmdGVyIiwidG91Y2hlc1JhbmdlIiwiZnJvbUpTT04iLCJqc29uIiwiQXJyYXkiLCJpc0FycmF5Iiwic29tZSIsImNyZWF0ZSIsIkNoYW5nZVNldCIsImluc2VydGVkIiwiYXBwbHkiLCJkb2MiLCJmcm9tQSIsInRvQSIsImZyb21CIiwiX3RvQiIsImludmVydCIsImluZGV4IiwiY29tcG9zZSIsIm1hcCIsImRlc2MiLCJmaWx0ZXIiLCJyYW5nZXMiLCJyZXN1bHRTZWN0aW9ucyIsInJlc3VsdEluc2VydGVkIiwiZmlsdGVyZWRTZWN0aW9ucyIsIlNlY3Rpb25JdGVyIiwiYWRkU2VjdGlvbiIsIm9mZiIsImFkZEluc2VydCIsImNoYW5nZXMiLCJmaWx0ZXJlZCIsInRvdGFsIiwiZm9yY2UiLCJzZXQiLCJwcm9jZXNzIiwic3BlYyIsInN1YiIsImluc2VydCIsImluc1RleHQiLCJpbnNMZW4iLCJlIiwiY3JlYXRlU2V0IiwiZm9yY2VKb2luIiwidmFsdWVzIiwiZW5kQiIsInNldEEiLCJzZXRCIiwibWtTZXQiLCJFcnJvciIsInBpZWNlIiwibGVmdCIsImxlbjIiLCJzZWN0aW9uTGVuIiwiaW5zQiIsInRleHRCaXQiLCJmb3J3YXJkMiIsInVuZGVmaW5lZCIsIlNlbGVjdGlvblJhbmdlIiwiZmxhZ3MiLCJhbmNob3IiLCJoZWFkIiwiYmlkaUxldmVsIiwibGV2ZWwiLCJnb2FsQ29sdW1uIiwiY2hhbmdlIiwiZXh0ZW5kIiwiRWRpdG9yU2VsZWN0aW9uIiwicmFuZ2UiLCJhYnMiLCJpbmNsdWRlQXNzb2MiLCJtYWluSW5kZXgiLCJyIiwibWFpbiIsImFzU2luZ2xlIiwiYWRkUmFuZ2UiLCJyZXBsYWNlUmFuZ2UiLCJ3aGljaCIsInNpbmdsZSIsIm5vcm1hbGl6ZWQiLCJzb3J0IiwiaW5kZXhPZiIsInNwbGljZSIsImNoZWNrU2VsZWN0aW9uIiwic2VsZWN0aW9uIiwiZG9jTGVuZ3RoIiwibmV4dElEIiwiRmFjZXQiLCJjb21iaW5lIiwiY29tcGFyZUlucHV0IiwiY29tcGFyZSIsImlzU3RhdGljIiwiZW5hYmxlcyIsImlkIiwiZGVmYXVsdCIsImV4dGVuc2lvbnMiLCJyZWFkZXIiLCJkZWZpbmUiLCJjb25maWciLCJzYW1lQXJyYXkiLCJzdGF0aWMiLCJGYWNldFByb3ZpZGVyIiwiY29tcHV0ZSIsImRlcHMiLCJnZXQiLCJjb21wdXRlTiIsImZpZWxkIiwieCIsInN0YXRlIiwiZXZlcnkiLCJkZXBlbmRlbmNpZXMiLCJmYWNldCIsInR5cGUiLCJkeW5hbWljU2xvdCIsImFkZHJlc3NlcyIsIl9hIiwiZ2V0dGVyIiwiaWR4IiwibXVsdGkiLCJkZXBEb2MiLCJkZXBTZWwiLCJkZXBBZGRycyIsImRlcCIsInVwZGF0ZSIsInRyIiwiZG9jQ2hhbmdlZCIsImVuc3VyZUFsbCIsIm5ld1ZhbCIsImNvbXBhcmVBcnJheSIsInJlY29uZmlndXJlIiwib2xkU3RhdGUiLCJvbGRBZGRyIiwiYWRkcmVzcyIsIm9sZFZhbCIsImdldEFkZHIiLCJTdGF0ZUZpZWxkIiwiYWRkcnMiLCJjaGFuZ2VkIiwiYWRkciIsImVuc3VyZUFkZHIiLCJkeW5hbWljRmFjZXRTbG90IiwicHJvdmlkZXJzIiwicHJvdmlkZXJBZGRycyIsInAiLCJwcm92aWRlclR5cGVzIiwiZHluYW1pYyIsInZhbCIsImRlcENoYW5nZWQiLCJvbGRQcm92aWRlcnMiLCJmYWNldHMiLCJvbGRWYWx1ZSIsImluaXRGaWVsZCIsImNyZWF0ZUYiLCJ1cGRhdGVGIiwiY29tcGFyZUYiLCJwcm92aWRlcyIsInByb3ZpZGUiLCJpbml0IiwiZmluZCIsInNsb3QiLCJvbGRJbml0IiwicmVJbml0IiwiZXh0ZW5zaW9uIiwiUHJlY18iLCJsb3dlc3QiLCJsb3ciLCJoaWdoIiwiaGlnaGVzdCIsInByZWMiLCJleHQiLCJQcmVjRXh0ZW5zaW9uIiwiUHJlYyIsIkNvbXBhcnRtZW50IiwiQ29tcGFydG1lbnRJbnN0YW5jZSIsImNvbnRlbnQiLCJjb21wYXJ0bWVudCIsImNvbXBhcnRtZW50cyIsIkNvbmZpZ3VyYXRpb24iLCJiYXNlIiwiZHluYW1pY1Nsb3RzIiwic3RhdGljVmFsdWVzIiwic3RhdHVzVGVtcGxhdGUiLCJzdGF0aWNGYWNldCIsInJlc29sdmUiLCJmaWVsZHMiLCJPYmplY3QiLCJuZXdDb21wYXJ0bWVudHMiLCJNYXAiLCJvbGRGYWNldHMiLCJzZWVuIiwia25vd24iLCJmb3VuZCIsImRlbGV0ZSIsImhhcyIsInN0YXR1cyIsImNvbXB1dGVTbG90IiwibGFuZ3VhZ2VEYXRhIiwiYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMiLCJ2IiwibGluZVNlcGFyYXRvciIsImNoYW5nZUZpbHRlciIsInRyYW5zYWN0aW9uRmlsdGVyIiwidHJhbnNhY3Rpb25FeHRlbmRlciIsInJlYWRPbmx5IiwiQW5ub3RhdGlvbiIsIkFubm90YXRpb25UeXBlIiwiU3RhdGVFZmZlY3RUeXBlIiwiU3RhdGVFZmZlY3QiLCJtYXBwaW5nIiwibWFwcGVkIiwiaXMiLCJtYXBFZmZlY3RzIiwiZWZmZWN0cyIsImVmZmVjdCIsImFwcGVuZENvbmZpZyIsIlRyYW5zYWN0aW9uIiwic3RhcnRTdGF0ZSIsImFubm90YXRpb25zIiwic2Nyb2xsSW50b1ZpZXciLCJfZG9jIiwiX3N0YXRlIiwidGltZSIsIkRhdGUiLCJub3ciLCJuZXdEb2MiLCJuZXdTZWxlY3Rpb24iLCJhcHBseVRyYW5zYWN0aW9uIiwiYW5ub3RhdGlvbiIsImFubiIsInJlY29uZmlndXJlZCIsImlzVXNlckV2ZW50IiwiZXZlbnQiLCJ1c2VyRXZlbnQiLCJhZGRUb0hpc3RvcnkiLCJyZW1vdGUiLCJqb2luUmFuZ2VzIiwibWVyZ2VUcmFuc2FjdGlvbiIsInNlcXVlbnRpYWwiLCJtYXBGb3JBIiwibWFwRm9yQiIsInJlc29sdmVUcmFuc2FjdGlvbklubmVyIiwiZG9jU2l6ZSIsInNlbCIsImFzQXJyYXkiLCJyZXNvbHZlVHJhbnNhY3Rpb24iLCJzcGVjcyIsInMiLCJzZXEiLCJleHRlbmRUcmFuc2FjdGlvbiIsImZpbHRlclRyYW5zYWN0aW9uIiwiYmFjayIsImZpbHRlcnMiLCJleHRlbmRlcnMiLCJrZXlzIiwibm9uZSIsIkNoYXJDYXRlZ29yeSIsIm5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyIiwid29yZENoYXIiLCJSZWdFeHAiLCJfIiwiaGFzV29yZENoYXIiLCJ0ZXN0IiwidG9VcHBlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsIm1ha2VDYXRlZ29yaXplciIsIndvcmRDaGFycyIsImNoYXIiLCJTcGFjZSIsIldvcmQiLCJPdGhlciIsIkVkaXRvclN0YXRlIiwicmVxdWlyZSIsImNvbmYiLCJmb3JFYWNoIiwia2V5Iiwic3RhcnRWYWx1ZXMiLCJpbnRlcm1lZGlhdGVTdGF0ZSIsInJlcGxhY2VTZWxlY3Rpb24iLCJ0b1RleHQiLCJjaGFuZ2VCeVJhbmdlIiwicmVzdWx0MSIsIm5ld0NoYW5nZXMiLCJuZXdNYXBwZWQiLCJqIiwibWFwQnkiLCJzbGljZURvYyIsInByb3AiLCJmaWVsZEluaXQiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJjb25maWd1cmF0aW9uIiwidGFiU2l6ZSIsInBocmFzZSIsInBocmFzZXMiLCJtIiwibGFuZ3VhZ2VEYXRhQXQiLCJuYW1lIiwic2lkZSIsInByb3ZpZGVyIiwiY2hhckNhdGVnb3JpemVyIiwiYXQiLCJqb2luIiwid29yZEF0IiwiY2F0Iiwia0EiLCJrQiIsImsiLCJjb21iaW5lQ29uZmlnIiwiY29uZmlncyIsImRlZmF1bHRzIiwiY3VycmVudCIsIlJhbmdlVmFsdWUiLCJSYW5nZSIsInN0YXJ0U2lkZSIsImVuZFNpZGUiLCJwb2ludCIsIm1hcE1vZGUiLCJjbXBSYW5nZSIsIkNodW5rIiwibWF4UG9pbnQiLCJmaW5kSW5kZXgiLCJzdGFydEF0IiwiYXJyIiwibG8iLCJoaSIsImRpZmYiLCJiZXR3ZWVuIiwibmV3UG9zIiwiY3VyRnJvbSIsImN1clRvIiwibmV3RnJvbSIsIm5ld1RvIiwiUmFuZ2VTZXQiLCJjaHVua1BvcyIsIm5leHRMYXllciIsImNodW5rRW5kIiwiaXNFbXB0eSIsInVwZGF0ZVNwZWMiLCJmaWx0ZXJGcm9tIiwiZmlsdGVyVG8iLCJjdXIiLCJMYXllckN1cnNvciIsImdvdG8iLCJzcGlsbCIsImJ1aWxkZXIiLCJSYW5nZVNldEJ1aWxkZXIiLCJhZGRJbm5lciIsInJhbmdlSW5kZXgiLCJjaHVua0luZGV4IiwiYWRkQ2h1bmsiLCJuZXh0Q2h1bmsiLCJmaW5pc2hJbm5lciIsImNodW5rcyIsInRvdWNoIiwiSGVhcEN1cnNvciIsInNldHMiLCJvbGRTZXRzIiwibmV3U2V0cyIsInRleHREaWZmIiwiY29tcGFyYXRvciIsIm1pblBvaW50U2l6ZSIsInNoYXJlZENodW5rcyIsImZpbmRTaGFyZWRDaHVua3MiLCJzaWRlQSIsIlNwYW5DdXJzb3IiLCJzaWRlQiIsInNhbWVWYWx1ZXMiLCJhY3RpdmUiLCJzcGFucyIsIm9wZW5SYW5nZXMiLCJvcGVuU3RhcnQiLCJhY3RpdmVGb3JQb2ludCIsIm9wZW5Db3VudCIsInBvaW50RnJvbSIsInBvaW50UmFuayIsIm9wZW5FbmQiLCJzcGFuIiwiYnVpbGQiLCJsYXp5U29ydCIsImZpbmlzaCIsImxheWVyIiwiZmluaXNoQ2h1bmsiLCJuZXdBcnJheXMiLCJjaHVua1N0YXJ0Iiwic2V0TWF4UG9pbnQiLCJsYXN0RnJvbSIsImxhc3RUbyIsImluQSIsInNoYXJlZCIsIlNldCIsIm1pblBvaW50IiwicmFuayIsImdvdG9Jbm5lciIsInNldFJhbmdlSW5kZXgiLCJoZWFwIiwiaGVhcEJ1YmJsZSIsImNoaWxkSW5kZXgiLCJhY3RpdmVUbyIsImFjdGl2ZVJhbmsiLCJtaW5BY3RpdmUiLCJyZW1vdmVBY3RpdmUiLCJyZW1vdmUiLCJmaW5kTWluSW5kZXgiLCJhZGRBY3RpdmUiLCJ0cmFja09wZW4iLCJ3YXNQb2ludCIsIm5leHRWYWwiLCJyZXZlcnNlIiwic3RhcnRBIiwic3RhcnRCIiwiZFBvcyIsImRFbmQiLCJjbGlwRW5kIiwiY29tcGFyZVBvaW50IiwiY29tcGFyZVJhbmdlIiwiYm91bmRDaGFuZ2UiLCJhcnJheSIsImZvdW5kUG9zIiwiY291bnRDb2x1bW4iLCJmaW5kQ29sdW1uIiwiY29sIiwic3RyaWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/state/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/theme-one-dark/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@codemirror/theme-one-dark/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   color: () => (/* binding */ color),\n/* harmony export */   oneDark: () => (/* binding */ oneDark),\n/* harmony export */   oneDarkHighlightStyle: () => (/* binding */ oneDarkHighlightStyle),\n/* harmony export */   oneDarkTheme: () => (/* binding */ oneDarkTheme)\n/* harmony export */ });\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"(ssr)/./node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _codemirror_language__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/language */ \"(ssr)/./node_modules/@codemirror/language/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/highlight */ \"(ssr)/./node_modules/@lezer/highlight/dist/index.js\");\n\n\n\n// Using https://github.com/one-dark/vscode-one-dark-theme/ as reference for the colors\nconst chalky = \"#e5c07b\", coral = \"#e06c75\", cyan = \"#56b6c2\", invalid = \"#ffffff\", ivory = \"#abb2bf\", stone = \"#7d8799\", malibu = \"#61afef\", sage = \"#98c379\", whiskey = \"#d19a66\", violet = \"#c678dd\", darkBackground = \"#21252b\", highlightBackground = \"#2c313a\", background = \"#282c34\", tooltipBackground = \"#353a42\", selection = \"#3E4451\", cursor = \"#528bff\";\n/**\nThe colors used in the theme, as CSS color strings.\n*/ const color = {\n    chalky,\n    coral,\n    cyan,\n    invalid,\n    ivory,\n    stone,\n    malibu,\n    sage,\n    whiskey,\n    violet,\n    darkBackground,\n    highlightBackground,\n    background,\n    tooltipBackground,\n    selection,\n    cursor\n};\n/**\nThe editor theme styles for One Dark.\n*/ const oneDarkTheme = /*@__PURE__*/ _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.theme({\n    \"&\": {\n        color: ivory,\n        backgroundColor: background\n    },\n    \".cm-content\": {\n        caretColor: cursor\n    },\n    \".cm-cursor, .cm-dropCursor\": {\n        borderLeftColor: cursor\n    },\n    \"&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection\": {\n        backgroundColor: selection\n    },\n    \".cm-panels\": {\n        backgroundColor: darkBackground,\n        color: ivory\n    },\n    \".cm-panels.cm-panels-top\": {\n        borderBottom: \"2px solid black\"\n    },\n    \".cm-panels.cm-panels-bottom\": {\n        borderTop: \"2px solid black\"\n    },\n    \".cm-searchMatch\": {\n        backgroundColor: \"#72a1ff59\",\n        outline: \"1px solid #457dff\"\n    },\n    \".cm-searchMatch.cm-searchMatch-selected\": {\n        backgroundColor: \"#6199ff2f\"\n    },\n    \".cm-activeLine\": {\n        backgroundColor: \"#6699ff0b\"\n    },\n    \".cm-selectionMatch\": {\n        backgroundColor: \"#aafe661a\"\n    },\n    \"&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket\": {\n        backgroundColor: \"#bad0f847\"\n    },\n    \".cm-gutters\": {\n        backgroundColor: background,\n        color: stone,\n        border: \"none\"\n    },\n    \".cm-activeLineGutter\": {\n        backgroundColor: highlightBackground\n    },\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"transparent\",\n        border: \"none\",\n        color: \"#ddd\"\n    },\n    \".cm-tooltip\": {\n        border: \"none\",\n        backgroundColor: tooltipBackground\n    },\n    \".cm-tooltip .cm-tooltip-arrow:before\": {\n        borderTopColor: \"transparent\",\n        borderBottomColor: \"transparent\"\n    },\n    \".cm-tooltip .cm-tooltip-arrow:after\": {\n        borderTopColor: tooltipBackground,\n        borderBottomColor: tooltipBackground\n    },\n    \".cm-tooltip-autocomplete\": {\n        \"& > ul > li[aria-selected]\": {\n            backgroundColor: highlightBackground,\n            color: ivory\n        }\n    }\n}, {\n    dark: true\n});\n/**\nThe highlighting style for code in the One Dark theme.\n*/ const oneDarkHighlightStyle = /*@__PURE__*/ _codemirror_language__WEBPACK_IMPORTED_MODULE_2__.HighlightStyle.define([\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.keyword,\n        color: violet\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.deleted,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.character,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.propertyName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.macroName\n        ],\n        color: coral\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.function(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.variableName),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.labelName\n        ],\n        color: malibu\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.color,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.constant(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name),\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.standard(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name)\n        ],\n        color: whiskey\n    },\n    {\n        tag: [\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.name),\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.separator\n        ],\n        color: ivory\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.typeName,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.className,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.number,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.changed,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.annotation,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.modifier,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.self,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.namespace\n        ],\n        color: chalky\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.operator,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.operatorKeyword,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.url,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.escape,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.regexp,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.link,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.string)\n        ],\n        color: cyan\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.meta,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.comment\n        ],\n        color: stone\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.strong,\n        fontWeight: \"bold\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.emphasis,\n        fontStyle: \"italic\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.strikethrough,\n        textDecoration: \"line-through\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.link,\n        color: stone,\n        textDecoration: \"underline\"\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.heading,\n        fontWeight: \"bold\",\n        color: coral\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.atom,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.bool,\n            /*@__PURE__*/ _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.variableName)\n        ],\n        color: whiskey\n    },\n    {\n        tag: [\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.processingInstruction,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.string,\n            _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.inserted\n        ],\n        color: sage\n    },\n    {\n        tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_0__.tags.invalid,\n        color: invalid\n    }\n]);\n/**\nExtension to enable the One Dark theme (both the editor theme and\nthe highlight style).\n*/ const oneDark = [\n    oneDarkTheme,\n    /*@__PURE__*/ (0,_codemirror_language__WEBPACK_IMPORTED_MODULE_2__.syntaxHighlighting)(oneDarkHighlightStyle)\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvdGhlbWUtb25lLWRhcmsvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQThDO0FBQzRCO0FBQ2xDO0FBRXhDLHVGQUF1RjtBQUN2RixNQUFNSSxTQUFTLFdBQVdDLFFBQVEsV0FBV0MsT0FBTyxXQUFXQyxVQUFVLFdBQVdDLFFBQVEsV0FBV0MsUUFBUSxXQUMvR0MsU0FBUyxXQUFXQyxPQUFPLFdBQVdDLFVBQVUsV0FBV0MsU0FBUyxXQUFXQyxpQkFBaUIsV0FBV0Msc0JBQXNCLFdBQVdDLGFBQWEsV0FBV0Msb0JBQW9CLFdBQVdDLFlBQVksV0FBV0MsU0FBUztBQUNuTzs7QUFFQSxHQUNBLE1BQU1DLFFBQVE7SUFDVmhCO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0FBQ0o7QUFDQTs7QUFFQSxHQUNBLE1BQU1FLGVBQWUsV0FBVyxHQUFFckIsd0RBQVVBLENBQUNzQixLQUFLLENBQUM7SUFDL0MsS0FBSztRQUNERixPQUFPWjtRQUNQZSxpQkFBaUJQO0lBQ3JCO0lBQ0EsZUFBZTtRQUNYUSxZQUFZTDtJQUNoQjtJQUNBLDhCQUE4QjtRQUFFTSxpQkFBaUJOO0lBQU87SUFDeEQsOEhBQThIO1FBQUVJLGlCQUFpQkw7SUFBVTtJQUMzSixjQUFjO1FBQUVLLGlCQUFpQlQ7UUFBZ0JNLE9BQU9aO0lBQU07SUFDOUQsNEJBQTRCO1FBQUVrQixjQUFjO0lBQWtCO0lBQzlELCtCQUErQjtRQUFFQyxXQUFXO0lBQWtCO0lBQzlELG1CQUFtQjtRQUNmSixpQkFBaUI7UUFDakJLLFNBQVM7SUFDYjtJQUNBLDJDQUEyQztRQUN2Q0wsaUJBQWlCO0lBQ3JCO0lBQ0Esa0JBQWtCO1FBQUVBLGlCQUFpQjtJQUFZO0lBQ2pELHNCQUFzQjtRQUFFQSxpQkFBaUI7SUFBWTtJQUNyRCx5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Q3ZCO1FBQUVqQyxLQUFLaEMsa0RBQUlBLENBQUNrRSxRQUFRO1FBQ2hCQyxXQUFXO0lBQVM7SUFDeEI7UUFBRW5DLEtBQUtoQyxrREFBSUEsQ0FBQ29FLGFBQWE7UUFDckJDLGdCQUFnQjtJQUFlO0lBQ25DO1FBQUVyQyxLQUFLaEMsa0RBQUlBLENBQUMyRCxJQUFJO1FBQ1oxQyxPQUFPWDtRQUNQK0QsZ0JBQWdCO0lBQVk7SUFDaEM7UUFBRXJDLEtBQUtoQyxrREFBSUEsQ0FBQ3NFLE9BQU87UUFDZkwsWUFBWTtRQUNaaEQsT0FBT2Y7SUFBTTtJQUNqQjtRQUFFOEIsS0FBSztZQUFDaEMsa0RBQUlBLENBQUN1RSxJQUFJO1lBQUV2RSxrREFBSUEsQ0FBQ3dFLElBQUk7WUFBRSxXQUFXLEdBQUV4RSxrREFBSUEsQ0FBQzRELE9BQU8sQ0FBQzVELGtEQUFJQSxDQUFDd0MsWUFBWTtTQUFFO1FBQ3ZFdkIsT0FBT1I7SUFBUTtJQUNuQjtRQUFFdUIsS0FBSztZQUFDaEMsa0RBQUlBLENBQUN5RSxxQkFBcUI7WUFBRXpFLGtEQUFJQSxDQUFDNkQsTUFBTTtZQUFFN0Qsa0RBQUlBLENBQUMwRSxRQUFRO1NBQUM7UUFDM0R6RCxPQUFPVDtJQUFLO0lBQ2hCO1FBQUV3QixLQUFLaEMsa0RBQUlBLENBQUNJLE9BQU87UUFDZmEsT0FBT2I7SUFBUTtDQUN0QjtBQUNEOzs7QUFHQSxHQUNBLE1BQU11RSxVQUFVO0lBQUN6RDtJQUFjLFdBQVcsR0FBRW5CLHdFQUFrQkEsQ0FBQytCO0NBQXVCO0FBRXZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFja25pY2hlLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3RoZW1lLW9uZS1kYXJrL2Rpc3QvaW5kZXguanM/Yjc4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBIaWdobGlnaHRTdHlsZSwgc3ludGF4SGlnaGxpZ2h0aW5nIH0gZnJvbSAnQGNvZGVtaXJyb3IvbGFuZ3VhZ2UnO1xuaW1wb3J0IHsgdGFncyB9IGZyb20gJ0BsZXplci9oaWdobGlnaHQnO1xuXG4vLyBVc2luZyBodHRwczovL2dpdGh1Yi5jb20vb25lLWRhcmsvdnNjb2RlLW9uZS1kYXJrLXRoZW1lLyBhcyByZWZlcmVuY2UgZm9yIHRoZSBjb2xvcnNcbmNvbnN0IGNoYWxreSA9IFwiI2U1YzA3YlwiLCBjb3JhbCA9IFwiI2UwNmM3NVwiLCBjeWFuID0gXCIjNTZiNmMyXCIsIGludmFsaWQgPSBcIiNmZmZmZmZcIiwgaXZvcnkgPSBcIiNhYmIyYmZcIiwgc3RvbmUgPSBcIiM3ZDg3OTlcIiwgLy8gQnJpZ2h0ZW5lZCBjb21wYXJlZCB0byBvcmlnaW5hbCB0byBpbmNyZWFzZSBjb250cmFzdFxubWFsaWJ1ID0gXCIjNjFhZmVmXCIsIHNhZ2UgPSBcIiM5OGMzNzlcIiwgd2hpc2tleSA9IFwiI2QxOWE2NlwiLCB2aW9sZXQgPSBcIiNjNjc4ZGRcIiwgZGFya0JhY2tncm91bmQgPSBcIiMyMTI1MmJcIiwgaGlnaGxpZ2h0QmFja2dyb3VuZCA9IFwiIzJjMzEzYVwiLCBiYWNrZ3JvdW5kID0gXCIjMjgyYzM0XCIsIHRvb2x0aXBCYWNrZ3JvdW5kID0gXCIjMzUzYTQyXCIsIHNlbGVjdGlvbiA9IFwiIzNFNDQ1MVwiLCBjdXJzb3IgPSBcIiM1MjhiZmZcIjtcbi8qKlxuVGhlIGNvbG9ycyB1c2VkIGluIHRoZSB0aGVtZSwgYXMgQ1NTIGNvbG9yIHN0cmluZ3MuXG4qL1xuY29uc3QgY29sb3IgPSB7XG4gICAgY2hhbGt5LFxuICAgIGNvcmFsLFxuICAgIGN5YW4sXG4gICAgaW52YWxpZCxcbiAgICBpdm9yeSxcbiAgICBzdG9uZSxcbiAgICBtYWxpYnUsXG4gICAgc2FnZSxcbiAgICB3aGlza2V5LFxuICAgIHZpb2xldCxcbiAgICBkYXJrQmFja2dyb3VuZCxcbiAgICBoaWdobGlnaHRCYWNrZ3JvdW5kLFxuICAgIGJhY2tncm91bmQsXG4gICAgdG9vbHRpcEJhY2tncm91bmQsXG4gICAgc2VsZWN0aW9uLFxuICAgIGN1cnNvclxufTtcbi8qKlxuVGhlIGVkaXRvciB0aGVtZSBzdHlsZXMgZm9yIE9uZSBEYXJrLlxuKi9cbmNvbnN0IG9uZURhcmtUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LnRoZW1lKHtcbiAgICBcIiZcIjoge1xuICAgICAgICBjb2xvcjogaXZvcnksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZFxuICAgIH0sXG4gICAgXCIuY20tY29udGVudFwiOiB7XG4gICAgICAgIGNhcmV0Q29sb3I6IGN1cnNvclxuICAgIH0sXG4gICAgXCIuY20tY3Vyc29yLCAuY20tZHJvcEN1cnNvclwiOiB7IGJvcmRlckxlZnRDb2xvcjogY3Vyc29yIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tc2VsZWN0aW9uTGF5ZXIgLmNtLXNlbGVjdGlvbkJhY2tncm91bmQsIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kLCAuY20tY29udGVudCA6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogc2VsZWN0aW9uIH0sXG4gICAgXCIuY20tcGFuZWxzXCI6IHsgYmFja2dyb3VuZENvbG9yOiBkYXJrQmFja2dyb3VuZCwgY29sb3I6IGl2b3J5IH0sXG4gICAgXCIuY20tcGFuZWxzLmNtLXBhbmVscy10b3BcIjogeyBib3JkZXJCb3R0b206IFwiMnB4IHNvbGlkIGJsYWNrXCIgfSxcbiAgICBcIi5jbS1wYW5lbHMuY20tcGFuZWxzLWJvdHRvbVwiOiB7IGJvcmRlclRvcDogXCIycHggc29saWQgYmxhY2tcIiB9LFxuICAgIFwiLmNtLXNlYXJjaE1hdGNoXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM3MmExZmY1OVwiLFxuICAgICAgICBvdXRsaW5lOiBcIjFweCBzb2xpZCAjNDU3ZGZmXCJcbiAgICB9LFxuICAgIFwiLmNtLXNlYXJjaE1hdGNoLmNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiM2MTk5ZmYyZlwiXG4gICAgfSxcbiAgICBcIi5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM2Njk5ZmYwYlwiIH0sXG4gICAgXCIuY20tc2VsZWN0aW9uTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2FhZmU2NjFhXCIgfSxcbiAgICBcIiYuY20tZm9jdXNlZCAuY20tbWF0Y2hpbmdCcmFja2V0LCAmLmNtLWZvY3VzZWQgLmNtLW5vbm1hdGNoaW5nQnJhY2tldFwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjYmFkMGY4NDdcIlxuICAgIH0sXG4gICAgXCIuY20tZ3V0dGVyc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZCxcbiAgICAgICAgY29sb3I6IHN0b25lLFxuICAgICAgICBib3JkZXI6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIi5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBoaWdobGlnaHRCYWNrZ3JvdW5kXG4gICAgfSxcbiAgICBcIi5jbS1mb2xkUGxhY2Vob2xkZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgY29sb3I6IFwiI2RkZFwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIm5vbmVcIixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0b29sdGlwQmFja2dyb3VuZFxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcCAuY20tdG9vbHRpcC1hcnJvdzpiZWZvcmVcIjoge1xuICAgICAgICBib3JkZXJUb3BDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93OmFmdGVyXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wQ29sb3I6IHRvb2x0aXBCYWNrZ3JvdW5kLFxuICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogdG9vbHRpcEJhY2tncm91bmRcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlXCI6IHtcbiAgICAgICAgXCImID4gdWwgPiBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhpZ2hsaWdodEJhY2tncm91bmQsXG4gICAgICAgICAgICBjb2xvcjogaXZvcnlcbiAgICAgICAgfVxuICAgIH1cbn0sIHsgZGFyazogdHJ1ZSB9KTtcbi8qKlxuVGhlIGhpZ2hsaWdodGluZyBzdHlsZSBmb3IgY29kZSBpbiB0aGUgT25lIERhcmsgdGhlbWUuXG4qL1xuY29uc3Qgb25lRGFya0hpZ2hsaWdodFN0eWxlID0gLypAX19QVVJFX18qL0hpZ2hsaWdodFN0eWxlLmRlZmluZShbXG4gICAgeyB0YWc6IHRhZ3Mua2V5d29yZCxcbiAgICAgICAgY29sb3I6IHZpb2xldCB9LFxuICAgIHsgdGFnOiBbdGFncy5uYW1lLCB0YWdzLmRlbGV0ZWQsIHRhZ3MuY2hhcmFjdGVyLCB0YWdzLnByb3BlcnR5TmFtZSwgdGFncy5tYWNyb05hbWVdLFxuICAgICAgICBjb2xvcjogY29yYWwgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLmZ1bmN0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSwgdGFncy5sYWJlbE5hbWVdLFxuICAgICAgICBjb2xvcjogbWFsaWJ1IH0sXG4gICAgeyB0YWc6IFt0YWdzLmNvbG9yLCAvKkBfX1BVUkVfXyovdGFncy5jb25zdGFudCh0YWdzLm5hbWUpLCAvKkBfX1BVUkVfXyovdGFncy5zdGFuZGFyZCh0YWdzLm5hbWUpXSxcbiAgICAgICAgY29sb3I6IHdoaXNrZXkgfSxcbiAgICB7IHRhZzogWy8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy5uYW1lKSwgdGFncy5zZXBhcmF0b3JdLFxuICAgICAgICBjb2xvcjogaXZvcnkgfSxcbiAgICB7IHRhZzogW3RhZ3MudHlwZU5hbWUsIHRhZ3MuY2xhc3NOYW1lLCB0YWdzLm51bWJlciwgdGFncy5jaGFuZ2VkLCB0YWdzLmFubm90YXRpb24sIHRhZ3MubW9kaWZpZXIsIHRhZ3Muc2VsZiwgdGFncy5uYW1lc3BhY2VdLFxuICAgICAgICBjb2xvcjogY2hhbGt5IH0sXG4gICAgeyB0YWc6IFt0YWdzLm9wZXJhdG9yLCB0YWdzLm9wZXJhdG9yS2V5d29yZCwgdGFncy51cmwsIHRhZ3MuZXNjYXBlLCB0YWdzLnJlZ2V4cCwgdGFncy5saW5rLCAvKkBfX1BVUkVfXyovdGFncy5zcGVjaWFsKHRhZ3Muc3RyaW5nKV0sXG4gICAgICAgIGNvbG9yOiBjeWFuIH0sXG4gICAgeyB0YWc6IFt0YWdzLm1ldGEsIHRhZ3MuY29tbWVudF0sXG4gICAgICAgIGNvbG9yOiBzdG9uZSB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5lbXBoYXNpcyxcbiAgICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3RyaWtldGhyb3VnaCxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwibGluZS10aHJvdWdoXCIgfSxcbiAgICB7IHRhZzogdGFncy5saW5rLFxuICAgICAgICBjb2xvcjogc3RvbmUsXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIsXG4gICAgICAgIGNvbG9yOiBjb3JhbCB9LFxuICAgIHsgdGFnOiBbdGFncy5hdG9tLCB0YWdzLmJvb2wsIC8qQF9fUFVSRV9fKi90YWdzLnNwZWNpYWwodGFncy52YXJpYWJsZU5hbWUpXSxcbiAgICAgICAgY29sb3I6IHdoaXNrZXkgfSxcbiAgICB7IHRhZzogW3RhZ3MucHJvY2Vzc2luZ0luc3RydWN0aW9uLCB0YWdzLnN0cmluZywgdGFncy5pbnNlcnRlZF0sXG4gICAgICAgIGNvbG9yOiBzYWdlIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW52YWxpZCxcbiAgICAgICAgY29sb3I6IGludmFsaWQgfSxcbl0pO1xuLyoqXG5FeHRlbnNpb24gdG8gZW5hYmxlIHRoZSBPbmUgRGFyayB0aGVtZSAoYm90aCB0aGUgZWRpdG9yIHRoZW1lIGFuZFxudGhlIGhpZ2hsaWdodCBzdHlsZSkuXG4qL1xuY29uc3Qgb25lRGFyayA9IFtvbmVEYXJrVGhlbWUsIC8qQF9fUFVSRV9fKi9zeW50YXhIaWdobGlnaHRpbmcob25lRGFya0hpZ2hsaWdodFN0eWxlKV07XG5cbmV4cG9ydCB7IGNvbG9yLCBvbmVEYXJrLCBvbmVEYXJrSGlnaGxpZ2h0U3R5bGUsIG9uZURhcmtUaGVtZSB9O1xuIl0sIm5hbWVzIjpbIkVkaXRvclZpZXciLCJIaWdobGlnaHRTdHlsZSIsInN5bnRheEhpZ2hsaWdodGluZyIsInRhZ3MiLCJjaGFsa3kiLCJjb3JhbCIsImN5YW4iLCJpbnZhbGlkIiwiaXZvcnkiLCJzdG9uZSIsIm1hbGlidSIsInNhZ2UiLCJ3aGlza2V5IiwidmlvbGV0IiwiZGFya0JhY2tncm91bmQiLCJoaWdobGlnaHRCYWNrZ3JvdW5kIiwiYmFja2dyb3VuZCIsInRvb2x0aXBCYWNrZ3JvdW5kIiwic2VsZWN0aW9uIiwiY3Vyc29yIiwiY29sb3IiLCJvbmVEYXJrVGhlbWUiLCJ0aGVtZSIsImJhY2tncm91bmRDb2xvciIsImNhcmV0Q29sb3IiLCJib3JkZXJMZWZ0Q29sb3IiLCJib3JkZXJCb3R0b20iLCJib3JkZXJUb3AiLCJvdXRsaW5lIiwiYm9yZGVyIiwiYm9yZGVyVG9wQ29sb3IiLCJib3JkZXJCb3R0b21Db2xvciIsImRhcmsiLCJvbmVEYXJrSGlnaGxpZ2h0U3R5bGUiLCJkZWZpbmUiLCJ0YWciLCJrZXl3b3JkIiwibmFtZSIsImRlbGV0ZWQiLCJjaGFyYWN0ZXIiLCJwcm9wZXJ0eU5hbWUiLCJtYWNyb05hbWUiLCJmdW5jdGlvbiIsInZhcmlhYmxlTmFtZSIsImxhYmVsTmFtZSIsImNvbnN0YW50Iiwic3RhbmRhcmQiLCJkZWZpbml0aW9uIiwic2VwYXJhdG9yIiwidHlwZU5hbWUiLCJjbGFzc05hbWUiLCJudW1iZXIiLCJjaGFuZ2VkIiwiYW5ub3RhdGlvbiIsIm1vZGlmaWVyIiwic2VsZiIsIm5hbWVzcGFjZSIsIm9wZXJhdG9yIiwib3BlcmF0b3JLZXl3b3JkIiwidXJsIiwiZXNjYXBlIiwicmVnZXhwIiwibGluayIsInNwZWNpYWwiLCJzdHJpbmciLCJtZXRhIiwiY29tbWVudCIsInN0cm9uZyIsImZvbnRXZWlnaHQiLCJlbXBoYXNpcyIsImZvbnRTdHlsZSIsInN0cmlrZXRocm91Z2giLCJ0ZXh0RGVjb3JhdGlvbiIsImhlYWRpbmciLCJhdG9tIiwiYm9vbCIsInByb2Nlc3NpbmdJbnN0cnVjdGlvbiIsImluc2VydGVkIiwib25lRGFyayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/theme-one-dark/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@codemirror/view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BidiSpan: () => (/* binding */ BidiSpan),\n/* harmony export */   BlockInfo: () => (/* binding */ BlockInfo),\n/* harmony export */   BlockType: () => (/* binding */ BlockType),\n/* harmony export */   Decoration: () => (/* binding */ Decoration),\n/* harmony export */   Direction: () => (/* binding */ Direction),\n/* harmony export */   EditorView: () => (/* binding */ EditorView),\n/* harmony export */   GutterMarker: () => (/* binding */ GutterMarker),\n/* harmony export */   MatchDecorator: () => (/* binding */ MatchDecorator),\n/* harmony export */   RectangleMarker: () => (/* binding */ RectangleMarker),\n/* harmony export */   ViewPlugin: () => (/* binding */ ViewPlugin),\n/* harmony export */   ViewUpdate: () => (/* binding */ ViewUpdate),\n/* harmony export */   WidgetType: () => (/* binding */ WidgetType),\n/* harmony export */   __test: () => (/* binding */ __test),\n/* harmony export */   closeHoverTooltips: () => (/* binding */ closeHoverTooltips),\n/* harmony export */   crosshairCursor: () => (/* binding */ crosshairCursor),\n/* harmony export */   drawSelection: () => (/* binding */ drawSelection),\n/* harmony export */   dropCursor: () => (/* binding */ dropCursor),\n/* harmony export */   getDrawSelectionConfig: () => (/* binding */ getDrawSelectionConfig),\n/* harmony export */   getPanel: () => (/* binding */ getPanel),\n/* harmony export */   getTooltip: () => (/* binding */ getTooltip),\n/* harmony export */   gutter: () => (/* binding */ gutter),\n/* harmony export */   gutterLineClass: () => (/* binding */ gutterLineClass),\n/* harmony export */   gutterWidgetClass: () => (/* binding */ gutterWidgetClass),\n/* harmony export */   gutters: () => (/* binding */ gutters),\n/* harmony export */   hasHoverTooltips: () => (/* binding */ hasHoverTooltips),\n/* harmony export */   highlightActiveLine: () => (/* binding */ highlightActiveLine),\n/* harmony export */   highlightActiveLineGutter: () => (/* binding */ highlightActiveLineGutter),\n/* harmony export */   highlightSpecialChars: () => (/* binding */ highlightSpecialChars),\n/* harmony export */   highlightTrailingWhitespace: () => (/* binding */ highlightTrailingWhitespace),\n/* harmony export */   highlightWhitespace: () => (/* binding */ highlightWhitespace),\n/* harmony export */   hoverTooltip: () => (/* binding */ hoverTooltip),\n/* harmony export */   keymap: () => (/* binding */ keymap),\n/* harmony export */   layer: () => (/* binding */ layer),\n/* harmony export */   lineNumberMarkers: () => (/* binding */ lineNumberMarkers),\n/* harmony export */   lineNumberWidgetMarker: () => (/* binding */ lineNumberWidgetMarker),\n/* harmony export */   lineNumbers: () => (/* binding */ lineNumbers),\n/* harmony export */   logException: () => (/* binding */ logException),\n/* harmony export */   panels: () => (/* binding */ panels),\n/* harmony export */   placeholder: () => (/* binding */ placeholder),\n/* harmony export */   rectangularSelection: () => (/* binding */ rectangularSelection),\n/* harmony export */   repositionTooltips: () => (/* binding */ repositionTooltips),\n/* harmony export */   runScopeHandlers: () => (/* binding */ runScopeHandlers),\n/* harmony export */   scrollPastEnd: () => (/* binding */ scrollPastEnd),\n/* harmony export */   showPanel: () => (/* binding */ showPanel),\n/* harmony export */   showTooltip: () => (/* binding */ showTooltip),\n/* harmony export */   tooltips: () => (/* binding */ tooltips)\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @codemirror/state */ \"(ssr)/./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-mod */ \"(ssr)/./node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! w3c-keyname */ \"(ssr)/./node_modules/w3c-keyname/index.js\");\n\n\n\nfunction getSelection(root) {\n    let target;\n    // Browsers differ on whether shadow roots have a getSelection\n    // method. If it exists, use that, otherwise, call it on the\n    // document.\n    if (root.nodeType == 11) {\n        target = root.getSelection ? root : root.ownerDocument;\n    } else {\n        target = root;\n    }\n    return target.getSelection();\n}\nfunction contains(dom, node) {\n    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;\n}\nfunction hasSelection(dom, selection) {\n    if (!selection.anchorNode) return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return contains(dom, selection.anchorNode);\n    } catch (_) {\n        return false;\n    }\n}\nfunction clientRectsFor(dom) {\n    if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();\n    else if (dom.nodeType == 1) return dom.getClientRects();\n    else return [];\n}\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;\n}\nfunction domIndex(node) {\n    for(var index = 0;; index++){\n        node = node.previousSibling;\n        if (!node) return index;\n    }\n}\nfunction isBlockElement(node) {\n    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    for(;;){\n        if (node == targetNode && off == targetOff) return true;\n        if (off == (dir < 0 ? 0 : maxOffset(node))) {\n            if (node.nodeName == \"DIV\") return false;\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1) return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        } else if (node.nodeType == 1) {\n            node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (node.nodeType == 1 && node.contentEditable == \"false\") return false;\n            off = dir < 0 ? maxOffset(node) : 0;\n        } else {\n            return false;\n        }\n    }\n}\nfunction maxOffset(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction flattenRect(rect, left) {\n    let x = left ? rect.left : rect.right;\n    return {\n        left: x,\n        right: x,\n        top: rect.top,\n        bottom: rect.bottom\n    };\n}\nfunction windowRect(win) {\n    let vp = win.visualViewport;\n    if (vp) return {\n        left: 0,\n        right: vp.width,\n        top: 0,\n        bottom: vp.height\n    };\n    return {\n        left: 0,\n        right: win.innerWidth,\n        top: 0,\n        bottom: win.innerHeight\n    };\n}\nfunction getScale(elt, rect) {\n    let scaleX = rect.width / elt.offsetWidth;\n    let scaleY = rect.height / elt.offsetHeight;\n    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1) scaleX = 1;\n    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1) scaleY = 1;\n    return {\n        scaleX,\n        scaleY\n    };\n}\nfunction scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\n    for(let cur = dom, stop = false; cur && !stop;){\n        if (cur.nodeType == 1) {\n            let bounding, top = cur == doc.body;\n            let scaleX = 1, scaleY = 1;\n            if (top) {\n                bounding = windowRect(win);\n            } else {\n                if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position)) stop = true;\n                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n                    cur = cur.assignedSlot || cur.parentNode;\n                    continue;\n                }\n                let rect = cur.getBoundingClientRect();\n                ({ scaleX, scaleY } = getScale(cur, rect));\n                // Make sure scrollbar width isn't included in the rectangle\n                bounding = {\n                    left: rect.left,\n                    right: rect.left + cur.clientWidth * scaleX,\n                    top: rect.top,\n                    bottom: rect.top + cur.clientHeight * scaleY\n                };\n            }\n            let moveX = 0, moveY = 0;\n            if (y == \"nearest\") {\n                if (rect.top < bounding.top) {\n                    moveY = rect.top - (bounding.top + yMargin);\n                    if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + yMargin;\n                } else if (rect.bottom > bounding.bottom) {\n                    moveY = rect.bottom - bounding.bottom + yMargin;\n                    if (side < 0 && rect.top - moveY < bounding.top) moveY = rect.top - (bounding.top + yMargin);\n                }\n            } else {\n                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;\n                let targetTop = y == \"center\" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == \"start\" || y == \"center\" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;\n                moveY = targetTop - bounding.top;\n            }\n            if (x == \"nearest\") {\n                if (rect.left < bounding.left) {\n                    moveX = rect.left - (bounding.left + xMargin);\n                    if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + xMargin;\n                } else if (rect.right > bounding.right) {\n                    moveX = rect.right - bounding.right + xMargin;\n                    if (side < 0 && rect.left < bounding.left + moveX) moveX = rect.left - (bounding.left + xMargin);\n                }\n            } else {\n                let targetLeft = x == \"center\" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == \"start\" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;\n                moveX = targetLeft - bounding.left;\n            }\n            if (moveX || moveY) {\n                if (top) {\n                    win.scrollBy(moveX, moveY);\n                } else {\n                    let movedX = 0, movedY = 0;\n                    if (moveY) {\n                        let start = cur.scrollTop;\n                        cur.scrollTop += moveY / scaleY;\n                        movedY = (cur.scrollTop - start) * scaleY;\n                    }\n                    if (moveX) {\n                        let start = cur.scrollLeft;\n                        cur.scrollLeft += moveX / scaleX;\n                        movedX = (cur.scrollLeft - start) * scaleX;\n                    }\n                    rect = {\n                        left: rect.left - movedX,\n                        top: rect.top - movedY,\n                        right: rect.right - movedX,\n                        bottom: rect.bottom - movedY\n                    };\n                    if (movedX && Math.abs(movedX - moveX) < 1) x = \"nearest\";\n                    if (movedY && Math.abs(movedY - moveY) < 1) y = \"nearest\";\n                }\n            }\n            if (top) break;\n            if (rect.top < bounding.top || rect.bottom > bounding.bottom || rect.left < bounding.left || rect.right > bounding.right) rect = {\n                left: Math.max(rect.left, bounding.left),\n                right: Math.min(rect.right, bounding.right),\n                top: Math.max(rect.top, bounding.top),\n                bottom: Math.min(rect.bottom, bounding.bottom)\n            };\n            cur = cur.assignedSlot || cur.parentNode;\n        } else if (cur.nodeType == 11) {\n            cur = cur.host;\n        } else {\n            break;\n        }\n    }\n}\nfunction scrollableParents(dom) {\n    let doc = dom.ownerDocument, x, y;\n    for(let cur = dom.parentNode; cur;){\n        if (cur == doc.body || x && y) {\n            break;\n        } else if (cur.nodeType == 1) {\n            if (!y && cur.scrollHeight > cur.clientHeight) y = cur;\n            if (!x && cur.scrollWidth > cur.clientWidth) x = cur;\n            cur = cur.assignedSlot || cur.parentNode;\n        } else if (cur.nodeType == 11) {\n            cur = cur.host;\n        } else {\n            break;\n        }\n    }\n    return {\n        x,\n        y\n    };\n}\nclass DOMSelectionState {\n    constructor(){\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    eq(domSel) {\n        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n    }\n    setRange(range) {\n        let { anchorNode, focusNode } = range;\n        // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)\n        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));\n    }\n    set(anchorNode, anchorOffset, focusNode, focusOffset) {\n        this.anchorNode = anchorNode;\n        this.anchorOffset = anchorOffset;\n        this.focusNode = focusNode;\n        this.focusOffset = focusOffset;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive) return dom.setActive(); // in IE\n    if (preventScrollSupported) return dom.focus(preventScrollSupported);\n    let stack = [];\n    for(let cur = dom; cur; cur = cur.parentNode){\n        stack.push(cur, cur.scrollTop, cur.scrollLeft);\n        if (cur == cur.ownerDocument) break;\n    }\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll () {\n            preventScrollSupported = {\n                preventScroll: true\n            };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        for(let i = 0; i < stack.length;){\n            let elt = stack[i++], top = stack[i++], left = stack[i++];\n            if (elt.scrollTop != top) elt.scrollTop = top;\n            if (elt.scrollLeft != left) elt.scrollLeft = left;\n        }\n    }\n}\nlet scratchRange;\nfunction textRange(node, from, to = from) {\n    let range = scratchRange || (scratchRange = document.createRange());\n    range.setEnd(node, to);\n    range.setStart(node, from);\n    return range;\n}\nfunction dispatchKey(elt, name, code, mods) {\n    let options = {\n        key: name,\n        code: name,\n        keyCode: code,\n        which: code,\n        cancelable: true\n    };\n    if (mods) ({ altKey: options.altKey, ctrlKey: options.ctrlKey, shiftKey: options.shiftKey, metaKey: options.metaKey } = mods);\n    let down = new KeyboardEvent(\"keydown\", options);\n    down.synthetic = true;\n    elt.dispatchEvent(down);\n    let up = new KeyboardEvent(\"keyup\", options);\n    up.synthetic = true;\n    elt.dispatchEvent(up);\n    return down.defaultPrevented || up.defaultPrevented;\n}\nfunction getRoot(node) {\n    while(node){\n        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host)) return node;\n        node = node.assignedSlot || node.parentNode;\n    }\n    return null;\n}\nfunction clearAttributes(node) {\n    while(node.attributes.length)node.removeAttributeNode(node.attributes[0]);\n}\nfunction atElementStart(doc, selection) {\n    let node = selection.focusNode, offset = selection.focusOffset;\n    if (!node || selection.anchorNode != node || selection.anchorOffset != offset) return false;\n    // Safari can report bogus offsets (#1152)\n    offset = Math.min(offset, maxOffset(node));\n    for(;;){\n        if (offset) {\n            if (node.nodeType != 1) return false;\n            let prev = node.childNodes[offset - 1];\n            if (prev.contentEditable == \"false\") offset--;\n            else {\n                node = prev;\n                offset = maxOffset(node);\n            }\n        } else if (node == doc) {\n            return true;\n        } else {\n            offset = domIndex(node);\n            node = node.parentNode;\n        }\n    }\n}\nfunction isScrolledToBottom(elt) {\n    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);\n}\nfunction textNodeBefore(startNode, startOffset) {\n    for(let node = startNode, offset = startOffset;;){\n        if (node.nodeType == 3 && offset > 0) {\n            return {\n                node: node,\n                offset: offset\n            };\n        } else if (node.nodeType == 1 && offset > 0) {\n            if (node.contentEditable == \"false\") return null;\n            node = node.childNodes[offset - 1];\n            offset = maxOffset(node);\n        } else if (node.parentNode && !isBlockElement(node)) {\n            offset = domIndex(node);\n            node = node.parentNode;\n        } else {\n            return null;\n        }\n    }\n}\nfunction textNodeAfter(startNode, startOffset) {\n    for(let node = startNode, offset = startOffset;;){\n        if (node.nodeType == 3 && offset < node.nodeValue.length) {\n            return {\n                node: node,\n                offset: offset\n            };\n        } else if (node.nodeType == 1 && offset < node.childNodes.length) {\n            if (node.contentEditable == \"false\") return null;\n            node = node.childNodes[offset];\n            offset = 0;\n        } else if (node.parentNode && !isBlockElement(node)) {\n            offset = domIndex(node) + 1;\n            node = node.parentNode;\n        } else {\n            return null;\n        }\n    }\n}\nclass DOMPos {\n    constructor(node, offset, precise = true){\n        this.node = node;\n        this.offset = offset;\n        this.precise = precise;\n    }\n    static before(dom, precise) {\n        return new DOMPos(dom.parentNode, domIndex(dom), precise);\n    }\n    static after(dom, precise) {\n        return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);\n    }\n}\nconst noChildren = [];\nclass ContentView {\n    constructor(){\n        this.parent = null;\n        this.dom = null;\n        this.flags = 2 /* ViewFlag.NodeDirty */ ;\n    }\n    get overrideDOMText() {\n        return null;\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBefore(this) : 0;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.length;\n    }\n    posBefore(view) {\n        let pos = this.posAtStart;\n        for (let child of this.children){\n            if (child == view) return pos;\n            pos += child.length + child.breakAfter;\n        }\n        throw new RangeError(\"Invalid child in posBefore\");\n    }\n    posAfter(view) {\n        return this.posBefore(view) + view.length;\n    }\n    sync(view, track) {\n        if (this.flags & 2 /* ViewFlag.NodeDirty */ ) {\n            let parent = this.dom;\n            let prev = null, next;\n            for (let child of this.children){\n                if (child.flags & 7 /* ViewFlag.Dirty */ ) {\n                    if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {\n                        let contentView = ContentView.get(next);\n                        if (!contentView || !contentView.parent && contentView.canReuseDOM(child)) child.reuseDOM(next);\n                    }\n                    child.sync(view, track);\n                    child.flags &= ~7 /* ViewFlag.Dirty */ ;\n                }\n                next = prev ? prev.nextSibling : parent.firstChild;\n                if (track && !track.written && track.node == parent && next != child.dom) track.written = true;\n                if (child.dom.parentNode == parent) {\n                    while(next && next != child.dom)next = rm$1(next);\n                } else {\n                    parent.insertBefore(child.dom, next);\n                }\n                prev = child.dom;\n            }\n            next = prev ? prev.nextSibling : parent.firstChild;\n            if (next && track && track.node == parent) track.written = true;\n            while(next)next = rm$1(next);\n        } else if (this.flags & 1 /* ViewFlag.ChildDirty */ ) {\n            for (let child of this.children)if (child.flags & 7 /* ViewFlag.Dirty */ ) {\n                child.sync(view, track);\n                child.flags &= ~7 /* ViewFlag.Dirty */ ;\n            }\n        }\n    }\n    reuseDOM(_dom) {}\n    localPosFromDOM(node, offset) {\n        let after;\n        if (node == this.dom) {\n            after = this.dom.childNodes[offset];\n        } else {\n            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n            for(;;){\n                let parent = node.parentNode;\n                if (parent == this.dom) break;\n                if (bias == 0 && parent.firstChild != parent.lastChild) {\n                    if (node == parent.firstChild) bias = -1;\n                    else bias = 1;\n                }\n                node = parent;\n            }\n            if (bias < 0) after = node;\n            else after = node.nextSibling;\n        }\n        if (after == this.dom.firstChild) return 0;\n        while(after && !ContentView.get(after))after = after.nextSibling;\n        if (!after) return this.length;\n        for(let i = 0, pos = 0;; i++){\n            let child = this.children[i];\n            if (child.dom == after) return pos;\n            pos += child.length + child.breakAfter;\n        }\n    }\n    domBoundsAround(from, to, offset = 0) {\n        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;\n        for(let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (pos < from && end > to) return child.domBoundsAround(from, to, pos);\n            if (end >= from && fromI == -1) {\n                fromI = i;\n                fromStart = pos;\n            }\n            if (pos > to && child.dom.parentNode == this.dom) {\n                toI = i;\n                toEnd = prevEnd;\n                break;\n            }\n            prevEnd = end;\n            pos = end + child.breakAfter;\n        }\n        return {\n            from: fromStart,\n            to: toEnd < 0 ? offset + this.length : toEnd,\n            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\n            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null\n        };\n    }\n    markDirty(andParent = false) {\n        this.flags |= 2 /* ViewFlag.NodeDirty */ ;\n        this.markParentsDirty(andParent);\n    }\n    markParentsDirty(childList) {\n        for(let parent = this.parent; parent; parent = parent.parent){\n            if (childList) parent.flags |= 2 /* ViewFlag.NodeDirty */ ;\n            if (parent.flags & 1 /* ViewFlag.ChildDirty */ ) return;\n            parent.flags |= 1 /* ViewFlag.ChildDirty */ ;\n            childList = false;\n        }\n    }\n    setParent(parent) {\n        if (this.parent != parent) {\n            this.parent = parent;\n            if (this.flags & 7 /* ViewFlag.Dirty */ ) this.markParentsDirty(true);\n        }\n    }\n    setDOM(dom) {\n        if (this.dom == dom) return;\n        if (this.dom) this.dom.cmView = null;\n        this.dom = dom;\n        dom.cmView = this;\n    }\n    get rootView() {\n        for(let v = this;;){\n            let parent = v.parent;\n            if (!parent) return v;\n            v = parent;\n        }\n    }\n    replaceChildren(from, to, children = noChildren) {\n        this.markDirty();\n        for(let i = from; i < to; i++){\n            let child = this.children[i];\n            if (child.parent == this && children.indexOf(child) < 0) child.destroy();\n        }\n        if (children.length < 250) this.children.splice(from, to - from, ...children);\n        else this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to));\n        for(let i = 0; i < children.length; i++)children[i].setParent(this);\n    }\n    ignoreMutation(_rec) {\n        return false;\n    }\n    ignoreEvent(_event) {\n        return false;\n    }\n    childCursor(pos = this.length) {\n        return new ChildCursor(this.children, pos, this.children.length);\n    }\n    childPos(pos, bias = 1) {\n        return this.childCursor().findPos(pos, bias);\n    }\n    toString() {\n        let name = this.constructor.name.replace(\"View\", \"\");\n        return name + (this.children.length ? \"(\" + this.children.join() + \")\" : this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") + (this.breakAfter ? \"#\" : \"\");\n    }\n    static get(node) {\n        return node.cmView;\n    }\n    get isEditable() {\n        return true;\n    }\n    get isWidget() {\n        return false;\n    }\n    get isHidden() {\n        return false;\n    }\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        return false;\n    }\n    become(other) {\n        return false;\n    }\n    canReuseDOM(other) {\n        return other.constructor == this.constructor && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */ );\n    }\n    // When this is a zero-length view with a side, this should return a\n    // number <= 0 to indicate it is before its position, or a\n    // number > 0 when after its position.\n    getSide() {\n        return 0;\n    }\n    destroy() {\n        for (let child of this.children)if (child.parent == this) child.destroy();\n        this.parent = null;\n    }\n}\nContentView.prototype.breakAfter = 0;\n// Remove a DOM node and return its next sibling.\nfunction rm$1(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\nclass ChildCursor {\n    constructor(children, pos, i){\n        this.children = children;\n        this.pos = pos;\n        this.i = i;\n        this.off = 0;\n    }\n    findPos(pos, bias = 1) {\n        for(;;){\n            if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n                this.off = pos - this.pos;\n                return this;\n            }\n            let next = this.children[--this.i];\n            this.pos -= next.length + next.breakAfter;\n        }\n    }\n}\nfunction replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {\n    let { children } = parent;\n    let before = children.length ? children[fromI] : null;\n    let last = insert.length ? insert[insert.length - 1] : null;\n    let breakAtEnd = last ? last.breakAfter : breakAtStart;\n    // Change within a single child\n    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 && before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd)) return;\n    if (toI < children.length) {\n        let after = children[toI];\n        // Make sure the end of the child after the update is preserved in `after`\n        if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {\n            // If we're splitting a child, separate part of it to avoid that\n            // being mangled when updating the child before the update.\n            if (fromI == toI) {\n                after = after.split(toOff);\n                toOff = 0;\n            }\n            // If the element after the replacement should be merged with\n            // the last replacing element, update `content`\n            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {\n                insert[insert.length - 1] = after;\n            } else {\n                // Remove the start of the after element, if necessary, and\n                // add it to `content`.\n                if (toOff || after.children.length && !after.children[0].length) after.merge(0, toOff, null, false, 0, openEnd);\n                insert.push(after);\n            }\n        } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {\n            // The element at `toI` is entirely covered by this range.\n            // Preserve its line break, if any.\n            if (last) last.breakAfter = 1;\n            else breakAtStart = 1;\n        }\n        // Since we've handled the next element from the current elements\n        // now, make sure `toI` points after that.\n        toI++;\n    }\n    if (before) {\n        before.breakAfter = breakAtStart;\n        if (fromOff > 0) {\n            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {\n                before.breakAfter = insert.shift().breakAfter;\n            } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n                before.merge(fromOff, before.length, null, false, openStart, 0);\n            }\n            fromI++;\n        }\n    }\n    // Try to merge widgets on the boundaries of the replacement\n    while(fromI < toI && insert.length){\n        if (children[toI - 1].become(insert[insert.length - 1])) {\n            toI--;\n            insert.pop();\n            openEnd = insert.length ? 0 : openStart;\n        } else if (children[fromI].become(insert[0])) {\n            fromI++;\n            insert.shift();\n            openStart = insert.length ? 0 : openEnd;\n        } else {\n            break;\n        }\n    }\n    if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd)) fromI--;\n    if (fromI < toI || insert.length) parent.replaceChildren(fromI, toI, insert);\n}\nfunction mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {\n    let cur = parent.childCursor();\n    let { i: toI, off: toOff } = cur.findPos(to, 1);\n    let { i: fromI, off: fromOff } = cur.findPos(from, -1);\n    let dLen = from - to;\n    for (let view of insert)dLen += view.length;\n    parent.length += dLen;\n    replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);\n}\nlet nav = typeof navigator != \"undefined\" ? navigator : {\n    userAgent: \"\",\n    vendor: \"\",\n    platform: \"\"\n};\nlet doc = typeof document != \"undefined\" ? document : {\n    documentElement: {\n        style: {}\n    }\n};\nconst ie_edge = /*@__PURE__*/ /Edge\\/(\\d+)/.exec(nav.userAgent);\nconst ie_upto10 = /*@__PURE__*/ /MSIE \\d/.test(nav.userAgent);\nconst ie_11up = /*@__PURE__*/ /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst gecko = !ie && /*@__PURE__*/ /gecko\\/(\\d+)/i.test(nav.userAgent);\nconst chrome = !ie && /*@__PURE__*/ /Chrome\\/(\\d+)/.exec(nav.userAgent);\nconst webkit = \"webkitFontSmoothing\" in doc.documentElement.style;\nconst safari = !ie && /*@__PURE__*/ /Apple Computer/.test(nav.vendor);\nconst ios = safari && /*@__PURE__*/ (/Mobile\\/\\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);\nvar browser = {\n    mac: ios || /*@__PURE__*/ /Mac/.test(nav.platform),\n    windows: /*@__PURE__*/ /Win/.test(nav.platform),\n    linux: /*@__PURE__*/ /Linux|X11/.test(nav.platform),\n    ie,\n    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n    gecko,\n    gecko_version: gecko ? +/*@__PURE__*/ (/Firefox\\/(\\d+)/.exec(nav.userAgent) || [\n        0,\n        0\n    ])[1] : 0,\n    chrome: !!chrome,\n    chrome_version: chrome ? +chrome[1] : 0,\n    ios,\n    android: /*@__PURE__*/ /Android\\b/.test(nav.userAgent),\n    webkit,\n    safari,\n    webkit_version: webkit ? +/*@__PURE__*/ (/\\bAppleWebKit\\/(\\d+)/.exec(nav.userAgent) || [\n        0,\n        0\n    ])[1] : 0,\n    tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\nconst MaxJoinLen = 256;\nclass TextView extends ContentView {\n    constructor(text){\n        super();\n        this.text = text;\n    }\n    get length() {\n        return this.text.length;\n    }\n    createDOM(textDOM) {\n        this.setDOM(textDOM || document.createTextNode(this.text));\n    }\n    sync(view, track) {\n        if (!this.dom) this.createDOM();\n        if (this.dom.nodeValue != this.text) {\n            if (track && track.node == this.dom) track.written = true;\n            this.dom.nodeValue = this.text;\n        }\n    }\n    reuseDOM(dom) {\n        if (dom.nodeType == 3) this.createDOM(dom);\n    }\n    merge(from, to, source) {\n        if (this.flags & 8 /* ViewFlag.Composition */  || source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen || source.flags & 8 /* ViewFlag.Composition */ )) return false;\n        this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n        this.markDirty();\n        return true;\n    }\n    split(from) {\n        let result = new TextView(this.text.slice(from));\n        this.text = this.text.slice(0, from);\n        this.markDirty();\n        result.flags |= this.flags & 8 /* ViewFlag.Composition */ ;\n        return result;\n    }\n    localPosFromDOM(node, offset) {\n        return node == this.dom ? offset : offset ? this.text.length : 0;\n    }\n    domAtPos(pos) {\n        return new DOMPos(this.dom, pos);\n    }\n    domBoundsAround(_from, _to, offset) {\n        return {\n            from: offset,\n            to: offset + this.length,\n            startDOM: this.dom,\n            endDOM: this.dom.nextSibling\n        };\n    }\n    coordsAt(pos, side) {\n        return textCoords(this.dom, pos, side);\n    }\n}\nclass MarkView extends ContentView {\n    constructor(mark, children = [], length = 0){\n        super();\n        this.mark = mark;\n        this.children = children;\n        this.length = length;\n        for (let ch of children)ch.setParent(this);\n    }\n    setAttrs(dom) {\n        clearAttributes(dom);\n        if (this.mark.class) dom.className = this.mark.class;\n        if (this.mark.attrs) for(let name in this.mark.attrs)dom.setAttribute(name, this.mark.attrs[name]);\n        return dom;\n    }\n    canReuseDOM(other) {\n        return super.canReuseDOM(other) && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */ );\n    }\n    reuseDOM(node) {\n        if (node.nodeName == this.mark.tagName.toUpperCase()) {\n            this.setDOM(node);\n            this.flags |= 4 /* ViewFlag.AttrsDirty */  | 2 /* ViewFlag.NodeDirty */ ;\n        }\n    }\n    sync(view, track) {\n        if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));\n        else if (this.flags & 4 /* ViewFlag.AttrsDirty */ ) this.setAttrs(this.dom);\n        super.sync(view, track);\n    }\n    merge(from, to, source, _hasStart, openStart, openEnd) {\n        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);\n        this.markDirty();\n        return true;\n    }\n    split(from) {\n        let result = [], off = 0, detachFrom = -1, i = 0;\n        for (let elt of this.children){\n            let end = off + elt.length;\n            if (end > from) result.push(off < from ? elt.split(from - off) : elt);\n            if (detachFrom < 0 && off >= from) detachFrom = i;\n            off = end;\n            i++;\n        }\n        let length = this.length - from;\n        this.length = from;\n        if (detachFrom > -1) {\n            this.children.length = detachFrom;\n            this.markDirty();\n        }\n        return new MarkView(this.mark, result, length);\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this, pos);\n    }\n    coordsAt(pos, side) {\n        return coordsInChildren(this, pos, side);\n    }\n}\nfunction textCoords(text, pos, side) {\n    let length = text.nodeValue.length;\n    if (pos > length) pos = length;\n    let from = pos, to = pos, flatten = 0;\n    if (pos == 0 && side < 0 || pos == length && side >= 0) {\n        if (!(browser.chrome || browser.gecko)) {\n            if (pos) {\n                from--;\n                flatten = 1;\n            } else if (to < length) {\n                to++;\n                flatten = -1;\n            }\n        }\n    } else {\n        if (side < 0) from--;\n        else if (to < length) to++;\n    }\n    let rects = textRange(text, from, to).getClientRects();\n    if (!rects.length) return null;\n    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\n    if (browser.safari && !flatten && rect.width == 0) rect = Array.prototype.find.call(rects, (r)=>r.width) || rect;\n    return flatten ? flattenRect(rect, flatten < 0) : rect || null;\n}\n// Also used for collapsed ranges that don't have a placeholder widget!\nclass WidgetView extends ContentView {\n    static create(widget, length, side) {\n        return new WidgetView(widget, length, side);\n    }\n    constructor(widget, length, side){\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.side = side;\n        this.prevWidget = null;\n    }\n    split(from) {\n        let result = WidgetView.create(this.widget, this.length - from, this.side);\n        this.length -= from;\n        return result;\n    }\n    sync(view) {\n        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n            if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);\n            this.prevWidget = null;\n            this.setDOM(this.widget.toDOM(view));\n            if (!this.widget.editable) this.dom.contentEditable = \"false\";\n        }\n    }\n    getSide() {\n        return this.side;\n    }\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    become(other) {\n        if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {\n            if (!this.widget.compare(other.widget)) this.markDirty(true);\n            if (this.dom && !this.prevWidget) this.prevWidget = this.widget;\n            this.widget = other.widget;\n            this.length = other.length;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() {\n        return true;\n    }\n    ignoreEvent(event) {\n        return this.widget.ignoreEvent(event);\n    }\n    get overrideDOMText() {\n        if (this.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n        let top = this;\n        while(top.parent)top = top.parent;\n        let { view } = top, text = view && view.state.doc, start = this.posAtStart;\n        return text ? text.slice(start, start + this.length) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    domAtPos(pos) {\n        return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    domBoundsAround() {\n        return null;\n    }\n    coordsAt(pos, side) {\n        let custom = this.widget.coordsAt(this.dom, pos, side);\n        if (custom) return custom;\n        let rects = this.dom.getClientRects(), rect = null;\n        if (!rects.length) return null;\n        let fromBack = this.side ? this.side < 0 : pos > 0;\n        for(let i = fromBack ? rects.length - 1 : 0;; i += fromBack ? -1 : 1){\n            rect = rects[i];\n            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break;\n        }\n        return flattenRect(rect, !fromBack);\n    }\n    get isEditable() {\n        return false;\n    }\n    get isWidget() {\n        return true;\n    }\n    get isHidden() {\n        return this.widget.isHidden;\n    }\n    destroy() {\n        super.destroy();\n        if (this.dom) this.widget.destroy(this.dom);\n    }\n}\n// These are drawn around uneditable widgets to avoid a number of\n// browser bugs that show up when the cursor is directly next to\n// uneditable inline content.\nclass WidgetBufferView extends ContentView {\n    constructor(side){\n        super();\n        this.side = side;\n    }\n    get length() {\n        return 0;\n    }\n    merge() {\n        return false;\n    }\n    become(other) {\n        return other instanceof WidgetBufferView && other.side == this.side;\n    }\n    split() {\n        return new WidgetBufferView(this.side);\n    }\n    sync() {\n        if (!this.dom) {\n            let dom = document.createElement(\"img\");\n            dom.className = \"cm-widgetBuffer\";\n            dom.setAttribute(\"aria-hidden\", \"true\");\n            this.setDOM(dom);\n        }\n    }\n    getSide() {\n        return this.side;\n    }\n    domAtPos(pos) {\n        return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);\n    }\n    localPosFromDOM() {\n        return 0;\n    }\n    domBoundsAround() {\n        return null;\n    }\n    coordsAt(pos) {\n        return this.dom.getBoundingClientRect();\n    }\n    get overrideDOMText() {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    get isHidden() {\n        return true;\n    }\n}\nTextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;\nfunction inlineDOMAtPos(parent, pos) {\n    let dom = parent.dom, { children } = parent, i = 0;\n    for(let off = 0; i < children.length; i++){\n        let child = children[i], end = off + child.length;\n        if (end == off && child.getSide() <= 0) continue;\n        if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);\n        if (pos <= off) break;\n        off = end;\n    }\n    for(let j = i; j > 0; j--){\n        let prev = children[j - 1];\n        if (prev.dom.parentNode == dom) return prev.domAtPos(prev.length);\n    }\n    for(let j = i; j < children.length; j++){\n        let next = children[j];\n        if (next.dom.parentNode == dom) return next.domAtPos(0);\n    }\n    return new DOMPos(dom, 0);\n}\n// Assumes `view`, if a mark view, has precisely 1 child.\nfunction joinInlineInto(parent, view, open) {\n    let last, { children } = parent;\n    if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {\n        joinInlineInto(last, view.children[0], open - 1);\n    } else {\n        children.push(view);\n        view.setParent(parent);\n    }\n    parent.length += view.length;\n}\nfunction coordsInChildren(view, pos, side) {\n    let before = null, beforePos = -1, after = null, afterPos = -1;\n    function scan(view, pos) {\n        for(let i = 0, off = 0; i < view.children.length && off <= pos; i++){\n            let child = view.children[i], end = off + child.length;\n            if (end >= pos) {\n                if (child.children.length) {\n                    scan(child, pos - off);\n                } else if ((!after || after.isHidden && side > 0) && (end > pos || off == end && child.getSide() > 0)) {\n                    after = child;\n                    afterPos = pos - off;\n                } else if (off < pos || off == end && child.getSide() < 0 && !child.isHidden) {\n                    before = child;\n                    beforePos = pos - off;\n                }\n            }\n            off = end;\n        }\n    }\n    scan(view, pos);\n    let target = (side < 0 ? before : after) || before || after;\n    if (target) return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);\n    return fallbackRect(view);\n}\nfunction fallbackRect(view) {\n    let last = view.dom.lastChild;\n    if (!last) return view.dom.getBoundingClientRect();\n    let rects = clientRectsFor(last);\n    return rects[rects.length - 1] || null;\n}\nfunction combineAttrs(source, target) {\n    for(let name in source){\n        if (name == \"class\" && target.class) target.class += \" \" + source.class;\n        else if (name == \"style\" && target.style) target.style += \";\" + source.style;\n        else target[name] = source[name];\n    }\n    return target;\n}\nconst noAttrs = /*@__PURE__*/ Object.create(null);\nfunction attrsEq(a, b, ignore) {\n    if (a == b) return true;\n    if (!a) a = noAttrs;\n    if (!b) b = noAttrs;\n    let keysA = Object.keys(a), keysB = Object.keys(b);\n    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0)) return false;\n    for (let key of keysA){\n        if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key])) return false;\n    }\n    return true;\n}\nfunction updateAttrs(dom, prev, attrs) {\n    let changed = false;\n    if (prev) {\n        for(let name in prev)if (!(attrs && name in attrs)) {\n            changed = true;\n            if (name == \"style\") dom.style.cssText = \"\";\n            else dom.removeAttribute(name);\n        }\n    }\n    if (attrs) {\n        for(let name in attrs)if (!(prev && prev[name] == attrs[name])) {\n            changed = true;\n            if (name == \"style\") dom.style.cssText = attrs[name];\n            else dom.setAttribute(name, attrs[name]);\n        }\n    }\n    return changed;\n}\nfunction getAttrs(dom) {\n    let attrs = Object.create(null);\n    for(let i = 0; i < dom.attributes.length; i++){\n        let attr = dom.attributes[i];\n        attrs[attr.name] = attr.value;\n    }\n    return attrs;\n}\n/**\nWidgets added to the content are described by subclasses of this\nclass. Using a description object like that makes it possible to\ndelay creating of the DOM structure for a widget until it is\nneeded, and to avoid redrawing widgets even if the decorations\nthat define them are recreated.\n*/ class WidgetType {\n    /**\n    Compare this instance to another instance of the same type.\n    (TypeScript can't express this, but only instances of the same\n    specific class will be passed to this method.) This is used to\n    avoid redrawing widgets when they are replaced by a new\n    decoration of the same type. The default implementation just\n    returns `false`, which will cause new instances of the widget to\n    always be redrawn.\n    */ eq(widget) {\n        return false;\n    }\n    /**\n    Update a DOM element created by a widget of the same type (but\n    different, non-`eq` content) to reflect this widget. May return\n    true to indicate that it could update, false to indicate it\n    couldn't (in which case the widget will be redrawn). The default\n    implementation just returns false.\n    */ updateDOM(dom, view) {\n        return false;\n    }\n    /**\n    @internal\n    */ compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    The estimated height this widget will have, to be used when\n    estimating the height of content that hasn't been drawn. May\n    return -1 to indicate you don't know. The default implementation\n    returns -1.\n    */ get estimatedHeight() {\n        return -1;\n    }\n    /**\n    For inline widgets that are displayed inline (as opposed to\n    `inline-block`) and introduce line breaks (through `<br>` tags\n    or textual newlines), this must indicate the amount of line\n    breaks they introduce. Defaults to 0.\n    */ get lineBreaks() {\n        return 0;\n    }\n    /**\n    Can be used to configure which kinds of events inside the widget\n    should be ignored by the editor. The default is to ignore all\n    events.\n    */ ignoreEvent(event) {\n        return true;\n    }\n    /**\n    Override the way screen coordinates for positions at/in the\n    widget are found. `pos` will be the offset into the widget, and\n    `side` the side of the position that is being queried—less than\n    zero for before, greater than zero for after, and zero for\n    directly at that position.\n    */ coordsAt(dom, pos, side) {\n        return null;\n    }\n    /**\n    @internal\n    */ get isHidden() {\n        return false;\n    }\n    /**\n    @internal\n    */ get editable() {\n        return false;\n    }\n    /**\n    This is called when the an instance of the widget is removed\n    from the editor view.\n    */ destroy(dom) {}\n}\n/**\nThe different types of blocks that can occur in an editor view.\n*/ var BlockType = /*@__PURE__*/ function(BlockType) {\n    /**\n    A line of text.\n    */ BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n    /**\n    A block widget associated with the position after it.\n    */ BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n    /**\n    A block widget associated with the position before it.\n    */ BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n    /**\n    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.\n    */ BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n    return BlockType;\n}(BlockType || (BlockType = {}));\n/**\nA decoration provides information on how to draw or style a piece\nof content. You'll usually use it wrapped in a\n[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.\n@nonabstract\n*/ class Decoration extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\n    constructor(/**\n    @internal\n    */ startSide, /**\n    @internal\n    */ endSide, /**\n    @internal\n    */ widget, /**\n    The config object used to create this decoration. You can\n    include additional properties in there to store metadata about\n    your decoration.\n    */ spec){\n        super();\n        this.startSide = startSide;\n        this.endSide = endSide;\n        this.widget = widget;\n        this.spec = spec;\n    }\n    /**\n    @internal\n    */ get heightRelevant() {\n        return false;\n    }\n    /**\n    Create a mark decoration, which influences the styling of the\n    content in its range. Nested mark decorations will cause nested\n    DOM elements to be created. Nesting order is determined by\n    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with\n    the higher-precedence decorations creating the inner DOM nodes.\n    Such elements are split on line boundaries and on the boundaries\n    of lower-precedence decorations.\n    */ static mark(spec) {\n        return new MarkDecoration(spec);\n    }\n    /**\n    Create a widget decoration, which displays a DOM element at the\n    given position.\n    */ static widget(spec) {\n        let side = Math.max(-10000, Math.min(10000, spec.side || 0)), block = !!spec.block;\n        side += block && !spec.inlineOrder ? side > 0 ? 300000000 /* Side.BlockAfter */  : -400000000 /* Side.BlockBefore */  : side > 0 ? 100000000 /* Side.InlineAfter */  : -100000000 /* Side.InlineBefore */ ;\n        return new PointDecoration(spec, side, side, block, spec.widget || null, false);\n    }\n    /**\n    Create a replace decoration which replaces the given range with\n    a widget, or simply hides it.\n    */ static replace(spec) {\n        let block = !!spec.block, startSide, endSide;\n        if (spec.isBlockGap) {\n            startSide = -500000000 /* Side.GapStart */ ;\n            endSide = 400000000 /* Side.GapEnd */ ;\n        } else {\n            let { start, end } = getInclusive(spec, block);\n            startSide = (start ? block ? -300000000 /* Side.BlockIncStart */  : -1 /* Side.InlineIncStart */  : 500000000 /* Side.NonIncStart */ ) - 1;\n            endSide = (end ? block ? 200000000 /* Side.BlockIncEnd */  : 1 /* Side.InlineIncEnd */  : -600000000 /* Side.NonIncEnd */ ) + 1;\n        }\n        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n    }\n    /**\n    Create a line decoration, which can add DOM attributes to the\n    line starting at the given position.\n    */ static line(spec) {\n        return new LineDecoration(spec);\n    }\n    /**\n    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given\n    decorated range or ranges. If the ranges aren't already sorted,\n    pass `true` for `sort` to make the library sort them for you.\n    */ static set(of, sort = false) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(of, sort);\n    }\n    /**\n    @internal\n    */ hasHeight() {\n        return this.widget ? this.widget.estimatedHeight > -1 : false;\n    }\n}\n/**\nThe empty set of decorations.\n*/ Decoration.none = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty;\nclass MarkDecoration extends Decoration {\n    constructor(spec){\n        let { start, end } = getInclusive(spec);\n        super(start ? -1 /* Side.InlineIncStart */  : 500000000 /* Side.NonIncStart */ , end ? 1 /* Side.InlineIncEnd */  : -600000000 /* Side.NonIncEnd */ , null, spec);\n        this.tagName = spec.tagName || \"span\";\n        this.class = spec.class || \"\";\n        this.attrs = spec.attributes || null;\n    }\n    eq(other) {\n        var _a, _b;\n        return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, \"class\");\n    }\n    range(from, to = from) {\n        if (from >= to) throw new RangeError(\"Mark decorations may not be empty\");\n        return super.range(from, to);\n    }\n}\nMarkDecoration.prototype.point = false;\nclass LineDecoration extends Decoration {\n    constructor(spec){\n        super(-200000000 /* Side.Line */ , -200000000 /* Side.Line */ , null, spec);\n    }\n    eq(other) {\n        return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);\n    }\n    range(from, to = from) {\n        if (to != from) throw new RangeError(\"Line decoration ranges must be zero-length\");\n        return super.range(from, to);\n    }\n}\nLineDecoration.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\nLineDecoration.prototype.point = true;\nclass PointDecoration extends Decoration {\n    constructor(spec, startSide, endSide, block, widget, isReplace){\n        super(startSide, endSide, widget, spec);\n        this.block = block;\n        this.isReplace = isReplace;\n        this.mapMode = !block ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel : startSide <= 0 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackAfter;\n    }\n    // Only relevant when this.block == true\n    get type() {\n        return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n    }\n    get heightRelevant() {\n        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);\n    }\n    eq(other) {\n        return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;\n    }\n    range(from, to = from) {\n        if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0)) throw new RangeError(\"Invalid range for replacement decoration\");\n        if (!this.isReplace && to != from) throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n        return super.range(from, to);\n    }\n}\nPointDecoration.prototype.point = true;\nfunction getInclusive(spec, block = false) {\n    let { inclusiveStart: start, inclusiveEnd: end } = spec;\n    if (start == null) start = spec.inclusive;\n    if (end == null) end = spec.inclusive;\n    return {\n        start: start !== null && start !== void 0 ? start : block,\n        end: end !== null && end !== void 0 ? end : block\n    };\n}\nfunction widgetsEq(a, b) {\n    return a == b || !!(a && b && a.compare(b));\n}\nfunction addRange(from, to, ranges, margin = 0) {\n    let last = ranges.length - 1;\n    if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to);\n    else ranges.push(from, to);\n}\nclass LineView extends ContentView {\n    constructor(){\n        super(...arguments);\n        this.children = [];\n        this.length = 0;\n        this.prevAttrs = undefined;\n        this.attrs = null;\n        this.breakAfter = 0;\n    }\n    // Consumes source\n    merge(from, to, source, hasStart, openStart, openEnd) {\n        if (source) {\n            if (!(source instanceof LineView)) return false;\n            if (!this.dom) source.transferDOM(this); // Reuse source.dom when appropriate\n        }\n        if (hasStart) this.setDeco(source ? source.attrs : null);\n        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);\n        return true;\n    }\n    split(at) {\n        let end = new LineView;\n        end.breakAfter = this.breakAfter;\n        if (this.length == 0) return end;\n        let { i, off } = this.childPos(at);\n        if (off) {\n            end.append(this.children[i].split(off), 0);\n            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);\n            i++;\n        }\n        for(let j = i; j < this.children.length; j++)end.append(this.children[j], 0);\n        while(i > 0 && this.children[i - 1].length == 0)this.children[--i].destroy();\n        this.children.length = i;\n        this.markDirty();\n        this.length = at;\n        return end;\n    }\n    transferDOM(other) {\n        if (!this.dom) return;\n        this.markDirty();\n        other.setDOM(this.dom);\n        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n        this.prevAttrs = undefined;\n        this.dom = null;\n    }\n    setDeco(attrs) {\n        if (!attrsEq(this.attrs, attrs)) {\n            if (this.dom) {\n                this.prevAttrs = this.attrs;\n                this.markDirty();\n            }\n            this.attrs = attrs;\n        }\n    }\n    append(child, openStart) {\n        joinInlineInto(this, child, openStart);\n    }\n    // Only called when building a line view in ContentBuilder\n    addLineDeco(deco) {\n        let attrs = deco.spec.attributes, cls = deco.spec.class;\n        if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});\n        if (cls) this.attrs = combineAttrs({\n            class: cls\n        }, this.attrs || {});\n    }\n    domAtPos(pos) {\n        return inlineDOMAtPos(this, pos);\n    }\n    reuseDOM(node) {\n        if (node.nodeName == \"DIV\") {\n            this.setDOM(node);\n            this.flags |= 4 /* ViewFlag.AttrsDirty */  | 2 /* ViewFlag.NodeDirty */ ;\n        }\n    }\n    sync(view, track) {\n        var _a;\n        if (!this.dom) {\n            this.setDOM(document.createElement(\"div\"));\n            this.dom.className = \"cm-line\";\n            this.prevAttrs = this.attrs ? null : undefined;\n        } else if (this.flags & 4 /* ViewFlag.AttrsDirty */ ) {\n            clearAttributes(this.dom);\n            this.dom.className = \"cm-line\";\n            this.prevAttrs = this.attrs ? null : undefined;\n        }\n        if (this.prevAttrs !== undefined) {\n            updateAttrs(this.dom, this.prevAttrs, this.attrs);\n            this.dom.classList.add(\"cm-line\");\n            this.prevAttrs = undefined;\n        }\n        super.sync(view, track);\n        let last = this.dom.lastChild;\n        while(last && ContentView.get(last) instanceof MarkView)last = last.lastChild;\n        if (!last || !this.length || last.nodeName != \"BR\" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false && (!browser.ios || !this.children.some((ch)=>ch instanceof TextView))) {\n            let hack = document.createElement(\"BR\");\n            hack.cmIgnore = true;\n            this.dom.appendChild(hack);\n        }\n    }\n    measureTextSize() {\n        if (this.children.length == 0 || this.length > 20) return null;\n        let totalWidth = 0, textHeight;\n        for (let child of this.children){\n            if (!(child instanceof TextView) || /[^ -~]/.test(child.text)) return null;\n            let rects = clientRectsFor(child.dom);\n            if (rects.length != 1) return null;\n            totalWidth += rects[0].width;\n            textHeight = rects[0].height;\n        }\n        return !totalWidth ? null : {\n            lineHeight: this.dom.getBoundingClientRect().height,\n            charWidth: totalWidth / this.length,\n            textHeight\n        };\n    }\n    coordsAt(pos, side) {\n        let rect = coordsInChildren(this, pos, side);\n        // Correct rectangle height for empty lines when the returned\n        // height is larger than the text height.\n        if (!this.children.length && rect && this.parent) {\n            let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;\n            if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {\n                let dist = (height - heightOracle.textHeight) / 2;\n                return {\n                    top: rect.top + dist,\n                    bottom: rect.bottom - dist,\n                    left: rect.left,\n                    right: rect.left\n                };\n            }\n        }\n        return rect;\n    }\n    become(other) {\n        return other instanceof LineView && this.children.length == 0 && other.children.length == 0 && attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;\n    }\n    covers() {\n        return true;\n    }\n    static find(docView, pos) {\n        for(let i = 0, off = 0; i < docView.children.length; i++){\n            let block = docView.children[i], end = off + block.length;\n            if (end >= pos) {\n                if (block instanceof LineView) return block;\n                if (end > pos) break;\n            }\n            off = end + block.breakAfter;\n        }\n        return null;\n    }\n}\nclass BlockWidgetView extends ContentView {\n    constructor(widget, length, deco){\n        super();\n        this.widget = widget;\n        this.length = length;\n        this.deco = deco;\n        this.breakAfter = 0;\n        this.prevWidget = null;\n    }\n    merge(from, to, source, _takeDeco, openStart, openEnd) {\n        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n        this.length = from + (source ? source.length : 0) + (this.length - to);\n        return true;\n    }\n    domAtPos(pos) {\n        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n    split(at) {\n        let len = this.length - at;\n        this.length = at;\n        let end = new BlockWidgetView(this.widget, len, this.deco);\n        end.breakAfter = this.breakAfter;\n        return end;\n    }\n    get children() {\n        return noChildren;\n    }\n    sync(view) {\n        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {\n            if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);\n            this.prevWidget = null;\n            this.setDOM(this.widget.toDOM(view));\n            if (!this.widget.editable) this.dom.contentEditable = \"false\";\n        }\n    }\n    get overrideDOMText() {\n        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n    }\n    domBoundsAround() {\n        return null;\n    }\n    become(other) {\n        if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {\n            if (!other.widget.compare(this.widget)) this.markDirty(true);\n            if (this.dom && !this.prevWidget) this.prevWidget = this.widget;\n            this.widget = other.widget;\n            this.length = other.length;\n            this.deco = other.deco;\n            this.breakAfter = other.breakAfter;\n            return true;\n        }\n        return false;\n    }\n    ignoreMutation() {\n        return true;\n    }\n    ignoreEvent(event) {\n        return this.widget.ignoreEvent(event);\n    }\n    get isEditable() {\n        return false;\n    }\n    get isWidget() {\n        return true;\n    }\n    coordsAt(pos, side) {\n        let custom = this.widget.coordsAt(this.dom, pos, side);\n        if (custom) return custom;\n        if (this.widget instanceof BlockGapWidget) return null;\n        return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);\n    }\n    destroy() {\n        super.destroy();\n        if (this.dom) this.widget.destroy(this.dom);\n    }\n    covers(side) {\n        let { startSide, endSide } = this.deco;\n        return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;\n    }\n}\nclass BlockGapWidget extends WidgetType {\n    constructor(height){\n        super();\n        this.height = height;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        elt.className = \"cm-gap\";\n        this.updateDOM(elt);\n        return elt;\n    }\n    eq(other) {\n        return other.height == this.height;\n    }\n    updateDOM(elt) {\n        elt.style.height = this.height + \"px\";\n        return true;\n    }\n    get editable() {\n        return true;\n    }\n    get estimatedHeight() {\n        return this.height;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nclass ContentBuilder {\n    constructor(doc, pos, end, disallowBlockEffectsFor){\n        this.doc = doc;\n        this.pos = pos;\n        this.end = end;\n        this.disallowBlockEffectsFor = disallowBlockEffectsFor;\n        this.content = [];\n        this.curLine = null;\n        this.breakAtStart = 0;\n        this.pendingBuffer = 0 /* Buf.No */ ;\n        this.bufferMarks = [];\n        // Set to false directly after a widget that covers the position after it\n        this.atCursorPos = true;\n        this.openStart = -1;\n        this.openEnd = -1;\n        this.text = \"\";\n        this.textOff = 0;\n        this.cursor = doc.iter();\n        this.skip = pos;\n    }\n    posCovered() {\n        if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\n        let last = this.content[this.content.length - 1];\n        return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);\n    }\n    getLine() {\n        if (!this.curLine) {\n            this.content.push(this.curLine = new LineView);\n            this.atCursorPos = true;\n        }\n        return this.curLine;\n    }\n    flushBuffer(active = this.bufferMarks) {\n        if (this.pendingBuffer) {\n            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);\n            this.pendingBuffer = 0 /* Buf.No */ ;\n        }\n    }\n    addBlockWidget(view) {\n        this.flushBuffer();\n        this.curLine = null;\n        this.content.push(view);\n    }\n    finish(openEnd) {\n        if (this.pendingBuffer && openEnd <= this.bufferMarks.length) this.flushBuffer();\n        else this.pendingBuffer = 0 /* Buf.No */ ;\n        if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView)) this.getLine();\n    }\n    buildText(length, active, openStart) {\n        while(length > 0){\n            if (this.textOff == this.text.length) {\n                let { value, lineBreak, done } = this.cursor.next(this.skip);\n                this.skip = 0;\n                if (done) throw new Error(\"Ran out of text content when drawing inline views\");\n                if (lineBreak) {\n                    if (!this.posCovered()) this.getLine();\n                    if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;\n                    else this.breakAtStart = 1;\n                    this.flushBuffer();\n                    this.curLine = null;\n                    this.atCursorPos = true;\n                    length--;\n                    continue;\n                } else {\n                    this.text = value;\n                    this.textOff = 0;\n                }\n            }\n            let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */ );\n            this.flushBuffer(active.slice(active.length - openStart));\n            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);\n            this.atCursorPos = true;\n            this.textOff += take;\n            length -= take;\n            openStart = 0;\n        }\n    }\n    span(from, to, active, openStart) {\n        this.buildText(to - from, active, openStart);\n        this.pos = to;\n        if (this.openStart < 0) this.openStart = openStart;\n    }\n    point(from, to, deco, active, openStart, index) {\n        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {\n            if (deco.block) throw new RangeError(\"Block decorations may not be specified via plugins\");\n            if (to > this.doc.lineAt(this.pos).to) throw new RangeError(\"Decorations that replace line breaks may not be specified via plugins\");\n        }\n        let len = to - from;\n        if (deco instanceof PointDecoration) {\n            if (deco.block) {\n                if (deco.startSide > 0 && !this.posCovered()) this.getLine();\n                this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));\n            } else {\n                let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);\n                let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);\n                let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);\n                let line = this.getLine();\n                if (this.pendingBuffer == 2 /* Buf.IfCursor */  && !cursorBefore && !view.isEditable) this.pendingBuffer = 0 /* Buf.No */ ;\n                this.flushBuffer(active);\n                if (cursorBefore) {\n                    line.append(wrapMarks(new WidgetBufferView(1), active), openStart);\n                    openStart = active.length + Math.max(0, openStart - active.length);\n                }\n                line.append(wrapMarks(view, active), openStart);\n                this.atCursorPos = cursorAfter;\n                this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */  : from < to || openStart > active.length ? 1 /* Buf.Yes */  : 2 /* Buf.IfCursor */ ;\n                if (this.pendingBuffer) this.bufferMarks = active.slice();\n            }\n        } else if (this.doc.lineAt(this.pos).from == this.pos) {\n            this.getLine().addLineDeco(deco);\n        }\n        if (len) {\n            // Advance the iterator past the replaced content\n            if (this.textOff + len <= this.text.length) {\n                this.textOff += len;\n            } else {\n                this.skip += len - (this.text.length - this.textOff);\n                this.text = \"\";\n                this.textOff = 0;\n            }\n            this.pos = to;\n        }\n        if (this.openStart < 0) this.openStart = openStart;\n    }\n    static build(text, from, to, decorations, dynamicDecorationMap) {\n        let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);\n        builder.openEnd = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder);\n        if (builder.openStart < 0) builder.openStart = builder.openEnd;\n        builder.finish(builder.openEnd);\n        return builder;\n    }\n}\nfunction wrapMarks(view, active) {\n    for (let mark of active)view = new MarkView(mark, [\n        view\n    ], view.length);\n    return view;\n}\nclass NullWidget extends WidgetType {\n    constructor(tag){\n        super();\n        this.tag = tag;\n    }\n    eq(other) {\n        return other.tag == this.tag;\n    }\n    toDOM() {\n        return document.createElement(this.tag);\n    }\n    updateDOM(elt) {\n        return elt.nodeName.toLowerCase() == this.tag;\n    }\n    get isHidden() {\n        return true;\n    }\n}\nNullWidget.inline = /*@__PURE__*/ new NullWidget(\"span\");\nNullWidget.block = /*@__PURE__*/ new NullWidget(\"div\");\n/**\nUsed to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n*/ var Direction = /*@__PURE__*/ function(Direction) {\n    // (These are chosen to match the base levels, in bidi algorithm\n    // terms, of spans in that direction.)\n    /**\n    Left-to-right.\n    */ Direction[Direction[\"LTR\"] = 0] = \"LTR\";\n    /**\n    Right-to-left.\n    */ Direction[Direction[\"RTL\"] = 1] = \"RTL\";\n    return Direction;\n}(Direction || (Direction = {}));\nconst LTR = Direction.LTR, RTL = Direction.RTL;\n// Decode a string with each type encoded as log2(type)\nfunction dec(str) {\n    let result = [];\n    for(let i = 0; i < str.length; i++)result.push(1 << +str[i]);\n    return result;\n}\n// Character types for codepoints 0 to 0xf8\nconst LowTypes = /*@__PURE__*/ dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\");\n// Character types for codepoints 0x600 to 0x6f9\nconst ArabicTypes = /*@__PURE__*/ dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\nconst Brackets = /*@__PURE__*/ Object.create(null), BracketStack = [];\n// There's a lot more in\n// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,\n// which are left out to keep code size down.\nfor (let p of [\n    \"()\",\n    \"[]\",\n    \"{}\"\n]){\n    let l = /*@__PURE__*/ p.charCodeAt(0), r = /*@__PURE__*/ p.charCodeAt(1);\n    Brackets[l] = r;\n    Brackets[r] = -l;\n}\nfunction charType(ch) {\n    return ch <= 0xf7 ? LowTypes[ch] : 0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */  : 0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] : 0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */  : 0x2000 <= ch && ch <= 0x200c ? 256 /* T.NI */  : 0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */  : 1 /* T.L */ ;\n}\nconst BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/;\n/**\nRepresents a contiguous range of text that has a single direction\n(as in left-to-right or right-to-left).\n*/ class BidiSpan {\n    /**\n    The direction of this span.\n    */ get dir() {\n        return this.level % 2 ? RTL : LTR;\n    }\n    /**\n    @internal\n    */ constructor(/**\n    The start of the span (relative to the start of the line).\n    */ from, /**\n    The end of the span.\n    */ to, /**\n    The [\"bidi\n    level\"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)\n    of the span (in this context, 0 means\n    left-to-right, 1 means right-to-left, 2 means left-to-right\n    number inside right-to-left text).\n    */ level){\n        this.from = from;\n        this.to = to;\n        this.level = level;\n    }\n    /**\n    @internal\n    */ side(end, dir) {\n        return this.dir == dir == end ? this.to : this.from;\n    }\n    /**\n    @internal\n    */ forward(forward, dir) {\n        return forward == (this.dir == dir);\n    }\n    /**\n    @internal\n    */ static find(order, index, level, assoc) {\n        let maybe = -1;\n        for(let i = 0; i < order.length; i++){\n            let span = order[i];\n            if (span.from <= index && span.to >= index) {\n                if (span.level == level) return i;\n                // When multiple spans match, if assoc != 0, take the one that\n                // covers that side, otherwise take the one with the minimum\n                // level.\n                if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level)) maybe = i;\n            }\n        }\n        if (maybe < 0) throw new RangeError(\"Index out of range\");\n        return maybe;\n    }\n}\nfunction isolatesEq(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++){\n        let iA = a[i], iB = b[i];\n        if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner)) return false;\n    }\n    return true;\n}\n// Reused array of character types\nconst types = [];\n// Fill in the character types (in `types`) from `from` to `to` and\n// apply W normalization rules.\nfunction computeCharTypes(line, rFrom, rTo, isolates, outerType) {\n    for(let iI = 0; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        let prevType = iI ? 256 /* T.NI */  : outerType;\n        // W1. Examine each non-spacing mark (NSM) in the level run, and\n        // change the type of the NSM to the type of the previous\n        // character. If the NSM is at the start of the level run, it will\n        // get the type of sor.\n        // W2. Search backwards from each instance of a European number\n        // until the first strong type (R, L, AL, or sor) is found. If an\n        // AL is found, change the type of the European number to Arabic\n        // number.\n        // W3. Change all ALs to R.\n        // (Left after this: L, R, EN, AN, ET, CS, NI)\n        for(let i = from, prev = prevType, prevStrong = prevType; i < to; i++){\n            let type = charType(line.charCodeAt(i));\n            if (type == 512 /* T.NSM */ ) type = prev;\n            else if (type == 8 /* T.EN */  && prevStrong == 4 /* T.AL */ ) type = 16 /* T.AN */ ;\n            types[i] = type == 4 /* T.AL */  ? 2 /* T.R */  : type;\n            if (type & 7 /* T.Strong */ ) prevStrong = type;\n            prev = type;\n        }\n        // W5. A sequence of European terminators adjacent to European\n        // numbers changes to all European numbers.\n        // W6. Otherwise, separators and terminators change to Other\n        // Neutral.\n        // W7. Search backwards from each instance of a European number\n        // until the first strong type (R, L, or sor) is found. If an L is\n        // found, then change the type of the European number to L.\n        // (Left after this: L, R, EN+AN, NI)\n        for(let i = from, prev = prevType, prevStrong = prevType; i < to; i++){\n            let type = types[i];\n            if (type == 128 /* T.CS */ ) {\n                if (i < to - 1 && prev == types[i + 1] && prev & 24 /* T.Num */ ) type = types[i] = prev;\n                else types[i] = 256 /* T.NI */ ;\n            } else if (type == 64 /* T.ET */ ) {\n                let end = i + 1;\n                while(end < to && types[end] == 64 /* T.ET */ )end++;\n                let replace = i && prev == 8 /* T.EN */  || end < rTo && types[end] == 8 /* T.EN */  ? prevStrong == 1 /* T.L */  ? 1 /* T.L */  : 8 /* T.EN */  : 256 /* T.NI */ ;\n                for(let j = i; j < end; j++)types[j] = replace;\n                i = end - 1;\n            } else if (type == 8 /* T.EN */  && prevStrong == 1 /* T.L */ ) {\n                types[i] = 1 /* T.L */ ;\n            }\n            prev = type;\n            if (type & 7 /* T.Strong */ ) prevStrong = type;\n        }\n    }\n}\n// Process brackets throughout a run sequence.\nfunction processBracketPairs(line, rFrom, rTo, isolates, outerType) {\n    let oppositeType = outerType == 1 /* T.L */  ? 2 /* T.R */  : 1 /* T.L */ ;\n    for(let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        // N0. Process bracket pairs in an isolating run sequence\n        // sequentially in the logical order of the text positions of the\n        // opening paired brackets using the logic given below. Within this\n        // scope, bidirectional types EN and AN are treated as R.\n        for(let i = from, ch, br, type; i < to; i++){\n            // Keeps [startIndex, type, strongSeen] triples for each open\n            // bracket on BracketStack.\n            if (br = Brackets[ch = line.charCodeAt(i)]) {\n                if (br < 0) {\n                    for(let sJ = sI - 3; sJ >= 0; sJ -= 3){\n                        if (BracketStack[sJ + 1] == -br) {\n                            let flags = BracketStack[sJ + 2];\n                            let type = flags & 2 /* Bracketed.EmbedInside */  ? outerType : !(flags & 4 /* Bracketed.OppositeInside */ ) ? 0 : flags & 1 /* Bracketed.OppositeBefore */  ? oppositeType : outerType;\n                            if (type) types[i] = types[BracketStack[sJ]] = type;\n                            sI = sJ;\n                            break;\n                        }\n                    }\n                } else if (BracketStack.length == 189 /* Bracketed.MaxDepth */ ) {\n                    break;\n                } else {\n                    BracketStack[sI++] = i;\n                    BracketStack[sI++] = ch;\n                    BracketStack[sI++] = context;\n                }\n            } else if ((type = types[i]) == 2 /* T.R */  || type == 1 /* T.L */ ) {\n                let embed = type == outerType;\n                context = embed ? 0 : 1 /* Bracketed.OppositeBefore */ ;\n                for(let sJ = sI - 3; sJ >= 0; sJ -= 3){\n                    let cur = BracketStack[sJ + 2];\n                    if (cur & 2 /* Bracketed.EmbedInside */ ) break;\n                    if (embed) {\n                        BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */ ;\n                    } else {\n                        if (cur & 4 /* Bracketed.OppositeInside */ ) break;\n                        BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */ ;\n                    }\n                }\n            }\n        }\n    }\n}\nfunction processNeutrals(rFrom, rTo, isolates, outerType) {\n    for(let iI = 0, prev = outerType; iI <= isolates.length; iI++){\n        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;\n        // N1. A sequence of neutrals takes the direction of the\n        // surrounding strong text if the text on both sides has the same\n        // direction. European and Arabic numbers act as if they were R in\n        // terms of their influence on neutrals. Start-of-level-run (sor)\n        // and end-of-level-run (eor) are used at level run boundaries.\n        // N2. Any remaining neutrals take the embedding direction.\n        // (Left after this: L, R, EN+AN)\n        for(let i = from; i < to;){\n            let type = types[i];\n            if (type == 256 /* T.NI */ ) {\n                let end = i + 1;\n                for(;;){\n                    if (end == to) {\n                        if (iI == isolates.length) break;\n                        end = isolates[iI++].to;\n                        to = iI < isolates.length ? isolates[iI].from : rTo;\n                    } else if (types[end] == 256 /* T.NI */ ) {\n                        end++;\n                    } else {\n                        break;\n                    }\n                }\n                let beforeL = prev == 1 /* T.L */ ;\n                let afterL = (end < rTo ? types[end] : outerType) == 1 /* T.L */ ;\n                let replace = beforeL == afterL ? beforeL ? 1 /* T.L */  : 2 /* T.R */  : outerType;\n                for(let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;){\n                    if (j == fromJ) {\n                        j = isolates[--jI].from;\n                        fromJ = jI ? isolates[jI - 1].to : rFrom;\n                    }\n                    types[--j] = replace;\n                }\n                i = end;\n            } else {\n                prev = type;\n                i++;\n            }\n        }\n    }\n}\n// Find the contiguous ranges of character types in a given range, and\n// emit spans for them. Flip the order of the spans as appropriate\n// based on the level, and call through to compute the spans for\n// isolates at the proper point.\nfunction emitSpans(line, from, to, level, baseLevel, isolates, order) {\n    let ourType = level % 2 ? 2 /* T.R */  : 1 /* T.L */ ;\n    if (level % 2 == baseLevel % 2) {\n        for(let iCh = from, iI = 0; iCh < to;){\n            // Scan a section of characters in direction ourType, unless\n            // there's another type of char right after iCh, in which case\n            // we scan a section of other characters (which, if ourType ==\n            // T.L, may contain both T.R and T.AN chars).\n            let sameDir = true, isNum = false;\n            if (iI == isolates.length || iCh < isolates[iI].from) {\n                let next = types[iCh];\n                if (next != ourType) {\n                    sameDir = false;\n                    isNum = next == 16 /* T.AN */ ;\n                }\n            }\n            // Holds an array of isolates to pass to a recursive call if we\n            // must recurse (to distinguish T.AN inside an RTL section in\n            // LTR text), null if we can emit directly\n            let recurse = !sameDir && ourType == 1 /* T.L */  ? [] : null;\n            let localLevel = sameDir ? level : level + 1;\n            let iScan = iCh;\n            run: for(;;){\n                if (iI < isolates.length && iScan == isolates[iI].from) {\n                    if (isNum) break run;\n                    let iso = isolates[iI];\n                    // Scan ahead to verify that there is another char in this dir after the isolate(s)\n                    if (!sameDir) for(let upto = iso.to, jI = iI + 1;;){\n                        if (upto == to) break run;\n                        if (jI < isolates.length && isolates[jI].from == upto) upto = isolates[jI++].to;\n                        else if (types[upto] == ourType) break run;\n                        else break;\n                    }\n                    iI++;\n                    if (recurse) {\n                        recurse.push(iso);\n                    } else {\n                        if (iso.from > iCh) order.push(new BidiSpan(iCh, iso.from, localLevel));\n                        let dirSwap = iso.direction == LTR != !(localLevel % 2);\n                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n                        iCh = iso.to;\n                    }\n                    iScan = iso.to;\n                } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {\n                    break;\n                } else {\n                    iScan++;\n                }\n            }\n            if (recurse) emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);\n            else if (iCh < iScan) order.push(new BidiSpan(iCh, iScan, localLevel));\n            iCh = iScan;\n        }\n    } else {\n        // Iterate in reverse to flip the span order. Same code again, but\n        // going from the back of the section to the front\n        for(let iCh = to, iI = isolates.length; iCh > from;){\n            let sameDir = true, isNum = false;\n            if (!iI || iCh > isolates[iI - 1].to) {\n                let next = types[iCh - 1];\n                if (next != ourType) {\n                    sameDir = false;\n                    isNum = next == 16 /* T.AN */ ;\n                }\n            }\n            let recurse = !sameDir && ourType == 1 /* T.L */  ? [] : null;\n            let localLevel = sameDir ? level : level + 1;\n            let iScan = iCh;\n            run: for(;;){\n                if (iI && iScan == isolates[iI - 1].to) {\n                    if (isNum) break run;\n                    let iso = isolates[--iI];\n                    // Scan ahead to verify that there is another char in this dir after the isolate(s)\n                    if (!sameDir) for(let upto = iso.from, jI = iI;;){\n                        if (upto == from) break run;\n                        if (jI && isolates[jI - 1].to == upto) upto = isolates[--jI].from;\n                        else if (types[upto - 1] == ourType) break run;\n                        else break;\n                    }\n                    if (recurse) {\n                        recurse.push(iso);\n                    } else {\n                        if (iso.to < iCh) order.push(new BidiSpan(iso.to, iCh, localLevel));\n                        let dirSwap = iso.direction == LTR != !(localLevel % 2);\n                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);\n                        iCh = iso.from;\n                    }\n                    iScan = iso.from;\n                } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {\n                    break;\n                } else {\n                    iScan--;\n                }\n            }\n            if (recurse) emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);\n            else if (iScan < iCh) order.push(new BidiSpan(iScan, iCh, localLevel));\n            iCh = iScan;\n        }\n    }\n}\nfunction computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {\n    let outerType = level % 2 ? 2 /* T.R */  : 1 /* T.L */ ;\n    computeCharTypes(line, from, to, isolates, outerType);\n    processBracketPairs(line, from, to, isolates, outerType);\n    processNeutrals(from, to, isolates, outerType);\n    emitSpans(line, from, to, level, baseLevel, isolates, order);\n}\nfunction computeOrder(line, direction, isolates) {\n    if (!line) return [\n        new BidiSpan(0, 0, direction == RTL ? 1 : 0)\n    ];\n    if (direction == LTR && !isolates.length && !BidiRE.test(line)) return trivialOrder(line.length);\n    if (isolates.length) while(line.length > types.length)types[types.length] = 256 /* T.NI */ ; // Make sure types array has no gaps\n    let order = [], level = direction == LTR ? 0 : 1;\n    computeSectionOrder(line, level, level, isolates, 0, line.length, order);\n    return order;\n}\nfunction trivialOrder(length) {\n    return [\n        new BidiSpan(0, length, 0)\n    ];\n}\nlet movedOver = \"\";\n// This implementation moves strictly visually, without concern for a\n// traversal visiting every logical position in the string. It will\n// still do so for simple input, but situations like multiple isolates\n// with the same level next to each other, or text going against the\n// main dir at the end of the line, will make some positions\n// unreachable with this motion. Each visible cursor position will\n// correspond to the lower-level bidi span that touches it.\n//\n// The alternative would be to solve an order globally for a given\n// line, making sure that it includes every position, but that would\n// require associating non-canonical (higher bidi span level)\n// positions with a given visual position, which is likely to confuse\n// people. (And would generally be a lot more complicated.)\nfunction moveVisually(line, order, dir, start, forward) {\n    var _a;\n    let startIndex = start.head - line.from;\n    let spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\n    let span = order[spanI], spanEnd = span.side(forward, dir);\n    // End of span\n    if (startIndex == spanEnd) {\n        let nextI = spanI += forward ? 1 : -1;\n        if (nextI < 0 || nextI >= order.length) return null;\n        span = order[spanI = nextI];\n        startIndex = span.side(!forward, dir);\n        spanEnd = span.side(forward, dir);\n    }\n    let nextIndex = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, startIndex, span.forward(forward, dir));\n    if (nextIndex < span.from || nextIndex > span.to) nextIndex = spanEnd;\n    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\n    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\n    if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);\n}\nfunction autoDirection(text, from, to) {\n    for(let i = from; i < to; i++){\n        let type = charType(text.charCodeAt(i));\n        if (type == 1 /* T.L */ ) return LTR;\n        if (type == 2 /* T.R */  || type == 4 /* T.AL */ ) return RTL;\n    }\n    return LTR;\n}\nconst clickAddsSelectionRange = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst dragMovesSelection$1 = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst mouseSelectionStyle = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst exceptionSink = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst updateListener = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst inputHandler = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst focusChangeEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst clipboardInputFilter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst clipboardOutputFilter = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst perLineTextDirection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\nconst nativeSelectionHidden = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\nconst scrollHandler = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nclass ScrollTarget {\n    constructor(range, y = \"nearest\", x = \"nearest\", yMargin = 5, xMargin = 5, // This data structure is abused to also store precise scroll\n    // snapshots, instead of a `scrollIntoView` request. When this\n    // flag is `true`, `range` points at a position in the reference\n    // line, `yMargin` holds the difference between the top of that\n    // line and the top of the editor, and `xMargin` holds the\n    // editor's `scrollLeft`.\n    isSnapshot = false){\n        this.range = range;\n        this.y = y;\n        this.x = x;\n        this.yMargin = yMargin;\n        this.xMargin = xMargin;\n        this.isSnapshot = isSnapshot;\n    }\n    map(changes) {\n        return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n    }\n    clip(state) {\n        return this.range.to <= state.doc.length ? this : new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n    }\n}\nconst scrollIntoView = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n    map: (t, ch)=>t.map(ch)\n});\nconst setEditContextFormatting = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n/**\nLog or report an unhandled exception in client code. Should\nprobably only be used by extension code that allows client code to\nprovide functions, and calls those functions in a context where an\nexception can't be propagated to calling code in a reasonable way\n(for example when in an event handler).\n\nEither calls a handler registered with\n[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),\n`window.onerror`, if defined, or `console.error` (in which case\nit'll pass `context`, when given, as first argument).\n*/ function logException(state, exception, context) {\n    let handler = state.facet(exceptionSink);\n    if (handler.length) handler[0](exception);\n    else if (window.onerror) window.onerror(String(exception), context, undefined, undefined, exception);\n    else if (context) console.error(context + \":\", exception);\n    else console.error(exception);\n}\nconst editable = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.length ? values[0] : true\n});\nlet nextPluginID = 0;\nconst viewPlugin = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nView plugins associate stateful values with a view. They can\ninfluence the way the content is drawn, and are notified of things\nthat happen in the view.\n*/ class ViewPlugin {\n    constructor(/**\n    @internal\n    */ id, /**\n    @internal\n    */ create, /**\n    @internal\n    */ domEventHandlers, /**\n    @internal\n    */ domEventObservers, buildExtensions){\n        this.id = id;\n        this.create = create;\n        this.domEventHandlers = domEventHandlers;\n        this.domEventObservers = domEventObservers;\n        this.extension = buildExtensions(this);\n    }\n    /**\n    Define a plugin from a constructor function that creates the\n    plugin's value, given an editor view.\n    */ static define(create, spec) {\n        const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};\n        return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, (plugin)=>{\n            let ext = [\n                viewPlugin.of(plugin)\n            ];\n            if (deco) ext.push(decorations.of((view)=>{\n                let pluginInst = view.plugin(plugin);\n                return pluginInst ? deco(pluginInst) : Decoration.none;\n            }));\n            if (provide) ext.push(provide(plugin));\n            return ext;\n        });\n    }\n    /**\n    Create a plugin for a class whose constructor takes a single\n    editor view as argument.\n    */ static fromClass(cls, spec) {\n        return ViewPlugin.define((view)=>new cls(view), spec);\n    }\n}\nclass PluginInstance {\n    constructor(spec){\n        this.spec = spec;\n        // When starting an update, all plugins have this field set to the\n        // update object, indicating they need to be updated. When finished\n        // updating, it is set to `false`. Retrieving a plugin that needs to\n        // be updated with `view.plugin` forces an eager update.\n        this.mustUpdate = null;\n        // This is null when the plugin is initially created, but\n        // initialized on the first update.\n        this.value = null;\n    }\n    update(view) {\n        if (!this.value) {\n            if (this.spec) {\n                try {\n                    this.value = this.spec.create(view);\n                } catch (e) {\n                    logException(view.state, e, \"CodeMirror plugin crashed\");\n                    this.deactivate();\n                }\n            }\n        } else if (this.mustUpdate) {\n            let update = this.mustUpdate;\n            this.mustUpdate = null;\n            if (this.value.update) {\n                try {\n                    this.value.update(update);\n                } catch (e) {\n                    logException(update.state, e, \"CodeMirror plugin crashed\");\n                    if (this.value.destroy) try {\n                        this.value.destroy();\n                    } catch (_) {}\n                    this.deactivate();\n                }\n            }\n        }\n        return this;\n    }\n    destroy(view) {\n        var _a;\n        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {\n            try {\n                this.value.destroy();\n            } catch (e) {\n                logException(view.state, e, \"CodeMirror plugin crashed\");\n            }\n        }\n    }\n    deactivate() {\n        this.spec = this.value = null;\n    }\n}\nconst editorAttributes = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst contentAttributes = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n// Provide decorations\nconst decorations = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst outerDecorations = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst atomicRanges = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst bidiIsolatedRanges = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nfunction getIsolatedRanges(view, line) {\n    let isolates = view.state.facet(bidiIsolatedRanges);\n    if (!isolates.length) return isolates;\n    let sets = isolates.map((i)=>i instanceof Function ? i(view) : i);\n    let result = [];\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(sets, line.from, line.to, {\n        point () {},\n        span (fromDoc, toDoc, active, open) {\n            let from = fromDoc - line.from, to = toDoc - line.from;\n            let level = result;\n            for(let i = active.length - 1; i >= 0; i--, open--){\n                let direction = active[i].spec.bidiIsolate, update;\n                if (direction == null) direction = autoDirection(line.text, from, to);\n                if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {\n                    update.to = to;\n                    level = update.inner;\n                } else {\n                    let add = {\n                        from,\n                        to,\n                        direction,\n                        inner: []\n                    };\n                    level.push(add);\n                    level = add.inner;\n                }\n            }\n        }\n    });\n    return result;\n}\nconst scrollMargins = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nfunction getScrollMargins(view) {\n    let left = 0, right = 0, top = 0, bottom = 0;\n    for (let source of view.state.facet(scrollMargins)){\n        let m = source(view);\n        if (m) {\n            if (m.left != null) left = Math.max(left, m.left);\n            if (m.right != null) right = Math.max(right, m.right);\n            if (m.top != null) top = Math.max(top, m.top);\n            if (m.bottom != null) bottom = Math.max(bottom, m.bottom);\n        }\n    }\n    return {\n        left,\n        right,\n        top,\n        bottom\n    };\n}\nconst styleModule = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nclass ChangedRange {\n    constructor(fromA, toA, fromB, toB){\n        this.fromA = fromA;\n        this.toA = toA;\n        this.fromB = fromB;\n        this.toB = toB;\n    }\n    join(other) {\n        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n    }\n    addToSet(set) {\n        let i = set.length, me = this;\n        for(; i > 0; i--){\n            let range = set[i - 1];\n            if (range.fromA > me.toA) continue;\n            if (range.toA < me.fromA) break;\n            me = me.join(range);\n            set.splice(i - 1, 1);\n        }\n        set.splice(i, 0, me);\n        return set;\n    }\n    static extendWithRanges(diff, ranges) {\n        if (ranges.length == 0) return diff;\n        let result = [];\n        for(let dI = 0, rI = 0, posA = 0, posB = 0;; dI++){\n            let next = dI == diff.length ? null : diff[dI], off = posA - posB;\n            let end = next ? next.fromB : 1e9;\n            while(rI < ranges.length && ranges[rI] < end){\n                let from = ranges[rI], to = ranges[rI + 1];\n                let fromB = Math.max(posB, from), toB = Math.min(end, to);\n                if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n                if (to > end) break;\n                else rI += 2;\n            }\n            if (!next) return result;\n            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n            posA = next.toA;\n            posB = next.toB;\n        }\n    }\n}\n/**\nView [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this\nclass, which describe what happened, whenever the view is updated.\n*/ class ViewUpdate {\n    constructor(/**\n    The editor view that the update is associated with.\n    */ view, /**\n    The new editor state.\n    */ state, /**\n    The transactions involved in the update. May be empty.\n    */ transactions){\n        this.view = view;\n        this.state = state;\n        this.transactions = transactions;\n        /**\n        @internal\n        */ this.flags = 0;\n        this.startState = view.state;\n        this.changes = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.startState.doc.length);\n        for (let tr of transactions)this.changes = this.changes.compose(tr.changes);\n        let changedRanges = [];\n        this.changes.iterChangedRanges((fromA, toA, fromB, toB)=>changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));\n        this.changedRanges = changedRanges;\n    }\n    /**\n    @internal\n    */ static create(view, state, transactions) {\n        return new ViewUpdate(view, state, transactions);\n    }\n    /**\n    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or\n    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this\n    update.\n    */ get viewportChanged() {\n        return (this.flags & 4 /* UpdateFlag.Viewport */ ) > 0;\n    }\n    /**\n    Returns true when\n    [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true\n    and the viewport change is not just the result of mapping it in\n    response to document changes.\n    */ get viewportMoved() {\n        return (this.flags & 8 /* UpdateFlag.ViewportMoved */ ) > 0;\n    }\n    /**\n    Indicates whether the height of a block element in the editor\n    changed in this update.\n    */ get heightChanged() {\n        return (this.flags & 2 /* UpdateFlag.Height */ ) > 0;\n    }\n    /**\n    Returns true when the document was modified or the size of the\n    editor, or elements within the editor, changed.\n    */ get geometryChanged() {\n        return this.docChanged || (this.flags & (16 /* UpdateFlag.Geometry */  | 2 /* UpdateFlag.Height */ )) > 0;\n    }\n    /**\n    True when this update indicates a focus change.\n    */ get focusChanged() {\n        return (this.flags & 1 /* UpdateFlag.Focus */ ) > 0;\n    }\n    /**\n    Whether the document changed in this update.\n    */ get docChanged() {\n        return !this.changes.empty;\n    }\n    /**\n    Whether the selection was explicitly set in this update.\n    */ get selectionSet() {\n        return this.transactions.some((tr)=>tr.selection);\n    }\n    /**\n    @internal\n    */ get empty() {\n        return this.flags == 0 && this.transactions.length == 0;\n    }\n}\nclass DocView extends ContentView {\n    get length() {\n        return this.view.state.doc.length;\n    }\n    constructor(view){\n        super();\n        this.view = view;\n        this.decorations = [];\n        this.dynamicDecorationMap = [\n            false\n        ];\n        this.domChanged = null;\n        this.hasComposition = null;\n        this.markedForComposition = new Set;\n        this.editContextFormatting = Decoration.none;\n        this.lastCompositionAfterCursor = false;\n        // Track a minimum width for the editor. When measuring sizes in\n        // measureVisibleLineHeights, this is updated to point at the width\n        // of a given element and its extent in the document. When a change\n        // happens in that range, these are reset. That way, once we've seen\n        // a line/element of a given length, we keep the editor wide enough\n        // to fit at least that element, until it is changed, at which point\n        // we forget it again.\n        this.minWidth = 0;\n        this.minWidthFrom = 0;\n        this.minWidthTo = 0;\n        // Track whether the DOM selection was set in a lossy way, so that\n        // we don't mess it up when reading it back it\n        this.impreciseAnchor = null;\n        this.impreciseHead = null;\n        this.forceSelection = false;\n        // Used by the resize observer to ignore resizes that we caused\n        // ourselves\n        this.lastUpdate = Date.now();\n        this.setDOM(view.contentDOM);\n        this.children = [\n            new LineView\n        ];\n        this.children[0].setParent(this);\n        this.updateDeco();\n        this.updateInner([\n            new ChangedRange(0, 0, 0, view.state.doc.length)\n        ], 0, null);\n    }\n    // Update the document view to a given state.\n    update(update) {\n        var _a;\n        let changedRanges = update.changedRanges;\n        if (this.minWidth > 0 && changedRanges.length) {\n            if (!changedRanges.every(({ fromA, toA })=>toA < this.minWidthFrom || fromA > this.minWidthTo)) {\n                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;\n            } else {\n                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);\n                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);\n            }\n        }\n        this.updateEditContextFormatting(update);\n        let readCompositionAt = -1;\n        if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {\n            if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel) readCompositionAt = this.domChanged.newSel.head;\n            else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet) readCompositionAt = update.state.selection.main.head;\n        }\n        let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;\n        this.domChanged = null;\n        if (this.hasComposition) {\n            this.markedForComposition.clear();\n            let { from, to } = this.hasComposition;\n            changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());\n        }\n        this.hasComposition = composition ? {\n            from: composition.range.fromB,\n            to: composition.range.toB\n        } : null;\n        // When the DOM nodes around the selection are moved to another\n        // parent, Chrome sometimes reports a different selection through\n        // getSelection than the one that it actually shows to the user.\n        // This forces a selection update when lines are joined to work\n        // around that. Issue #54\n        if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines) this.forceSelection = true;\n        let prevDeco = this.decorations, deco = this.updateDeco();\n        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);\n        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\n        if (!(this.flags & 7 /* ViewFlag.Dirty */ ) && changedRanges.length == 0) {\n            return false;\n        } else {\n            this.updateInner(changedRanges, update.startState.doc.length, composition);\n            if (update.transactions.length) this.lastUpdate = Date.now();\n            return true;\n        }\n    }\n    // Used by update and the constructor do perform the actual DOM\n    // update\n    updateInner(changes, oldLength, composition) {\n        this.view.viewState.mustMeasureContent = true;\n        this.updateChildren(changes, oldLength, composition);\n        let { observer } = this.view;\n        observer.ignore(()=>{\n            // Lock the height during redrawing, since Chrome sometimes\n            // messes with the scroll position during DOM mutation (though\n            // no relayout is triggered and I cannot imagine how it can\n            // recompute the scroll position without a layout)\n            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + \"px\";\n            this.dom.style.flexBasis = this.minWidth ? this.minWidth + \"px\" : \"\";\n            // Chrome will sometimes, when DOM mutations occur directly\n            // around the selection, get confused and report a different\n            // selection from the one it displays (issue #218). This tries\n            // to detect that situation.\n            let track = browser.chrome || browser.ios ? {\n                node: observer.selectionRange.focusNode,\n                written: false\n            } : undefined;\n            this.sync(this.view, track);\n            this.flags &= ~7 /* ViewFlag.Dirty */ ;\n            if (track && (track.written || observer.selectionRange.focusNode != track.node)) this.forceSelection = true;\n            this.dom.style.height = \"\";\n        });\n        this.markedForComposition.forEach((cView)=>cView.flags &= ~8 /* ViewFlag.Composition */ );\n        let gaps = [];\n        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {\n            for (let child of this.children)if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget) gaps.push(child.dom);\n        }\n        observer.updateGaps(gaps);\n    }\n    updateChildren(changes, oldLength, composition) {\n        let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;\n        let cursor = this.childCursor(oldLength);\n        for(let i = ranges.length - 1;; i--){\n            let next = i >= 0 ? ranges[i] : null;\n            if (!next) break;\n            let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;\n            if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {\n                let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);\n                let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);\n                breakAtStart = before.breakAtStart;\n                openStart = before.openStart;\n                openEnd = after.openEnd;\n                let compLine = this.compositionView(composition);\n                if (after.breakAtStart) {\n                    compLine.breakAfter = 1;\n                } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {\n                    compLine.breakAfter = after.content[0].breakAfter;\n                    after.content.shift();\n                }\n                if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {\n                    before.content.pop();\n                }\n                content = before.content.concat(compLine).concat(after.content);\n            } else {\n                ({ content, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));\n            }\n            let { i: toI, off: toOff } = cursor.findPos(toA, 1);\n            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);\n            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);\n        }\n        if (composition) this.fixCompositionDOM(composition);\n    }\n    updateEditContextFormatting(update) {\n        this.editContextFormatting = this.editContextFormatting.map(update.changes);\n        for (let tr of update.transactions)for (let effect of tr.effects)if (effect.is(setEditContextFormatting)) {\n            this.editContextFormatting = effect.value;\n        }\n    }\n    compositionView(composition) {\n        let cur = new TextView(composition.text.nodeValue);\n        cur.flags |= 8 /* ViewFlag.Composition */ ;\n        for (let { deco } of composition.marks)cur = new MarkView(deco, [\n            cur\n        ], cur.length);\n        let line = new LineView;\n        line.append(cur, 0);\n        return line;\n    }\n    fixCompositionDOM(composition) {\n        let fix = (dom, cView)=>{\n            cView.flags |= 8 /* ViewFlag.Composition */  | (cView.children.some((c)=>c.flags & 7 /* ViewFlag.Dirty */ ) ? 1 /* ViewFlag.ChildDirty */  : 0);\n            this.markedForComposition.add(cView);\n            let prev = ContentView.get(dom);\n            if (prev && prev != cView) prev.dom = null;\n            cView.setDOM(dom);\n        };\n        let pos = this.childPos(composition.range.fromB, 1);\n        let cView = this.children[pos.i];\n        fix(composition.line, cView);\n        for(let i = composition.marks.length - 1; i >= -1; i--){\n            pos = cView.childPos(pos.off, 1);\n            cView = cView.children[pos.i];\n            fix(i >= 0 ? composition.marks[i].node : composition.text, cView);\n        }\n    }\n    // Sync the DOM selection to this.state.selection\n    updateSelection(mustRead = false, fromPointer = false) {\n        if (mustRead || !this.view.observer.selectionRange.focusNode) this.view.observer.readSelectionRange();\n        let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;\n        let selectionNotFocus = !focused && !(this.view.state.facet(editable) || this.dom.tabIndex > -1) && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));\n        if (!(focused || fromPointer || selectionNotFocus)) return;\n        let force = this.forceSelection;\n        this.forceSelection = false;\n        let main = this.view.state.selection.main;\n        let anchor = this.moveToLine(this.domAtPos(main.anchor));\n        let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));\n        // Always reset on Firefox when next to an uneditable node to\n        // avoid invisible cursor bugs (#111)\n        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {\n            let dummy = document.createTextNode(\"\");\n            this.view.observer.ignore(()=>anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));\n            anchor = head = new DOMPos(dummy, 0);\n            force = true;\n        }\n        let domSel = this.view.observer.selectionRange;\n        // If the selection is already here, or in an equivalent position, don't touch it\n        if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {\n            this.view.observer.ignore(()=>{\n                // Chrome Android will hide the virtual keyboard when tapping\n                // inside an uneditable node, and not bring it back when we\n                // move the cursor to its proper position. This tries to\n                // restore the keyboard by cycling focus.\n                if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {\n                    this.dom.blur();\n                    this.dom.focus({\n                        preventScroll: true\n                    });\n                }\n                let rawSel = getSelection(this.view.root);\n                if (!rawSel) ;\n                else if (main.empty) {\n                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076\n                    if (browser.gecko) {\n                        let nextTo = nextToUneditable(anchor.node, anchor.offset);\n                        if (nextTo && nextTo != (1 /* NextTo.Before */  | 2 /* NextTo.After */ )) {\n                            let text = (nextTo == 1 /* NextTo.Before */  ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);\n                            if (text) anchor = new DOMPos(text.node, text.offset);\n                        }\n                    }\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined) rawSel.caretBidiLevel = main.bidiLevel;\n                } else if (rawSel.extend) {\n                    // Selection.extend can be used to create an 'inverted' selection\n                    // (one where the focus is before the anchor), but not all\n                    // browsers support it yet.\n                    rawSel.collapse(anchor.node, anchor.offset);\n                    // Safari will ignore the call above when the editor is\n                    // hidden, and then raise an error on the call to extend\n                    // (#940).\n                    try {\n                        rawSel.extend(head.node, head.offset);\n                    } catch (_) {}\n                } else {\n                    // Primitive (IE) way\n                    let range = document.createRange();\n                    if (main.anchor > main.head) [anchor, head] = [\n                        head,\n                        anchor\n                    ];\n                    range.setEnd(head.node, head.offset);\n                    range.setStart(anchor.node, anchor.offset);\n                    rawSel.removeAllRanges();\n                    rawSel.addRange(range);\n                }\n                if (selectionNotFocus && this.view.root.activeElement == this.dom) {\n                    this.dom.blur();\n                    if (activeElt) activeElt.focus();\n                }\n            });\n            this.view.observer.setSelectionRange(anchor, head);\n        }\n        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n    }\n    // If a zero-length widget is inserted next to the cursor during\n    // composition, avoid moving it across it and disrupting the\n    // composition.\n    suppressWidgetCursorChange(sel, cursor) {\n        return this.hasComposition && cursor.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;\n    }\n    enforceCursorAssoc() {\n        if (this.hasComposition) return;\n        let { view } = this, cursor = view.state.selection.main;\n        let sel = getSelection(view.root);\n        let { anchorNode, anchorOffset } = view.observer.selectionRange;\n        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify) return;\n        let line = LineView.find(this, cursor.head);\n        if (!line) return;\n        let lineStart = line.posAtStart;\n        if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;\n        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);\n        if (!before || !after || before.bottom > after.top) return;\n        let dom = this.domAtPos(cursor.head + cursor.assoc);\n        sel.collapse(dom.node, dom.offset);\n        sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\n        // This can go wrong in corner cases like single-character lines,\n        // so check and reset if necessary.\n        view.observer.readSelectionRange();\n        let newRange = view.observer.selectionRange;\n        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from) sel.collapse(anchorNode, anchorOffset);\n    }\n    // If a position is in/near a block widget, move it to a nearby text\n    // line, since we don't want the cursor inside a block widget.\n    moveToLine(pos) {\n        // Block widgets will return positions before/after them, which\n        // are thus directly in the document DOM element.\n        let dom = this.dom, newPos;\n        if (pos.node != dom) return pos;\n        for(let i = pos.offset; !newPos && i < dom.childNodes.length; i++){\n            let view = ContentView.get(dom.childNodes[i]);\n            if (view instanceof LineView) newPos = view.domAtPos(0);\n        }\n        for(let i = pos.offset - 1; !newPos && i >= 0; i--){\n            let view = ContentView.get(dom.childNodes[i]);\n            if (view instanceof LineView) newPos = view.domAtPos(view.length);\n        }\n        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;\n    }\n    nearest(dom) {\n        for(let cur = dom; cur;){\n            let domView = ContentView.get(cur);\n            if (domView && domView.rootView == this) return domView;\n            cur = cur.parentNode;\n        }\n        return null;\n    }\n    posFromDOM(node, offset) {\n        let view = this.nearest(node);\n        if (!view) throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n        return view.localPosFromDOM(node, offset) + view.posAtStart;\n    }\n    domAtPos(pos) {\n        let { i, off } = this.childCursor().findPos(pos, -1);\n        for(; i < this.children.length - 1;){\n            let child = this.children[i];\n            if (off < child.length || child instanceof LineView) break;\n            i++;\n            off = 0;\n        }\n        return this.children[i].domAtPos(off);\n    }\n    coordsAt(pos, side) {\n        let best = null, bestPos = 0;\n        for(let off = this.length, i = this.children.length - 1; i >= 0; i--){\n            let child = this.children[i], end = off - child.breakAfter, start = end - child.length;\n            if (end < pos) break;\n            if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {\n                best = child;\n                bestPos = start;\n            } else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {\n                if (child.deco.startSide < 0) break;\n                else if (i) best = null;\n            }\n            off = start;\n        }\n        return best ? best.coordsAt(pos - bestPos, side) : null;\n    }\n    coordsForChar(pos) {\n        let { i, off } = this.childPos(pos, 1), child = this.children[i];\n        if (!(child instanceof LineView)) return null;\n        while(child.children.length){\n            let { i, off: childOff } = child.childPos(off, 1);\n            for(;; i++){\n                if (i == child.children.length) return null;\n                if ((child = child.children[i]).length) break;\n            }\n            off = childOff;\n        }\n        if (!(child instanceof TextView)) return null;\n        let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(child.text, off);\n        if (end == off) return null;\n        let rects = textRange(child.dom, off, end).getClientRects();\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right) return rect;\n        }\n        return null;\n    }\n    measureVisibleLineHeights(viewport) {\n        let result = [], { from, to } = viewport;\n        let contentWidth = this.view.contentDOM.clientWidth;\n        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n        let widest = -1, ltr = this.view.textDirection == Direction.LTR;\n        for(let pos = 0, i = 0; i < this.children.length; i++){\n            let child = this.children[i], end = pos + child.length;\n            if (end > to) break;\n            if (pos >= from) {\n                let childRect = child.dom.getBoundingClientRect();\n                result.push(childRect.height);\n                if (isWider) {\n                    let last = child.dom.lastChild;\n                    let rects = last ? clientRectsFor(last) : [];\n                    if (rects.length) {\n                        let rect = rects[rects.length - 1];\n                        let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;\n                        if (width > widest) {\n                            widest = width;\n                            this.minWidth = contentWidth;\n                            this.minWidthFrom = pos;\n                            this.minWidthTo = end;\n                        }\n                    }\n                }\n            }\n            pos = end + child.breakAfter;\n        }\n        return result;\n    }\n    textDirectionAt(pos) {\n        let { i } = this.childPos(pos, 1);\n        return getComputedStyle(this.children[i].dom).direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n    }\n    measureTextSize() {\n        for (let child of this.children){\n            if (child instanceof LineView) {\n                let measure = child.measureTextSize();\n                if (measure) return measure;\n            }\n        }\n        // If no workable line exists, force a layout of a measurable element\n        let dummy = document.createElement(\"div\"), lineHeight, charWidth, textHeight;\n        dummy.className = \"cm-line\";\n        dummy.style.width = \"99999px\";\n        dummy.style.position = \"absolute\";\n        dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n        this.view.observer.ignore(()=>{\n            this.dom.appendChild(dummy);\n            let rect = clientRectsFor(dummy.firstChild)[0];\n            lineHeight = dummy.getBoundingClientRect().height;\n            charWidth = rect ? rect.width / 27 : 7;\n            textHeight = rect ? rect.height : lineHeight;\n            dummy.remove();\n        });\n        return {\n            lineHeight,\n            charWidth,\n            textHeight\n        };\n    }\n    childCursor(pos = this.length) {\n        // Move back to start of last element when possible, so that\n        // `ChildCursor.findPos` doesn't have to deal with the edge case\n        // of being after the last element.\n        let i = this.children.length;\n        if (i) pos -= this.children[--i].length;\n        return new ChildCursor(this.children, pos, i);\n    }\n    computeBlockGapDeco() {\n        let deco = [], vs = this.view.viewState;\n        for(let pos = 0, i = 0;; i++){\n            let next = i == vs.viewports.length ? null : vs.viewports[i];\n            let end = next ? next.from - 1 : this.length;\n            if (end > pos) {\n                let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;\n                deco.push(Decoration.replace({\n                    widget: new BlockGapWidget(height),\n                    block: true,\n                    inclusive: true,\n                    isBlockGap: true\n                }).range(pos, end));\n            }\n            if (!next) break;\n            pos = next.to + 1;\n        }\n        return Decoration.set(deco);\n    }\n    updateDeco() {\n        let i = 1;\n        let allDeco = this.view.state.facet(decorations).map((d)=>{\n            let dynamic = this.dynamicDecorationMap[i++] = typeof d == \"function\";\n            return dynamic ? d(this.view) : d;\n        });\n        let dynamicOuter = false, outerDeco = this.view.state.facet(outerDecorations).map((d, i)=>{\n            let dynamic = typeof d == \"function\";\n            if (dynamic) dynamicOuter = true;\n            return dynamic ? d(this.view) : d;\n        });\n        if (outerDeco.length) {\n            this.dynamicDecorationMap[i++] = dynamicOuter;\n            allDeco.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.join(outerDeco));\n        }\n        this.decorations = [\n            this.editContextFormatting,\n            ...allDeco,\n            this.computeBlockGapDeco(),\n            this.view.viewState.lineGapDeco\n        ];\n        while(i < this.decorations.length)this.dynamicDecorationMap[i++] = false;\n        return this.decorations;\n    }\n    scrollIntoView(target) {\n        if (target.isSnapshot) {\n            let ref = this.view.viewState.lineBlockAt(target.range.head);\n            this.view.scrollDOM.scrollTop = ref.top - target.yMargin;\n            this.view.scrollDOM.scrollLeft = target.xMargin;\n            return;\n        }\n        for (let handler of this.view.state.facet(scrollHandler)){\n            try {\n                if (handler(this.view, target.range, target)) return true;\n            } catch (e) {\n                logException(this.view.state, e, \"scroll handler\");\n            }\n        }\n        let { range } = target;\n        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;\n        if (!rect) return;\n        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1))) rect = {\n            left: Math.min(rect.left, other.left),\n            top: Math.min(rect.top, other.top),\n            right: Math.max(rect.right, other.right),\n            bottom: Math.max(rect.bottom, other.bottom)\n        };\n        let margins = getScrollMargins(this.view);\n        let targetRect = {\n            left: rect.left - margins.left,\n            top: rect.top - margins.top,\n            right: rect.right + margins.right,\n            bottom: rect.bottom + margins.bottom\n        };\n        let { offsetWidth, offsetHeight } = this.view.scrollDOM;\n        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);\n    }\n}\nfunction betweenUneditable(pos) {\n    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == \"false\") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == \"false\");\n}\nfunction findCompositionNode(view, headPos) {\n    let sel = view.observer.selectionRange;\n    if (!sel.focusNode) return null;\n    let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);\n    let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);\n    let textNode = textBefore || textAfter;\n    if (textAfter && textBefore && textAfter.node != textBefore.node) {\n        let descAfter = ContentView.get(textAfter.node);\n        if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {\n            textNode = textAfter;\n        } else if (view.docView.lastCompositionAfterCursor) {\n            let descBefore = ContentView.get(textBefore.node);\n            if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue)) textNode = textAfter;\n        }\n    }\n    view.docView.lastCompositionAfterCursor = textNode != textBefore;\n    if (!textNode) return null;\n    let from = headPos - textNode.offset;\n    return {\n        from,\n        to: from + textNode.node.nodeValue.length,\n        node: textNode.node\n    };\n}\nfunction findCompositionRange(view, changes, headPos) {\n    let found = findCompositionNode(view, headPos);\n    if (!found) return null;\n    let { node: textNode, from, to } = found, text = textNode.nodeValue;\n    // Don't try to preserve multi-line compositions\n    if (/[\\n\\r]/.test(text)) return null;\n    if (view.state.doc.sliceString(found.from, found.to) != text) return null;\n    let inv = changes.invertedDesc;\n    let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);\n    let marks = [];\n    for(let parent = textNode.parentNode;; parent = parent.parentNode){\n        let parentView = ContentView.get(parent);\n        if (parentView instanceof MarkView) marks.push({\n            node: parent,\n            deco: parentView.mark\n        });\n        else if (parentView instanceof LineView || parent.nodeName == \"DIV\" && parent.parentNode == view.contentDOM) return {\n            range,\n            text: textNode,\n            marks,\n            line: parent\n        };\n        else if (parent != view.contentDOM) marks.push({\n            node: parent,\n            deco: new MarkDecoration({\n                inclusive: true,\n                attributes: getAttrs(parent),\n                tagName: parent.tagName.toLowerCase()\n            })\n        });\n        else return null;\n    }\n}\nfunction nextToUneditable(node, offset) {\n    if (node.nodeType != 1) return 0;\n    return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1 /* NextTo.Before */  : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2 /* NextTo.After */  : 0);\n}\nlet DecorationComparator$1 = class DecorationComparator {\n    constructor(){\n        this.changes = [];\n    }\n    compareRange(from, to) {\n        addRange(from, to, this.changes);\n    }\n    comparePoint(from, to) {\n        addRange(from, to, this.changes);\n    }\n    boundChange(pos) {\n        addRange(pos, pos, this.changes);\n    }\n};\nfunction findChangedDeco(a, b, diff) {\n    let comp = new DecorationComparator$1;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp);\n    return comp.changes;\n}\nfunction inUneditable(node, inside) {\n    for(let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode){\n        if (cur.nodeType == 1 && cur.contentEditable == \"false\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction touchesComposition(changes, composition) {\n    let touched = false;\n    if (composition) changes.iterChangedRanges((from, to)=>{\n        if (from < composition.to && to > composition.from) touched = true;\n    });\n    return touched;\n}\nfunction groupAt(state, pos, bias = 1) {\n    let categorize = state.charCategorizer(pos);\n    let line = state.doc.lineAt(pos), linePos = pos - line.from;\n    if (line.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos);\n    if (linePos == 0) bias = 1;\n    else if (linePos == line.length) bias = -1;\n    let from = linePos, to = linePos;\n    if (bias < 0) from = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos, false);\n    else to = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, linePos);\n    let cat = categorize(line.text.slice(from, to));\n    while(from > 0){\n        let prev = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, from, false);\n        if (categorize(line.text.slice(prev, from)) != cat) break;\n        from = prev;\n    }\n    while(to < line.length){\n        let next = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findClusterBreak)(line.text, to);\n        if (categorize(line.text.slice(to, next)) != cat) break;\n        to = next;\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from + line.from, to + line.from);\n}\n// Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\nfunction getdx(x, rect) {\n    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\nfunction getdy(y, rect) {\n    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\nfunction yOverlap(a, b) {\n    return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\nfunction upTop(rect, top) {\n    return top < rect.top ? {\n        top,\n        left: rect.left,\n        right: rect.right,\n        bottom: rect.bottom\n    } : rect;\n}\nfunction upBot(rect, bottom) {\n    return bottom > rect.bottom ? {\n        top: rect.top,\n        left: rect.left,\n        right: rect.right,\n        bottom\n    } : rect;\n}\nfunction domPosAtCoords(parent, x, y) {\n    let closest, closestRect, closestX, closestY, closestOverlap = false;\n    let above, below, aboveRect, belowRect;\n    for(let child = parent.firstChild; child; child = child.nextSibling){\n        let rects = clientRectsFor(child);\n        for(let i = 0; i < rects.length; i++){\n            let rect = rects[i];\n            if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n            let dx = getdx(x, rect), dy = getdy(y, rect);\n            if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n            if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n                closest = child;\n                closestRect = rect;\n                closestX = dx;\n                closestY = dy;\n                let side = dy ? y < rect.top ? -1 : 1 : dx ? x < rect.left ? -1 : 1 : 0;\n                closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);\n            }\n            if (dx == 0) {\n                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n                    above = child;\n                    aboveRect = rect;\n                } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n                    below = child;\n                    belowRect = rect;\n                }\n            } else if (aboveRect && yOverlap(aboveRect, rect)) {\n                aboveRect = upBot(aboveRect, rect.bottom);\n            } else if (belowRect && yOverlap(belowRect, rect)) {\n                belowRect = upTop(belowRect, rect.top);\n            }\n        }\n    }\n    if (aboveRect && aboveRect.bottom >= y) {\n        closest = above;\n        closestRect = aboveRect;\n    } else if (belowRect && belowRect.top <= y) {\n        closest = below;\n        closestRect = belowRect;\n    }\n    if (!closest) return {\n        node: parent,\n        offset: 0\n    };\n    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n    if (closest.nodeType == 3) return domPosInText(closest, clipX, y);\n    if (closestOverlap && closest.contentEditable != \"false\") return domPosAtCoords(closest, clipX, y);\n    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n    return {\n        node: parent,\n        offset\n    };\n}\nfunction domPosInText(node, x, y) {\n    let len = node.nodeValue.length;\n    let closestOffset = -1, closestDY = 1e9, generalSide = 0;\n    for(let i = 0; i < len; i++){\n        let rects = textRange(node, i, i + 1).getClientRects();\n        for(let j = 0; j < rects.length; j++){\n            let rect = rects[j];\n            if (rect.top == rect.bottom) continue;\n            if (!generalSide) generalSide = x - rect.left;\n            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;\n            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {\n                let right = x >= (rect.left + rect.right) / 2, after = right;\n                if (browser.chrome || browser.gecko) {\n                    // Check for RTL on browsers that support getting client\n                    // rects for empty ranges.\n                    let rectBefore = textRange(node, i).getBoundingClientRect();\n                    if (rectBefore.left == rect.right) after = !right;\n                }\n                if (dy <= 0) return {\n                    node,\n                    offset: i + (after ? 1 : 0)\n                };\n                closestOffset = i + (after ? 1 : 0);\n                closestDY = dy;\n            }\n        }\n    }\n    return {\n        node,\n        offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0\n    };\n}\nfunction posAtCoords(view, coords, precise, bias = -1) {\n    var _a, _b;\n    let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;\n    let block, { docHeight } = view.viewState;\n    let { x, y } = coords, yOffset = y - docTop;\n    if (yOffset < 0) return 0;\n    if (yOffset > docHeight) return view.state.doc.length;\n    // Scan for a text block near the queried y position\n    for(let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;){\n        block = view.elementAtHeight(yOffset);\n        if (block.type == BlockType.Text) break;\n        for(;;){\n            // Move the y position out of this block\n            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n            if (yOffset >= 0 && yOffset <= docHeight) break;\n            // If the document consists entirely of replaced widgets, we\n            // won't find a text block, so return 0\n            if (bounced) return precise ? null : 0;\n            bounced = true;\n            bias = -bias;\n        }\n    }\n    y = docTop + yOffset;\n    let lineStart = block.from;\n    // If this is outside of the rendered viewport, we can't determine a position\n    if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n    if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n    // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not\n    let doc = view.dom.ownerDocument;\n    let root = view.root.elementFromPoint ? view.root : doc;\n    let element = root.elementFromPoint(x, y);\n    if (element && !view.contentDOM.contains(element)) element = null;\n    // If the element is unexpected, clip x at the sides of the content area and try again\n    if (!element) {\n        x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n        element = root.elementFromPoint(x, y);\n        if (element && !view.contentDOM.contains(element)) element = null;\n    }\n    // There's visible editor content under the point, so we can try\n    // using caret(Position|Range)FromPoint as a shortcut\n    let node, offset = -1;\n    if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {\n        if (doc.caretPositionFromPoint) {\n            let pos = doc.caretPositionFromPoint(x, y);\n            if (pos) ({ offsetNode: node, offset } = pos);\n        } else if (doc.caretRangeFromPoint) {\n            let range = doc.caretRangeFromPoint(x, y);\n            if (range) {\n                ({ startContainer: node, startOffset: offset } = range);\n                if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x)) node = undefined;\n            }\n        }\n        // Chrome will return offsets into <input> elements without child\n        // nodes, which will lead to a null deref below, so clip the\n        // offset to the node size.\n        if (node) offset = Math.min(maxOffset(node), offset);\n    }\n    // No luck, do our own (potentially expensive) search\n    if (!node || !view.docView.dom.contains(node)) {\n        let line = LineView.find(view.docView, lineStart);\n        if (!line) return yOffset > block.top + block.height / 2 ? block.to : block.from;\n        ({ node, offset } = domPosAtCoords(line.dom, x, y));\n    }\n    let nearest = view.docView.nearest(node);\n    if (!nearest) return null;\n    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {\n        let rect = nearest.dom.getBoundingClientRect();\n        return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;\n    } else {\n        return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;\n    }\n}\nfunction posAtCoordsImprecise(view, contentRect, block, x, y) {\n    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);\n    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {\n        let textHeight = view.viewState.heightOracle.textHeight;\n        let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);\n        into += line * view.viewState.heightOracle.lineLength;\n    }\n    let content = view.state.sliceDoc(block.from, block.to);\n    return block.from + (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(content, into, view.state.tabSize);\n}\n// In case of a high line height, Safari's caretRangeFromPoint treats\n// the space between lines as belonging to the last character of the\n// line before. This is used to detect such a result so that it can be\n// ignored (issue #401).\nfunction isSuspiciousSafariCaretResult(node, offset, x) {\n    let len;\n    if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;\n    for(let next = node.nextSibling; next; next = next.nextSibling)if (next.nodeType != 1 || next.nodeName != \"BR\") return false;\n    return textRange(node, len - 1, len).getBoundingClientRect().left > x;\n}\n// Chrome will move positions between lines to the start of the next line\nfunction isSuspiciousChromeCaretResult(node, offset, x) {\n    if (offset != 0) return false;\n    for(let cur = node;;){\n        let parent = cur.parentNode;\n        if (!parent || parent.nodeType != 1 || parent.firstChild != cur) return false;\n        if (parent.classList.contains(\"cm-line\")) break;\n        cur = parent;\n    }\n    let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();\n    return x - rect.left > 5;\n}\nfunction blockAt(view, pos) {\n    let line = view.lineBlockAt(pos);\n    if (Array.isArray(line.type)) for (let l of line.type){\n        if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text)) return l;\n    }\n    return line;\n}\nfunction moveToLineBoundary(view, start, forward, includeWrap) {\n    let line = blockAt(view, start.head);\n    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\n    if (coords) {\n        let editorRect = view.dom.getBoundingClientRect();\n        let direction = view.textDirectionAt(line.from);\n        let pos = view.posAtCoords({\n            x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\n            y: (coords.top + coords.bottom) / 2\n        });\n        if (pos != null) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, forward ? -1 : 1);\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);\n}\nfunction moveByChar(view, start, forward, by) {\n    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);\n    let direction = view.textDirectionAt(line.from);\n    for(let cur = start, check = null;;){\n        let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;\n        if (!next) {\n            if (line.number == (forward ? view.state.doc.lines : 1)) return cur;\n            char = \"\\n\";\n            line = view.state.doc.line(line.number + (forward ? 1 : -1));\n            spans = view.bidiSpans(line);\n            next = view.visualLineSide(line, !forward);\n        }\n        if (!check) {\n            if (!by) return next;\n            check = by(char);\n        } else if (!check(char)) {\n            return cur;\n        }\n        cur = next;\n    }\n}\nfunction byGroup(view, pos, start) {\n    let categorize = view.state.charCategorizer(pos);\n    let cat = categorize(start);\n    return (next)=>{\n        let nextCat = categorize(next);\n        if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.CharCategory.Space) cat = nextCat;\n        return cat == nextCat;\n    };\n}\nfunction moveVertically(view, start, forward, distance) {\n    let startPos = start.head, dir = forward ? 1 : -1;\n    if (startPos == (forward ? view.state.doc.length : 0)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(startPos, start.assoc);\n    let goal = start.goalColumn, startY;\n    let rect = view.contentDOM.getBoundingClientRect();\n    let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;\n    if (startCoords) {\n        if (goal == null) goal = startCoords.left - rect.left;\n        startY = dir < 0 ? startCoords.top : startCoords.bottom;\n    } else {\n        let line = view.viewState.lineBlockAt(startPos);\n        if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));\n        startY = (dir < 0 ? line.top : line.bottom) + docTop;\n    }\n    let resolvedGoal = rect.left + goal;\n    let dist = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;\n    for(let extra = 0;; extra += 10){\n        let curY = startY + (dist + extra) * dir;\n        let pos = posAtCoords(view, {\n            x: resolvedGoal,\n            y: curY\n        }, false, dir);\n        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {\n            let charRect = view.docView.coordsForChar(pos);\n            let assoc = !charRect || curY < charRect.top ? -1 : 1;\n            return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, assoc, undefined, goal);\n        }\n    }\n}\nfunction skipAtomicRanges(atoms, pos, bias) {\n    for(;;){\n        let moved = 0;\n        for (let set of atoms){\n            set.between(pos - 1, pos + 1, (from, to, value)=>{\n                if (pos > from && pos < to) {\n                    let side = moved || bias || (pos - from < to - pos ? -1 : 1);\n                    pos = side < 0 ? from : to;\n                    moved = side;\n                }\n            });\n        }\n        if (!moved) return pos;\n    }\n}\nfunction skipAtoms(view, oldPos, pos) {\n    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map((f)=>f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);\n    return newPos == pos.from ? pos : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);\n}\nconst LineBreakPlaceholder = \"￿\";\nclass DOMReader {\n    constructor(points, state){\n        this.points = points;\n        this.text = \"\";\n        this.lineSeparator = state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.lineSeparator);\n    }\n    append(text) {\n        this.text += text;\n    }\n    lineBreak() {\n        this.text += LineBreakPlaceholder;\n    }\n    readRange(start, end) {\n        if (!start) return this;\n        let parent = start.parentNode;\n        for(let cur = start;;){\n            this.findPointBefore(parent, cur);\n            let oldLen = this.text.length;\n            this.readNode(cur);\n            let next = cur.nextSibling;\n            if (next == end) break;\n            let view = ContentView.get(cur), nextView = ContentView.get(next);\n            if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != \"BR\" || cur.cmIgnore) && this.text.length > oldLen) this.lineBreak();\n            cur = next;\n        }\n        this.findPointBefore(parent, end);\n        return this;\n    }\n    readTextNode(node) {\n        let text = node.nodeValue;\n        for (let point of this.points)if (point.node == node) point.pos = this.text.length + Math.min(point.offset, text.length);\n        for(let off = 0, re = this.lineSeparator ? null : /\\r\\n?|\\n/g;;){\n            let nextBreak = -1, breakSize = 1, m;\n            if (this.lineSeparator) {\n                nextBreak = text.indexOf(this.lineSeparator, off);\n                breakSize = this.lineSeparator.length;\n            } else if (m = re.exec(text)) {\n                nextBreak = m.index;\n                breakSize = m[0].length;\n            }\n            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));\n            if (nextBreak < 0) break;\n            this.lineBreak();\n            if (breakSize > 1) {\n                for (let point of this.points)if (point.node == node && point.pos > this.text.length) point.pos -= breakSize - 1;\n            }\n            off = nextBreak + breakSize;\n        }\n    }\n    readNode(node) {\n        if (node.cmIgnore) return;\n        let view = ContentView.get(node);\n        let fromView = view && view.overrideDOMText;\n        if (fromView != null) {\n            this.findPointInside(node, fromView.length);\n            for(let i = fromView.iter(); !i.next().done;){\n                if (i.lineBreak) this.lineBreak();\n                else this.append(i.value);\n            }\n        } else if (node.nodeType == 3) {\n            this.readTextNode(node);\n        } else if (node.nodeName == \"BR\") {\n            if (node.nextSibling) this.lineBreak();\n        } else if (node.nodeType == 1) {\n            this.readRange(node.firstChild, null);\n        }\n    }\n    findPointBefore(node, next) {\n        for (let point of this.points)if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;\n    }\n    findPointInside(node, length) {\n        for (let point of this.points)if (node.nodeType == 3 ? point.node == node : node.contains(point.node)) point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);\n    }\n}\nfunction isAtEnd(parent, node, offset) {\n    for(;;){\n        if (!node || offset < maxOffset(node)) return false;\n        if (node == parent) return true;\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n    }\n}\nclass DOMPoint {\n    constructor(node, offset){\n        this.node = node;\n        this.offset = offset;\n        this.pos = -1;\n    }\n}\nclass DOMChange {\n    constructor(view, start, end, typeOver){\n        this.typeOver = typeOver;\n        this.bounds = null;\n        this.text = \"\";\n        this.domChanged = start > -1;\n        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;\n        if (view.state.readOnly && start > -1) {\n            // Ignore changes when the editor is read-only\n            this.newSel = null;\n        } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {\n            let selPoints = iHead || iAnchor ? [] : selectionPoints(view);\n            let reader = new DOMReader(selPoints, view.state);\n            reader.readRange(this.bounds.startDOM, this.bounds.endDOM);\n            this.text = reader.text;\n            this.newSel = selectionFromPoints(selPoints, this.bounds.from);\n        } else {\n            let domSel = view.observer.selectionRange;\n            let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n            let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n            // iOS will refuse to select the block gaps when doing\n            // select-all.\n            // Chrome will put the selection *inside* them, confusing\n            // posFromDOM\n            let vp = view.viewport;\n            if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {\n                let from = Math.min(head, anchor), to = Math.max(head, anchor);\n                let offFrom = vp.from - from, offTo = vp.to - to;\n                if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {\n                    head = 0;\n                    anchor = view.state.doc.length;\n                }\n            }\n            this.newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor, head);\n        }\n    }\n}\nfunction applyDOMChange(view, domChange) {\n    let change;\n    let { newSel } = domChange, sel = view.state.selection.main;\n    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;\n    if (domChange.bounds) {\n        let { from, to } = domChange.bounds;\n        let preferredPos = sel.from, preferredSide = null;\n        // Prefer anchoring to end when Backspace is pressed (or, on\n        // Android, when something was deleted)\n        if (lastKey === 8 || browser.android && domChange.text.length < to - from) {\n            preferredPos = sel.to;\n            preferredSide = \"end\";\n        }\n        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);\n        if (diff) {\n            // Chrome inserts two newlines when pressing shift-enter at the\n            // end of a line. DomChange drops one of those.\n            if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder) diff.toB--;\n            change = {\n                from: from + diff.from,\n                to: from + diff.toA,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))\n            };\n        }\n    } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {\n        newSel = null;\n    }\n    if (!change && !newSel) return false;\n    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {\n        // Heuristic to notice typing over a selected character\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: view.state.doc.slice(sel.from, sel.to)\n        };\n    } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute(\"autocorrect\") == \"off\") {\n        // Detect insert-period-on-double-space Mac and Android behavior,\n        // and transform it into a regular space insert.\n        if (newSel && change.insert.length == 2) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n        change = {\n            from: change.from,\n            to: change.to,\n            insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\n                change.insert.toString().replace(\".\", \" \")\n            ])\n        };\n    } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {\n        // If the change is inside the selection and covers most of it,\n        // assume it is a selection replace (with identical characters at\n        // the start/end not included in the diff)\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))\n        };\n    } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == \"\\n \" && view.lineWrapping) {\n        // In Chrome, if you insert a space at the start of a wrapped\n        // line, it will actually insert a newline and a space, causing a\n        // bogus new line to be created in CodeMirror (#968)\n        if (newSel) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);\n        change = {\n            from: sel.from,\n            to: sel.to,\n            insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\n                \" \"\n            ])\n        };\n    }\n    if (change) {\n        return applyDOMChangeInner(view, change, newSel, lastKey);\n    } else if (newSel && !newSel.main.eq(sel)) {\n        let scrollIntoView = false, userEvent = \"select\";\n        if (view.inputState.lastSelectionTime > Date.now() - 50) {\n            if (view.inputState.lastSelectionOrigin == \"select\") scrollIntoView = true;\n            userEvent = view.inputState.lastSelectionOrigin;\n        }\n        view.dispatch({\n            selection: newSel,\n            scrollIntoView,\n            userEvent\n        });\n        return true;\n    } else {\n        return false;\n    }\n}\nfunction applyDOMChangeInner(view, change, newSel, lastKey = -1) {\n    if (browser.ios && view.inputState.flushIOSKey(change)) return true;\n    let sel = view.state.selection.main;\n    // Android browsers don't fire reasonable key events for enter,\n    // backspace, or delete. So this detects changes that look like\n    // they're caused by those keys, and reinterprets them as key\n    // events. (Some of these keys are also handled by beforeinput\n    // events and the pendingAndroidKey mechanism, but that's not\n    // reliable in all situations.)\n    if (browser.android && (change.to == sel.to && // GBoard will sometimes remove a space it just inserted\n    // after a completion when you press enter\n    (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == \" \") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, \"Enter\", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, \"Backspace\", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, \"Delete\", 46))) return true;\n    let text = change.insert.toString();\n    if (view.inputState.composing >= 0) view.inputState.composing++;\n    let defaultTr;\n    let defaultInsert = ()=>defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));\n    if (!view.state.facet(inputHandler).some((h)=>h(view, change.from, change.to, text, defaultInsert))) view.dispatch(defaultInsert());\n    return true;\n}\nfunction applyDefaultInsert(view, change, newSel) {\n    let tr, startState = view.state, sel = startState.selection.main;\n    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {\n        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\n        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\n        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));\n    } else {\n        let changes = startState.changes(change);\n        let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;\n        // Try to apply a composition change to all cursors\n        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {\n            let replaced = view.state.sliceDoc(change.from, change.to);\n            let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);\n            if (composition) {\n                let dLen = change.insert.length - (change.to - change.from);\n                compositionRange = {\n                    from: composition.from,\n                    to: composition.to - dLen\n                };\n            } else {\n                compositionRange = view.state.doc.lineAt(sel.head);\n            }\n            let offset = sel.to - change.to, size = sel.to - sel.from;\n            tr = startState.changeByRange((range)=>{\n                if (range.from == sel.from && range.to == sel.to) return {\n                    changes,\n                    range: mainSel || range.map(changes)\n                };\n                let to = range.to - offset, from = to - replaced.length;\n                if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple\n                // changes in the same node work without aborting\n                // composition, so cursors in the composition range are\n                // ignored.\n                range.to >= compositionRange.from && range.from <= compositionRange.to) return {\n                    range\n                };\n                let rangeChanges = startState.changes({\n                    from,\n                    to,\n                    insert: change.insert\n                }), selOff = range.to - sel.to;\n                return {\n                    changes: rangeChanges,\n                    range: !mainSel ? range.map(rangeChanges) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))\n                };\n            });\n        } else {\n            tr = {\n                changes,\n                selection: mainSel && startState.selection.replaceRange(mainSel)\n            };\n        }\n    }\n    let userEvent = \"input.type\";\n    if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {\n        view.inputState.compositionPendingChange = false;\n        userEvent += \".compose\";\n        if (view.inputState.compositionFirstChange) {\n            userEvent += \".start\";\n            view.inputState.compositionFirstChange = false;\n        }\n    }\n    return startState.update(tr, {\n        userEvent,\n        scrollIntoView: true\n    });\n}\nfunction findDiff(a, b, preferredPos, preferredSide) {\n    let minLen = Math.min(a.length, b.length);\n    let from = 0;\n    while(from < minLen && a.charCodeAt(from) == b.charCodeAt(from))from++;\n    if (from == minLen && a.length == b.length) return null;\n    let toA = a.length, toB = b.length;\n    while(toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)){\n        toA--;\n        toB--;\n    }\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, from - Math.min(toA, toB));\n        preferredPos -= toA + adjust - from;\n    }\n    if (toA < from && a.length < b.length) {\n        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n        from -= move;\n        toB = from + (toB - toA);\n        toA = from;\n    } else if (toB < from) {\n        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n        from -= move;\n        toA = from + (toA - toB);\n        toB = from;\n    }\n    return {\n        from,\n        toA,\n        toB\n    };\n}\nfunction selectionPoints(view) {\n    let result = [];\n    if (view.root.activeElement != view.contentDOM) return result;\n    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;\n    if (anchorNode) {\n        result.push(new DOMPoint(anchorNode, anchorOffset));\n        if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));\n    }\n    return result;\n}\nfunction selectionFromPoints(points, base) {\n    if (points.length == 0) return null;\n    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;\n    return anchor > -1 && head > -1 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(anchor + base, head + base) : null;\n}\nclass InputState {\n    setSelectionOrigin(origin) {\n        this.lastSelectionOrigin = origin;\n        this.lastSelectionTime = Date.now();\n    }\n    constructor(view){\n        this.view = view;\n        this.lastKeyCode = 0;\n        this.lastKeyTime = 0;\n        this.lastTouchTime = 0;\n        this.lastFocusTime = 0;\n        this.lastScrollTop = 0;\n        this.lastScrollLeft = 0;\n        // On iOS, some keys need to have their default behavior happen\n        // (after which we retroactively handle them and reset the DOM) to\n        // avoid messing up the virtual keyboard state.\n        this.pendingIOSKey = undefined;\n        /**\n        When enabled (>-1), tab presses are not given to key handlers,\n        leaving the browser's default behavior. If >0, the mode expires\n        at that timestamp, and any other keypress clears it.\n        Esc enables temporary tab focus mode for two seconds when not\n        otherwise handled.\n        */ this.tabFocusMode = -1;\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastContextMenu = 0;\n        this.scrollHandlers = [];\n        this.handlers = Object.create(null);\n        // -1 means not in a composition. Otherwise, this counts the number\n        // of changes made during the composition. The count is used to\n        // avoid treating the start state of the composition, before any\n        // changes have been made, as part of the composition.\n        this.composing = -1;\n        // Tracks whether the next change should be marked as starting the\n        // composition (null means no composition, true means next is the\n        // first, false means first has already been marked for this\n        // composition)\n        this.compositionFirstChange = null;\n        // End time of the previous composition\n        this.compositionEndedAt = 0;\n        // Used in a kludge to detect when an Enter keypress should be\n        // considered part of the composition on Safari, which fires events\n        // in the wrong order\n        this.compositionPendingKey = false;\n        // Used to categorize changes as part of a composition, even when\n        // the mutation events fire shortly after the compositionend event\n        this.compositionPendingChange = false;\n        this.mouseSelection = null;\n        // When a drag from the editor is active, this points at the range\n        // being dragged.\n        this.draggedContent = null;\n        this.handleEvent = this.handleEvent.bind(this);\n        this.notifiedFocused = view.hasFocus;\n        // On Safari adding an input event handler somehow prevents an\n        // issue where the composition vanishes when you press enter.\n        if (browser.safari) view.contentDOM.addEventListener(\"input\", ()=>null);\n        if (browser.gecko) firefoxCopyCutHack(view.contentDOM.ownerDocument);\n    }\n    handleEvent(event) {\n        if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event)) return;\n        if (event.type == \"keydown\" && this.keydown(event)) return;\n        if (this.view.updateState != 0 /* UpdateState.Idle */ ) Promise.resolve().then(()=>this.runHandlers(event.type, event));\n        else this.runHandlers(event.type, event);\n    }\n    runHandlers(type, event) {\n        let handlers = this.handlers[type];\n        if (handlers) {\n            for (let observer of handlers.observers)observer(this.view, event);\n            for (let handler of handlers.handlers){\n                if (event.defaultPrevented) break;\n                if (handler(this.view, event)) {\n                    event.preventDefault();\n                    break;\n                }\n            }\n        }\n    }\n    ensureHandlers(plugins) {\n        let handlers = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;\n        for(let type in handlers)if (type != \"scroll\") {\n            let passive = !handlers[type].handlers.length;\n            let exists = prev[type];\n            if (exists && passive != !exists.handlers.length) {\n                dom.removeEventListener(type, this.handleEvent);\n                exists = null;\n            }\n            if (!exists) dom.addEventListener(type, this.handleEvent, {\n                passive\n            });\n        }\n        for(let type in prev)if (type != \"scroll\" && !handlers[type]) dom.removeEventListener(type, this.handleEvent);\n        this.handlers = handlers;\n    }\n    keydown(event) {\n        // Must always run, even if a custom handler handled the event\n        this.lastKeyCode = event.keyCode;\n        this.lastKeyTime = Date.now();\n        if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode)) return true;\n        if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0) this.tabFocusMode = -1;\n        // Chrome for Android usually doesn't fire proper key events, but\n        // occasionally does, usually surrounded by a bunch of complicated\n        // composition changes. When an enter or backspace key event is\n        // seen, hold off on handling DOM events for a bit, and then\n        // dispatch it.\n        if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {\n            this.view.observer.delayAndroidKey(event.key, event.keyCode);\n            return true;\n        }\n        // Preventing the default behavior of Enter on iOS makes the\n        // virtual keyboard get stuck in the wrong (lowercase)\n        // state. So we let it go through, and then, in\n        // applyDOMChange, notify key handlers of it and reset to\n        // the state they produce.\n        let pending;\n        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find((key)=>key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {\n            this.pendingIOSKey = pending || event;\n            setTimeout(()=>this.flushIOSKey(), 250);\n            return true;\n        }\n        if (event.keyCode != 229) this.view.observer.forceFlush();\n        return false;\n    }\n    flushIOSKey(change) {\n        let key = this.pendingIOSKey;\n        if (!key) return false;\n        // This looks like an autocorrection before Enter\n        if (key.key == \"Enter\" && change && change.from < change.to && /^\\S+$/.test(change.insert.toString())) return false;\n        this.pendingIOSKey = undefined;\n        return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : undefined);\n    }\n    ignoreDuringComposition(event) {\n        if (!/^key/.test(event.type)) return false;\n        if (this.composing > 0) return true;\n        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n        // On some input method editors (IMEs), the Enter key is used to\n        // confirm character selection. On Safari, when Enter is pressed,\n        // compositionend and keydown events are sometimes emitted in the\n        // wrong order. The key event should still be ignored, even when\n        // it happens after the compositionend event.\n        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {\n            this.compositionPendingKey = false;\n            return true;\n        }\n        return false;\n    }\n    startMouseSelection(mouseSelection) {\n        if (this.mouseSelection) this.mouseSelection.destroy();\n        this.mouseSelection = mouseSelection;\n    }\n    update(update) {\n        this.view.observer.update(update);\n        if (this.mouseSelection) this.mouseSelection.update(update);\n        if (this.draggedContent && update.docChanged) this.draggedContent = this.draggedContent.map(update.changes);\n        if (update.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;\n    }\n    destroy() {\n        if (this.mouseSelection) this.mouseSelection.destroy();\n    }\n}\nfunction bindHandler(plugin, handler) {\n    return (view, event)=>{\n        try {\n            return handler.call(plugin, event, view);\n        } catch (e) {\n            logException(view.state, e);\n        }\n    };\n}\nfunction computeHandlers(plugins) {\n    let result = Object.create(null);\n    function record(type) {\n        return result[type] || (result[type] = {\n            observers: [],\n            handlers: []\n        });\n    }\n    for (let plugin of plugins){\n        let spec = plugin.spec;\n        if (spec && spec.domEventHandlers) for(let type in spec.domEventHandlers){\n            let f = spec.domEventHandlers[type];\n            if (f) record(type).handlers.push(bindHandler(plugin.value, f));\n        }\n        if (spec && spec.domEventObservers) for(let type in spec.domEventObservers){\n            let f = spec.domEventObservers[type];\n            if (f) record(type).observers.push(bindHandler(plugin.value, f));\n        }\n    }\n    for(let type in handlers)record(type).handlers.push(handlers[type]);\n    for(let type in observers)record(type).observers.push(observers[type]);\n    return result;\n}\nconst PendingKeys = [\n    {\n        key: \"Backspace\",\n        keyCode: 8,\n        inputType: \"deleteContentBackward\"\n    },\n    {\n        key: \"Enter\",\n        keyCode: 13,\n        inputType: \"insertParagraph\"\n    },\n    {\n        key: \"Enter\",\n        keyCode: 13,\n        inputType: \"insertLineBreak\"\n    },\n    {\n        key: \"Delete\",\n        keyCode: 46,\n        inputType: \"deleteContentForward\"\n    }\n];\nconst EmacsyPendingKeys = \"dthko\";\n// Key codes for modifier keys\nconst modifierCodes = [\n    16,\n    17,\n    18,\n    20,\n    91,\n    92,\n    224,\n    225\n];\nconst dragScrollMargin = 6;\nfunction dragScrollSpeed(dist) {\n    return Math.max(0, dist) * 0.7 + 8;\n}\nfunction dist(a, b) {\n    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));\n}\nclass MouseSelection {\n    constructor(view, startEvent, style, mustSelect){\n        this.view = view;\n        this.startEvent = startEvent;\n        this.style = style;\n        this.mustSelect = mustSelect;\n        this.scrollSpeed = {\n            x: 0,\n            y: 0\n        };\n        this.scrolling = -1;\n        this.lastEvent = startEvent;\n        this.scrollParents = scrollableParents(view.contentDOM);\n        this.atoms = view.state.facet(atomicRanges).map((f)=>f(view));\n        let doc = view.contentDOM.ownerDocument;\n        doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        this.extend = startEvent.shiftKey;\n        this.multiple = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\n        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;\n    }\n    start(event) {\n        // When clicking outside of the selection, immediately apply the\n        // effect of starting the selection\n        if (this.dragging === false) this.select(event);\n    }\n    move(event) {\n        if (event.buttons == 0) return this.destroy();\n        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10) return;\n        this.select(this.lastEvent = event);\n        let sx = 0, sy = 0;\n        let left = 0, top = 0, right = this.view.win.innerWidth, bottom = this.view.win.innerHeight;\n        if (this.scrollParents.x) ({ left, right } = this.scrollParents.x.getBoundingClientRect());\n        if (this.scrollParents.y) ({ top, bottom } = this.scrollParents.y.getBoundingClientRect());\n        let margins = getScrollMargins(this.view);\n        if (event.clientX - margins.left <= left + dragScrollMargin) sx = -dragScrollSpeed(left - event.clientX);\n        else if (event.clientX + margins.right >= right - dragScrollMargin) sx = dragScrollSpeed(event.clientX - right);\n        if (event.clientY - margins.top <= top + dragScrollMargin) sy = -dragScrollSpeed(top - event.clientY);\n        else if (event.clientY + margins.bottom >= bottom - dragScrollMargin) sy = dragScrollSpeed(event.clientY - bottom);\n        this.setScrollSpeed(sx, sy);\n    }\n    up(event) {\n        if (this.dragging == null) this.select(this.lastEvent);\n        if (!this.dragging) event.preventDefault();\n        this.destroy();\n    }\n    destroy() {\n        this.setScrollSpeed(0, 0);\n        let doc = this.view.contentDOM.ownerDocument;\n        doc.removeEventListener(\"mousemove\", this.move);\n        doc.removeEventListener(\"mouseup\", this.up);\n        this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;\n    }\n    setScrollSpeed(sx, sy) {\n        this.scrollSpeed = {\n            x: sx,\n            y: sy\n        };\n        if (sx || sy) {\n            if (this.scrolling < 0) this.scrolling = setInterval(()=>this.scroll(), 50);\n        } else if (this.scrolling > -1) {\n            clearInterval(this.scrolling);\n            this.scrolling = -1;\n        }\n    }\n    scroll() {\n        let { x, y } = this.scrollSpeed;\n        if (x && this.scrollParents.x) {\n            this.scrollParents.x.scrollLeft += x;\n            x = 0;\n        }\n        if (y && this.scrollParents.y) {\n            this.scrollParents.y.scrollTop += y;\n            y = 0;\n        }\n        if (x || y) this.view.win.scrollBy(x, y);\n        if (this.dragging === false) this.select(this.lastEvent);\n    }\n    skipAtoms(sel) {\n        let ranges = null;\n        for(let i = 0; i < sel.ranges.length; i++){\n            let range = sel.ranges[i], updated = null;\n            if (range.empty) {\n                let pos = skipAtomicRanges(this.atoms, range.from, 0);\n                if (pos != range.from) updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, -1);\n            } else {\n                let from = skipAtomicRanges(this.atoms, range.from, -1);\n                let to = skipAtomicRanges(this.atoms, range.to, 1);\n                if (from != range.from || to != range.to) updated = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);\n            }\n            if (updated) {\n                if (!ranges) ranges = sel.ranges.slice();\n                ranges[i] = updated;\n            }\n        }\n        return ranges ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges, sel.mainIndex) : sel;\n    }\n    select(event) {\n        let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));\n        if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false)) this.view.dispatch({\n            selection,\n            userEvent: \"select.pointer\"\n        });\n        this.mustSelect = false;\n    }\n    update(update) {\n        if (update.transactions.some((tr)=>tr.isUserEvent(\"input.type\"))) this.destroy();\n        else if (this.style.update(update)) setTimeout(()=>this.select(this.lastEvent), 20);\n    }\n}\nfunction addsSelectionRange(view, event) {\n    let facet = view.state.facet(clickAddsSelectionRange);\n    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\nfunction dragMovesSelection(view, event) {\n    let facet = view.state.facet(dragMovesSelection$1);\n    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\nfunction isInPrimarySelection(view, event) {\n    let { main } = view.state.selection;\n    if (main.empty) return false;\n    // On boundary clicks, check whether the coordinates are inside the\n    // selection's client rectangles\n    let sel = getSelection(view.root);\n    if (!sel || sel.rangeCount == 0) return true;\n    let rects = sel.getRangeAt(0).getClientRects();\n    for(let i = 0; i < rects.length; i++){\n        let rect = rects[i];\n        if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;\n    }\n    return false;\n}\nfunction eventBelongsToEditor(view, event) {\n    if (!event.bubbles) return true;\n    if (event.defaultPrevented) return false;\n    for(let node = event.target, cView; node != view.contentDOM; node = node.parentNode)if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;\n    return true;\n}\nconst handlers = /*@__PURE__*/ Object.create(null);\nconst observers = /*@__PURE__*/ Object.create(null);\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;\nfunction capturePaste(view) {\n    let parent = view.dom.parentNode;\n    if (!parent) return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    setTimeout(()=>{\n        view.focus();\n        target.remove();\n        doPaste(view, target.value);\n    }, 50);\n}\nfunction textFilter(state, facet, text) {\n    for (let filter of state.facet(facet))text = filter(text, state);\n    return text;\n}\nfunction doPaste(view, input) {\n    input = textFilter(view.state, clipboardInputFilter, input);\n    let { state } = view, changes, i = 1, text = state.toText(input);\n    let byLine = text.lines == state.selection.ranges.length;\n    let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r)=>r.empty) && lastLinewiseCopy == text.toString();\n    if (linewise) {\n        let lastLine = -1;\n        changes = state.changeByRange((range)=>{\n            let line = state.doc.lineAt(range.from);\n            if (line.from == lastLine) return {\n                range\n            };\n            lastLine = line.from;\n            let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);\n            return {\n                changes: {\n                    from: line.from,\n                    insert\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + insert.length)\n            };\n        });\n    } else if (byLine) {\n        changes = state.changeByRange((range)=>{\n            let line = text.line(i++);\n            return {\n                changes: {\n                    from: range.from,\n                    to: range.to,\n                    insert: line.text\n                },\n                range: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(range.from + line.length)\n            };\n        });\n    } else {\n        changes = state.replaceSelection(text);\n    }\n    view.dispatch(changes, {\n        userEvent: \"input.paste\",\n        scrollIntoView: true\n    });\n}\nobservers.scroll = (view)=>{\n    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;\n    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;\n};\nhandlers.keydown = (view, event)=>{\n    view.inputState.setSelectionOrigin(\"select\");\n    if (event.keyCode == 27 && view.inputState.tabFocusMode != 0) view.inputState.tabFocusMode = Date.now() + 2000;\n    return false;\n};\nobservers.touchstart = (view, e)=>{\n    view.inputState.lastTouchTime = Date.now();\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nobservers.touchmove = (view)=>{\n    view.inputState.setSelectionOrigin(\"select.pointer\");\n};\nhandlers.mousedown = (view, event)=>{\n    view.observer.flush();\n    if (view.inputState.lastTouchTime > Date.now() - 2000) return false; // Ignore touch interaction\n    let style = null;\n    for (let makeStyle of view.state.facet(mouseSelectionStyle)){\n        style = makeStyle(view, event);\n        if (style) break;\n    }\n    if (!style && event.button == 0) style = basicMouseSelection(view, event);\n    if (style) {\n        let mustFocus = !view.hasFocus;\n        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));\n        if (mustFocus) view.observer.ignore(()=>{\n            focusPreventScroll(view.contentDOM);\n            let active = view.root.activeElement;\n            if (active && !active.contains(view.contentDOM)) active.blur();\n        });\n        let mouseSel = view.inputState.mouseSelection;\n        if (mouseSel) {\n            mouseSel.start(event);\n            return mouseSel.dragging === false;\n        }\n    }\n    return false;\n};\nfunction rangeForClick(view, pos, bias, type) {\n    if (type == 1) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos, bias);\n    } else if (type == 2) {\n        return groupAt(view.state, pos, bias);\n    } else {\n        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);\n        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;\n        if (to < view.state.doc.length && to == line.to) to++;\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to);\n    }\n}\nlet inside = (x, y, rect)=>y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;\n// Try to determine, for the given coordinates, associated with the\n// given position, whether they are related to the element before or\n// the element after the position.\nfunction findPositionSide(view, pos, x, y) {\n    let line = LineView.find(view.docView, pos);\n    if (!line) return 1;\n    let off = pos - line.posAtStart;\n    // Line boundaries point into the line\n    if (off == 0) return 1;\n    if (off == line.length) return -1;\n    // Positions on top of an element point at that element\n    let before = line.coordsAt(off, -1);\n    if (before && inside(x, y, before)) return -1;\n    let after = line.coordsAt(off, 1);\n    if (after && inside(x, y, after)) return 1;\n    // This is probably a line wrap point. Pick before if the point is\n    // above its bottom.\n    return before && before.bottom >= y ? -1 : 1;\n}\nfunction queryPos(view, event) {\n    let pos = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    return {\n        pos,\n        bias: findPositionSide(view, pos, event.clientX, event.clientY)\n    };\n}\nconst BadMouseDetail = browser.ie && browser.ie_version <= 11;\nlet lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;\nfunction getClickType(event) {\n    if (!BadMouseDetail) return event.detail;\n    let last = lastMouseDown, lastTime = lastMouseDownTime;\n    lastMouseDown = event;\n    lastMouseDownTime = Date.now();\n    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;\n}\nfunction basicMouseSelection(view, event) {\n    let start = queryPos(view, event), type = getClickType(event);\n    let startSel = view.state.selection;\n    return {\n        update (update) {\n            if (update.docChanged) {\n                start.pos = update.changes.mapPos(start.pos);\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get (event, extend, multiple) {\n            let cur = queryPos(view, event), removed;\n            let range = rangeForClick(view, cur.pos, cur.bias, type);\n            if (start.pos != cur.pos && !extend) {\n                let startRange = rangeForClick(view, start.pos, start.bias, type);\n                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);\n                range = from < range.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to) : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(to, from);\n            }\n            if (extend) return startSel.replaceRange(startSel.main.extend(range.from, range.to));\n            else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos))) return removed;\n            else if (multiple) return startSel.addRange(range);\n            else return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create([\n                range\n            ]);\n        }\n    };\n}\nfunction removeRangeAround(sel, pos) {\n    for(let i = 0; i < sel.ranges.length; i++){\n        let { from, to } = sel.ranges[i];\n        if (from <= pos && to >= pos) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));\n    }\n    return null;\n}\nhandlers.dragstart = (view, event)=>{\n    let { selection: { main: range } } = view.state;\n    if (event.target.draggable) {\n        let cView = view.docView.nearest(event.target);\n        if (cView && cView.isWidget) {\n            let from = cView.posAtStart, to = from + cView.length;\n            if (from >= range.to || to <= range.from) range = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(from, to);\n        }\n    }\n    let { inputState } = view;\n    if (inputState.mouseSelection) inputState.mouseSelection.dragging = true;\n    inputState.draggedContent = range;\n    if (event.dataTransfer) {\n        event.dataTransfer.setData(\"Text\", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));\n        event.dataTransfer.effectAllowed = \"copyMove\";\n    }\n    return false;\n};\nhandlers.dragend = (view)=>{\n    view.inputState.draggedContent = null;\n    return false;\n};\nfunction dropText(view, event, text, direct) {\n    text = textFilter(view.state, clipboardInputFilter, text);\n    if (!text) return;\n    let dropPos = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    let { draggedContent } = view.inputState;\n    let del = direct && draggedContent && dragMovesSelection(view, event) ? {\n        from: draggedContent.from,\n        to: draggedContent.to\n    } : null;\n    let ins = {\n        from: dropPos,\n        insert: text\n    };\n    let changes = view.state.changes(del ? [\n        del,\n        ins\n    ] : ins);\n    view.focus();\n    view.dispatch({\n        changes,\n        selection: {\n            anchor: changes.mapPos(dropPos, -1),\n            head: changes.mapPos(dropPos, 1)\n        },\n        userEvent: del ? \"move.drop\" : \"input.drop\"\n    });\n    view.inputState.draggedContent = null;\n}\nhandlers.drop = (view, event)=>{\n    if (!event.dataTransfer) return false;\n    if (view.state.readOnly) return true;\n    let files = event.dataTransfer.files;\n    if (files && files.length) {\n        let text = Array(files.length), read = 0;\n        let finishFile = ()=>{\n            if (++read == files.length) dropText(view, event, text.filter((s)=>s != null).join(view.state.lineBreak), false);\n        };\n        for(let i = 0; i < files.length; i++){\n            let reader = new FileReader;\n            reader.onerror = finishFile;\n            reader.onload = ()=>{\n                if (!/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(reader.result)) text[i] = reader.result;\n                finishFile();\n            };\n            reader.readAsText(files[i]);\n        }\n        return true;\n    } else {\n        let text = event.dataTransfer.getData(\"Text\");\n        if (text) {\n            dropText(view, event, text, true);\n            return true;\n        }\n    }\n    return false;\n};\nhandlers.paste = (view, event)=>{\n    if (view.state.readOnly) return true;\n    view.observer.flush();\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        doPaste(view, data.getData(\"text/plain\") || data.getData(\"text/uri-list\"));\n        return true;\n    } else {\n        capturePaste(view);\n        return false;\n    }\n};\nfunction captureCopy(view, text) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    let parent = view.dom.parentNode;\n    if (!parent) return;\n    let target = parent.appendChild(document.createElement(\"textarea\"));\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.value = text;\n    target.focus();\n    target.selectionEnd = text.length;\n    target.selectionStart = 0;\n    setTimeout(()=>{\n        target.remove();\n        view.focus();\n    }, 50);\n}\nfunction copiedRange(state) {\n    let content = [], ranges = [], linewise = false;\n    for (let range of state.selection.ranges)if (!range.empty) {\n        content.push(state.sliceDoc(range.from, range.to));\n        ranges.push(range);\n    }\n    if (!content.length) {\n        // Nothing selected, do a line-wise copy\n        let upto = -1;\n        for (let { from } of state.selection.ranges){\n            let line = state.doc.lineAt(from);\n            if (line.number > upto) {\n                content.push(line.text);\n                ranges.push({\n                    from: line.from,\n                    to: Math.min(state.doc.length, line.to + 1)\n                });\n            }\n            upto = line.number;\n        }\n        linewise = true;\n    }\n    return {\n        text: textFilter(state, clipboardOutputFilter, content.join(state.lineBreak)),\n        ranges,\n        linewise\n    };\n}\nlet lastLinewiseCopy = null;\nhandlers.copy = handlers.cut = (view, event)=>{\n    let { text, ranges, linewise } = copiedRange(view.state);\n    if (!text && !linewise) return false;\n    lastLinewiseCopy = linewise ? text : null;\n    if (event.type == \"cut\" && !view.state.readOnly) view.dispatch({\n        changes: ranges,\n        scrollIntoView: true,\n        userEvent: \"delete.cut\"\n    });\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    if (data) {\n        data.clearData();\n        data.setData(\"text/plain\", text);\n        return true;\n    } else {\n        captureCopy(view, text);\n        return false;\n    }\n};\nconst isFocusChange = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Annotation.define();\nfunction focusChangeTransaction(state, focus) {\n    let effects = [];\n    for (let getEffect of state.facet(focusChangeEffect)){\n        let effect = getEffect(state, focus);\n        if (effect) effects.push(effect);\n    }\n    return effects ? state.update({\n        effects,\n        annotations: isFocusChange.of(true)\n    }) : null;\n}\nfunction updateForFocusChange(view) {\n    setTimeout(()=>{\n        let focus = view.hasFocus;\n        if (focus != view.inputState.notifiedFocused) {\n            let tr = focusChangeTransaction(view.state, focus);\n            if (tr) view.dispatch(tr);\n            else view.update([]);\n        }\n    }, 10);\n}\nobservers.focus = (view)=>{\n    view.inputState.lastFocusTime = Date.now();\n    // When focusing reset the scroll position, move it back to where it was\n    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {\n        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;\n        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;\n    }\n    updateForFocusChange(view);\n};\nobservers.blur = (view)=>{\n    view.observer.clearSelectionRange();\n    updateForFocusChange(view);\n};\nobservers.compositionstart = observers.compositionupdate = (view)=>{\n    if (view.observer.editContext) return; // Composition handled by edit context\n    if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;\n    if (view.inputState.composing < 0) {\n        // FIXME possibly set a timeout to clear it again on Android\n        view.inputState.composing = 0;\n    }\n};\nobservers.compositionend = (view)=>{\n    if (view.observer.editContext) return; // Composition handled by edit context\n    view.inputState.composing = -1;\n    view.inputState.compositionEndedAt = Date.now();\n    view.inputState.compositionPendingKey = true;\n    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;\n    view.inputState.compositionFirstChange = null;\n    if (browser.chrome && browser.android) {\n        // Delay flushing for a bit on Android because it'll often fire a\n        // bunch of contradictory changes in a row at end of compositon\n        view.observer.flushSoon();\n    } else if (view.inputState.compositionPendingChange) {\n        // If we found pending records, schedule a flush.\n        Promise.resolve().then(()=>view.observer.flush());\n    } else {\n        // Otherwise, make sure that, if no changes come in soon, the\n        // composition view is cleared.\n        setTimeout(()=>{\n            if (view.inputState.composing < 0 && view.docView.hasComposition) view.update([]);\n        }, 50);\n    }\n};\nobservers.contextmenu = (view)=>{\n    view.inputState.lastContextMenu = Date.now();\n};\nhandlers.beforeinput = (view, event)=>{\n    var _a, _b;\n    // In EditContext mode, we must handle insertReplacementText events\n    // directly, to make spell checking corrections work\n    if (event.inputType == \"insertReplacementText\" && view.observer.editContext) {\n        let text = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData(\"text/plain\"), ranges = event.getTargetRanges();\n        if (text && ranges.length) {\n            let r = ranges[0];\n            let from = view.posAtDOM(r.startContainer, r.startOffset), to = view.posAtDOM(r.endContainer, r.endOffset);\n            applyDOMChangeInner(view, {\n                from,\n                to,\n                insert: view.state.toText(text)\n            }, null);\n            return true;\n        }\n    }\n    // Because Chrome Android doesn't fire useful key events, use\n    // beforeinput to detect backspace (and possibly enter and delete,\n    // but those usually don't even seem to fire beforeinput events at\n    // the moment) and fake a key event for it.\n    //\n    // (preventDefault on beforeinput, though supported in the spec,\n    // seems to do nothing at all on Chrome).\n    let pending;\n    if (browser.chrome && browser.android && (pending = PendingKeys.find((key)=>key.inputType == event.inputType))) {\n        view.observer.delayAndroidKey(pending.key, pending.keyCode);\n        if (pending.key == \"Backspace\" || pending.key == \"Delete\") {\n            let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;\n            setTimeout(()=>{\n                var _a;\n                // Backspacing near uneditable nodes on Chrome Android sometimes\n                // closes the virtual keyboard. This tries to crudely detect\n                // that and refocus to get it back.\n                if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {\n                    view.contentDOM.blur();\n                    view.focus();\n                }\n            }, 100);\n        }\n    }\n    if (browser.ios && event.inputType == \"deleteContentForward\") {\n        // For some reason, DOM changes (and beforeinput) happen _before_\n        // the key event for ctrl-d on iOS when using an external\n        // keyboard.\n        view.observer.flushSoon();\n    }\n    // Safari will occasionally forget to fire compositionend at the end of a dead-key composition\n    if (browser.safari && event.inputType == \"insertText\" && view.inputState.composing >= 0) {\n        setTimeout(()=>observers.compositionend(view, event), 20);\n    }\n    return false;\n};\nconst appliedFirefoxHack = /*@__PURE__*/ new Set;\n// In Firefox, when cut/copy handlers are added to the document, that\n// somehow avoids a bug where those events aren't fired when the\n// selection is empty. See https://github.com/codemirror/dev/issues/1082\n// and https://bugzilla.mozilla.org/show_bug.cgi?id=995961\nfunction firefoxCopyCutHack(doc) {\n    if (!appliedFirefoxHack.has(doc)) {\n        appliedFirefoxHack.add(doc);\n        doc.addEventListener(\"copy\", ()=>{});\n        doc.addEventListener(\"cut\", ()=>{});\n    }\n}\nconst wrappingWhiteSpace = [\n    \"pre-wrap\",\n    \"normal\",\n    \"pre-line\",\n    \"break-spaces\"\n];\n// Used to track, during updateHeight, if any actual heights changed\nlet heightChangeFlag = false;\nfunction clearHeightChangeFlag() {\n    heightChangeFlag = false;\n}\nclass HeightOracle {\n    constructor(lineWrapping){\n        this.lineWrapping = lineWrapping;\n        this.doc = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty;\n        this.heightSamples = {};\n        this.lineHeight = 14; // The height of an entire line (line-height)\n        this.charWidth = 7;\n        this.textHeight = 14; // The height of the actual font (font-size)\n        this.lineLength = 30;\n    }\n    heightForGap(from, to) {\n        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n        if (this.lineWrapping) lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));\n        return this.lineHeight * lines;\n    }\n    heightForLine(length) {\n        if (!this.lineWrapping) return this.lineHeight;\n        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n        return lines * this.lineHeight;\n    }\n    setDoc(doc) {\n        this.doc = doc;\n        return this;\n    }\n    mustRefreshForWrapping(whiteSpace) {\n        return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;\n    }\n    mustRefreshForHeights(lineHeights) {\n        let newHeight = false;\n        for(let i = 0; i < lineHeights.length; i++){\n            let h = lineHeights[i];\n            if (h < 0) {\n                i++;\n            } else if (!this.heightSamples[Math.floor(h * 10)]) {\n                newHeight = true;\n                this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return newHeight;\n    }\n    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {\n        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;\n        this.lineWrapping = lineWrapping;\n        this.lineHeight = lineHeight;\n        this.charWidth = charWidth;\n        this.textHeight = textHeight;\n        this.lineLength = lineLength;\n        if (changed) {\n            this.heightSamples = {};\n            for(let i = 0; i < knownHeights.length; i++){\n                let h = knownHeights[i];\n                if (h < 0) i++;\n                else this.heightSamples[Math.floor(h * 10)] = true;\n            }\n        }\n        return changed;\n    }\n}\n// This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\nclass MeasuredHeights {\n    constructor(from, heights){\n        this.from = from;\n        this.heights = heights;\n        this.index = 0;\n    }\n    get more() {\n        return this.index < this.heights.length;\n    }\n}\n/**\nRecord used to represent information about a block-level element\nin the editor view.\n*/ class BlockInfo {\n    /**\n    @internal\n    */ constructor(/**\n    The start of the element in the document.\n    */ from, /**\n    The length of the element.\n    */ length, /**\n    The top position of the element (relative to the top of the\n    document).\n    */ top, /**\n    Its height.\n    */ height, /**\n    @internal Weird packed field that holds an array of children\n    for composite blocks, a decoration for block widgets, and a\n    number indicating the amount of widget-create line breaks for\n    text blocks.\n    */ _content){\n        this.from = from;\n        this.length = length;\n        this.top = top;\n        this.height = height;\n        this._content = _content;\n    }\n    /**\n    The type of element this is. When querying lines, this may be\n    an array of all the blocks that make up the line.\n    */ get type() {\n        return typeof this._content == \"number\" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;\n    }\n    /**\n    The end of the element as a document position.\n    */ get to() {\n        return this.from + this.length;\n    }\n    /**\n    The bottom position of the element.\n    */ get bottom() {\n        return this.top + this.height;\n    }\n    /**\n    If this is a widget block, this will return the widget\n    associated with it.\n    */ get widget() {\n        return this._content instanceof PointDecoration ? this._content.widget : null;\n    }\n    /**\n    If this is a textblock, this holds the number of line breaks\n    that appear in widgets inside the block.\n    */ get widgetLineBreaks() {\n        return typeof this._content == \"number\" ? this._content : 0;\n    }\n    /**\n    @internal\n    */ join(other) {\n        let content = (Array.isArray(this._content) ? this._content : [\n            this\n        ]).concat(Array.isArray(other._content) ? other._content : [\n            other\n        ]);\n        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);\n    }\n}\nvar QueryType = /*@__PURE__*/ function(QueryType) {\n    QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n    QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n    QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n    return QueryType;\n}(QueryType || (QueryType = {}));\nconst Epsilon = 1e-3;\nclass HeightMap {\n    constructor(length, height, flags = 2 /* Flag.Outdated */ ){\n        this.length = length;\n        this.height = height;\n        this.flags = flags;\n    }\n    get outdated() {\n        return (this.flags & 2 /* Flag.Outdated */ ) > 0;\n    }\n    set outdated(value) {\n        this.flags = (value ? 2 /* Flag.Outdated */  : 0) | this.flags & ~2 /* Flag.Outdated */ ;\n    }\n    setHeight(height) {\n        if (this.height != height) {\n            if (Math.abs(this.height - height) > Epsilon) heightChangeFlag = true;\n            this.height = height;\n        }\n    }\n    // Base case is to replace a leaf node, which simply builds a tree\n    // from the new nodes and returns that (HeightMapBranch and\n    // HeightMapGap override this to actually use from/to)\n    replace(_from, _to, nodes) {\n        return HeightMap.of(nodes);\n    }\n    // Again, these are base cases, and are overridden for branch and gap nodes.\n    decomposeLeft(_to, result) {\n        result.push(this);\n    }\n    decomposeRight(_from, result) {\n        result.push(this);\n    }\n    applyChanges(decorations, oldDoc, oracle, changes) {\n        let me = this, doc = oracle.doc;\n        for(let i = changes.length - 1; i >= 0; i--){\n            let { fromA, toA, fromB, toB } = changes[i];\n            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);\n            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);\n            toB += end.to - toA;\n            toA = end.to;\n            while(i > 0 && start.from <= changes[i - 1].toA){\n                fromA = changes[i - 1].fromA;\n                fromB = changes[i - 1].fromB;\n                i--;\n                if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);\n            }\n            fromB += start.from - fromA;\n            fromA = start.from;\n            let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);\n            me = replace(me, me.replace(fromA, toA, nodes));\n        }\n        return me.updateHeight(oracle, 0);\n    }\n    static empty() {\n        return new HeightMapText(0, 0);\n    }\n    // nodes uses null values to indicate the position of line breaks.\n    // There are never line breaks at the start or end of the array, or\n    // two line breaks next to each other, and the array isn't allowed\n    // to be empty (same restrictions as return value from the builder).\n    static of(nodes) {\n        if (nodes.length == 1) return nodes[0];\n        let i = 0, j = nodes.length, before = 0, after = 0;\n        for(;;){\n            if (i == j) {\n                if (before > after * 2) {\n                    let split = nodes[i - 1];\n                    if (split.break) nodes.splice(--i, 1, split.left, null, split.right);\n                    else nodes.splice(--i, 1, split.left, split.right);\n                    j += 1 + split.break;\n                    before -= split.size;\n                } else if (after > before * 2) {\n                    let split = nodes[j];\n                    if (split.break) nodes.splice(j, 1, split.left, null, split.right);\n                    else nodes.splice(j, 1, split.left, split.right);\n                    j += 2 + split.break;\n                    after -= split.size;\n                } else {\n                    break;\n                }\n            } else if (before < after) {\n                let next = nodes[i++];\n                if (next) before += next.size;\n            } else {\n                let next = nodes[--j];\n                if (next) after += next.size;\n            }\n        }\n        let brk = 0;\n        if (nodes[i - 1] == null) {\n            brk = 1;\n            i--;\n        } else if (nodes[i] == null) {\n            brk = 1;\n            j++;\n        }\n        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n    }\n}\nfunction replace(old, val) {\n    if (old == val) return old;\n    if (old.constructor != val.constructor) heightChangeFlag = true;\n    return val;\n}\nHeightMap.prototype.size = 1;\nclass HeightMapBlock extends HeightMap {\n    constructor(length, height, deco){\n        super(length, height);\n        this.deco = deco;\n    }\n    blockAt(_height, _oracle, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);\n    }\n    lineAt(_value, _type, oracle, top, offset) {\n        return this.blockAt(0, oracle, top, offset);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        if (from <= offset + this.length && to >= offset) f(this.blockAt(0, oracle, top, offset));\n    }\n    updateHeight(oracle, offset = 0, _force = false, measured) {\n        if (measured && measured.from <= offset && measured.more) this.setHeight(measured.heights[measured.index++]);\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `block(${this.length})`;\n    }\n}\nclass HeightMapText extends HeightMapBlock {\n    constructor(length, height){\n        super(length, height, null);\n        this.collapsed = 0; // Amount of collapsed content in the line\n        this.widgetHeight = 0; // Maximum inline widget height\n        this.breaks = 0; // Number of widget-introduced line breaks on the line\n    }\n    blockAt(_height, _oracle, top, offset) {\n        return new BlockInfo(offset, this.length, top, this.height, this.breaks);\n    }\n    replace(_from, _to, nodes) {\n        let node = nodes[0];\n        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4 /* Flag.SingleLine */ ) && Math.abs(this.length - node.length) < 10) {\n            if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height);\n            else node.height = this.height;\n            if (!this.outdated) node.outdated = false;\n            return node;\n        } else {\n            return HeightMap.of(nodes);\n        }\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        if (measured && measured.from <= offset && measured.more) this.setHeight(measured.heights[measured.index++]);\n        else if (force || this.outdated) this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n    }\n}\nclass HeightMapGap extends HeightMap {\n    constructor(length){\n        super(length, 0);\n    }\n    heightMetrics(oracle, offset) {\n        let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;\n        let lines = lastLine - firstLine + 1;\n        let perLine, perChar = 0;\n        if (oracle.lineWrapping) {\n            let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);\n            perLine = totalPerLine / lines;\n            if (this.length > lines + 1) perChar = (this.height - totalPerLine) / (this.length - lines - 1);\n        } else {\n            perLine = this.height / lines;\n        }\n        return {\n            firstLine,\n            lastLine,\n            perLine,\n            perChar\n        };\n    }\n    blockAt(height, oracle, top, offset) {\n        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        if (oracle.lineWrapping) {\n            let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length));\n            let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;\n            let lineTop = Math.max(top, height - lineHeight / 2);\n            return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);\n        } else {\n            let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));\n            let { from, length } = oracle.doc.line(firstLine + line);\n            return new BlockInfo(from, length, top + perLine * line, perLine, 0);\n        }\n    }\n    lineAt(value, type, oracle, top, offset) {\n        if (type == QueryType.ByHeight) return this.blockAt(value, oracle, top, offset);\n        if (type == QueryType.ByPosNoHeight) {\n            let { from, to } = oracle.doc.lineAt(value);\n            return new BlockInfo(from, to - from, 0, 0, 0);\n        }\n        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;\n        let linesAbove = line.number - firstLine;\n        let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);\n        return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        from = Math.max(from, offset);\n        to = Math.min(to, offset + this.length);\n        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);\n        for(let pos = from, lineTop = top; pos <= to;){\n            let line = oracle.doc.lineAt(pos);\n            if (pos == from) {\n                let linesAbove = line.number - firstLine;\n                lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);\n            }\n            let lineHeight = perLine + perChar * line.length;\n            f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));\n            lineTop += lineHeight;\n            pos = line.to + 1;\n        }\n    }\n    replace(from, to, nodes) {\n        let after = this.length - to;\n        if (after > 0) {\n            let last = nodes[nodes.length - 1];\n            if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);\n            else nodes.push(null, new HeightMapGap(after - 1));\n        }\n        if (from > 0) {\n            let first = nodes[0];\n            if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);\n            else nodes.unshift(new HeightMapGap(from - 1), null);\n        }\n        return HeightMap.of(nodes);\n    }\n    decomposeLeft(to, result) {\n        result.push(new HeightMapGap(to - 1), null);\n    }\n    decomposeRight(from, result) {\n        result.push(null, new HeightMapGap(this.length - from - 1));\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let end = offset + this.length;\n        if (measured && measured.from <= offset + this.length && measured.more) {\n            // Fill in part of this gap with measured lines. We know there\n            // can't be widgets or collapsed ranges in those lines, because\n            // they would already have been added to the heightmap (gaps\n            // only contain plain text).\n            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;\n            if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n            while(pos <= end && measured.more){\n                let len = oracle.doc.lineAt(pos).length;\n                if (nodes.length) nodes.push(null);\n                let height = measured.heights[measured.index++];\n                if (singleHeight == -1) singleHeight = height;\n                else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2;\n                let line = new HeightMapText(len, height);\n                line.outdated = false;\n                nodes.push(line);\n                pos += len + 1;\n            }\n            if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n            let result = HeightMap.of(nodes);\n            if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon) heightChangeFlag = true;\n            return replace(this, result);\n        } else if (force || this.outdated) {\n            this.setHeight(oracle.heightForGap(offset, offset + this.length));\n            this.outdated = false;\n        }\n        return this;\n    }\n    toString() {\n        return `gap(${this.length})`;\n    }\n}\nclass HeightMapBranch extends HeightMap {\n    constructor(left, brk, right){\n        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */  : 0));\n        this.left = left;\n        this.right = right;\n        this.size = left.size + right.size;\n    }\n    get break() {\n        return this.flags & 1 /* Flag.Break */ ;\n    }\n    blockAt(height, oracle, top, offset) {\n        let mid = top + this.left.height;\n        return height < mid ? this.left.blockAt(height, oracle, top, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);\n    }\n    lineAt(value, type, oracle, top, offset) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;\n        let base = left ? this.left.lineAt(value, type, oracle, top, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);\n        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset)) return base;\n        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n        if (left) return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));\n        else return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);\n    }\n    forEachLine(from, to, oracle, top, offset, f) {\n        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;\n        if (this.break) {\n            if (from < rightOffset) this.left.forEachLine(from, to, oracle, top, offset, f);\n            if (to >= rightOffset) this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);\n        } else {\n            let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);\n            if (from < mid.from) this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);\n            if (mid.to >= from && mid.from <= to) f(mid);\n            if (to > mid.to) this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);\n        }\n    }\n    replace(from, to, nodes) {\n        let rightStart = this.left.length + this.break;\n        if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);\n        if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n        let result = [];\n        if (from > 0) this.decomposeLeft(from, result);\n        let left = result.length;\n        for (let node of nodes)result.push(node);\n        if (from > 0) mergeGaps(result, left - 1);\n        if (to < this.length) {\n            let right = result.length;\n            this.decomposeRight(to, result);\n            mergeGaps(result, right);\n        }\n        return HeightMap.of(result);\n    }\n    decomposeLeft(to, result) {\n        let left = this.left.length;\n        if (to <= left) return this.left.decomposeLeft(to, result);\n        result.push(this.left);\n        if (this.break) {\n            left++;\n            if (to >= left) result.push(null);\n        }\n        if (to > left) this.right.decomposeLeft(to - left, result);\n    }\n    decomposeRight(from, result) {\n        let left = this.left.length, right = left + this.break;\n        if (from >= right) return this.right.decomposeRight(from - right, result);\n        if (from < left) this.left.decomposeRight(from, result);\n        if (this.break && from < right) result.push(null);\n        result.push(this.right);\n    }\n    balanced(left, right) {\n        if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [\n            left,\n            null,\n            right\n        ] : [\n            left,\n            right\n        ]);\n        this.left = replace(this.left, left);\n        this.right = replace(this.right, right);\n        this.setHeight(left.height + right.height);\n        this.outdated = left.outdated || right.outdated;\n        this.size = left.size + right.size;\n        this.length = left.length + this.break + right.length;\n        return this;\n    }\n    updateHeight(oracle, offset = 0, force = false, measured) {\n        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;\n        if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);\n        else left.updateHeight(oracle, offset, force);\n        if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);\n        else right.updateHeight(oracle, rightStart, force);\n        if (rebalance) return this.balanced(left, right);\n        this.height = this.left.height + this.right.height;\n        this.outdated = false;\n        return this;\n    }\n    toString() {\n        return this.left + (this.break ? \" \" : \"-\") + this.right;\n    }\n}\nfunction mergeGaps(nodes, around) {\n    let before, after;\n    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\nconst relevantWidgetHeight = 5;\nclass NodeBuilder {\n    constructor(pos, oracle){\n        this.pos = pos;\n        this.oracle = oracle;\n        this.nodes = [];\n        this.lineStart = -1;\n        this.lineEnd = -1;\n        this.covering = null;\n        this.writtenTo = pos;\n    }\n    get isCovered() {\n        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n    }\n    span(_from, to) {\n        if (this.lineStart > -1) {\n            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];\n            if (last instanceof HeightMapText) last.length += end - this.pos;\n            else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));\n            this.writtenTo = end;\n            if (to > end) {\n                this.nodes.push(null);\n                this.writtenTo++;\n                this.lineStart = -1;\n            }\n        }\n        this.pos = to;\n    }\n    point(from, to, deco) {\n        if (from < to || deco.heightRelevant) {\n            let height = deco.widget ? deco.widget.estimatedHeight : 0;\n            let breaks = deco.widget ? deco.widget.lineBreaks : 0;\n            if (height < 0) height = this.oracle.lineHeight;\n            let len = to - from;\n            if (deco.block) {\n                this.addBlock(new HeightMapBlock(len, height, deco));\n            } else if (len || breaks || height >= relevantWidgetHeight) {\n                this.addLineDeco(height, breaks, len);\n            }\n        } else if (to > from) {\n            this.span(from, to);\n        }\n        if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\n    }\n    enterLine() {\n        if (this.lineStart > -1) return;\n        let { from, to } = this.oracle.doc.lineAt(this.pos);\n        this.lineStart = from;\n        this.lineEnd = to;\n        if (this.writtenTo < from) {\n            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));\n            this.nodes.push(null);\n        }\n        if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));\n        this.writtenTo = this.pos;\n    }\n    blankContent(from, to) {\n        let gap = new HeightMapGap(to - from);\n        if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4 /* Flag.SingleLine */ ;\n        return gap;\n    }\n    ensureLine() {\n        this.enterLine();\n        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n        if (last instanceof HeightMapText) return last;\n        let line = new HeightMapText(0, -1);\n        this.nodes.push(line);\n        return line;\n    }\n    addBlock(block) {\n        this.enterLine();\n        let deco = block.deco;\n        if (deco && deco.startSide > 0 && !this.isCovered) this.ensureLine();\n        this.nodes.push(block);\n        this.writtenTo = this.pos = this.pos + block.length;\n        if (deco && deco.endSide > 0) this.covering = block;\n    }\n    addLineDeco(height, breaks, length) {\n        let line = this.ensureLine();\n        line.length += length;\n        line.collapsed += length;\n        line.widgetHeight = Math.max(line.widgetHeight, height);\n        line.breaks += breaks;\n        this.writtenTo = this.pos = this.pos + length;\n    }\n    finish(from) {\n        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));\n        else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n        let pos = from;\n        for (let node of this.nodes){\n            if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);\n            pos += node ? node.length : 1;\n        }\n        return this.nodes;\n    }\n    // Always called with a region that on both sides either stretches\n    // to a line break or the end of the document.\n    // The returned array uses null to indicate line breaks, but never\n    // starts or ends in a line break, or has multiple line breaks next\n    // to each other.\n    static build(oracle, decorations, from, to) {\n        let builder = new NodeBuilder(from, oracle);\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(decorations, from, to, builder, 0);\n        return builder.finish(from);\n    }\n}\nfunction heightRelevantDecoChanges(a, b, diff) {\n    let comp = new DecorationComparator;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.compare(a, b, diff, comp, 0);\n    return comp.changes;\n}\nclass DecorationComparator {\n    constructor(){\n        this.changes = [];\n    }\n    compareRange() {}\n    comparePoint(from, to, a, b) {\n        if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);\n    }\n}\nfunction visiblePixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    let doc = dom.ownerDocument, win = doc.defaultView || window;\n    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);\n    let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);\n    for(let parent = dom.parentNode; parent && parent != doc.body;){\n        if (parent.nodeType == 1) {\n            let elt = parent;\n            let style = window.getComputedStyle(elt);\n            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != \"visible\") {\n                let parentRect = elt.getBoundingClientRect();\n                left = Math.max(left, parentRect.left);\n                right = Math.min(right, parentRect.right);\n                top = Math.max(top, parentRect.top);\n                bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);\n            }\n            parent = style.position == \"absolute\" || style.position == \"fixed\" ? elt.offsetParent : elt.parentNode;\n        } else if (parent.nodeType == 11) {\n            parent = parent.host;\n        } else {\n            break;\n        }\n    }\n    return {\n        left: left - rect.left,\n        right: Math.max(left, right) - rect.left,\n        top: top - (rect.top + paddingTop),\n        bottom: Math.max(top, bottom) - (rect.top + paddingTop)\n    };\n}\nfunction inWindow(elt) {\n    let rect = elt.getBoundingClientRect(), win = elt.ownerDocument.defaultView || window;\n    return rect.left < win.innerWidth && rect.right > 0 && rect.top < win.innerHeight && rect.bottom > 0;\n}\nfunction fullPixelRange(dom, paddingTop) {\n    let rect = dom.getBoundingClientRect();\n    return {\n        left: 0,\n        right: rect.right - rect.left,\n        top: paddingTop,\n        bottom: rect.bottom - (rect.top + paddingTop)\n    };\n}\n// Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\nclass LineGap {\n    constructor(from, to, size, displaySize){\n        this.from = from;\n        this.to = to;\n        this.size = size;\n        this.displaySize = displaySize;\n    }\n    static same(a, b) {\n        if (a.length != b.length) return false;\n        for(let i = 0; i < a.length; i++){\n            let gA = a[i], gB = b[i];\n            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;\n        }\n        return true;\n    }\n    draw(viewState, wrapping) {\n        return Decoration.replace({\n            widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)\n        }).range(this.from, this.to);\n    }\n}\nclass LineGapWidget extends WidgetType {\n    constructor(size, vertical){\n        super();\n        this.size = size;\n        this.vertical = vertical;\n    }\n    eq(other) {\n        return other.size == this.size && other.vertical == this.vertical;\n    }\n    toDOM() {\n        let elt = document.createElement(\"div\");\n        if (this.vertical) {\n            elt.style.height = this.size + \"px\";\n        } else {\n            elt.style.width = this.size + \"px\";\n            elt.style.height = \"2px\";\n            elt.style.display = \"inline-block\";\n        }\n        return elt;\n    }\n    get estimatedHeight() {\n        return this.vertical ? this.size : -1;\n    }\n}\nclass ViewState {\n    constructor(state){\n        this.state = state;\n        // These are contentDOM-local coordinates\n        this.pixelViewport = {\n            left: 0,\n            right: window.innerWidth,\n            top: 0,\n            bottom: 0\n        };\n        this.inView = true;\n        this.paddingTop = 0; // Padding above the document, scaled\n        this.paddingBottom = 0; // Padding below the document, scaled\n        this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width\n        this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height\n        this.editorHeight = 0; // scrollDOM.clientHeight, unscaled\n        this.editorWidth = 0; // scrollDOM.clientWidth, unscaled\n        this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled\n        this.scrolledToBottom = false;\n        // The CSS-transformation scale of the editor (transformed size /\n        // concrete size)\n        this.scaleX = 1;\n        this.scaleY = 1;\n        // The vertical position (document-relative) to which to anchor the\n        // scroll position. -1 means anchor to the end of the document.\n        this.scrollAnchorPos = 0;\n        // The height at the anchor position. Set by the DOM update phase.\n        // -1 means no height available.\n        this.scrollAnchorHeight = -1;\n        // See VP.MaxDOMHeight\n        this.scaler = IdScaler;\n        this.scrollTarget = null;\n        // Briefly set to true when printing, to disable viewport limiting\n        this.printing = false;\n        // Flag set when editor content was redrawn, so that the next\n        // measure stage knows it must read DOM layout\n        this.mustMeasureContent = true;\n        this.defaultTextDirection = Direction.LTR;\n        this.visibleRanges = [];\n        // Cursor 'assoc' is only significant when the cursor is on a line\n        // wrap point, where it must stick to the character that it is\n        // associated with. Since browsers don't provide a reasonable\n        // interface to set or query this, when a selection is set that\n        // might cause this to be significant, this flag is set. The next\n        // measure phase will check whether the cursor is on a line-wrapping\n        // boundary and, if so, reset it to make sure it is positioned in\n        // the right place.\n        this.mustEnforceCursorAssoc = false;\n        let guessWrapping = state.facet(contentAttributes).some((v)=>typeof v != \"function\" && v.class == \"cm-lineWrapping\");\n        this.heightOracle = new HeightOracle(guessWrapping);\n        this.stateDeco = state.facet(decorations).filter((d)=>typeof d != \"function\");\n        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle.setDoc(state.doc), [\n            new ChangedRange(0, 0, 0, state.doc.length)\n        ]);\n        for(let i = 0; i < 2; i++){\n            this.viewport = this.getViewport(0, null);\n            if (!this.updateForViewport()) break;\n        }\n        this.updateViewportLines();\n        this.lineGaps = this.ensureLineGaps([]);\n        this.lineGapDeco = Decoration.set(this.lineGaps.map((gap)=>gap.draw(this, false)));\n        this.computeVisibleRanges();\n    }\n    updateForViewport() {\n        let viewports = [\n            this.viewport\n        ], { main } = this.state.selection;\n        for(let i = 0; i <= 1; i++){\n            let pos = i ? main.head : main.anchor;\n            if (!viewports.some(({ from, to })=>pos >= from && pos <= to)) {\n                let { from, to } = this.lineBlockAt(pos);\n                viewports.push(new Viewport(from, to));\n            }\n        }\n        this.viewports = viewports.sort((a, b)=>a.from - b.from);\n        return this.updateScaler();\n    }\n    updateScaler() {\n        let scaler = this.scaler;\n        this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */  ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);\n        return scaler.eq(this.scaler) ? 0 : 2 /* UpdateFlag.Height */ ;\n    }\n    updateViewportLines() {\n        this.viewportLines = [];\n        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (block)=>{\n            this.viewportLines.push(scaleBlock(block, this.scaler));\n        });\n    }\n    update(update, scrollTarget = null) {\n        this.state = update.state;\n        let prevDeco = this.stateDeco;\n        this.stateDeco = this.state.facet(decorations).filter((d)=>typeof d != \"function\");\n        let contentChanges = update.changedRanges;\n        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.ChangeSet.empty(this.state.doc.length)));\n        let prevHeight = this.heightMap.height;\n        let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);\n        clearHeightChangeFlag();\n        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n        if (this.heightMap.height != prevHeight || heightChangeFlag) update.flags |= 2 /* UpdateFlag.Height */ ;\n        if (scrollAnchor) {\n            this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);\n            this.scrollAnchorHeight = scrollAnchor.top;\n        } else {\n            this.scrollAnchorPos = -1;\n            this.scrollAnchorHeight = this.heightMap.height;\n        }\n        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;\n        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);\n        let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;\n        this.viewport = viewport;\n        update.flags |= this.updateForViewport();\n        if (viewportChange || !update.changes.empty || update.flags & 2 /* UpdateFlag.Height */ ) this.updateViewportLines();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */  << 1) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));\n        update.flags |= this.computeVisibleRanges(update.changes);\n        if (scrollTarget) this.scrollTarget = scrollTarget;\n        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden)) this.mustEnforceCursorAssoc = true;\n    }\n    measure(view) {\n        let dom = view.contentDOM, style = window.getComputedStyle(dom);\n        let oracle = this.heightOracle;\n        let whiteSpace = style.whiteSpace;\n        this.defaultTextDirection = style.direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);\n        let domRect = dom.getBoundingClientRect();\n        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;\n        this.contentDOMHeight = domRect.height;\n        this.mustMeasureContent = false;\n        let result = 0, bias = 0;\n        if (domRect.width && domRect.height) {\n            let { scaleX, scaleY } = getScale(dom, domRect);\n            if (scaleX > .005 && Math.abs(this.scaleX - scaleX) > .005 || scaleY > .005 && Math.abs(this.scaleY - scaleY) > .005) {\n                this.scaleX = scaleX;\n                this.scaleY = scaleY;\n                result |= 16 /* UpdateFlag.Geometry */ ;\n                refresh = measureContent = true;\n            }\n        }\n        // Vertical padding\n        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;\n        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;\n        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {\n            this.paddingTop = paddingTop;\n            this.paddingBottom = paddingBottom;\n            result |= 16 /* UpdateFlag.Geometry */  | 2 /* UpdateFlag.Height */ ;\n        }\n        if (this.editorWidth != view.scrollDOM.clientWidth) {\n            if (oracle.lineWrapping) measureContent = true;\n            this.editorWidth = view.scrollDOM.clientWidth;\n            result |= 16 /* UpdateFlag.Geometry */ ;\n        }\n        let scrollTop = view.scrollDOM.scrollTop * this.scaleY;\n        if (this.scrollTop != scrollTop) {\n            this.scrollAnchorHeight = -1;\n            this.scrollTop = scrollTop;\n        }\n        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);\n        // Pixel viewport\n        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);\n        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n        this.pixelViewport = pixelViewport;\n        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n        if (inView != this.inView) {\n            this.inView = inView;\n            if (inView) measureContent = true;\n        }\n        if (!this.inView && !this.scrollTarget && !inWindow(view.dom)) return 0;\n        let contentWidth = domRect.width;\n        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {\n            this.contentDOMWidth = domRect.width;\n            this.editorHeight = view.scrollDOM.clientHeight;\n            result |= 16 /* UpdateFlag.Geometry */ ;\n        }\n        if (measureContent) {\n            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);\n            if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;\n            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {\n                let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();\n                refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);\n                if (refresh) {\n                    view.docView.minWidth = 0;\n                    result |= 16 /* UpdateFlag.Geometry */ ;\n                }\n            }\n            if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);\n            else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);\n            clearHeightChangeFlag();\n            for (let vp of this.viewports){\n                let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);\n                this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.empty, this.heightOracle, [\n                    new ChangedRange(0, 0, 0, view.state.doc.length)\n                ]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));\n            }\n            if (heightChangeFlag) result |= 2 /* UpdateFlag.Height */ ;\n        }\n        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);\n        if (viewportChange) {\n            if (result & 2 /* UpdateFlag.Height */ ) result |= this.updateScaler();\n            this.viewport = this.getViewport(bias, this.scrollTarget);\n            result |= this.updateForViewport();\n        }\n        if (result & 2 /* UpdateFlag.Height */  || viewportChange) this.updateViewportLines();\n        if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 /* LG.Margin */  << 1) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));\n        result |= this.computeVisibleRanges();\n        if (this.mustEnforceCursorAssoc) {\n            this.mustEnforceCursorAssoc = false;\n            // This is done in the read stage, because moving the selection\n            // to a line end is going to trigger a layout anyway, so it\n            // can't be a pure write. It should be rare that it does any\n            // writing.\n            view.docView.enforceCursorAssoc();\n        }\n        return result;\n    }\n    get visibleTop() {\n        return this.scaler.fromDOM(this.pixelViewport.top);\n    }\n    get visibleBottom() {\n        return this.scaler.fromDOM(this.pixelViewport.bottom);\n    }\n    getViewport(bias, scrollTarget) {\n        // This will divide VP.Margin between the top and the\n        // bottom, depending on the bias (the change in viewport position\n        // since the last update). It'll hold a number between 0 and 1\n        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */  / 2));\n        let map = this.heightMap, oracle = this.heightOracle;\n        let { visibleTop, visibleBottom } = this;\n        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */ , QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */ , QueryType.ByHeight, oracle, 0, 0).to);\n        // If scrollTarget is given, make sure the viewport includes that position\n        if (scrollTarget) {\n            let { head } = scrollTarget.range;\n            if (head < viewport.from || head > viewport.to) {\n                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);\n                let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;\n                if (scrollTarget.y == \"center\") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;\n                else if (scrollTarget.y == \"start\" || scrollTarget.y == \"nearest\" && head < viewport.from) topPos = block.top;\n                else topPos = block.bottom - viewHeight;\n                viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */  / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */  / 2, QueryType.ByHeight, oracle, 0, 0).to);\n            }\n        }\n        return viewport;\n    }\n    mapViewport(viewport, changes) {\n        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);\n        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);\n    }\n    // Checks if a given viewport covers the visible part of the\n    // document and not too much beyond that.\n    viewportIsAppropriate({ from, to }, bias = 0) {\n        if (!this.inView) return true;\n        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);\n        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);\n        let { visibleTop, visibleBottom } = this;\n        return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */ , Math.min(-bias, 250 /* VP.MaxCoverMargin */ ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */ , Math.min(bias, 250 /* VP.MaxCoverMargin */ ))) && top > visibleTop - 2 * 1000 /* VP.Margin */  && bottom < visibleBottom + 2 * 1000 /* VP.Margin */ ;\n    }\n    mapLineGaps(gaps, changes) {\n        if (!gaps.length || changes.empty) return gaps;\n        let mapped = [];\n        for (let gap of gaps)if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));\n        return mapped;\n    }\n    // Computes positions in the viewport where the start or end of a\n    // line should be hidden, trying to reuse existing line gaps when\n    // appropriate to avoid unneccesary redraws.\n    // Uses crude character-counting for the positioning and sizing,\n    // since actual DOM coordinates aren't always available and\n    // predictable. Relies on generous margins (see LG.Margin) to hide\n    // the artifacts this might produce from the user.\n    ensureLineGaps(current, mayMeasure) {\n        let wrapping = this.heightOracle.lineWrapping;\n        let margin = wrapping ? 10000 /* LG.MarginWrap */  : 2000 /* LG.Margin */ , halfMargin = margin >> 1, doubleMargin = margin << 1;\n        // The non-wrapping logic won't work at all in predominantly right-to-left text.\n        if (this.defaultTextDirection != Direction.LTR && !wrapping) return [];\n        let gaps = [];\n        let addGap = (from, to, line, structure)=>{\n            if (to - from < halfMargin) return;\n            let sel = this.state.selection.main, avoid = [\n                sel.from\n            ];\n            if (!sel.empty) avoid.push(sel.to);\n            for (let pos of avoid){\n                if (pos > from && pos < to) {\n                    addGap(from, pos - 10 /* LG.SelectionMargin */ , line, structure);\n                    addGap(pos + 10 /* LG.SelectionMargin */ , to, line, structure);\n                    return;\n                }\n            }\n            let gap = find(current, (gap)=>gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin && !avoid.some((pos)=>gap.from < pos && gap.to > pos));\n            if (!gap) {\n                // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping\n                if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r)=>r.from <= to && r.to >= to)) {\n                    let lineStart = mayMeasure.moveToLineBoundary(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(to), false, true).head;\n                    if (lineStart > from) to = lineStart;\n                }\n                let size = this.gapSize(line, from, to, structure);\n                let displaySize = wrapping || size < 2000000 /* VP.MaxHorizGap */  ? size : 2000000 /* VP.MaxHorizGap */ ;\n                gap = new LineGap(from, to, size, displaySize);\n            }\n            gaps.push(gap);\n        };\n        let checkLine = (line)=>{\n            if (line.length < doubleMargin || line.type != BlockType.Text) return;\n            let structure = lineStructure(line.from, line.to, this.stateDeco);\n            if (structure.total < doubleMargin) return;\n            let target = this.scrollTarget ? this.scrollTarget.range.head : null;\n            let viewFrom, viewTo;\n            if (wrapping) {\n                let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;\n                let top, bot;\n                if (target != null) {\n                    let targetFrac = findFraction(structure, target);\n                    let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;\n                    top = targetFrac - spaceFrac;\n                    bot = targetFrac + spaceFrac;\n                } else {\n                    top = (this.visibleTop - line.top - marginHeight) / line.height;\n                    bot = (this.visibleBottom - line.top + marginHeight) / line.height;\n                }\n                viewFrom = findPosition(structure, top);\n                viewTo = findPosition(structure, bot);\n            } else {\n                let totalWidth = structure.total * this.heightOracle.charWidth;\n                let marginWidth = margin * this.heightOracle.charWidth;\n                let horizOffset = 0;\n                if (totalWidth > 2000000 /* VP.MaxHorizGap */ ) for (let old of current){\n                    if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left) horizOffset = old.size - old.displaySize;\n                }\n                let pxLeft = this.pixelViewport.left + horizOffset, pxRight = this.pixelViewport.right + horizOffset;\n                let left, right;\n                if (target != null) {\n                    let targetFrac = findFraction(structure, target);\n                    let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;\n                    left = targetFrac - spaceFrac;\n                    right = targetFrac + spaceFrac;\n                } else {\n                    left = (pxLeft - marginWidth) / totalWidth;\n                    right = (pxRight + marginWidth) / totalWidth;\n                }\n                viewFrom = findPosition(structure, left);\n                viewTo = findPosition(structure, right);\n            }\n            if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure);\n            if (viewTo < line.to) addGap(viewTo, line.to, line, structure);\n        };\n        for (let line of this.viewportLines){\n            if (Array.isArray(line.type)) line.type.forEach(checkLine);\n            else checkLine(line);\n        }\n        return gaps;\n    }\n    gapSize(line, from, to, structure) {\n        let fraction = findFraction(structure, to) - findFraction(structure, from);\n        if (this.heightOracle.lineWrapping) {\n            return line.height * fraction;\n        } else {\n            return structure.total * this.heightOracle.charWidth * fraction;\n        }\n    }\n    updateLineGaps(gaps) {\n        if (!LineGap.same(gaps, this.lineGaps)) {\n            this.lineGaps = gaps;\n            this.lineGapDeco = Decoration.set(gaps.map((gap)=>gap.draw(this, this.heightOracle.lineWrapping)));\n        }\n    }\n    computeVisibleRanges(changes) {\n        let deco = this.stateDeco;\n        if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);\n        let ranges = [];\n        _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n            span (from, to) {\n                ranges.push({\n                    from,\n                    to\n                });\n            },\n            point () {}\n        }, 20);\n        let changed = 0;\n        if (ranges.length != this.visibleRanges.length) {\n            changed = 8 /* UpdateFlag.ViewportMoved */  | 4 /* UpdateFlag.Viewport */ ;\n        } else {\n            for(let i = 0; i < ranges.length && !(changed & 8 /* UpdateFlag.ViewportMoved */ ); i++){\n                let old = this.visibleRanges[i], nw = ranges[i];\n                if (old.from != nw.from || old.to != nw.to) {\n                    changed |= 4 /* UpdateFlag.Viewport */ ;\n                    if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to)) changed |= 8 /* UpdateFlag.ViewportMoved */ ;\n                }\n            }\n        }\n        this.visibleRanges = ranges;\n        return changed;\n    }\n    lineBlockAt(pos) {\n        return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b)=>b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);\n    }\n    lineBlockAtHeight(height) {\n        return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((l)=>l.top <= height && l.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);\n    }\n    scrollAnchorAt(scrollTop) {\n        let block = this.lineBlockAtHeight(scrollTop + 8);\n        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];\n    }\n    elementAtHeight(height) {\n        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);\n    }\n    get docHeight() {\n        return this.scaler.toDOM(this.heightMap.height);\n    }\n    get contentHeight() {\n        return this.docHeight + this.paddingTop + this.paddingBottom;\n    }\n}\nclass Viewport {\n    constructor(from, to){\n        this.from = from;\n        this.to = to;\n    }\n}\nfunction lineStructure(from, to, stateDeco) {\n    let ranges = [], pos = from, total = 0;\n    _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.spans(stateDeco, from, to, {\n        span () {},\n        point (from, to) {\n            if (from > pos) {\n                ranges.push({\n                    from: pos,\n                    to: from\n                });\n                total += from - pos;\n            }\n            pos = to;\n        }\n    }, 20); // We're only interested in collapsed ranges of a significant size\n    if (pos < to) {\n        ranges.push({\n            from: pos,\n            to\n        });\n        total += to - pos;\n    }\n    return {\n        total,\n        ranges\n    };\n}\nfunction findPosition({ total, ranges }, ratio) {\n    if (ratio <= 0) return ranges[0].from;\n    if (ratio >= 1) return ranges[ranges.length - 1].to;\n    let dist = Math.floor(total * ratio);\n    for(let i = 0;; i++){\n        let { from, to } = ranges[i], size = to - from;\n        if (dist <= size) return from + dist;\n        dist -= size;\n    }\n}\nfunction findFraction(structure, pos) {\n    let counted = 0;\n    for (let { from, to } of structure.ranges){\n        if (pos <= to) {\n            counted += pos - from;\n            break;\n        }\n        counted += to - from;\n    }\n    return counted / structure.total;\n}\nfunction find(array, f) {\n    for (let val of array)if (f(val)) return val;\n    return undefined;\n}\n// Don't scale when the document height is within the range of what\n// the DOM can handle.\nconst IdScaler = {\n    toDOM (n) {\n        return n;\n    },\n    fromDOM (n) {\n        return n;\n    },\n    scale: 1,\n    eq (other) {\n        return other == this;\n    }\n};\n// When the height is too big (> VP.MaxDOMHeight), scale down the\n// regions outside the viewports so that the total height is\n// VP.MaxDOMHeight.\nclass BigScaler {\n    constructor(oracle, heightMap, viewports){\n        let vpHeight = 0, base = 0, domBase = 0;\n        this.viewports = viewports.map(({ from, to })=>{\n            let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;\n            let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;\n            vpHeight += bottom - top;\n            return {\n                from,\n                to,\n                top,\n                bottom,\n                domTop: 0,\n                domBottom: 0\n            };\n        });\n        this.scale = (7000000 /* VP.MaxDOMHeight */  - vpHeight) / (heightMap.height - vpHeight);\n        for (let obj of this.viewports){\n            obj.domTop = domBase + (obj.top - base) * this.scale;\n            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);\n            base = obj.bottom;\n        }\n    }\n    toDOM(n) {\n        for(let i = 0, base = 0, domBase = 0;; i++){\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.top) return domBase + (n - base) * this.scale;\n            if (n <= vp.bottom) return vp.domTop + (n - vp.top);\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n    fromDOM(n) {\n        for(let i = 0, base = 0, domBase = 0;; i++){\n            let vp = i < this.viewports.length ? this.viewports[i] : null;\n            if (!vp || n < vp.domTop) return base + (n - domBase) / this.scale;\n            if (n <= vp.domBottom) return vp.top + (n - vp.domTop);\n            base = vp.bottom;\n            domBase = vp.domBottom;\n        }\n    }\n    eq(other) {\n        if (!(other instanceof BigScaler)) return false;\n        return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i)=>vp.from == other.viewports[i].from && vp.to == other.viewports[i].to);\n    }\n}\nfunction scaleBlock(block, scaler) {\n    if (scaler.scale == 1) return block;\n    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);\n    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map((b)=>scaleBlock(b, scaler)) : block._content);\n}\nconst theme = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (strs)=>strs.join(\" \")\n});\nconst darkTheme = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.indexOf(true) > -1\n});\nconst baseThemeID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseLightID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(), baseDarkID = /*@__PURE__*/ style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\nconst lightDarkIDs = {\n    \"&light\": \".\" + baseLightID,\n    \"&dark\": \".\" + baseDarkID\n};\nfunction buildTheme(main, spec, scopes) {\n    return new style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule(spec, {\n        finish (sel) {\n            return /&/.test(sel) ? sel.replace(/&\\w*/, (m)=>{\n                if (m == \"&\") return main;\n                if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`);\n                return scopes[m];\n            }) : main + \" \" + sel;\n        }\n    });\n}\nconst baseTheme$1 = /*@__PURE__*/ buildTheme(\".\" + baseThemeID, {\n    \"&\": {\n        position: \"relative !important\",\n        boxSizing: \"border-box\",\n        \"&.cm-focused\": {\n            // Provide a simple default outline to make sure a focused\n            // editor is visually distinct. Can't leave the default behavior\n            // because that will apply to the content element, which is\n            // inside the scrollable container and doesn't include the\n            // gutters. We also can't use an 'auto' outline, since those\n            // are, for some reason, drawn behind the element content, which\n            // will cause things like the active line background to cover\n            // the outline (#297).\n            outline: \"1px dotted #212121\"\n        },\n        display: \"flex !important\",\n        flexDirection: \"column\"\n    },\n    \".cm-scroller\": {\n        display: \"flex !important\",\n        alignItems: \"flex-start !important\",\n        fontFamily: \"monospace\",\n        lineHeight: 1.4,\n        height: \"100%\",\n        overflowX: \"auto\",\n        position: \"relative\",\n        zIndex: 0,\n        overflowAnchor: \"none\"\n    },\n    \".cm-content\": {\n        margin: 0,\n        flexGrow: 2,\n        flexShrink: 0,\n        display: \"block\",\n        whiteSpace: \"pre\",\n        wordWrap: \"normal\",\n        boxSizing: \"border-box\",\n        minHeight: \"100%\",\n        padding: \"4px 0\",\n        outline: \"none\",\n        \"&[contenteditable=true]\": {\n            WebkitUserModify: \"read-write-plaintext-only\"\n        }\n    },\n    \".cm-lineWrapping\": {\n        whiteSpace_fallback: \"pre-wrap\",\n        whiteSpace: \"break-spaces\",\n        wordBreak: \"break-word\",\n        overflowWrap: \"anywhere\",\n        flexShrink: 1\n    },\n    \"&light .cm-content\": {\n        caretColor: \"black\"\n    },\n    \"&dark .cm-content\": {\n        caretColor: \"white\"\n    },\n    \".cm-line\": {\n        display: \"block\",\n        padding: \"0 2px 0 6px\"\n    },\n    \".cm-layer\": {\n        position: \"absolute\",\n        left: 0,\n        top: 0,\n        contain: \"size style\",\n        \"& > *\": {\n            position: \"absolute\"\n        }\n    },\n    \"&light .cm-selectionBackground\": {\n        background: \"#d9d9d9\"\n    },\n    \"&dark .cm-selectionBackground\": {\n        background: \"#222\"\n    },\n    \"&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n        background: \"#d7d4f0\"\n    },\n    \"&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n        background: \"#233\"\n    },\n    \".cm-cursorLayer\": {\n        pointerEvents: \"none\"\n    },\n    \"&.cm-focused > .cm-scroller > .cm-cursorLayer\": {\n        animation: \"steps(1) cm-blink 1.2s infinite\"\n    },\n    // Two animations defined so that we can switch between them to\n    // restart the animation without forcing another style\n    // recomputation.\n    \"@keyframes cm-blink\": {\n        \"0%\": {},\n        \"50%\": {\n            opacity: 0\n        },\n        \"100%\": {}\n    },\n    \"@keyframes cm-blink2\": {\n        \"0%\": {},\n        \"50%\": {\n            opacity: 0\n        },\n        \"100%\": {}\n    },\n    \".cm-cursor, .cm-dropCursor\": {\n        borderLeft: \"1.2px solid black\",\n        marginLeft: \"-0.6px\",\n        pointerEvents: \"none\"\n    },\n    \".cm-cursor\": {\n        display: \"none\"\n    },\n    \"&dark .cm-cursor\": {\n        borderLeftColor: \"#ddd\"\n    },\n    \".cm-dropCursor\": {\n        position: \"absolute\"\n    },\n    \"&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor\": {\n        display: \"block\"\n    },\n    \".cm-iso\": {\n        unicodeBidi: \"isolate\"\n    },\n    \".cm-announced\": {\n        position: \"fixed\",\n        top: \"-10000px\"\n    },\n    \"@media print\": {\n        \".cm-announced\": {\n            display: \"none\"\n        }\n    },\n    \"&light .cm-activeLine\": {\n        backgroundColor: \"#cceeff44\"\n    },\n    \"&dark .cm-activeLine\": {\n        backgroundColor: \"#99eeff33\"\n    },\n    \"&light .cm-specialChar\": {\n        color: \"red\"\n    },\n    \"&dark .cm-specialChar\": {\n        color: \"#f78\"\n    },\n    \".cm-gutters\": {\n        flexShrink: 0,\n        display: \"flex\",\n        height: \"100%\",\n        boxSizing: \"border-box\",\n        insetInlineStart: 0,\n        zIndex: 200\n    },\n    \"&light .cm-gutters\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"#6c6c6c\",\n        borderRight: \"1px solid #ddd\"\n    },\n    \"&dark .cm-gutters\": {\n        backgroundColor: \"#333338\",\n        color: \"#ccc\"\n    },\n    \".cm-gutter\": {\n        display: \"flex !important\",\n        flexDirection: \"column\",\n        flexShrink: 0,\n        boxSizing: \"border-box\",\n        minHeight: \"100%\",\n        overflow: \"hidden\"\n    },\n    \".cm-gutterElement\": {\n        boxSizing: \"border-box\"\n    },\n    \".cm-lineNumbers .cm-gutterElement\": {\n        padding: \"0 3px 0 5px\",\n        minWidth: \"20px\",\n        textAlign: \"right\",\n        whiteSpace: \"nowrap\"\n    },\n    \"&light .cm-activeLineGutter\": {\n        backgroundColor: \"#e2f2ff\"\n    },\n    \"&dark .cm-activeLineGutter\": {\n        backgroundColor: \"#222227\"\n    },\n    \".cm-panels\": {\n        boxSizing: \"border-box\",\n        position: \"sticky\",\n        left: 0,\n        right: 0,\n        zIndex: 300\n    },\n    \"&light .cm-panels\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"black\"\n    },\n    \"&light .cm-panels-top\": {\n        borderBottom: \"1px solid #ddd\"\n    },\n    \"&light .cm-panels-bottom\": {\n        borderTop: \"1px solid #ddd\"\n    },\n    \"&dark .cm-panels\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-tab\": {\n        display: \"inline-block\",\n        overflow: \"hidden\",\n        verticalAlign: \"bottom\"\n    },\n    \".cm-widgetBuffer\": {\n        verticalAlign: \"text-top\",\n        height: \"1em\",\n        width: 0,\n        display: \"inline\"\n    },\n    \".cm-placeholder\": {\n        color: \"#888\",\n        display: \"inline-block\",\n        verticalAlign: \"top\"\n    },\n    \".cm-highlightSpace\": {\n        backgroundImage: \"radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)\",\n        backgroundPosition: \"center\"\n    },\n    \".cm-highlightTab\": {\n        backgroundImage: `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"20\"><path stroke=\"%23888\" stroke-width=\"1\" fill=\"none\" d=\"M1 10H196L190 5M190 15L196 10M197 4L197 16\"/></svg>')`,\n        backgroundSize: \"auto 100%\",\n        backgroundPosition: \"right 90%\",\n        backgroundRepeat: \"no-repeat\"\n    },\n    \".cm-trailingSpace\": {\n        backgroundColor: \"#ff332255\"\n    },\n    \".cm-button\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        padding: \".2em 1em\",\n        borderRadius: \"1px\"\n    },\n    \"&light .cm-button\": {\n        backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n        }\n    },\n    \"&dark .cm-button\": {\n        backgroundImage: \"linear-gradient(#393939, #111)\",\n        border: \"1px solid #888\",\n        \"&:active\": {\n            backgroundImage: \"linear-gradient(#111, #333)\"\n        }\n    },\n    \".cm-textfield\": {\n        verticalAlign: \"middle\",\n        color: \"inherit\",\n        fontSize: \"70%\",\n        border: \"1px solid silver\",\n        padding: \".2em .5em\"\n    },\n    \"&light .cm-textfield\": {\n        backgroundColor: \"white\"\n    },\n    \"&dark .cm-textfield\": {\n        border: \"1px solid #555\",\n        backgroundColor: \"inherit\"\n    }\n}, lightDarkIDs);\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    subtree: true,\n    attributes: true,\n    characterDataOldValue: true\n};\n// IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\nconst useCharData = browser.ie && browser.ie_version <= 11;\nclass DOMObserver {\n    constructor(view){\n        this.view = view;\n        this.active = false;\n        this.editContext = null;\n        // The known selection. Kept in our own object, as opposed to just\n        // directly accessing the selection because:\n        //  - Safari doesn't report the right selection in shadow DOM\n        //  - Reading from the selection forces a DOM layout\n        //  - This way, we can ignore selectionchange events if we have\n        //    already seen the 'new' selection\n        this.selectionRange = new DOMSelectionState;\n        // Set when a selection change is detected, cleared on flush\n        this.selectionChanged = false;\n        this.delayedFlush = -1;\n        this.resizeTimeout = -1;\n        this.queue = [];\n        this.delayedAndroidKey = null;\n        this.flushingAndroidKey = -1;\n        this.lastChange = 0;\n        this.scrollTargets = [];\n        this.intersection = null;\n        this.resizeScroll = null;\n        this.intersecting = false;\n        this.gapIntersection = null;\n        this.gaps = [];\n        this.printQuery = null;\n        // Timeout for scheduling check of the parents that need scroll handlers\n        this.parentCheck = -1;\n        this.dom = view.contentDOM;\n        this.observer = new MutationObserver((mutations)=>{\n            for (let mut of mutations)this.queue.push(mut);\n            // IE11 will sometimes (on typing over a selection or\n            // backspacing out a single character text node) call the\n            // observer callback before actually updating the DOM.\n            //\n            // Unrelatedly, iOS Safari will, when ending a composition,\n            // sometimes first clear it, deliver the mutations, and then\n            // reinsert the finished text. CodeMirror's handling of the\n            // deletion will prevent the reinsertion from happening,\n            // breaking composition.\n            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m)=>m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();\n            else this.flush();\n        });\n        if (window.EditContext && view.constructor.EDIT_CONTEXT !== false && // Chrome <126 doesn't support inverted selections in edit context (#1392)\n        !(browser.chrome && browser.chrome_version < 126)) {\n            this.editContext = new EditContextManager(view);\n            if (view.state.facet(editable)) view.contentDOM.editContext = this.editContext.editContext;\n        }\n        if (useCharData) this.onCharData = (event)=>{\n            this.queue.push({\n                target: event.target,\n                type: \"characterData\",\n                oldValue: event.prevValue\n            });\n            this.flushSoon();\n        };\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n        this.onResize = this.onResize.bind(this);\n        this.onPrint = this.onPrint.bind(this);\n        this.onScroll = this.onScroll.bind(this);\n        if (window.matchMedia) this.printQuery = window.matchMedia(\"print\");\n        if (typeof ResizeObserver == \"function\") {\n            this.resizeScroll = new ResizeObserver(()=>{\n                var _a;\n                if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75) this.onResize();\n            });\n            this.resizeScroll.observe(view.scrollDOM);\n        }\n        this.addWindowListeners(this.win = view.win);\n        this.start();\n        if (typeof IntersectionObserver == \"function\") {\n            this.intersection = new IntersectionObserver((entries)=>{\n                if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);\n                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {\n                    this.intersecting = !this.intersecting;\n                    if (this.intersecting != this.view.inView) this.onScrollChanged(document.createEvent(\"Event\"));\n                }\n            }, {\n                threshold: [\n                    0,\n                    .001\n                ]\n            });\n            this.intersection.observe(this.dom);\n            this.gapIntersection = new IntersectionObserver((entries)=>{\n                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) this.onScrollChanged(document.createEvent(\"Event\"));\n            }, {});\n        }\n        this.listenForScroll();\n        this.readSelectionRange();\n    }\n    onScrollChanged(e) {\n        this.view.inputState.runHandlers(\"scroll\", e);\n        if (this.intersecting) this.view.measure();\n    }\n    onScroll(e) {\n        if (this.intersecting) this.flush(false);\n        if (this.editContext) this.view.requestMeasure(this.editContext.measureReq);\n        this.onScrollChanged(e);\n    }\n    onResize() {\n        if (this.resizeTimeout < 0) this.resizeTimeout = setTimeout(()=>{\n            this.resizeTimeout = -1;\n            this.view.requestMeasure();\n        }, 50);\n    }\n    onPrint(event) {\n        if ((event.type == \"change\" || !event.type) && !event.matches) return;\n        this.view.viewState.printing = true;\n        this.view.measure();\n        setTimeout(()=>{\n            this.view.viewState.printing = false;\n            this.view.requestMeasure();\n        }, 500);\n    }\n    updateGaps(gaps) {\n        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i)=>g != gaps[i]))) {\n            this.gapIntersection.disconnect();\n            for (let gap of gaps)this.gapIntersection.observe(gap);\n            this.gaps = gaps;\n        }\n    }\n    onSelectionChange(event) {\n        let wasChanged = this.selectionChanged;\n        if (!this.readSelectionRange() || this.delayedAndroidKey) return;\n        let { view } = this, sel = this.selectionRange;\n        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel)) return;\n        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);\n        if (context && context.ignoreEvent(event)) {\n            if (!wasChanged) this.selectionChanged = false;\n            return;\n        }\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        // Chrome Android has a similar issue when backspacing out a\n        // selection (#645).\n        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)\n        sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();\n        else this.flush(false);\n    }\n    readSelectionRange() {\n        let { view } = this;\n        // The Selection object is broken in shadow roots in Safari. See\n        // https://github.com/codemirror/dev/issues/414\n        let selection = getSelection(view.root);\n        if (!selection) return false;\n        let range = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection) || selection;\n        if (!range || this.selectionRange.eq(range)) return false;\n        let local = hasSelection(this.dom, range);\n        // Detect the situation where the browser has, on focus, moved the\n        // selection to the start of the content element. Reset it to the\n        // position from the editor state.\n        if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {\n            this.view.inputState.lastFocusTime = 0;\n            view.docView.updateSelection();\n            return false;\n        }\n        this.selectionRange.setRange(range);\n        if (local) this.selectionChanged = true;\n        return true;\n    }\n    setSelectionRange(anchor, head) {\n        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);\n        this.selectionChanged = false;\n    }\n    clearSelectionRange() {\n        this.selectionRange.set(null, 0, null, 0);\n    }\n    listenForScroll() {\n        this.parentCheck = -1;\n        let i = 0, changed = null;\n        for(let dom = this.dom; dom;){\n            if (dom.nodeType == 1) {\n                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++;\n                else if (!changed) changed = this.scrollTargets.slice(0, i);\n                if (changed) changed.push(dom);\n                dom = dom.assignedSlot || dom.parentNode;\n            } else if (dom.nodeType == 11) {\n                dom = dom.host;\n            } else {\n                break;\n            }\n        }\n        if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i);\n        if (changed) {\n            for (let dom of this.scrollTargets)dom.removeEventListener(\"scroll\", this.onScroll);\n            for (let dom of this.scrollTargets = changed)dom.addEventListener(\"scroll\", this.onScroll);\n        }\n    }\n    ignore(f) {\n        if (!this.active) return f();\n        try {\n            this.stop();\n            return f();\n        } finally{\n            this.start();\n            this.clear();\n        }\n    }\n    start() {\n        if (this.active) return;\n        this.observer.observe(this.dom, observeOptions);\n        if (useCharData) this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.active = true;\n    }\n    stop() {\n        if (!this.active) return;\n        this.active = false;\n        this.observer.disconnect();\n        if (useCharData) this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    }\n    // Throw away any pending changes\n    clear() {\n        this.processRecords();\n        this.queue.length = 0;\n        this.selectionChanged = false;\n    }\n    // Chrome Android, especially in combination with GBoard, not only\n    // doesn't reliably fire regular key events, but also often\n    // surrounds the effect of enter or backspace with a bunch of\n    // composition events that, when interrupted, cause text duplication\n    // or other kinds of corruption. This hack makes the editor back off\n    // from handling DOM changes for a moment when such a key is\n    // detected (via beforeinput or keydown), and then tries to flush\n    // them or, if that has no effect, dispatches the given key.\n    delayAndroidKey(key, keyCode) {\n        var _a;\n        if (!this.delayedAndroidKey) {\n            let flush = ()=>{\n                let key = this.delayedAndroidKey;\n                if (key) {\n                    this.clearDelayedAndroidKey();\n                    this.view.inputState.lastKeyCode = key.keyCode;\n                    this.view.inputState.lastKeyTime = Date.now();\n                    let flushed = this.flush();\n                    if (!flushed && key.force) dispatchKey(this.dom, key.key, key.keyCode);\n                }\n            };\n            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);\n        }\n        // Since backspace beforeinput is sometimes signalled spuriously,\n        // Enter always takes precedence.\n        if (!this.delayedAndroidKey || key == \"Enter\") this.delayedAndroidKey = {\n            key,\n            keyCode,\n            // Only run the key handler when no changes are detected if\n            // this isn't coming right after another change, in which case\n            // it is probably part of a weird chain of updates, and should\n            // be ignored if it returns the DOM to its previous state.\n            force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)\n        };\n    }\n    clearDelayedAndroidKey() {\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\n        this.delayedAndroidKey = null;\n        this.flushingAndroidKey = -1;\n    }\n    flushSoon() {\n        if (this.delayedFlush < 0) this.delayedFlush = this.view.win.requestAnimationFrame(()=>{\n            this.delayedFlush = -1;\n            this.flush();\n        });\n    }\n    forceFlush() {\n        if (this.delayedFlush >= 0) {\n            this.view.win.cancelAnimationFrame(this.delayedFlush);\n            this.delayedFlush = -1;\n        }\n        this.flush();\n    }\n    pendingRecords() {\n        for (let mut of this.observer.takeRecords())this.queue.push(mut);\n        return this.queue;\n    }\n    processRecords() {\n        let records = this.pendingRecords();\n        if (records.length) this.queue = [];\n        let from = -1, to = -1, typeOver = false;\n        for (let record of records){\n            let range = this.readMutation(record);\n            if (!range) continue;\n            if (range.typeOver) typeOver = true;\n            if (from == -1) {\n                ({ from, to } = range);\n            } else {\n                from = Math.min(range.from, from);\n                to = Math.max(range.to, to);\n            }\n        }\n        return {\n            from,\n            to,\n            typeOver\n        };\n    }\n    readChange() {\n        let { from, to, typeOver } = this.processRecords();\n        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);\n        if (from < 0 && !newSel) return null;\n        if (from > -1) this.lastChange = Date.now();\n        this.view.inputState.lastFocusTime = 0;\n        this.selectionChanged = false;\n        let change = new DOMChange(this.view, from, to, typeOver);\n        this.view.docView.domChanged = {\n            newSel: change.newSel ? change.newSel.main : null\n        };\n        return change;\n    }\n    // Apply pending changes, if any\n    flush(readSelection = true) {\n        // Completely hold off flushing when pending keys are set—the code\n        // managing those will make sure processRecords is called and the\n        // view is resynchronized after\n        if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;\n        if (readSelection) this.readSelectionRange();\n        let domChange = this.readChange();\n        if (!domChange) {\n            this.view.requestMeasure();\n            return false;\n        }\n        let startState = this.view.state;\n        let handled = applyDOMChange(this.view, domChange);\n        // The view wasn't updated but DOM/selection changes were seen. Reset the view.\n        if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main))) this.view.update([]);\n        return handled;\n    }\n    readMutation(rec) {\n        let cView = this.view.docView.nearest(rec.target);\n        if (!cView || cView.ignoreMutation(rec)) return null;\n        cView.markDirty(rec.type == \"attributes\");\n        if (rec.type == \"attributes\") cView.flags |= 4 /* ViewFlag.AttrsDirty */ ;\n        if (rec.type == \"childList\") {\n            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n            return {\n                from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,\n                typeOver: false\n            };\n        } else if (rec.type == \"characterData\") {\n            return {\n                from: cView.posAtStart,\n                to: cView.posAtEnd,\n                typeOver: rec.target.nodeValue == rec.oldValue\n            };\n        } else {\n            return null;\n        }\n    }\n    setWindow(win) {\n        if (win != this.win) {\n            this.removeWindowListeners(this.win);\n            this.win = win;\n            this.addWindowListeners(this.win);\n        }\n    }\n    addWindowListeners(win) {\n        win.addEventListener(\"resize\", this.onResize);\n        if (this.printQuery) {\n            if (this.printQuery.addEventListener) this.printQuery.addEventListener(\"change\", this.onPrint);\n            else this.printQuery.addListener(this.onPrint);\n        } else win.addEventListener(\"beforeprint\", this.onPrint);\n        win.addEventListener(\"scroll\", this.onScroll);\n        win.document.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    removeWindowListeners(win) {\n        win.removeEventListener(\"scroll\", this.onScroll);\n        win.removeEventListener(\"resize\", this.onResize);\n        if (this.printQuery) {\n            if (this.printQuery.removeEventListener) this.printQuery.removeEventListener(\"change\", this.onPrint);\n            else this.printQuery.removeListener(this.onPrint);\n        } else win.removeEventListener(\"beforeprint\", this.onPrint);\n        win.document.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    update(update) {\n        if (this.editContext) {\n            this.editContext.update(update);\n            if (update.startState.facet(editable) != update.state.facet(editable)) update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;\n        }\n    }\n    destroy() {\n        var _a, _b, _c;\n        this.stop();\n        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();\n        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();\n        for (let dom of this.scrollTargets)dom.removeEventListener(\"scroll\", this.onScroll);\n        this.removeWindowListeners(this.win);\n        clearTimeout(this.parentCheck);\n        clearTimeout(this.resizeTimeout);\n        this.win.cancelAnimationFrame(this.delayedFlush);\n        this.win.cancelAnimationFrame(this.flushingAndroidKey);\n        if (this.editContext) {\n            this.view.contentDOM.editContext = null;\n            this.editContext.destroy();\n        }\n    }\n}\nfunction findChild(cView, dom, dir) {\n    while(dom){\n        let curView = ContentView.get(dom);\n        if (curView && curView.parent == cView) return curView;\n        let parent = dom.parentNode;\n        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n    }\n    return null;\n}\nfunction buildSelectionRangeFromRange(view, range) {\n    let anchorNode = range.startContainer, anchorOffset = range.startOffset;\n    let focusNode = range.endContainer, focusOffset = range.endOffset;\n    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [\n        focusNode,\n        focusOffset,\n        anchorNode,\n        anchorOffset\n    ];\n    return {\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset\n    };\n}\n// Used to work around a Safari Selection/shadow DOM bug (#414)\nfunction safariSelectionRangeHack(view, selection) {\n    if (selection.getComposedRanges) {\n        let range = selection.getComposedRanges(view.root)[0];\n        if (range) return buildSelectionRangeFromRange(view, range);\n    }\n    let found = null;\n    // Because Safari (at least in 2018-2021) doesn't provide regular\n    // access to the selection inside a shadowroot, we have to perform a\n    // ridiculous hack to get at it—using `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    view.contentDOM.addEventListener(\"beforeinput\", read, true);\n    view.dom.ownerDocument.execCommand(\"indent\");\n    view.contentDOM.removeEventListener(\"beforeinput\", read, true);\n    return found ? buildSelectionRangeFromRange(view, found) : null;\n}\nclass EditContextManager {\n    constructor(view){\n        // The document window for which the text in the context is\n        // maintained. For large documents, this may be smaller than the\n        // editor document. This window always includes the selection head.\n        this.from = 0;\n        this.to = 0;\n        // When applying a transaction, this is used to compare the change\n        // made to the context content to the change in the transaction in\n        // order to make the minimal changes to the context (since touching\n        // that sometimes breaks series of multiple edits made for a single\n        // user action on some Android keyboards)\n        this.pendingContextChange = null;\n        this.handlers = Object.create(null);\n        // Kludge to work around the fact that EditContext does not respond\n        // well to having its content updated during a composition (see #1472)\n        this.composing = null;\n        this.resetRange(view.state);\n        let context = this.editContext = new window.EditContext({\n            text: view.state.doc.sliceString(this.from, this.to),\n            selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),\n            selectionEnd: this.toContextPos(view.state.selection.main.head)\n        });\n        this.handlers.textupdate = (e)=>{\n            let main = view.state.selection.main, { anchor, head } = main;\n            let from = this.toEditorPos(e.updateRangeStart), to = this.toEditorPos(e.updateRangeEnd);\n            if (view.inputState.composing >= 0 && !this.composing) this.composing = {\n                contextBase: e.updateRangeStart,\n                editorBase: from,\n                drifted: false\n            };\n            let change = {\n                from,\n                to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of(e.text.split(\"\\n\"))\n            };\n            // If the window doesn't include the anchor, assume changes\n            // adjacent to a side go up to the anchor.\n            if (change.from == this.from && anchor < this.from) change.from = anchor;\n            else if (change.to == this.to && anchor > this.to) change.to = anchor;\n            // Edit contexts sometimes fire empty changes\n            if (change.from == change.to && !change.insert.length) {\n                let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd));\n                if (!newSel.main.eq(main)) view.dispatch({\n                    selection: newSel,\n                    userEvent: \"select\"\n                });\n                return;\n            }\n            if ((browser.mac || browser.android) && change.from == head - 1 && /^\\. ?$/.test(e.text) && view.contentDOM.getAttribute(\"autocorrect\") == \"off\") change = {\n                from,\n                to,\n                insert: _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Text.of([\n                    e.text.replace(\".\", \" \")\n                ])\n            };\n            this.pendingContextChange = change;\n            if (!view.state.readOnly) {\n                let newLen = this.to - this.from + (change.to - change.from + change.insert.length);\n                applyDOMChangeInner(view, change, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.single(this.toEditorPos(e.selectionStart, newLen), this.toEditorPos(e.selectionEnd, newLen)));\n            }\n            // If the transaction didn't flush our change, revert it so\n            // that the context is in sync with the editor state again.\n            if (this.pendingContextChange) {\n                this.revertPending(view.state);\n                this.setSelection(view.state);\n            }\n        };\n        this.handlers.characterboundsupdate = (e)=>{\n            let rects = [], prev = null;\n            for(let i = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i < end; i++){\n                let rect = view.coordsForChar(i);\n                prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect;\n                rects.push(prev);\n            }\n            context.updateCharacterBounds(e.rangeStart, rects);\n        };\n        this.handlers.textformatupdate = (e)=>{\n            let deco = [];\n            for (let format of e.getTextFormats()){\n                let lineStyle = format.underlineStyle, thickness = format.underlineThickness;\n                if (lineStyle != \"None\" && thickness != \"None\") {\n                    let from = this.toEditorPos(format.rangeStart), to = this.toEditorPos(format.rangeEnd);\n                    if (from < to) {\n                        let style = `text-decoration: underline ${lineStyle == \"Dashed\" ? \"dashed \" : lineStyle == \"Squiggle\" ? \"wavy \" : \"\"}${thickness == \"Thin\" ? 1 : 2}px`;\n                        deco.push(Decoration.mark({\n                            attributes: {\n                                style\n                            }\n                        }).range(from, to));\n                    }\n                }\n            }\n            view.dispatch({\n                effects: setEditContextFormatting.of(Decoration.set(deco))\n            });\n        };\n        this.handlers.compositionstart = ()=>{\n            if (view.inputState.composing < 0) {\n                view.inputState.composing = 0;\n                view.inputState.compositionFirstChange = true;\n            }\n        };\n        this.handlers.compositionend = ()=>{\n            view.inputState.composing = -1;\n            view.inputState.compositionFirstChange = null;\n            if (this.composing) {\n                let { drifted } = this.composing;\n                this.composing = null;\n                if (drifted) this.reset(view.state);\n            }\n        };\n        for(let event in this.handlers)context.addEventListener(event, this.handlers[event]);\n        this.measureReq = {\n            read: (view)=>{\n                this.editContext.updateControlBounds(view.contentDOM.getBoundingClientRect());\n                let sel = getSelection(view.root);\n                if (sel && sel.rangeCount) this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());\n            }\n        };\n    }\n    applyEdits(update) {\n        let off = 0, abort = false, pending = this.pendingContextChange;\n        update.changes.iterChanges((fromA, toA, _fromB, _toB, insert)=>{\n            if (abort) return;\n            let dLen = insert.length - (toA - fromA);\n            if (pending && toA >= pending.to) {\n                if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert)) {\n                    pending = this.pendingContextChange = null; // Match\n                    off += dLen;\n                    this.to += dLen;\n                    return;\n                } else {\n                    pending = null;\n                    this.revertPending(update.state);\n                }\n            }\n            fromA += off;\n            toA += off;\n            if (toA <= this.from) {\n                this.from += dLen;\n                this.to += dLen;\n            } else if (fromA < this.to) {\n                if (fromA < this.from || toA > this.to || this.to - this.from + insert.length > 30000 /* CxVp.MaxSize */ ) {\n                    abort = true;\n                    return;\n                }\n                this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert.toString());\n                this.to += dLen;\n            }\n            off += dLen;\n        });\n        if (pending && !abort) this.revertPending(update.state);\n        return !abort;\n    }\n    update(update) {\n        let reverted = this.pendingContextChange, startSel = update.startState.selection.main;\n        if (this.composing && (this.composing.drifted || !update.changes.touchesRange(startSel.from, startSel.to) && update.transactions.some((tr)=>!tr.isUserEvent(\"input.type\") && tr.changes.touchesRange(this.from, this.to)))) {\n            this.composing.drifted = true;\n            this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);\n        } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {\n            this.pendingContextChange = null;\n            this.reset(update.state);\n        } else if (update.docChanged || update.selectionSet || reverted) {\n            this.setSelection(update.state);\n        }\n        if (update.geometryChanged || update.docChanged || update.selectionSet) update.view.requestMeasure(this.measureReq);\n    }\n    resetRange(state) {\n        let { head } = state.selection.main;\n        this.from = Math.max(0, head - 10000 /* CxVp.Margin */ );\n        this.to = Math.min(state.doc.length, head + 10000 /* CxVp.Margin */ );\n    }\n    reset(state) {\n        this.resetRange(state);\n        this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));\n        this.setSelection(state);\n    }\n    revertPending(state) {\n        let pending = this.pendingContextChange;\n        this.pendingContextChange = null;\n        this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));\n    }\n    setSelection(state) {\n        let { main } = state.selection;\n        let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));\n        let end = this.toContextPos(main.head);\n        if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end) this.editContext.updateSelection(start, end);\n    }\n    rangeIsValid(state) {\n        let { head } = state.selection.main;\n        return !(this.from > 0 && head - this.from < 500 /* CxVp.MinMargin */  || this.to < state.doc.length && this.to - head < 500 /* CxVp.MinMargin */  || this.to - this.from > 10000 /* CxVp.Margin */  * 3);\n    }\n    toEditorPos(contextPos, clipLen = this.to - this.from) {\n        contextPos = Math.min(contextPos, clipLen);\n        let c = this.composing;\n        return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;\n    }\n    toContextPos(editorPos) {\n        let c = this.composing;\n        return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;\n    }\n    destroy() {\n        for(let event in this.handlers)this.editContext.removeEventListener(event, this.handlers[event]);\n    }\n}\n// The editor's update state machine looks something like this:\n//\n//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle\n//                                         ↑      ↓\n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n/**\nAn editor view represents the editor's user interface. It holds\nthe editable DOM surface, and possibly other elements such as the\nline number gutter. It handles events and dispatches state\ntransactions for editing actions.\n*/ class EditorView {\n    /**\n    The current editor state.\n    */ get state() {\n        return this.viewState.state;\n    }\n    /**\n    To be able to display large documents without consuming too much\n    memory or overloading the browser, CodeMirror only draws the\n    code that is visible (plus a margin around it) to the DOM. This\n    property tells you the extent of the current drawn viewport, in\n    document positions.\n    */ get viewport() {\n        return this.viewState.viewport;\n    }\n    /**\n    When there are, for example, large collapsed ranges in the\n    viewport, its size can be a lot bigger than the actual visible\n    content. Thus, if you are doing something like styling the\n    content in the viewport, it is preferable to only do so for\n    these ranges, which are the subset of the viewport that is\n    actually drawn.\n    */ get visibleRanges() {\n        return this.viewState.visibleRanges;\n    }\n    /**\n    Returns false when the editor is entirely scrolled out of view\n    or otherwise hidden.\n    */ get inView() {\n        return this.viewState.inView;\n    }\n    /**\n    Indicates whether the user is currently composing text via\n    [IME](https://en.wikipedia.org/wiki/Input_method), and at least\n    one change has been made in the current composition.\n    */ get composing() {\n        return this.inputState.composing > 0;\n    }\n    /**\n    Indicates whether the user is currently in composing state. Note\n    that on some platforms, like Android, this will be the case a\n    lot, since just putting the cursor on a word starts a\n    composition there.\n    */ get compositionStarted() {\n        return this.inputState.composing >= 0;\n    }\n    /**\n    The document or shadow root that the view lives in.\n    */ get root() {\n        return this._root;\n    }\n    /**\n    @internal\n    */ get win() {\n        return this.dom.ownerDocument.defaultView || window;\n    }\n    /**\n    Construct a new view. You'll want to either provide a `parent`\n    option, or put `view.dom` into your document after creating a\n    view, so that the user can see the editor.\n    */ constructor(config = {}){\n        var _a;\n        this.plugins = [];\n        this.pluginMap = new Map;\n        this.editorAttrs = {};\n        this.contentAttrs = {};\n        this.bidiCache = [];\n        this.destroyed = false;\n        /**\n        @internal\n        */ this.updateState = 2 /* UpdateState.Updating */ ;\n        /**\n        @internal\n        */ this.measureScheduled = -1;\n        /**\n        @internal\n        */ this.measureRequests = [];\n        this.contentDOM = document.createElement(\"div\");\n        this.scrollDOM = document.createElement(\"div\");\n        this.scrollDOM.tabIndex = -1;\n        this.scrollDOM.className = \"cm-scroller\";\n        this.scrollDOM.appendChild(this.contentDOM);\n        this.announceDOM = document.createElement(\"div\");\n        this.announceDOM.className = \"cm-announced\";\n        this.announceDOM.setAttribute(\"aria-live\", \"polite\");\n        this.dom = document.createElement(\"div\");\n        this.dom.appendChild(this.announceDOM);\n        this.dom.appendChild(this.scrollDOM);\n        if (config.parent) config.parent.appendChild(this.dom);\n        let { dispatch } = config;\n        this.dispatchTransactions = config.dispatchTransactions || dispatch && ((trs)=>trs.forEach((tr)=>dispatch(tr, this))) || ((trs)=>this.update(trs));\n        this.dispatch = this.dispatch.bind(this);\n        this._root = config.root || getRoot(config.parent) || document;\n        this.viewState = new ViewState(config.state || _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.create(config));\n        if (config.scrollTo && config.scrollTo.is(scrollIntoView)) this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);\n        this.plugins = this.state.facet(viewPlugin).map((spec)=>new PluginInstance(spec));\n        for (let plugin of this.plugins)plugin.update(this);\n        this.observer = new DOMObserver(this);\n        this.inputState = new InputState(this);\n        this.inputState.ensureHandlers(this.plugins);\n        this.docView = new DocView(this);\n        this.mountStyles();\n        this.updateAttrs();\n        this.updateState = 0 /* UpdateState.Idle */ ;\n        this.requestMeasure();\n        if ((_a = document.fonts) === null || _a === void 0 ? void 0 : _a.ready) document.fonts.ready.then(()=>this.requestMeasure());\n    }\n    dispatch(...input) {\n        let trs = input.length == 1 && input[0] instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Transaction ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [\n            this.state.update(...input)\n        ];\n        this.dispatchTransactions(trs, this);\n    }\n    /**\n    Update the view for the given array of transactions. This will\n    update the visible document and selection to match the state\n    produced by the transactions, and notify view plugins of the\n    change. You should usually call\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this\n    as a primitive.\n    */ update(transactions) {\n        if (this.updateState != 0 /* UpdateState.Idle */ ) throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n        let redrawn = false, attrsChanged = false, update;\n        let state = this.state;\n        for (let tr of transactions){\n            if (tr.startState != state) throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n            state = tr.state;\n        }\n        if (this.destroyed) {\n            this.viewState.state = state;\n            return;\n        }\n        let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;\n        if (transactions.some((tr)=>tr.annotation(isFocusChange))) {\n            this.inputState.notifiedFocused = focus;\n            // If a focus-change transaction is being dispatched, set this update flag.\n            focusFlag = 1 /* UpdateFlag.Focus */ ;\n        } else if (focus != this.inputState.notifiedFocused) {\n            this.inputState.notifiedFocused = focus;\n            // Schedule a separate focus transaction if necessary, otherwise\n            // add a flag to this update\n            dispatchFocus = focusChangeTransaction(state, focus);\n            if (!dispatchFocus) focusFlag = 1 /* UpdateFlag.Focus */ ;\n        }\n        // If there was a pending DOM change, eagerly read it and try to\n        // apply it after the given transactions.\n        let pendingKey = this.observer.delayedAndroidKey, domChange = null;\n        if (pendingKey) {\n            this.observer.clearDelayedAndroidKey();\n            domChange = this.observer.readChange();\n            // Only try to apply DOM changes if the transactions didn't\n            // change the doc or selection.\n            if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection)) domChange = null;\n        } else {\n            this.observer.clear();\n        }\n        // When the phrases change, redraw the editor\n        if (state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases) != this.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorState.phrases)) return this.setState(state);\n        update = ViewUpdate.create(this, state, transactions);\n        update.flags |= focusFlag;\n        let scrollTarget = this.viewState.scrollTarget;\n        try {\n            this.updateState = 2 /* UpdateState.Updating */ ;\n            for (let tr of transactions){\n                if (scrollTarget) scrollTarget = scrollTarget.map(tr.changes);\n                if (tr.scrollIntoView) {\n                    let { main } = tr.state.selection;\n                    scrollTarget = new ScrollTarget(main.empty ? main : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));\n                }\n                for (let e of tr.effects)if (e.is(scrollIntoView)) scrollTarget = e.value.clip(this.state);\n            }\n            this.viewState.update(update, scrollTarget);\n            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\n            if (!update.empty) {\n                this.updatePlugins(update);\n                this.inputState.update(update);\n            }\n            redrawn = this.docView.update(update);\n            if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();\n            attrsChanged = this.updateAttrs();\n            this.showAnnouncements(transactions);\n            this.docView.updateSelection(redrawn, transactions.some((tr)=>tr.isUserEvent(\"select.pointer\")));\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n        }\n        if (update.startState.facet(theme) != update.state.facet(theme)) this.viewState.mustMeasureContent = true;\n        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) this.requestMeasure();\n        if (redrawn) this.docViewUpdate();\n        if (!update.empty) for (let listener of this.state.facet(updateListener)){\n            try {\n                listener(update);\n            } catch (e) {\n                logException(this.state, e, \"update listener\");\n            }\n        }\n        if (dispatchFocus || domChange) Promise.resolve().then(()=>{\n            if (dispatchFocus && this.state == dispatchFocus.startState) this.dispatch(dispatchFocus);\n            if (domChange) {\n                if (!applyDOMChange(this, domChange) && pendingKey.force) dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);\n            }\n        });\n    }\n    /**\n    Reset the view to the given state. (This will cause the entire\n    document to be redrawn and all view plugins to be reinitialized,\n    so you should probably only use it when the new state isn't\n    derived from the old state. Otherwise, use\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)\n    */ setState(newState) {\n        if (this.updateState != 0 /* UpdateState.Idle */ ) throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n        if (this.destroyed) {\n            this.viewState.state = newState;\n            return;\n        }\n        this.updateState = 2 /* UpdateState.Updating */ ;\n        let hadFocus = this.hasFocus;\n        try {\n            for (let plugin of this.plugins)plugin.destroy(this);\n            this.viewState = new ViewState(newState);\n            this.plugins = newState.facet(viewPlugin).map((spec)=>new PluginInstance(spec));\n            this.pluginMap.clear();\n            for (let plugin of this.plugins)plugin.update(this);\n            this.docView.destroy();\n            this.docView = new DocView(this);\n            this.inputState.ensureHandlers(this.plugins);\n            this.mountStyles();\n            this.updateAttrs();\n            this.bidiCache = [];\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n        }\n        if (hadFocus) this.focus();\n        this.requestMeasure();\n    }\n    updatePlugins(update) {\n        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);\n        if (prevSpecs != specs) {\n            let newPlugins = [];\n            for (let spec of specs){\n                let found = prevSpecs.indexOf(spec);\n                if (found < 0) {\n                    newPlugins.push(new PluginInstance(spec));\n                } else {\n                    let plugin = this.plugins[found];\n                    plugin.mustUpdate = update;\n                    newPlugins.push(plugin);\n                }\n            }\n            for (let plugin of this.plugins)if (plugin.mustUpdate != update) plugin.destroy(this);\n            this.plugins = newPlugins;\n            this.pluginMap.clear();\n        } else {\n            for (let p of this.plugins)p.mustUpdate = update;\n        }\n        for(let i = 0; i < this.plugins.length; i++)this.plugins[i].update(this);\n        if (prevSpecs != specs) this.inputState.ensureHandlers(this.plugins);\n    }\n    docViewUpdate() {\n        for (let plugin of this.plugins){\n            let val = plugin.value;\n            if (val && val.docViewUpdate) {\n                try {\n                    val.docViewUpdate(this);\n                } catch (e) {\n                    logException(this.state, e, \"doc view update listener\");\n                }\n            }\n        }\n    }\n    /**\n    @internal\n    */ measure(flush = true) {\n        if (this.destroyed) return;\n        if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);\n        if (this.observer.delayedAndroidKey) {\n            this.measureScheduled = -1;\n            this.requestMeasure();\n            return;\n        }\n        this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame\n        if (flush) this.observer.forceFlush();\n        let updated = null;\n        let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;\n        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;\n        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1) scrollAnchorHeight = -1;\n        this.viewState.scrollAnchorHeight = -1;\n        try {\n            for(let i = 0;; i++){\n                if (scrollAnchorHeight < 0) {\n                    if (isScrolledToBottom(sDOM)) {\n                        scrollAnchorPos = -1;\n                        scrollAnchorHeight = this.viewState.heightMap.height;\n                    } else {\n                        let block = this.viewState.scrollAnchorAt(scrollTop);\n                        scrollAnchorPos = block.from;\n                        scrollAnchorHeight = block.top;\n                    }\n                }\n                this.updateState = 1 /* UpdateState.Measuring */ ;\n                let changed = this.viewState.measure(this);\n                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break;\n                if (i > 5) {\n                    console.warn(this.measureRequests.length ? \"Measure loop restarted more than 5 times\" : \"Viewport failed to stabilize\");\n                    break;\n                }\n                let measuring = [];\n                // Only run measure requests in this cycle when the viewport didn't change\n                if (!(changed & 4 /* UpdateFlag.Viewport */ )) [this.measureRequests, measuring] = [\n                    measuring,\n                    this.measureRequests\n                ];\n                let measured = measuring.map((m)=>{\n                    try {\n                        return m.read(this);\n                    } catch (e) {\n                        logException(this.state, e);\n                        return BadMeasure;\n                    }\n                });\n                let update = ViewUpdate.create(this, this.state, []), redrawn = false;\n                update.flags |= changed;\n                if (!updated) updated = update;\n                else updated.flags |= changed;\n                this.updateState = 2 /* UpdateState.Updating */ ;\n                if (!update.empty) {\n                    this.updatePlugins(update);\n                    this.inputState.update(update);\n                    this.updateAttrs();\n                    redrawn = this.docView.update(update);\n                    if (redrawn) this.docViewUpdate();\n                }\n                for(let i = 0; i < measuring.length; i++)if (measured[i] != BadMeasure) {\n                    try {\n                        let m = measuring[i];\n                        if (m.write) m.write(measured[i], this);\n                    } catch (e) {\n                        logException(this.state, e);\n                    }\n                }\n                if (redrawn) this.docView.updateSelection(true);\n                if (!update.viewportChanged && this.measureRequests.length == 0) {\n                    if (this.viewState.editorHeight) {\n                        if (this.viewState.scrollTarget) {\n                            this.docView.scrollIntoView(this.viewState.scrollTarget);\n                            this.viewState.scrollTarget = null;\n                            scrollAnchorHeight = -1;\n                            continue;\n                        } else {\n                            let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;\n                            let diff = newAnchorHeight - scrollAnchorHeight;\n                            if (diff > 1 || diff < -1) {\n                                scrollTop = scrollTop + diff;\n                                sDOM.scrollTop = scrollTop / this.scaleY;\n                                scrollAnchorHeight = -1;\n                                continue;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        } finally{\n            this.updateState = 0 /* UpdateState.Idle */ ;\n            this.measureScheduled = -1;\n        }\n        if (updated && !updated.empty) for (let listener of this.state.facet(updateListener))listener(updated);\n    }\n    /**\n    Get the CSS classes for the currently active editor themes.\n    */ get themeClasses() {\n        return baseThemeID + \" \" + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + \" \" + this.state.facet(theme);\n    }\n    updateAttrs() {\n        let editorAttrs = attrsFromFacet(this, editorAttributes, {\n            class: \"cm-editor\" + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n        });\n        let contentAttrs = {\n            spellcheck: \"false\",\n            autocorrect: \"off\",\n            autocapitalize: \"off\",\n            writingsuggestions: \"false\",\n            translate: \"no\",\n            contenteditable: !this.state.facet(editable) ? \"false\" : \"true\",\n            class: \"cm-content\",\n            style: `${browser.tabSize}: ${this.state.tabSize}`,\n            role: \"textbox\",\n            \"aria-multiline\": \"true\"\n        };\n        if (this.state.readOnly) contentAttrs[\"aria-readonly\"] = \"true\";\n        attrsFromFacet(this, contentAttributes, contentAttrs);\n        let changed = this.observer.ignore(()=>{\n            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);\n            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);\n            return changedContent || changedEditor;\n        });\n        this.editorAttrs = editorAttrs;\n        this.contentAttrs = contentAttrs;\n        return changed;\n    }\n    showAnnouncements(trs) {\n        let first = true;\n        for (let tr of trs)for (let effect of tr.effects)if (effect.is(EditorView.announce)) {\n            if (first) this.announceDOM.textContent = \"\";\n            first = false;\n            let div = this.announceDOM.appendChild(document.createElement(\"div\"));\n            div.textContent = effect.value;\n        }\n    }\n    mountStyles() {\n        this.styleModules = this.state.facet(styleModule);\n        let nonce = this.state.facet(EditorView.cspNonce);\n        style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? {\n            nonce\n        } : undefined);\n    }\n    readMeasured() {\n        if (this.updateState == 2 /* UpdateState.Updating */ ) throw new Error(\"Reading the editor layout isn't allowed during an update\");\n        if (this.updateState == 0 /* UpdateState.Idle */  && this.measureScheduled > -1) this.measure(false);\n    }\n    /**\n    Schedule a layout measurement, optionally providing callbacks to\n    do custom DOM measuring followed by a DOM write phase. Using\n    this is preferable reading DOM layout directly from, for\n    example, an event handler, because it'll make sure measuring and\n    drawing done by other components is synchronized, avoiding\n    unnecessary DOM layout computations.\n    */ requestMeasure(request) {\n        if (this.measureScheduled < 0) this.measureScheduled = this.win.requestAnimationFrame(()=>this.measure());\n        if (request) {\n            if (this.measureRequests.indexOf(request) > -1) return;\n            if (request.key != null) for(let i = 0; i < this.measureRequests.length; i++){\n                if (this.measureRequests[i].key === request.key) {\n                    this.measureRequests[i] = request;\n                    return;\n                }\n            }\n            this.measureRequests.push(request);\n        }\n    }\n    /**\n    Get the value of a specific plugin, if present. Note that\n    plugins that crash can be dropped from a view, so even when you\n    know you registered a given plugin, it is recommended to check\n    the return value of this method.\n    */ plugin(plugin) {\n        let known = this.pluginMap.get(plugin);\n        if (known === undefined || known && known.spec != plugin) this.pluginMap.set(plugin, known = this.plugins.find((p)=>p.spec == plugin) || null);\n        return known && known.update(this).value;\n    }\n    /**\n    The top position of the document, in screen coordinates. This\n    may be negative when the editor is scrolled down. Points\n    directly to the top of the first line, not above the padding.\n    */ get documentTop() {\n        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;\n    }\n    /**\n    Reports the padding above and below the document.\n    */ get documentPadding() {\n        return {\n            top: this.viewState.paddingTop,\n            bottom: this.viewState.paddingBottom\n        };\n    }\n    /**\n    If the editor is transformed with CSS, this provides the scale\n    along the X axis. Otherwise, it will just be 1. Note that\n    transforms other than translation and scaling are not supported.\n    */ get scaleX() {\n        return this.viewState.scaleX;\n    }\n    /**\n    Provide the CSS transformed scale along the Y axis.\n    */ get scaleY() {\n        return this.viewState.scaleY;\n    }\n    /**\n    Find the text line or block widget at the given vertical\n    position (which is interpreted as relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).\n    */ elementAtHeight(height) {\n        this.readMeasured();\n        return this.viewState.elementAtHeight(height);\n    }\n    /**\n    Find the line block (see\n    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given\n    height, again interpreted relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).\n    */ lineBlockAtHeight(height) {\n        this.readMeasured();\n        return this.viewState.lineBlockAtHeight(height);\n    }\n    /**\n    Get the extent and vertical position of all [line\n    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions\n    are relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);\n    */ get viewportLineBlocks() {\n        return this.viewState.viewportLines;\n    }\n    /**\n    Find the line block around the given document position. A line\n    block is a range delimited on both sides by either a\n    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the\n    start/end of the document. It will usually just hold a line of\n    text, but may be broken into multiple textblocks by block\n    widgets.\n    */ lineBlockAt(pos) {\n        return this.viewState.lineBlockAt(pos);\n    }\n    /**\n    The editor's total content height.\n    */ get contentHeight() {\n        return this.viewState.contentHeight;\n    }\n    /**\n    Move a cursor position by [grapheme\n    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether\n    the motion is away from the line start, or towards it. In\n    bidirectional text, the line is traversed in visual order, using\n    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n    When the start position was the last one on the line, the\n    returned position will be across the line break. If there is no\n    further line, the original position is returned.\n    \n    By default, this method moves over a single cluster. The\n    optional `by` argument can be used to move across more. It will\n    be called with the first cluster as argument, and should return\n    a predicate that determines, for each subsequent cluster,\n    whether it should also be moved over.\n    */ moveByChar(start, forward, by) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, by));\n    }\n    /**\n    Move a cursor position across the next group of either\n    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter\n    non-whitespace characters.\n    */ moveByGroup(start, forward) {\n        return skipAtoms(this, start, moveByChar(this, start, forward, (initial)=>byGroup(this, start.head, initial)));\n    }\n    /**\n    Get the cursor position visually at the start or end of a line.\n    Note that this may differ from the _logical_ position at its\n    start or end (which is simply at `line.from`/`line.to`) if text\n    at the start or end goes against the line's base text direction.\n    */ visualLineSide(line, end) {\n        let order = this.bidiSpans(line), dir = this.textDirectionAt(line.from);\n        let span = order[end ? order.length - 1 : 0];\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);\n    }\n    /**\n    Move to the next line boundary in the given direction. If\n    `includeWrap` is true, line wrapping is on, and there is a\n    further wrap point on the current line, the wrap point will be\n    returned. Otherwise this function will return the start or end\n    of the line.\n    */ moveToLineBoundary(start, forward, includeWrap = true) {\n        return moveToLineBoundary(this, start, forward, includeWrap);\n    }\n    /**\n    Move a cursor position vertically. When `distance` isn't given,\n    it defaults to moving to the next line (including wrapped\n    lines). Otherwise, `distance` should provide a positive distance\n    in pixels.\n    \n    When `start` has a\n    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical\n    motion will use that as a target horizontal position. Otherwise,\n    the cursor's own horizontal position is used. The returned\n    cursor will have its goal column set to whichever column was\n    used.\n    */ moveVertically(start, forward, distance) {\n        return skipAtoms(this, start, moveVertically(this, start, forward, distance));\n    }\n    /**\n    Find the DOM parent node and offset (child offset if `node` is\n    an element, character offset when it is a text node) at the\n    given document position.\n    \n    Note that for positions that aren't currently in\n    `visibleRanges`, the resulting DOM position isn't necessarily\n    meaningful (it may just point before or after a placeholder\n    element).\n    */ domAtPos(pos) {\n        return this.docView.domAtPos(pos);\n    }\n    /**\n    Find the document position at the given DOM node. Can be useful\n    for associating positions with DOM events. Will raise an error\n    when `node` isn't part of the editor content.\n    */ posAtDOM(node, offset = 0) {\n        return this.docView.posFromDOM(node, offset);\n    }\n    posAtCoords(coords, precise = true) {\n        this.readMeasured();\n        return posAtCoords(this, coords, precise);\n    }\n    /**\n    Get the screen coordinates at the given document position.\n    `side` determines whether the coordinates are based on the\n    element before (-1) or after (1) the position (if no element is\n    available on the given side, the method will transparently use\n    another strategy to get reasonable coordinates).\n    */ coordsAtPos(pos, side = 1) {\n        this.readMeasured();\n        let rect = this.docView.coordsAt(pos, side);\n        if (!rect || rect.left == rect.right) return rect;\n        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);\n        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];\n        return flattenRect(rect, span.dir == Direction.LTR == side > 0);\n    }\n    /**\n    Return the rectangle around a given character. If `pos` does not\n    point in front of a character that is in the viewport and\n    rendered (i.e. not replaced, not a line break), this will return\n    null. For space characters that are a line wrap point, this will\n    return the position before the line break.\n    */ coordsForChar(pos) {\n        this.readMeasured();\n        return this.docView.coordsForChar(pos);\n    }\n    /**\n    The default width of a character in the editor. May not\n    accurately reflect the width of all characters (given variable\n    width fonts or styling of invididual ranges).\n    */ get defaultCharacterWidth() {\n        return this.viewState.heightOracle.charWidth;\n    }\n    /**\n    The default height of a line in the editor. May not be accurate\n    for all lines.\n    */ get defaultLineHeight() {\n        return this.viewState.heightOracle.lineHeight;\n    }\n    /**\n    The text direction\n    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)\n    CSS property) of the editor's content element.\n    */ get textDirection() {\n        return this.viewState.defaultTextDirection;\n    }\n    /**\n    Find the text direction of the block at the given position, as\n    assigned by CSS. If\n    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)\n    isn't enabled, or the given position is outside of the viewport,\n    this will always return the same as\n    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that\n    this may trigger a DOM layout.\n    */ textDirectionAt(pos) {\n        let perLine = this.state.facet(perLineTextDirection);\n        if (!perLine || pos < this.viewport.from || pos > this.viewport.to) return this.textDirection;\n        this.readMeasured();\n        return this.docView.textDirectionAt(pos);\n    }\n    /**\n    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)\n    (as determined by the\n    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)\n    CSS property of its content element).\n    */ get lineWrapping() {\n        return this.viewState.heightOracle.lineWrapping;\n    }\n    /**\n    Returns the bidirectional text structure of the given line\n    (which should be in the current document) as an array of span\n    objects. The order of these spans matches the [text\n    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is\n    left-to-right, the leftmost spans come first, otherwise the\n    rightmost spans come first.\n    */ bidiSpans(line) {\n        if (line.length > MaxBidiLine) return trivialOrder(line.length);\n        let dir = this.textDirectionAt(line.from), isolates;\n        for (let entry of this.bidiCache){\n            if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line)))) return entry.order;\n        }\n        if (!isolates) isolates = getIsolatedRanges(this, line);\n        let order = computeOrder(line.text, dir, isolates);\n        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));\n        return order;\n    }\n    /**\n    Check whether the editor has focus.\n    */ get hasFocus() {\n        var _a;\n        // Safari return false for hasFocus when the context menu is open\n        // or closing, which leads us to ignore selection changes from the\n        // context menu because it looks like the editor isn't focused.\n        // This kludges around that.\n        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;\n    }\n    /**\n    Put focus on the editor.\n    */ focus() {\n        this.observer.ignore(()=>{\n            focusPreventScroll(this.contentDOM);\n            this.docView.updateSelection();\n        });\n    }\n    /**\n    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only\n    necessary when moving the editor's existing DOM to a new window or shadow root.\n    */ setRoot(root) {\n        if (this._root != root) {\n            this._root = root;\n            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);\n            this.mountStyles();\n        }\n    }\n    /**\n    Clean up this editor view, removing its element from the\n    document, unregistering event handlers, and notifying\n    plugins. The view instance can no longer be used after\n    calling this.\n    */ destroy() {\n        if (this.root.activeElement == this.contentDOM) this.contentDOM.blur();\n        for (let plugin of this.plugins)plugin.destroy(this);\n        this.plugins = [];\n        this.inputState.destroy();\n        this.docView.destroy();\n        this.dom.remove();\n        this.observer.destroy();\n        if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);\n        this.destroyed = true;\n    }\n    /**\n    Returns an effect that can be\n    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to\n    cause it to scroll the given position or range into view.\n    */ static scrollIntoView(pos, options = {}) {\n        return scrollIntoView.of(new ScrollTarget(typeof pos == \"number\" ? _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));\n    }\n    /**\n    Return an effect that resets the editor to its current (at the\n    time this method was called) scroll position. Note that this\n    only affects the editor's own scrollable element, not parents.\n    See also\n    [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).\n    \n    The effect should be used with a document identical to the one\n    it was created for. Failing to do so is not an error, but may\n    not scroll to the expected position. You can\n    [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.\n    */ scrollSnapshot() {\n        let { scrollTop, scrollLeft } = this.scrollDOM;\n        let ref = this.viewState.scrollAnchorAt(scrollTop);\n        return scrollIntoView.of(new ScrollTarget(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(ref.from), \"start\", \"start\", ref.top - scrollTop, scrollLeft, true));\n    }\n    /**\n    Enable or disable tab-focus mode, which disables key bindings\n    for Tab and Shift-Tab, letting the browser's default\n    focus-changing behavior go through instead. This is useful to\n    prevent trapping keyboard users in your editor.\n    \n    Without argument, this toggles the mode. With a boolean, it\n    enables (true) or disables it (false). Given a number, it\n    temporarily enables the mode until that number of milliseconds\n    have passed or another non-Tab key is pressed.\n    */ setTabFocusMode(to) {\n        if (to == null) this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;\n        else if (typeof to == \"boolean\") this.inputState.tabFocusMode = to ? 0 : -1;\n        else if (this.inputState.tabFocusMode != 0) this.inputState.tabFocusMode = Date.now() + to;\n    }\n    /**\n    Returns an extension that can be used to add DOM event handlers.\n    The value should be an object mapping event names to handler\n    functions. For any given event, such functions are ordered by\n    extension precedence, and the first handler to return true will\n    be assumed to have handled that event, and no other handlers or\n    built-in behavior will be activated for it. These are registered\n    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except\n    for `scroll` handlers, which will be called any time the\n    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of\n    its parent nodes is scrolled.\n    */ static domEventHandlers(handlers) {\n        return ViewPlugin.define(()=>({}), {\n            eventHandlers: handlers\n        });\n    }\n    /**\n    Create an extension that registers DOM event observers. Contrary\n    to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),\n    observers can't be prevented from running by a higher-precedence\n    handler returning true. They also don't prevent other handlers\n    and observers from running when they return true, and should not\n    call `preventDefault`.\n    */ static domEventObservers(observers) {\n        return ViewPlugin.define(()=>({}), {\n            eventObservers: observers\n        });\n    }\n    /**\n    Create a theme extension. The first argument can be a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n    style spec providing the styles for the theme. These will be\n    prefixed with a generated class for the style.\n    \n    Because the selectors will be prefixed with a scope class, rule\n    that directly match the editor's [wrapper\n    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be\n    added—need to be explicitly differentiated by adding an `&` to\n    the selector for that element—for example\n    `&.cm-focused`.\n    \n    When `dark` is set to true, the theme will be marked as dark,\n    which will cause the `&dark` rules from [base\n    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to\n    `&light` when a light theme is active).\n    */ static theme(spec, options) {\n        let prefix = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\n        let result = [\n            theme.of(prefix),\n            styleModule.of(buildTheme(`.${prefix}`, spec))\n        ];\n        if (options && options.dark) result.push(darkTheme.of(true));\n        return result;\n    }\n    /**\n    Create an extension that adds styles to the base theme. Like\n    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the\n    place of the editor wrapper element when directly targeting\n    that. You can also use `&dark` or `&light` instead to only\n    target editors with a dark or light theme.\n    */ static baseTheme(spec) {\n        return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.lowest(styleModule.of(buildTheme(\".\" + baseThemeID, spec, lightDarkIDs)));\n    }\n    /**\n    Retrieve an editor view instance from the view's DOM\n    representation.\n    */ static findFromDOM(dom) {\n        var _a;\n        let content = dom.querySelector(\".cm-content\");\n        let cView = content && ContentView.get(content) || ContentView.get(dom);\n        return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;\n    }\n}\n/**\nFacet to add a [style\nmodule](https://github.com/marijnh/style-mod#documentation) to\nan editor view. The view will ensure that the module is\nmounted in its [document\nroot](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).\n*/ EditorView.styleModule = styleModule;\n/**\nAn input handler can override the way changes to the editable\nDOM content are handled. Handlers are passed the document\npositions between which the change was found, and the new\ncontent. When one returns true, no further input handlers are\ncalled and the default behavior is prevented.\n\nThe `insert` argument can be used to get the default transaction\nthat would be applied for this input. This can be useful when\ndispatching the custom behavior as a separate transaction.\n*/ EditorView.inputHandler = inputHandler;\n/**\nFunctions provided in this facet will be used to transform text\npasted or dropped into the editor.\n*/ EditorView.clipboardInputFilter = clipboardInputFilter;\n/**\nTransform text copied or dragged from the editor.\n*/ EditorView.clipboardOutputFilter = clipboardOutputFilter;\n/**\nScroll handlers can override how things are scrolled into view.\nIf they return `true`, no further handling happens for the\nscrolling. If they return false, the default scroll behavior is\napplied. Scroll handlers should never initiate editor updates.\n*/ EditorView.scrollHandler = scrollHandler;\n/**\nThis facet can be used to provide functions that create effects\nto be dispatched when the editor's focus state changes.\n*/ EditorView.focusChangeEffect = focusChangeEffect;\n/**\nBy default, the editor assumes all its content has the same\n[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`\nvalue to make it read the text direction of every (rendered)\nline separately.\n*/ EditorView.perLineTextDirection = perLineTextDirection;\n/**\nAllows you to provide a function that should be called when the\nlibrary catches an exception from an extension (mostly from view\nplugins, but may be used by other extensions to route exceptions\nfrom user-code-provided callbacks). This is mostly useful for\ndebugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).\n*/ EditorView.exceptionSink = exceptionSink;\n/**\nA facet that can be used to register a function to be called\nevery time the view updates.\n*/ EditorView.updateListener = updateListener;\n/**\nFacet that controls whether the editor content DOM is editable.\nWhen its highest-precedence value is `false`, the element will\nnot have its `contenteditable` attribute set. (Note that this\ndoesn't affect API calls that change the editor content, even\nwhen those are bound to keys or buttons. See the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)\n*/ EditorView.editable = editable;\n/**\nAllows you to influence the way mouse selection happens. The\nfunctions in this facet will be called for a `mousedown` event\non the editor, and can return an object that overrides the way a\nselection is computed from that mouse click or drag.\n*/ EditorView.mouseSelectionStyle = mouseSelectionStyle;\n/**\nFacet used to configure whether a given selection drag event\nshould move or copy the selection. The given predicate will be\ncalled with the `mousedown` event, and can return `true` when\nthe drag should move the content.\n*/ EditorView.dragMovesSelection = dragMovesSelection$1;\n/**\nFacet used to configure whether a given selecting click adds a\nnew range to the existing selection or replaces it entirely. The\ndefault behavior is to check `event.metaKey` on macOS, and\n`event.ctrlKey` elsewhere.\n*/ EditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/**\nA facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)\nare shown in the view. Decorations can be provided in two\nways—directly, or via a function that takes an editor view.\n\nOnly decoration sets provided directly are allowed to influence\nthe editor's vertical layout structure. The ones provided as\nfunctions are called _after_ the new viewport has been computed,\nand thus **must not** introduce block widgets or replacing\ndecorations that cover line breaks.\n\nIf you want decorated ranges to behave like atomic units for\ncursor motion and deletion purposes, also provide the range set\ncontaining the decorations to\n[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).\n*/ EditorView.decorations = decorations;\n/**\nFacet that works much like\n[`decorations`](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), but puts its\ninputs at the very bottom of the precedence stack, meaning mark\ndecorations provided here will only be split by other, partially\noverlapping \\`outerDecorations\\` ranges, and wrap around all\nregular decorations. Use this for mark elements that should, as\nmuch as possible, remain in one piece.\n*/ EditorView.outerDecorations = outerDecorations;\n/**\nUsed to provide ranges that should be treated as atoms as far as\ncursor motion is concerned. This causes methods like\n[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and\n[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the\ncommands built on top of them) to skip across such regions when\na selection endpoint would enter them. This does _not_ prevent\ndirect programmatic [selection\nupdates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such\nregions.\n*/ EditorView.atomicRanges = atomicRanges;\n/**\nWhen range decorations add a `unicode-bidi: isolate` style, they\nshould also include a\n[`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property\nin their decoration spec, and be exposed through this facet, so\nthat the editor can compute the proper text order. (Other values\nfor `unicode-bidi`, except of course `normal`, are not\nsupported.)\n*/ EditorView.bidiIsolatedRanges = bidiIsolatedRanges;\n/**\nFacet that allows extensions to provide additional scroll\nmargins (space around the sides of the scrolling element that\nshould be considered invisible). This can be useful when the\nplugin introduces elements that cover part of that element (for\nexample a horizontally fixed gutter).\n*/ EditorView.scrollMargins = scrollMargins;\n/**\nThis facet records whether a dark theme is active. The extension\nreturned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically\nincludes an instance of this when the `dark` option is set to\ntrue.\n*/ EditorView.darkTheme = darkTheme;\n/**\nProvides a Content Security Policy nonce to use when creating\nthe style sheets for the editor. Holds the empty string when no\nnonce has been provided.\n*/ EditorView.cspNonce = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.length ? values[0] : \"\"\n});\n/**\nFacet that provides additional DOM attributes for the editor's\neditable DOM element.\n*/ EditorView.contentAttributes = contentAttributes;\n/**\nFacet that provides DOM attributes for the editor's outer\nelement.\n*/ EditorView.editorAttributes = editorAttributes;\n/**\nAn extension that enables line wrapping in the editor (by\nsetting CSS `white-space` to `pre-wrap` in the content).\n*/ EditorView.lineWrapping = /*@__PURE__*/ EditorView.contentAttributes.of({\n    \"class\": \"cm-lineWrapping\"\n});\n/**\nState effect used to include screen reader announcements in a\ntransaction. These will be added to the DOM in a visually hidden\nelement with `aria-live=\"polite\"` set, and should be used to\ndescribe effects that are visually obvious but may not be\nnoticed by screen reader users (such as moving to the next\nsearch match).\n*/ EditorView.announce = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n// Maximum line length for which we compute accurate bidi info\nconst MaxBidiLine = 4096;\nconst BadMeasure = {};\nclass CachedOrder {\n    constructor(from, to, dir, isolates, fresh, order){\n        this.from = from;\n        this.to = to;\n        this.dir = dir;\n        this.isolates = isolates;\n        this.fresh = fresh;\n        this.order = order;\n    }\n    static update(cache, changes) {\n        if (changes.empty && !cache.some((c)=>c.fresh)) return cache;\n        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\n        for(let i = Math.max(0, cache.length - 10); i < cache.length; i++){\n            let entry = cache[i];\n            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));\n        }\n        return result;\n    }\n}\nfunction attrsFromFacet(view, facet, base) {\n    for(let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--){\n        let source = sources[i], value = typeof source == \"function\" ? source(view) : source;\n        if (value) combineAttrs(value, base);\n    }\n    return base;\n}\nconst currentPlatform = browser.mac ? \"mac\" : browser.windows ? \"win\" : browser.linux ? \"linux\" : \"key\";\nfunction normalizeKeyName(name, platform) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result == \"Space\") result = \" \";\n    let alt, ctrl, shift, meta;\n    for(let i = 0; i < parts.length - 1; ++i){\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod)) meta = true;\n        else if (/^a(lt)?$/i.test(mod)) alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n        else if (/^s(hift)?$/i.test(mod)) shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (platform == \"mac\") meta = true;\n            else ctrl = true;\n        } else throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt) result = \"Alt-\" + result;\n    if (ctrl) result = \"Ctrl-\" + result;\n    if (meta) result = \"Meta-\" + result;\n    if (shift) result = \"Shift-\" + result;\n    return result;\n}\nfunction modifiers(name, event, shift) {\n    if (event.altKey) name = \"Alt-\" + name;\n    if (event.ctrlKey) name = \"Ctrl-\" + name;\n    if (event.metaKey) name = \"Meta-\" + name;\n    if (shift !== false && event.shiftKey) name = \"Shift-\" + name;\n    return name;\n}\nconst handleKeyEvents = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.default(/*@__PURE__*/ EditorView.domEventHandlers({\n    keydown (event, view) {\n        return runHandlers(getKeymap(view.state), event, view, \"editor\");\n    }\n}));\n/**\nFacet used for registering keymaps.\n\nYou can add multiple keymaps to an editor. Their priorities\ndetermine their precedence (the ones specified early or with high\npriority get checked first). When a handler has returned `true`\nfor a given key, no further handlers are called.\n*/ const keymap = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    enables: handleKeyEvents\n});\nconst Keymaps = /*@__PURE__*/ new WeakMap();\n// This is hidden behind an indirection, rather than directly computed\n// by the facet, to keep internal types out of the facet's type.\nfunction getKeymap(state) {\n    let bindings = state.facet(keymap);\n    let map = Keymaps.get(bindings);\n    if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b)=>a.concat(b), [])));\n    return map;\n}\n/**\nRun the key handlers registered for a given scope. The event\nobject should be a `\"keydown\"` event. Returns true if any of the\nhandlers handled it.\n*/ function runScopeHandlers(view, event, scope) {\n    return runHandlers(getKeymap(view.state), event, view, scope);\n}\nlet storedPrefix = null;\nconst PrefixTimeout = 4000;\nfunction buildKeymap(bindings, platform = currentPlatform) {\n    let bound = Object.create(null);\n    let isPrefix = Object.create(null);\n    let checkPrefix = (name, is)=>{\n        let current = isPrefix[name];\n        if (current == null) isPrefix[name] = is;\n        else if (current != is) throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\n    };\n    let add = (scope, key, command, preventDefault, stopPropagation)=>{\n        var _a, _b;\n        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n        let parts = key.split(/ (?!$)/).map((k)=>normalizeKeyName(k, platform));\n        for(let i = 1; i < parts.length; i++){\n            let prefix = parts.slice(0, i).join(\" \");\n            checkPrefix(prefix, true);\n            if (!scopeObj[prefix]) scopeObj[prefix] = {\n                preventDefault: true,\n                stopPropagation: false,\n                run: [\n                    (view)=>{\n                        let ourObj = storedPrefix = {\n                            view,\n                            prefix,\n                            scope\n                        };\n                        setTimeout(()=>{\n                            if (storedPrefix == ourObj) storedPrefix = null;\n                        }, PrefixTimeout);\n                        return true;\n                    }\n                ]\n            };\n        }\n        let full = parts.join(\" \");\n        checkPrefix(full, false);\n        let binding = scopeObj[full] || (scopeObj[full] = {\n            preventDefault: false,\n            stopPropagation: false,\n            run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []\n        });\n        if (command) binding.run.push(command);\n        if (preventDefault) binding.preventDefault = true;\n        if (stopPropagation) binding.stopPropagation = true;\n    };\n    for (let b of bindings){\n        let scopes = b.scope ? b.scope.split(\" \") : [\n            \"editor\"\n        ];\n        if (b.any) for (let scope of scopes){\n            let scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n            if (!scopeObj._any) scopeObj._any = {\n                preventDefault: false,\n                stopPropagation: false,\n                run: []\n            };\n            let { any } = b;\n            for(let key in scopeObj)scopeObj[key].run.push((view)=>any(view, currentKeyEvent));\n        }\n        let name = b[platform] || b.key;\n        if (!name) continue;\n        for (let scope of scopes){\n            add(scope, name, b.run, b.preventDefault, b.stopPropagation);\n            if (b.shift) add(scope, \"Shift-\" + name, b.shift, b.preventDefault, b.stopPropagation);\n        }\n    }\n    return bound;\n}\nlet currentKeyEvent = null;\nfunction runHandlers(map, event, view, scope) {\n    currentKeyEvent = event;\n    let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.keyName)(event);\n    let charCode = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(name, 0), isChar = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointSize)(charCode) == name.length && name != \" \";\n    let prefix = \"\", handled = false, prevented = false, stopPropagation = false;\n    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\n        prefix = storedPrefix.prefix + \" \";\n        if (modifierCodes.indexOf(event.keyCode) < 0) {\n            prevented = true;\n            storedPrefix = null;\n        }\n    }\n    let ran = new Set;\n    let runFor = (binding)=>{\n        if (binding) {\n            for (let cmd of binding.run)if (!ran.has(cmd)) {\n                ran.add(cmd);\n                if (cmd(view)) {\n                    if (binding.stopPropagation) stopPropagation = true;\n                    return true;\n                }\n            }\n            if (binding.preventDefault) {\n                if (binding.stopPropagation) stopPropagation = true;\n                prevented = true;\n            }\n        }\n        return false;\n    };\n    let scopeObj = map[scope], baseName, shiftName;\n    if (scopeObj) {\n        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {\n            handled = true;\n        } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows\n        !(browser.windows && event.ctrlKey && event.altKey) && (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.base[event.keyCode]) && baseName != name) {\n            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {\n                handled = true;\n            } else if (event.shiftKey && (shiftName = w3c_keyname__WEBPACK_IMPORTED_MODULE_1__.shift[event.keyCode]) != name && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {\n                handled = true;\n            }\n        } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name, event, true)])) {\n            handled = true;\n        }\n        if (!handled && runFor(scopeObj._any)) handled = true;\n    }\n    if (prevented) handled = true;\n    if (handled && stopPropagation) event.stopPropagation();\n    currentKeyEvent = null;\n    return handled;\n}\n/**\nImplementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates\na rectangle at a given set of coordinates.\n*/ class RectangleMarker {\n    /**\n    Create a marker with the given class and dimensions. If `width`\n    is null, the DOM element will get no width style.\n    */ constructor(className, /**\n    The left position of the marker (in pixels, document-relative).\n    */ left, /**\n    The top position of the marker.\n    */ top, /**\n    The width of the marker, or null if it shouldn't get a width assigned.\n    */ width, /**\n    The height of the marker.\n    */ height){\n        this.className = className;\n        this.left = left;\n        this.top = top;\n        this.width = width;\n        this.height = height;\n    }\n    draw() {\n        let elt = document.createElement(\"div\");\n        elt.className = this.className;\n        this.adjust(elt);\n        return elt;\n    }\n    update(elt, prev) {\n        if (prev.className != this.className) return false;\n        this.adjust(elt);\n        return true;\n    }\n    adjust(elt) {\n        elt.style.left = this.left + \"px\";\n        elt.style.top = this.top + \"px\";\n        if (this.width != null) elt.style.width = this.width + \"px\";\n        elt.style.height = this.height + \"px\";\n    }\n    eq(p) {\n        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;\n    }\n    /**\n    Create a set of rectangles for the given selection range,\n    assigning them theclass`className`. Will create a single\n    rectangle for empty ranges, and a set of selection-style\n    rectangles covering the range's content (in a bidi-aware\n    way) for non-empty ones.\n    */ static forRange(view, className, range) {\n        if (range.empty) {\n            let pos = view.coordsAtPos(range.head, range.assoc || 1);\n            if (!pos) return [];\n            let base = getBase(view);\n            return [\n                new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)\n            ];\n        } else {\n            return rectanglesForRange(view, className, range);\n        }\n    }\n}\nfunction getBase(view) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;\n    return {\n        left: left - view.scrollDOM.scrollLeft * view.scaleX,\n        top: rect.top - view.scrollDOM.scrollTop * view.scaleY\n    };\n}\nfunction wrappedLine(view, pos, side, inside) {\n    let coords = view.coordsAtPos(pos, side * 2);\n    if (!coords) return inside;\n    let editorRect = view.dom.getBoundingClientRect();\n    let y = (coords.top + coords.bottom) / 2;\n    let left = view.posAtCoords({\n        x: editorRect.left + 1,\n        y\n    });\n    let right = view.posAtCoords({\n        x: editorRect.right - 1,\n        y\n    });\n    if (left == null || right == null) return inside;\n    return {\n        from: Math.max(inside.from, Math.min(left, right)),\n        to: Math.min(inside.to, Math.max(left, right))\n    };\n}\nfunction rectanglesForRange(view, className, range) {\n    if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];\n    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);\n    let ltr = view.textDirection == Direction.LTR;\n    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);\n    let lineElt = content.querySelector(\".cm-line\"), lineStyle = lineElt && window.getComputedStyle(lineElt);\n    let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);\n    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);\n    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);\n    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;\n    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;\n    if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks)) visualStart = wrappedLine(view, from, 1, visualStart);\n    if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks)) visualEnd = wrappedLine(view, to, -1, visualEnd);\n    if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {\n        return pieces(drawForLine(range.from, range.to, visualStart));\n    } else {\n        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);\n        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);\n        let between = [];\n        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top) between.push(piece(leftSide, top.bottom, rightSide, bottom.top));\n        else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text) top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\n        return pieces(top).concat(between).concat(pieces(bottom));\n    }\n    function piece(left, top, right, bottom) {\n        return new RectangleMarker(className, left - base.left, top - base.top, right - left, bottom - top);\n    }\n    function pieces({ top, bottom, horizontal }) {\n        let pieces = [];\n        for(let i = 0; i < horizontal.length; i += 2)pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\n        return pieces;\n    }\n    // Gets passed from/to in line-local positions\n    function drawForLine(from, to, line) {\n        let top = 1e9, bottom = -1e9, horizontal = [];\n        function addSpan(from, fromOpen, to, toOpen, dir) {\n            // Passing 2/-2 is a kludge to force the view to return\n            // coordinates on the proper side of block widgets, since\n            // normalizing the side there, though appropriate for most\n            // coordsAtPos queries, would break selection drawing.\n            let fromCoords = view.coordsAtPos(from, from == line.to ? -2 : 2);\n            let toCoords = view.coordsAtPos(to, to == line.from ? 2 : -2);\n            if (!fromCoords || !toCoords) return;\n            top = Math.min(fromCoords.top, toCoords.top, top);\n            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\n            if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);\n            else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\n        }\n        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;\n        // Split the range by visible range and document line\n        for (let r of view.visibleRanges)if (r.to > start && r.from < end) {\n            for(let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;){\n                let docLine = view.state.doc.lineAt(pos);\n                for (let span of view.bidiSpans(docLine)){\n                    let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;\n                    if (spanFrom >= endPos) break;\n                    if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\n                }\n                pos = docLine.to + 1;\n                if (pos >= endPos) break;\n            }\n        }\n        if (horizontal.length == 0) addSpan(start, from == null, end, to == null, view.textDirection);\n        return {\n            top,\n            bottom,\n            horizontal\n        };\n    }\n    function drawForWidget(block, top) {\n        let y = contentRect.top + (top ? block.top : block.bottom);\n        return {\n            top: y,\n            bottom: y,\n            horizontal: []\n        };\n    }\n}\nfunction sameMarker(a, b) {\n    return a.constructor == b.constructor && a.eq(b);\n}\nclass LayerView {\n    constructor(view, layer){\n        this.view = view;\n        this.layer = layer;\n        this.drawn = [];\n        this.scaleX = 1;\n        this.scaleY = 1;\n        this.measureReq = {\n            read: this.measure.bind(this),\n            write: this.draw.bind(this)\n        };\n        this.dom = view.scrollDOM.appendChild(document.createElement(\"div\"));\n        this.dom.classList.add(\"cm-layer\");\n        if (layer.above) this.dom.classList.add(\"cm-layer-above\");\n        if (layer.class) this.dom.classList.add(layer.class);\n        this.scale();\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.setOrder(view.state);\n        view.requestMeasure(this.measureReq);\n        if (layer.mount) layer.mount(this.dom, view);\n    }\n    update(update) {\n        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder)) this.setOrder(update.state);\n        if (this.layer.update(update, this.dom) || update.geometryChanged) {\n            this.scale();\n            update.view.requestMeasure(this.measureReq);\n        }\n    }\n    docViewUpdate(view) {\n        if (this.layer.updateOnDocViewUpdate !== false) view.requestMeasure(this.measureReq);\n    }\n    setOrder(state) {\n        let pos = 0, order = state.facet(layerOrder);\n        while(pos < order.length && order[pos] != this.layer)pos++;\n        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);\n    }\n    measure() {\n        return this.layer.markers(this.view);\n    }\n    scale() {\n        let { scaleX, scaleY } = this.view;\n        if (scaleX != this.scaleX || scaleY != this.scaleY) {\n            this.scaleX = scaleX;\n            this.scaleY = scaleY;\n            this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;\n        }\n    }\n    draw(markers) {\n        if (markers.length != this.drawn.length || markers.some((p, i)=>!sameMarker(p, this.drawn[i]))) {\n            let old = this.dom.firstChild, oldI = 0;\n            for (let marker of markers){\n                if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {\n                    old = old.nextSibling;\n                    oldI++;\n                } else {\n                    this.dom.insertBefore(marker.draw(), old);\n                }\n            }\n            while(old){\n                let next = old.nextSibling;\n                old.remove();\n                old = next;\n            }\n            this.drawn = markers;\n        }\n    }\n    destroy() {\n        if (this.layer.destroy) this.layer.destroy(this.dom, this.view);\n        this.dom.remove();\n    }\n}\nconst layerOrder = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nDefine a layer.\n*/ function layer(config) {\n    return [\n        ViewPlugin.define((v)=>new LayerView(v, config)),\n        layerOrder.of(config)\n    ];\n}\nconst CanHidePrimary = !(browser.ios && browser.webkit && browser.webkit_version < 534);\nconst selectionConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            cursorBlinkRate: 1200,\n            drawRangeCursor: true\n        }, {\n            cursorBlinkRate: (a, b)=>Math.min(a, b),\n            drawRangeCursor: (a, b)=>a || b\n        });\n    }\n});\n/**\nReturns an extension that hides the browser's native selection and\ncursor, replacing the selection with a background behind the text\n(with the `cm-selectionBackground` class), and the\ncursors with elements overlaid over the code (using\n`cm-cursor-primary` and `cm-cursor-secondary`).\n\nThis allows the editor to display secondary selection ranges, and\ntends to produce a type of selection more in line with that users\nexpect in a text editor (the native selection styling will often\nleave gaps between lines and won't fill the horizontal space after\na line when the selection continues past it).\n\nIt does have a performance cost, in that it requires an extra DOM\nlayout cycle for many updates (the selection is drawn based on DOM\nlayout information that's only available after laying out the\ncontent).\n*/ function drawSelection(config = {}) {\n    return [\n        selectionConfig.of(config),\n        cursorLayer,\n        selectionLayer,\n        hideNativeSelection,\n        nativeSelectionHidden.of(true)\n    ];\n}\n/**\nRetrieve the [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) configuration\nfor this state. (Note that this will return a set of defaults even\nif `drawSelection` isn't enabled.)\n*/ function getDrawSelectionConfig(state) {\n    return state.facet(selectionConfig);\n}\nfunction configChanged(update) {\n    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);\n}\nconst cursorLayer = /*@__PURE__*/ layer({\n    above: true,\n    markers (view) {\n        let { state } = view, conf = state.facet(selectionConfig);\n        let cursors = [];\n        for (let r of state.selection.ranges){\n            let prim = r == state.selection.main;\n            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {\n                let className = prim ? \"cm-cursor cm-cursor-primary\" : \"cm-cursor cm-cursor-secondary\";\n                let cursor = r.empty ? r : _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);\n                for (let piece of RectangleMarker.forRange(view, className, cursor))cursors.push(piece);\n            }\n        }\n        return cursors;\n    },\n    update (update, dom) {\n        if (update.transactions.some((tr)=>tr.selection)) dom.style.animationName = dom.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n        let confChange = configChanged(update);\n        if (confChange) setBlinkRate(update.state, dom);\n        return update.docChanged || update.selectionSet || confChange;\n    },\n    mount (dom, view) {\n        setBlinkRate(view.state, dom);\n    },\n    class: \"cm-cursorLayer\"\n});\nfunction setBlinkRate(state, dom) {\n    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + \"ms\";\n}\nconst selectionLayer = /*@__PURE__*/ layer({\n    above: false,\n    markers (view) {\n        return view.state.selection.ranges.map((r)=>r.empty ? [] : RectangleMarker.forRange(view, \"cm-selectionBackground\", r)).reduce((a, b)=>a.concat(b));\n    },\n    update (update, dom) {\n        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);\n    },\n    class: \"cm-selectionLayer\"\n});\nconst themeSpec = {\n    \".cm-line\": {\n        \"& ::selection, &::selection\": {\n            backgroundColor: \"transparent !important\"\n        }\n    },\n    \".cm-content\": {\n        \"& :focus\": {\n            caretColor: \"initial !important\",\n            \"&::selection, & ::selection\": {\n                backgroundColor: \"Highlight !important\"\n            }\n        }\n    }\n};\nif (CanHidePrimary) themeSpec[\".cm-line\"].caretColor = themeSpec[\".cm-content\"].caretColor = \"transparent !important\";\nconst hideNativeSelection = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Prec.highest(/*@__PURE__*/ EditorView.theme(themeSpec));\nconst setDropCursorPos = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define({\n    map (pos, mapping) {\n        return pos == null ? null : mapping.mapPos(pos);\n    }\n});\nconst dropCursorPos = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n    create () {\n        return null;\n    },\n    update (pos, tr) {\n        if (pos != null) pos = tr.changes.mapPos(pos);\n        return tr.effects.reduce((pos, e)=>e.is(setDropCursorPos) ? e.value : pos, pos);\n    }\n});\nconst drawDropCursor = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.cursor = null;\n        this.measureReq = {\n            read: this.readPos.bind(this),\n            write: this.drawCursor.bind(this)\n        };\n    }\n    update(update) {\n        var _a;\n        let cursorPos = update.state.field(dropCursorPos);\n        if (cursorPos == null) {\n            if (this.cursor != null) {\n                (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();\n                this.cursor = null;\n            }\n        } else {\n            if (!this.cursor) {\n                this.cursor = this.view.scrollDOM.appendChild(document.createElement(\"div\"));\n                this.cursor.className = \"cm-dropCursor\";\n            }\n            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged) this.view.requestMeasure(this.measureReq);\n        }\n    }\n    readPos() {\n        let { view } = this;\n        let pos = view.state.field(dropCursorPos);\n        let rect = pos != null && view.coordsAtPos(pos);\n        if (!rect) return null;\n        let outer = view.scrollDOM.getBoundingClientRect();\n        return {\n            left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,\n            top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,\n            height: rect.bottom - rect.top\n        };\n    }\n    drawCursor(pos) {\n        if (this.cursor) {\n            let { scaleX, scaleY } = this.view;\n            if (pos) {\n                this.cursor.style.left = pos.left / scaleX + \"px\";\n                this.cursor.style.top = pos.top / scaleY + \"px\";\n                this.cursor.style.height = pos.height / scaleY + \"px\";\n            } else {\n                this.cursor.style.left = \"-100000px\";\n            }\n        }\n    }\n    destroy() {\n        if (this.cursor) this.cursor.remove();\n    }\n    setDropPos(pos) {\n        if (this.view.state.field(dropCursorPos) != pos) this.view.dispatch({\n            effects: setDropCursorPos.of(pos)\n        });\n    }\n}, {\n    eventObservers: {\n        dragover (event) {\n            this.setDropPos(this.view.posAtCoords({\n                x: event.clientX,\n                y: event.clientY\n            }));\n        },\n        dragleave (event) {\n            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget)) this.setDropPos(null);\n        },\n        dragend () {\n            this.setDropPos(null);\n        },\n        drop () {\n            this.setDropPos(null);\n        }\n    }\n});\n/**\nDraws a cursor at the current drop position when something is\ndragged over the editor.\n*/ function dropCursor() {\n    return [\n        dropCursorPos,\n        drawDropCursor\n    ];\n}\nfunction iterMatches(doc, re, from, to, f) {\n    re.lastIndex = 0;\n    for(let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length){\n        if (!cursor.lineBreak) while(m = re.exec(cursor.value))f(pos + m.index, m);\n    }\n}\nfunction matchRanges(view, maxLength) {\n    let visible = view.visibleRanges;\n    if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to) return visible;\n    let result = [];\n    for (let { from, to } of visible){\n        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);\n        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);\n        if (result.length && result[result.length - 1].to >= from) result[result.length - 1].to = to;\n        else result.push({\n            from,\n            to\n        });\n    }\n    return result;\n}\n/**\nHelper class used to make it easier to maintain decorations on\nvisible code that matches a given regular expression. To be used\nin a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object\nrepresent a matching configuration.\n*/ class MatchDecorator {\n    /**\n    Create a decorator.\n    */ constructor(config){\n        const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;\n        if (!regexp.global) throw new RangeError(\"The regular expression given to MatchDecorator should have its 'g' flag set\");\n        this.regexp = regexp;\n        if (decorate) {\n            this.addMatch = (match, view, from, add)=>decorate(add, from, from + match[0].length, match, view);\n        } else if (typeof decoration == \"function\") {\n            this.addMatch = (match, view, from, add)=>{\n                let deco = decoration(match, view, from);\n                if (deco) add(from, from + match[0].length, deco);\n            };\n        } else if (decoration) {\n            this.addMatch = (match, _view, from, add)=>add(from, from + match[0].length, decoration);\n        } else {\n            throw new RangeError(\"Either 'decorate' or 'decoration' should be provided to MatchDecorator\");\n        }\n        this.boundary = boundary;\n        this.maxLength = maxLength;\n    }\n    /**\n    Compute the full set of decorations for matches in the given\n    view's viewport. You'll want to call this when initializing your\n    plugin.\n    */ createDeco(view) {\n        let build = new _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSetBuilder(), add = build.add.bind(build);\n        for (let { from, to } of matchRanges(view, this.maxLength))iterMatches(view.state.doc, this.regexp, from, to, (from, m)=>this.addMatch(m, view, from, add));\n        return build.finish();\n    }\n    /**\n    Update a set of decorations for a view update. `deco` _must_ be\n    the set of decorations produced by _this_ `MatchDecorator` for\n    the view state before the update.\n    */ updateDeco(update, deco) {\n        let changeFrom = 1e9, changeTo = -1;\n        if (update.docChanged) update.changes.iterChanges((_f, _t, from, to)=>{\n            if (to >= update.view.viewport.from && from <= update.view.viewport.to) {\n                changeFrom = Math.min(from, changeFrom);\n                changeTo = Math.max(to, changeTo);\n            }\n        });\n        if (update.viewportMoved || changeTo - changeFrom > 1000) return this.createDeco(update.view);\n        if (changeTo > -1) return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);\n        return deco;\n    }\n    updateRange(view, deco, updateFrom, updateTo) {\n        for (let r of view.visibleRanges){\n            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);\n            if (to > from) {\n                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;\n                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);\n                if (this.boundary) {\n                    for(; from > fromLine.from; from--)if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {\n                        start = from;\n                        break;\n                    }\n                    for(; to < toLine.to; to++)if (this.boundary.test(toLine.text[to - toLine.from])) {\n                        end = to;\n                        break;\n                    }\n                }\n                let ranges = [], m;\n                let add = (from, to, deco)=>ranges.push(deco.range(from, to));\n                if (fromLine == toLine) {\n                    this.regexp.lastIndex = start - fromLine.from;\n                    while((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)this.addMatch(m, view, m.index + fromLine.from, add);\n                } else {\n                    iterMatches(view.state.doc, this.regexp, start, end, (from, m)=>this.addMatch(m, view, from, add));\n                }\n                deco = deco.update({\n                    filterFrom: start,\n                    filterTo: end,\n                    filter: (from, to)=>from < start || to > end,\n                    add: ranges\n                });\n            }\n        }\n        return deco;\n    }\n}\nconst UnicodeRegexpSupport = /x/.unicode != null ? \"gu\" : \"g\";\nconst Specials = /*@__PURE__*/ new RegExp(\"[\\x00-\\b\\n-\\x1f\\x7f-\\x9f\\xad؜​‎‏\\u2028\\u2029‭‮⁦⁧⁩\\uFEFF￹-￼]\", UnicodeRegexpSupport);\nconst Names = {\n    0: \"null\",\n    7: \"bell\",\n    8: \"backspace\",\n    10: \"newline\",\n    11: \"vertical tab\",\n    13: \"carriage return\",\n    27: \"escape\",\n    8203: \"zero width space\",\n    8204: \"zero width non-joiner\",\n    8205: \"zero width joiner\",\n    8206: \"left-to-right mark\",\n    8207: \"right-to-left mark\",\n    8232: \"line separator\",\n    8237: \"left-to-right override\",\n    8238: \"right-to-left override\",\n    8294: \"left-to-right isolate\",\n    8295: \"right-to-left isolate\",\n    8297: \"pop directional isolate\",\n    8233: \"paragraph separator\",\n    65279: \"zero width no-break space\",\n    65532: \"object replacement\"\n};\nlet _supportsTabSize = null;\nfunction supportsTabSize() {\n    var _a;\n    if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\n        let styles = document.body.style;\n        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;\n    }\n    return _supportsTabSize || false;\n}\nconst specialCharConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        let config = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(configs, {\n            render: null,\n            specialChars: Specials,\n            addSpecialChars: null\n        });\n        if (config.replaceTabs = !supportsTabSize()) config.specialChars = new RegExp(\"\t|\" + config.specialChars.source, UnicodeRegexpSupport);\n        if (config.addSpecialChars) config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\n        return config;\n    }\n});\n/**\nReturns an extension that installs highlighting of special\ncharacters.\n*/ function highlightSpecialChars(/**\nConfiguration options.\n*/ config = {}) {\n    return [\n        specialCharConfig.of(config),\n        specialCharPlugin()\n    ];\n}\nlet _plugin = null;\nfunction specialCharPlugin() {\n    return _plugin || (_plugin = ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.decorations = Decoration.none;\n            this.decorationCache = Object.create(null);\n            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));\n            this.decorations = this.decorator.createDeco(view);\n        }\n        makeDecorator(conf) {\n            return new MatchDecorator({\n                regexp: conf.specialChars,\n                decoration: (m, view, pos)=>{\n                    let { doc } = view.state;\n                    let code = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.codePointAt)(m[0], 0);\n                    if (code == 9) {\n                        let line = doc.lineAt(pos);\n                        let size = view.state.tabSize, col = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, size, pos - line.from);\n                        return Decoration.replace({\n                            widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)\n                        });\n                    }\n                    return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({\n                        widget: new SpecialCharWidget(conf, code)\n                    }));\n                },\n                boundary: conf.replaceTabs ? undefined : /[^]/\n            });\n        }\n        update(update) {\n            let conf = update.state.facet(specialCharConfig);\n            if (update.startState.facet(specialCharConfig) != conf) {\n                this.decorator = this.makeDecorator(conf);\n                this.decorations = this.decorator.createDeco(update.view);\n            } else {\n                this.decorations = this.decorator.updateDeco(update, this.decorations);\n            }\n        }\n    }, {\n        decorations: (v)=>v.decorations\n    }));\n}\nconst DefaultPlaceholder = \"•\";\n// Assigns placeholder characters from the Control Pictures block to\n// ASCII control characters\nfunction placeholder$1(code) {\n    if (code >= 32) return DefaultPlaceholder;\n    if (code == 10) return \"␤\";\n    return String.fromCharCode(9216 + code);\n}\nclass SpecialCharWidget extends WidgetType {\n    constructor(options, code){\n        super();\n        this.options = options;\n        this.code = code;\n    }\n    eq(other) {\n        return other.code == this.code;\n    }\n    toDOM(view) {\n        let ph = placeholder$1(this.code);\n        let desc = view.state.phrase(\"Control character\") + \" \" + (Names[this.code] || \"0x\" + this.code.toString(16));\n        let custom = this.options.render && this.options.render(this.code, desc, ph);\n        if (custom) return custom;\n        let span = document.createElement(\"span\");\n        span.textContent = ph;\n        span.title = desc;\n        span.setAttribute(\"aria-label\", desc);\n        span.className = \"cm-specialChar\";\n        return span;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nclass TabWidget extends WidgetType {\n    constructor(width){\n        super();\n        this.width = width;\n    }\n    eq(other) {\n        return other.width == this.width;\n    }\n    toDOM() {\n        let span = document.createElement(\"span\");\n        span.textContent = \"\t\";\n        span.className = \"cm-tab\";\n        span.style.width = this.width + \"px\";\n        return span;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\nconst plugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(){\n        this.height = 1000;\n        this.attrs = {\n            style: \"padding-bottom: 1000px\"\n        };\n    }\n    update(update) {\n        let { view } = update;\n        let height = view.viewState.editorHeight - view.defaultLineHeight - view.documentPadding.top - 0.5;\n        if (height >= 0 && height != this.height) {\n            this.height = height;\n            this.attrs = {\n                style: `padding-bottom: ${height}px`\n            };\n        }\n    }\n});\n/**\nReturns an extension that makes sure the content has a bottom\nmargin equivalent to the height of the editor, minus one line\nheight, so that every line in the document can be scrolled to the\ntop of the editor.\n\nThis is only meaningful when the editor is scrollable, and should\nnot be enabled in editors that take the size of their content.\n*/ function scrollPastEnd() {\n    return [\n        plugin,\n        contentAttributes.of((view)=>{\n            var _a;\n            return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null;\n        })\n    ];\n}\n/**\nMark lines that have a cursor on them with the `\"cm-activeLine\"`\nDOM class.\n*/ function highlightActiveLine() {\n    return activeLineHighlighter;\n}\nconst lineDeco = /*@__PURE__*/ Decoration.line({\n    class: \"cm-activeLine\"\n});\nconst activeLineHighlighter = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.docChanged || update.selectionSet) this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let lastLineStart = -1, deco = [];\n        for (let r of view.state.selection.ranges){\n            let line = view.lineBlockAt(r.head);\n            if (line.from > lastLineStart) {\n                deco.push(lineDeco.range(line.from));\n                lastLineStart = line.from;\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: (v)=>v.decorations\n});\nclass Placeholder extends WidgetType {\n    constructor(content){\n        super();\n        this.content = content;\n    }\n    toDOM(view) {\n        let wrap = document.createElement(\"span\");\n        wrap.className = \"cm-placeholder\";\n        wrap.style.pointerEvents = \"none\";\n        wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : typeof this.content == \"function\" ? this.content(view) : this.content.cloneNode(true));\n        if (typeof this.content == \"string\") wrap.setAttribute(\"aria-label\", \"placeholder \" + this.content);\n        else wrap.setAttribute(\"aria-hidden\", \"true\");\n        return wrap;\n    }\n    coordsAt(dom) {\n        let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];\n        if (!rects.length) return null;\n        let style = window.getComputedStyle(dom.parentNode);\n        let rect = flattenRect(rects[0], style.direction != \"rtl\");\n        let lineHeight = parseInt(style.lineHeight);\n        if (rect.bottom - rect.top > lineHeight * 1.5) return {\n            left: rect.left,\n            right: rect.right,\n            top: rect.top,\n            bottom: rect.top + lineHeight\n        };\n        return rect;\n    }\n    ignoreEvent() {\n        return false;\n    }\n}\n/**\nExtension that enables a placeholder—a piece of example content\nto show when the editor is empty.\n*/ function placeholder(content) {\n    return ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.placeholder = content ? Decoration.set([\n                Decoration.widget({\n                    widget: new Placeholder(content),\n                    side: 1\n                }).range(0)\n            ]) : Decoration.none;\n        }\n        get decorations() {\n            return this.view.state.doc.length ? Decoration.none : this.placeholder;\n        }\n    }, {\n        decorations: (v)=>v.decorations\n    });\n}\n// Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);\n    let ranges = [];\n    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);\n        for(let i = startLine; i <= endLine; i++){\n            let line = state.doc.line(i);\n            if (line.length <= endOff) ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + startOff, line.to + endOff));\n        }\n    } else {\n        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);\n        for(let i = startLine; i <= endLine; i++){\n            let line = state.doc.line(i);\n            let start = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, startCol, state.tabSize, true);\n            if (start < 0) {\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.cursor(line.to));\n            } else {\n                let end = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.findColumn)(line.text, endCol, state.tabSize);\n                ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.range(line.from + start, line.from + end));\n            }\n        }\n    }\n    return ranges;\n}\nfunction absoluteColumn(view, x) {\n    let ref = view.coordsAtPos(view.viewport.from);\n    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n    let offset = view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n    }, false);\n    let line = view.state.doc.lineAt(offset), off = offset - line.from;\n    let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.countColumn)(line.text, view.state.tabSize, offset - line.from);\n    return {\n        line: line.number,\n        col,\n        off\n    };\n}\nfunction rectangleSelectionStyle(view, event) {\n    let start = getPos(view, event), startSel = view.state.selection;\n    if (!start) return null;\n    return {\n        update (update) {\n            if (update.docChanged) {\n                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n                let newLine = update.state.doc.lineAt(newStart);\n                start = {\n                    line: newLine.number,\n                    col: start.col,\n                    off: Math.min(start.off, newLine.length)\n                };\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get (event, _extend, multiple) {\n            let cur = getPos(view, event);\n            if (!cur) return startSel;\n            let ranges = rectangleFor(view.state, start, cur);\n            if (!ranges.length) return startSel;\n            if (multiple) return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges.concat(startSel.ranges));\n            else return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.EditorSelection.create(ranges);\n        }\n    };\n}\n/**\nCreate an extension that enables rectangular selections. By\ndefault, it will react to left mouse drag with the Alt key held\ndown. When such a selection occurs, the text within the rectangle\nthat was dragged over will be selected, as one selection\n[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.\n*/ function rectangularSelection(options) {\n    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || ((e)=>e.altKey && e.button == 0);\n    return EditorView.mouseSelectionStyle.of((view, event)=>filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\nconst keys = {\n    Alt: [\n        18,\n        (e)=>!!e.altKey\n    ],\n    Control: [\n        17,\n        (e)=>!!e.ctrlKey\n    ],\n    Shift: [\n        16,\n        (e)=>!!e.shiftKey\n    ],\n    Meta: [\n        91,\n        (e)=>!!e.metaKey\n    ]\n};\nconst showCrosshair = {\n    style: \"cursor: crosshair\"\n};\n/**\nReturns an extension that turns the pointer cursor into a\ncrosshair when a given modifier key, defaulting to Alt, is held\ndown. Can serve as a visual hint that rectangular selection is\ngoing to happen when paired with\n[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).\n*/ function crosshairCursor(options = {}) {\n    let [code, getter] = keys[options.key || \"Alt\"];\n    let plugin = ViewPlugin.fromClass(class {\n        constructor(view){\n            this.view = view;\n            this.isDown = false;\n        }\n        set(isDown) {\n            if (this.isDown != isDown) {\n                this.isDown = isDown;\n                this.view.update([]);\n            }\n        }\n    }, {\n        eventObservers: {\n            keydown (e) {\n                this.set(e.keyCode == code || getter(e));\n            },\n            keyup (e) {\n                if (e.keyCode == code || !getter(e)) this.set(false);\n            },\n            mousemove (e) {\n                this.set(getter(e));\n            }\n        }\n    });\n    return [\n        plugin,\n        EditorView.contentAttributes.of((view)=>{\n            var _a;\n            return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null;\n        })\n    ];\n}\nconst Outside = \"-10000px\";\nclass TooltipViewManager {\n    constructor(view, facet, createTooltipView, removeTooltipView){\n        this.facet = facet;\n        this.createTooltipView = createTooltipView;\n        this.removeTooltipView = removeTooltipView;\n        this.input = view.state.facet(facet);\n        this.tooltips = this.input.filter((t)=>t);\n        let prev = null;\n        this.tooltipViews = this.tooltips.map((t)=>prev = createTooltipView(t, prev));\n    }\n    update(update, above) {\n        var _a;\n        let input = update.state.facet(this.facet);\n        let tooltips = input.filter((x)=>x);\n        if (input === this.input) {\n            for (let t of this.tooltipViews)if (t.update) t.update(update);\n            return false;\n        }\n        let tooltipViews = [], newAbove = above ? [] : null;\n        for(let i = 0; i < tooltips.length; i++){\n            let tip = tooltips[i], known = -1;\n            if (!tip) continue;\n            for(let i = 0; i < this.tooltips.length; i++){\n                let other = this.tooltips[i];\n                if (other && other.create == tip.create) known = i;\n            }\n            if (known < 0) {\n                tooltipViews[i] = this.createTooltipView(tip, i ? tooltipViews[i - 1] : null);\n                if (newAbove) newAbove[i] = !!tip.above;\n            } else {\n                let tooltipView = tooltipViews[i] = this.tooltipViews[known];\n                if (newAbove) newAbove[i] = above[known];\n                if (tooltipView.update) tooltipView.update(update);\n            }\n        }\n        for (let t of this.tooltipViews)if (tooltipViews.indexOf(t) < 0) {\n            this.removeTooltipView(t);\n            (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n        }\n        if (above) {\n            newAbove.forEach((val, i)=>above[i] = val);\n            above.length = newAbove.length;\n        }\n        this.input = input;\n        this.tooltips = tooltips;\n        this.tooltipViews = tooltipViews;\n        return true;\n    }\n}\n/**\nCreates an extension that configures tooltip behavior.\n*/ function tooltips(config = {}) {\n    return tooltipConfig.of(config);\n}\nfunction windowSpace(view) {\n    let docElt = view.dom.ownerDocument.documentElement;\n    return {\n        top: 0,\n        left: 0,\n        bottom: docElt.clientHeight,\n        right: docElt.clientWidth\n    };\n}\nconst tooltipConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>{\n        var _a, _b, _c;\n        return {\n            position: browser.ios ? \"absolute\" : ((_a = values.find((conf)=>conf.position)) === null || _a === void 0 ? void 0 : _a.position) || \"fixed\",\n            parent: ((_b = values.find((conf)=>conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,\n            tooltipSpace: ((_c = values.find((conf)=>conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace\n        };\n    }\n});\nconst knownHeight = /*@__PURE__*/ new WeakMap();\nconst tooltipPlugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.above = [];\n        this.inView = true;\n        this.madeAbsolute = false;\n        this.lastTransaction = 0;\n        this.measureTimeout = -1;\n        let config = view.state.facet(tooltipConfig);\n        this.position = config.position;\n        this.parent = config.parent;\n        this.classes = view.themeClasses;\n        this.createContainer();\n        this.measureReq = {\n            read: this.readMeasure.bind(this),\n            write: this.writeMeasure.bind(this),\n            key: this\n        };\n        this.resizeObserver = typeof ResizeObserver == \"function\" ? new ResizeObserver(()=>this.measureSoon()) : null;\n        this.manager = new TooltipViewManager(view, showTooltip, (t, p)=>this.createTooltip(t, p), (t)=>{\n            if (this.resizeObserver) this.resizeObserver.unobserve(t.dom);\n            t.dom.remove();\n        });\n        this.above = this.manager.tooltips.map((t)=>!!t.above);\n        this.intersectionObserver = typeof IntersectionObserver == \"function\" ? new IntersectionObserver((entries)=>{\n            if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) this.measureSoon();\n        }, {\n            threshold: [\n                1\n            ]\n        }) : null;\n        this.observeIntersection();\n        view.win.addEventListener(\"resize\", this.measureSoon = this.measureSoon.bind(this));\n        this.maybeMeasure();\n    }\n    createContainer() {\n        if (this.parent) {\n            this.container = document.createElement(\"div\");\n            this.container.style.position = \"relative\";\n            this.container.className = this.view.themeClasses;\n            this.parent.appendChild(this.container);\n        } else {\n            this.container = this.view.dom;\n        }\n    }\n    observeIntersection() {\n        if (this.intersectionObserver) {\n            this.intersectionObserver.disconnect();\n            for (let tooltip of this.manager.tooltipViews)this.intersectionObserver.observe(tooltip.dom);\n        }\n    }\n    measureSoon() {\n        if (this.measureTimeout < 0) this.measureTimeout = setTimeout(()=>{\n            this.measureTimeout = -1;\n            this.maybeMeasure();\n        }, 50);\n    }\n    update(update) {\n        if (update.transactions.length) this.lastTransaction = Date.now();\n        let updated = this.manager.update(update, this.above);\n        if (updated) this.observeIntersection();\n        let shouldMeasure = updated || update.geometryChanged;\n        let newConfig = update.state.facet(tooltipConfig);\n        if (newConfig.position != this.position && !this.madeAbsolute) {\n            this.position = newConfig.position;\n            for (let t of this.manager.tooltipViews)t.dom.style.position = this.position;\n            shouldMeasure = true;\n        }\n        if (newConfig.parent != this.parent) {\n            if (this.parent) this.container.remove();\n            this.parent = newConfig.parent;\n            this.createContainer();\n            for (let t of this.manager.tooltipViews)this.container.appendChild(t.dom);\n            shouldMeasure = true;\n        } else if (this.parent && this.view.themeClasses != this.classes) {\n            this.classes = this.container.className = this.view.themeClasses;\n        }\n        if (shouldMeasure) this.maybeMeasure();\n    }\n    createTooltip(tooltip, prev) {\n        let tooltipView = tooltip.create(this.view);\n        let before = prev ? prev.dom : null;\n        tooltipView.dom.classList.add(\"cm-tooltip\");\n        if (tooltip.arrow && !tooltipView.dom.querySelector(\".cm-tooltip > .cm-tooltip-arrow\")) {\n            let arrow = document.createElement(\"div\");\n            arrow.className = \"cm-tooltip-arrow\";\n            tooltipView.dom.appendChild(arrow);\n        }\n        tooltipView.dom.style.position = this.position;\n        tooltipView.dom.style.top = Outside;\n        tooltipView.dom.style.left = \"0px\";\n        this.container.insertBefore(tooltipView.dom, before);\n        if (tooltipView.mount) tooltipView.mount(this.view);\n        if (this.resizeObserver) this.resizeObserver.observe(tooltipView.dom);\n        return tooltipView;\n    }\n    destroy() {\n        var _a, _b, _c;\n        this.view.win.removeEventListener(\"resize\", this.measureSoon);\n        for (let tooltipView of this.manager.tooltipViews){\n            tooltipView.dom.remove();\n            (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);\n        }\n        if (this.parent) this.container.remove();\n        (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n        (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();\n        clearTimeout(this.measureTimeout);\n    }\n    readMeasure() {\n        let scaleX = 1, scaleY = 1, makeAbsolute = false;\n        if (this.position == \"fixed\" && this.manager.tooltipViews.length) {\n            let { dom } = this.manager.tooltipViews[0];\n            if (browser.gecko) {\n                // Firefox sets the element's `offsetParent` to the\n                // transformed element when a transform interferes with fixed\n                // positioning.\n                makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;\n            } else if (dom.style.top == Outside && dom.style.left == \"0px\") {\n                // On other browsers, we have to awkwardly try and use other\n                // information to detect a transform.\n                let rect = dom.getBoundingClientRect();\n                makeAbsolute = Math.abs(rect.top + 10000) > 1 || Math.abs(rect.left) > 1;\n            }\n        }\n        if (makeAbsolute || this.position == \"absolute\") {\n            if (this.parent) {\n                let rect = this.parent.getBoundingClientRect();\n                if (rect.width && rect.height) {\n                    scaleX = rect.width / this.parent.offsetWidth;\n                    scaleY = rect.height / this.parent.offsetHeight;\n                }\n            } else {\n                ({ scaleX, scaleY } = this.view.viewState);\n            }\n        }\n        let visible = this.view.scrollDOM.getBoundingClientRect(), margins = getScrollMargins(this.view);\n        return {\n            visible: {\n                left: visible.left + margins.left,\n                top: visible.top + margins.top,\n                right: visible.right - margins.right,\n                bottom: visible.bottom - margins.bottom\n            },\n            parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),\n            pos: this.manager.tooltips.map((t, i)=>{\n                let tv = this.manager.tooltipViews[i];\n                return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);\n            }),\n            size: this.manager.tooltipViews.map(({ dom })=>dom.getBoundingClientRect()),\n            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),\n            scaleX,\n            scaleY,\n            makeAbsolute\n        };\n    }\n    writeMeasure(measured) {\n        var _a;\n        if (measured.makeAbsolute) {\n            this.madeAbsolute = true;\n            this.position = \"absolute\";\n            for (let t of this.manager.tooltipViews)t.dom.style.position = \"absolute\";\n        }\n        let { visible, space, scaleX, scaleY } = measured;\n        let others = [];\n        for(let i = 0; i < this.manager.tooltips.length; i++){\n            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;\n            let pos = measured.pos[i], size = measured.size[i];\n            // Hide tooltips that are outside of the editor.\n            if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space.top) || pos.top >= Math.min(visible.bottom, space.bottom) || pos.right < Math.max(visible.left, space.left) - .1 || pos.left > Math.min(visible.right, space.right) + .1)) {\n                dom.style.top = Outside;\n                continue;\n            }\n            let arrow = tooltip.arrow ? tView.dom.querySelector(\".cm-tooltip-arrow\") : null;\n            let arrowHeight = arrow ? 7 /* Arrow.Size */  : 0;\n            let width = size.right - size.left, height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;\n            let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;\n            let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.max(space.left, Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */  : 0) + offset.x, space.right - width)) : Math.min(Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */  : 0) - offset.x), space.right - width);\n            let above = this.above[i];\n            if (!tooltip.strictSide && (above ? pos.top - height - arrowHeight - offset.y < space.top : pos.bottom + height + arrowHeight + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top) above = this.above[i] = !above;\n            let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;\n            if (spaceVert < height && tView.resize !== false) {\n                if (spaceVert < this.view.defaultLineHeight) {\n                    dom.style.top = Outside;\n                    continue;\n                }\n                knownHeight.set(tView, height);\n                dom.style.height = (height = spaceVert) / scaleY + \"px\";\n            } else if (dom.style.height) {\n                dom.style.height = \"\";\n            }\n            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;\n            let right = left + width;\n            if (tView.overlap !== true) {\n                for (let r of others)if (r.left < right && r.right > left && r.top < top + height && r.bottom > top) top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;\n            }\n            if (this.position == \"absolute\") {\n                dom.style.top = (top - measured.parent.top) / scaleY + \"px\";\n                setLeftStyle(dom, (left - measured.parent.left) / scaleX);\n            } else {\n                dom.style.top = top / scaleY + \"px\";\n                setLeftStyle(dom, left / scaleX);\n            }\n            if (arrow) {\n                let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */  - 7 /* Arrow.Size */ );\n                arrow.style.left = arrowLeft / scaleX + \"px\";\n            }\n            if (tView.overlap !== true) others.push({\n                left,\n                top,\n                right,\n                bottom: top + height\n            });\n            dom.classList.toggle(\"cm-tooltip-above\", above);\n            dom.classList.toggle(\"cm-tooltip-below\", !above);\n            if (tView.positioned) tView.positioned(measured.space);\n        }\n    }\n    maybeMeasure() {\n        if (this.manager.tooltips.length) {\n            if (this.view.inView) this.view.requestMeasure(this.measureReq);\n            if (this.inView != this.view.inView) {\n                this.inView = this.view.inView;\n                if (!this.inView) for (let tv of this.manager.tooltipViews)tv.dom.style.top = Outside;\n            }\n        }\n    }\n}, {\n    eventObservers: {\n        scroll () {\n            this.maybeMeasure();\n        }\n    }\n});\nfunction setLeftStyle(elt, value) {\n    let current = parseInt(elt.style.left, 10);\n    if (isNaN(current) || Math.abs(value - current) > 1) elt.style.left = value + \"px\";\n}\nconst baseTheme = /*@__PURE__*/ EditorView.baseTheme({\n    \".cm-tooltip\": {\n        zIndex: 500,\n        boxSizing: \"border-box\"\n    },\n    \"&light .cm-tooltip\": {\n        border: \"1px solid #bbb\",\n        backgroundColor: \"#f5f5f5\"\n    },\n    \"&light .cm-tooltip-section:not(:first-child)\": {\n        borderTop: \"1px solid #bbb\"\n    },\n    \"&dark .cm-tooltip\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    },\n    \".cm-tooltip-arrow\": {\n        height: `${7 /* Arrow.Size */ }px`,\n        width: `${7 /* Arrow.Size */  * 2}px`,\n        position: \"absolute\",\n        zIndex: -1,\n        overflow: \"hidden\",\n        \"&:before, &:after\": {\n            content: \"''\",\n            position: \"absolute\",\n            width: 0,\n            height: 0,\n            borderLeft: `${7 /* Arrow.Size */ }px solid transparent`,\n            borderRight: `${7 /* Arrow.Size */ }px solid transparent`\n        },\n        \".cm-tooltip-above &\": {\n            bottom: `-${7 /* Arrow.Size */ }px`,\n            \"&:before\": {\n                borderTop: `${7 /* Arrow.Size */ }px solid #bbb`\n            },\n            \"&:after\": {\n                borderTop: `${7 /* Arrow.Size */ }px solid #f5f5f5`,\n                bottom: \"1px\"\n            }\n        },\n        \".cm-tooltip-below &\": {\n            top: `-${7 /* Arrow.Size */ }px`,\n            \"&:before\": {\n                borderBottom: `${7 /* Arrow.Size */ }px solid #bbb`\n            },\n            \"&:after\": {\n                borderBottom: `${7 /* Arrow.Size */ }px solid #f5f5f5`,\n                top: \"1px\"\n            }\n        }\n    },\n    \"&dark .cm-tooltip .cm-tooltip-arrow\": {\n        \"&:before\": {\n            borderTopColor: \"#333338\",\n            borderBottomColor: \"#333338\"\n        },\n        \"&:after\": {\n            borderTopColor: \"transparent\",\n            borderBottomColor: \"transparent\"\n        }\n    }\n});\nconst noOffset = {\n    x: 0,\n    y: 0\n};\n/**\nFacet to which an extension can add a value to show a tooltip.\n*/ const showTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    enables: [\n        tooltipPlugin,\n        baseTheme\n    ]\n});\nconst showHoverTooltip = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (inputs)=>inputs.reduce((a, i)=>a.concat(i), [])\n});\nclass HoverTooltipHost {\n    // Needs to be static so that host tooltip instances always match\n    static create(view) {\n        return new HoverTooltipHost(view);\n    }\n    constructor(view){\n        this.view = view;\n        this.mounted = false;\n        this.dom = document.createElement(\"div\");\n        this.dom.classList.add(\"cm-tooltip-hover\");\n        this.manager = new TooltipViewManager(view, showHoverTooltip, (t, p)=>this.createHostedView(t, p), (t)=>t.dom.remove());\n    }\n    createHostedView(tooltip, prev) {\n        let hostedView = tooltip.create(this.view);\n        hostedView.dom.classList.add(\"cm-tooltip-section\");\n        this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);\n        if (this.mounted && hostedView.mount) hostedView.mount(this.view);\n        return hostedView;\n    }\n    mount(view) {\n        for (let hostedView of this.manager.tooltipViews){\n            if (hostedView.mount) hostedView.mount(view);\n        }\n        this.mounted = true;\n    }\n    positioned(space) {\n        for (let hostedView of this.manager.tooltipViews){\n            if (hostedView.positioned) hostedView.positioned(space);\n        }\n    }\n    update(update) {\n        this.manager.update(update);\n    }\n    destroy() {\n        var _a;\n        for (let t of this.manager.tooltipViews)(_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);\n    }\n    passProp(name) {\n        let value = undefined;\n        for (let view of this.manager.tooltipViews){\n            let given = view[name];\n            if (given !== undefined) {\n                if (value === undefined) value = given;\n                else if (value !== given) return undefined;\n            }\n        }\n        return value;\n    }\n    get offset() {\n        return this.passProp(\"offset\");\n    }\n    get getCoords() {\n        return this.passProp(\"getCoords\");\n    }\n    get overlap() {\n        return this.passProp(\"overlap\");\n    }\n    get resize() {\n        return this.passProp(\"resize\");\n    }\n}\nconst showHoverTooltipHost = /*@__PURE__*/ showTooltip.compute([\n    showHoverTooltip\n], (state)=>{\n    let tooltips = state.facet(showHoverTooltip);\n    if (tooltips.length === 0) return null;\n    return {\n        pos: Math.min(...tooltips.map((t)=>t.pos)),\n        end: Math.max(...tooltips.map((t)=>{\n            var _a;\n            return (_a = t.end) !== null && _a !== void 0 ? _a : t.pos;\n        })),\n        create: HoverTooltipHost.create,\n        above: tooltips[0].above,\n        arrow: tooltips.some((t)=>t.arrow)\n    };\n});\nclass HoverPlugin {\n    constructor(view, source, field, setHover, hoverTime){\n        this.view = view;\n        this.source = source;\n        this.field = field;\n        this.setHover = setHover;\n        this.hoverTime = hoverTime;\n        this.hoverTimeout = -1;\n        this.restartTimeout = -1;\n        this.pending = null;\n        this.lastMove = {\n            x: 0,\n            y: 0,\n            target: view.dom,\n            time: 0\n        };\n        this.checkHover = this.checkHover.bind(this);\n        view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n        view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n    }\n    update() {\n        if (this.pending) {\n            this.pending = null;\n            clearTimeout(this.restartTimeout);\n            this.restartTimeout = setTimeout(()=>this.startHover(), 20);\n        }\n    }\n    get active() {\n        return this.view.state.field(this.field);\n    }\n    checkHover() {\n        this.hoverTimeout = -1;\n        if (this.active.length) return;\n        let hovered = Date.now() - this.lastMove.time;\n        if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);\n        else this.startHover();\n    }\n    startHover() {\n        clearTimeout(this.restartTimeout);\n        let { view, lastMove } = this;\n        let desc = view.docView.nearest(lastMove.target);\n        if (!desc) return;\n        let pos, side = 1;\n        if (desc instanceof WidgetView) {\n            pos = desc.posAtStart;\n        } else {\n            pos = view.posAtCoords(lastMove);\n            if (pos == null) return;\n            let posCoords = view.coordsAtPos(pos);\n            if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth) return;\n            let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find((s)=>s.from <= pos && s.to >= pos);\n            let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;\n            side = lastMove.x < posCoords.left ? -rtl : rtl;\n        }\n        let open = this.source(view, pos, side);\n        if (open === null || open === void 0 ? void 0 : open.then) {\n            let pending = this.pending = {\n                pos\n            };\n            open.then((result)=>{\n                if (this.pending == pending) {\n                    this.pending = null;\n                    if (result && !(Array.isArray(result) && !result.length)) view.dispatch({\n                        effects: this.setHover.of(Array.isArray(result) ? result : [\n                            result\n                        ])\n                    });\n                }\n            }, (e)=>logException(view.state, e, \"hover tooltip\"));\n        } else if (open && !(Array.isArray(open) && !open.length)) {\n            view.dispatch({\n                effects: this.setHover.of(Array.isArray(open) ? open : [\n                    open\n                ])\n            });\n        }\n    }\n    get tooltip() {\n        let plugin = this.view.plugin(tooltipPlugin);\n        let index = plugin ? plugin.manager.tooltips.findIndex((t)=>t.create == HoverTooltipHost.create) : -1;\n        return index > -1 ? plugin.manager.tooltipViews[index] : null;\n    }\n    mousemove(event) {\n        var _a, _b;\n        this.lastMove = {\n            x: event.clientX,\n            y: event.clientY,\n            target: event.target,\n            time: Date.now()\n        };\n        if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);\n        let { active, tooltip } = this;\n        if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {\n            let { pos } = active[0] || this.pending, end = (_b = (_a = active[0]) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : pos;\n            if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {\n                this.view.dispatch({\n                    effects: this.setHover.of([])\n                });\n                this.pending = null;\n            }\n        }\n    }\n    mouseleave(event) {\n        clearTimeout(this.hoverTimeout);\n        this.hoverTimeout = -1;\n        let { active } = this;\n        if (active.length) {\n            let { tooltip } = this;\n            let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);\n            if (!inTooltip) this.view.dispatch({\n                effects: this.setHover.of([])\n            });\n            else this.watchTooltipLeave(tooltip.dom);\n        }\n    }\n    watchTooltipLeave(tooltip) {\n        let watch = (event)=>{\n            tooltip.removeEventListener(\"mouseleave\", watch);\n            if (this.active.length && !this.view.dom.contains(event.relatedTarget)) this.view.dispatch({\n                effects: this.setHover.of([])\n            });\n        };\n        tooltip.addEventListener(\"mouseleave\", watch);\n    }\n    destroy() {\n        clearTimeout(this.hoverTimeout);\n        this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n        this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n    }\n}\nconst tooltipMargin = 4;\nfunction isInTooltip(tooltip, event) {\n    let { left, right, top, bottom } = tooltip.getBoundingClientRect(), arrow;\n    if (arrow = tooltip.querySelector(\".cm-tooltip-arrow\")) {\n        let arrowRect = arrow.getBoundingClientRect();\n        top = Math.min(arrowRect.top, top);\n        bottom = Math.max(arrowRect.bottom, bottom);\n    }\n    return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin && event.clientY >= top - tooltipMargin && event.clientY <= bottom + tooltipMargin;\n}\nfunction isOverRange(view, from, to, x, y, margin) {\n    let rect = view.scrollDOM.getBoundingClientRect();\n    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;\n    if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y) return false;\n    let pos = view.posAtCoords({\n        x,\n        y\n    }, false);\n    return pos >= from && pos <= to;\n}\n/**\nSet up a hover tooltip, which shows up when the pointer hovers\nover ranges of text. The callback is called when the mouse hovers\nover the document text. It should, if there is a tooltip\nassociated with position `pos`, return the tooltip description\n(either directly or in a promise). The `side` argument indicates\non which side of the position the pointer is—it will be -1 if the\npointer is before the position, 1 if after the position.\n\nNote that all hover tooltips are hosted within a single tooltip\ncontainer element. This allows multiple tooltips over the same\nrange to be \"merged\" together without overlapping.\n\nThe return value is a valid [editor extension](https://codemirror.net/6/docs/ref/#state.Extension)\nbut also provides an `active` property holding a state field that\ncan be used to read the currently active tooltips produced by this\nextension.\n*/ function hoverTooltip(source, options = {}) {\n    let setHover = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n    let hoverState = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateField.define({\n        create () {\n            return [];\n        },\n        update (value, tr) {\n            if (value.length) {\n                if (options.hideOnChange && (tr.docChanged || tr.selection)) value = [];\n                else if (options.hideOn) value = value.filter((v)=>!options.hideOn(tr, v));\n                if (tr.docChanged) {\n                    let mapped = [];\n                    for (let tooltip of value){\n                        let newPos = tr.changes.mapPos(tooltip.pos, -1, _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackDel);\n                        if (newPos != null) {\n                            let copy = Object.assign(Object.create(null), tooltip);\n                            copy.pos = newPos;\n                            if (copy.end != null) copy.end = tr.changes.mapPos(copy.end);\n                            mapped.push(copy);\n                        }\n                    }\n                    value = mapped;\n                }\n            }\n            for (let effect of tr.effects){\n                if (effect.is(setHover)) value = effect.value;\n                if (effect.is(closeHoverTooltipEffect)) value = [];\n            }\n            return value;\n        },\n        provide: (f)=>showHoverTooltip.from(f)\n    });\n    return {\n        active: hoverState,\n        extension: [\n            hoverState,\n            ViewPlugin.define((view)=>new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */ )),\n            showHoverTooltipHost\n        ]\n    };\n}\n/**\nGet the active tooltip view for a given tooltip, if available.\n*/ function getTooltip(view, tooltip) {\n    let plugin = view.plugin(tooltipPlugin);\n    if (!plugin) return null;\n    let found = plugin.manager.tooltips.indexOf(tooltip);\n    return found < 0 ? null : plugin.manager.tooltipViews[found];\n}\n/**\nReturns true if any hover tooltips are currently active.\n*/ function hasHoverTooltips(state) {\n    return state.facet(showHoverTooltip).some((x)=>x);\n}\nconst closeHoverTooltipEffect = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.StateEffect.define();\n/**\nTransaction effect that closes all hover tooltips.\n*/ const closeHoverTooltips = /*@__PURE__*/ closeHoverTooltipEffect.of(null);\n/**\nTell the tooltip extension to recompute the position of the active\ntooltips. This can be useful when something happens (such as a\nre-positioning or CSS change affecting the editor) that could\ninvalidate the existing tooltip positions.\n*/ function repositionTooltips(view) {\n    let plugin = view.plugin(tooltipPlugin);\n    if (plugin) plugin.maybeMeasure();\n}\nconst panelConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (configs) {\n        let topContainer, bottomContainer;\n        for (let c of configs){\n            topContainer = topContainer || c.topContainer;\n            bottomContainer = bottomContainer || c.bottomContainer;\n        }\n        return {\n            topContainer,\n            bottomContainer\n        };\n    }\n});\n/**\nConfigures the panel-managing extension.\n*/ function panels(config) {\n    return config ? [\n        panelConfig.of(config)\n    ] : [];\n}\n/**\nGet the active panel created by the given constructor, if any.\nThis can be useful when you need access to your panels' DOM\nstructure.\n*/ function getPanel(view, panel) {\n    let plugin = view.plugin(panelPlugin);\n    let index = plugin ? plugin.specs.indexOf(panel) : -1;\n    return index > -1 ? plugin.panels[index] : null;\n}\nconst panelPlugin = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.input = view.state.facet(showPanel);\n        this.specs = this.input.filter((s)=>s);\n        this.panels = this.specs.map((spec)=>spec(view));\n        let conf = view.state.facet(panelConfig);\n        this.top = new PanelGroup(view, true, conf.topContainer);\n        this.bottom = new PanelGroup(view, false, conf.bottomContainer);\n        this.top.sync(this.panels.filter((p)=>p.top));\n        this.bottom.sync(this.panels.filter((p)=>!p.top));\n        for (let p of this.panels){\n            p.dom.classList.add(\"cm-panel\");\n            if (p.mount) p.mount();\n        }\n    }\n    update(update) {\n        let conf = update.state.facet(panelConfig);\n        if (this.top.container != conf.topContainer) {\n            this.top.sync([]);\n            this.top = new PanelGroup(update.view, true, conf.topContainer);\n        }\n        if (this.bottom.container != conf.bottomContainer) {\n            this.bottom.sync([]);\n            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);\n        }\n        this.top.syncClasses();\n        this.bottom.syncClasses();\n        let input = update.state.facet(showPanel);\n        if (input != this.input) {\n            let specs = input.filter((x)=>x);\n            let panels = [], top = [], bottom = [], mount = [];\n            for (let spec of specs){\n                let known = this.specs.indexOf(spec), panel;\n                if (known < 0) {\n                    panel = spec(update.view);\n                    mount.push(panel);\n                } else {\n                    panel = this.panels[known];\n                    if (panel.update) panel.update(update);\n                }\n                panels.push(panel);\n                (panel.top ? top : bottom).push(panel);\n            }\n            this.specs = specs;\n            this.panels = panels;\n            this.top.sync(top);\n            this.bottom.sync(bottom);\n            for (let p of mount){\n                p.dom.classList.add(\"cm-panel\");\n                if (p.mount) p.mount();\n            }\n        } else {\n            for (let p of this.panels)if (p.update) p.update(update);\n        }\n    }\n    destroy() {\n        this.top.sync([]);\n        this.bottom.sync([]);\n    }\n}, {\n    provide: (plugin)=>EditorView.scrollMargins.of((view)=>{\n            let value = view.plugin(plugin);\n            return value && {\n                top: value.top.scrollMargin(),\n                bottom: value.bottom.scrollMargin()\n            };\n        })\n});\nclass PanelGroup {\n    constructor(view, top, container){\n        this.view = view;\n        this.top = top;\n        this.container = container;\n        this.dom = undefined;\n        this.classes = \"\";\n        this.panels = [];\n        this.syncClasses();\n    }\n    sync(panels) {\n        for (let p of this.panels)if (p.destroy && panels.indexOf(p) < 0) p.destroy();\n        this.panels = panels;\n        this.syncDOM();\n    }\n    syncDOM() {\n        if (this.panels.length == 0) {\n            if (this.dom) {\n                this.dom.remove();\n                this.dom = undefined;\n            }\n            return;\n        }\n        if (!this.dom) {\n            this.dom = document.createElement(\"div\");\n            this.dom.className = this.top ? \"cm-panels cm-panels-top\" : \"cm-panels cm-panels-bottom\";\n            this.dom.style[this.top ? \"top\" : \"bottom\"] = \"0\";\n            let parent = this.container || this.view.dom;\n            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);\n        }\n        let curDOM = this.dom.firstChild;\n        for (let panel of this.panels){\n            if (panel.dom.parentNode == this.dom) {\n                while(curDOM != panel.dom)curDOM = rm(curDOM);\n                curDOM = curDOM.nextSibling;\n            } else {\n                this.dom.insertBefore(panel.dom, curDOM);\n            }\n        }\n        while(curDOM)curDOM = rm(curDOM);\n    }\n    scrollMargin() {\n        return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);\n    }\n    syncClasses() {\n        if (!this.container || this.classes == this.view.themeClasses) return;\n        for (let cls of this.classes.split(\" \"))if (cls) this.container.classList.remove(cls);\n        for (let cls of (this.classes = this.view.themeClasses).split(\" \"))if (cls) this.container.classList.add(cls);\n    }\n}\nfunction rm(node) {\n    let next = node.nextSibling;\n    node.remove();\n    return next;\n}\n/**\nOpening a panel is done by providing a constructor function for\nthe panel through this facet. (The panel is closed again when its\nconstructor is no longer provided.) Values of `null` are ignored.\n*/ const showPanel = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    enables: panelPlugin\n});\n/**\nA gutter marker represents a bit of information attached to a line\nin a specific gutter. Your own custom markers have to extend this\nclass.\n*/ class GutterMarker extends _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeValue {\n    /**\n    @internal\n    */ compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    Compare this marker to another marker of the same type.\n    */ eq(other) {\n        return false;\n    }\n    /**\n    Called if the marker has a `toDOM` method and its representation\n    was removed from a gutter.\n    */ destroy(dom) {}\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.toDOM = undefined;\nGutterMarker.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.MapMode.TrackBefore;\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\nGutterMarker.prototype.point = true;\n/**\nFacet used to add a class to all gutter elements for a given line.\nMarkers given to this facet should _only_ define an\n[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a\n[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear\nin all gutters for the line).\n*/ const gutterLineClass = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nFacet used to add a class to all gutter elements next to a widget.\nShould not provide widgets with a `toDOM` method.\n*/ const gutterWidgetClass = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst defaults = {\n    class: \"\",\n    renderEmptyElements: false,\n    elementStyle: \"\",\n    markers: ()=>_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.empty,\n    lineMarker: ()=>null,\n    widgetMarker: ()=>null,\n    lineMarkerChange: null,\n    initialSpacer: null,\n    updateSpacer: null,\n    domEventHandlers: {}\n};\nconst activeGutters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nDefine an editor gutter. The order in which the gutters appear is\ndetermined by their extension priority.\n*/ function gutter(config) {\n    return [\n        gutters(),\n        activeGutters.of(Object.assign(Object.assign({}, defaults), config))\n    ];\n}\nconst unfixGutters = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine: (values)=>values.some((x)=>x)\n});\n/**\nThe gutter-drawing plugin is automatically enabled when you add a\ngutter, but you can use this function to explicitly configure it.\n\nUnless `fixed` is explicitly set to `false`, the gutters are\nfixed, meaning they don't scroll along with the content\nhorizontally (except on Internet Explorer, which doesn't support\nCSS [`position:\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\n*/ function gutters(config) {\n    let result = [\n        gutterView\n    ];\n    if (config && config.fixed === false) result.push(unfixGutters.of(true));\n    return result;\n}\nconst gutterView = /*@__PURE__*/ ViewPlugin.fromClass(class {\n    constructor(view){\n        this.view = view;\n        this.prevViewport = view.viewport;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutters\";\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + \"px\";\n        this.gutters = view.state.facet(activeGutters).map((conf)=>new SingleGutterView(view, conf));\n        for (let gutter of this.gutters)this.dom.appendChild(gutter.dom);\n        this.fixed = !view.state.facet(unfixGutters);\n        if (this.fixed) {\n            // FIXME IE11 fallback, which doesn't support position: sticky,\n            // by using position: relative + event handlers that realign the\n            // gutter (or just force fixed=false on IE11?)\n            this.dom.style.position = \"sticky\";\n        }\n        this.syncGutters(false);\n        view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n    }\n    update(update) {\n        if (this.updateGutters(update)) {\n            // Detach during sync when the viewport changed significantly\n            // (such as during scrolling), since for large updates that is\n            // faster.\n            let vpA = this.prevViewport, vpB = update.view.viewport;\n            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);\n            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);\n        }\n        if (update.geometryChanged) {\n            this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + \"px\";\n        }\n        if (this.view.state.facet(unfixGutters) != !this.fixed) {\n            this.fixed = !this.fixed;\n            this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n        }\n        this.prevViewport = update.view.viewport;\n    }\n    syncGutters(detach) {\n        let after = this.dom.nextSibling;\n        if (detach) this.dom.remove();\n        let lineClasses = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\n        let classSet = [];\n        let contexts = this.gutters.map((gutter)=>new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));\n        for (let line of this.view.viewportLineBlocks){\n            if (classSet.length) classSet = [];\n            if (Array.isArray(line.type)) {\n                let first = true;\n                for (let b of line.type){\n                    if (b.type == BlockType.Text && first) {\n                        advanceCursor(lineClasses, classSet, b.from);\n                        for (let cx of contexts)cx.line(this.view, b, classSet);\n                        first = false;\n                    } else if (b.widget) {\n                        for (let cx of contexts)cx.widget(this.view, b);\n                    }\n                }\n            } else if (line.type == BlockType.Text) {\n                advanceCursor(lineClasses, classSet, line.from);\n                for (let cx of contexts)cx.line(this.view, line, classSet);\n            } else if (line.widget) {\n                for (let cx of contexts)cx.widget(this.view, line);\n            }\n        }\n        for (let cx of contexts)cx.finish();\n        if (detach) this.view.scrollDOM.insertBefore(this.dom, after);\n    }\n    updateGutters(update) {\n        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);\n        let change = update.docChanged || update.heightChanged || update.viewportChanged || !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\n        if (prev == cur) {\n            for (let gutter of this.gutters)if (gutter.update(update)) change = true;\n        } else {\n            change = true;\n            let gutters = [];\n            for (let conf of cur){\n                let known = prev.indexOf(conf);\n                if (known < 0) {\n                    gutters.push(new SingleGutterView(this.view, conf));\n                } else {\n                    this.gutters[known].update(update);\n                    gutters.push(this.gutters[known]);\n                }\n            }\n            for (let g of this.gutters){\n                g.dom.remove();\n                if (gutters.indexOf(g) < 0) g.destroy();\n            }\n            for (let g of gutters)this.dom.appendChild(g.dom);\n            this.gutters = gutters;\n        }\n        return change;\n    }\n    destroy() {\n        for (let view of this.gutters)view.destroy();\n        this.dom.remove();\n    }\n}, {\n    provide: (plugin)=>EditorView.scrollMargins.of((view)=>{\n            let value = view.plugin(plugin);\n            if (!value || value.gutters.length == 0 || !value.fixed) return null;\n            return view.textDirection == Direction.LTR ? {\n                left: value.dom.offsetWidth * view.scaleX\n            } : {\n                right: value.dom.offsetWidth * view.scaleX\n            };\n        })\n});\nfunction asArray(val) {\n    return Array.isArray(val) ? val : [\n        val\n    ];\n}\nfunction advanceCursor(cursor, collect, pos) {\n    while(cursor.value && cursor.from <= pos){\n        if (cursor.from == pos) collect.push(cursor.value);\n        cursor.next();\n    }\n}\nclass UpdateContext {\n    constructor(gutter, viewport, height){\n        this.gutter = gutter;\n        this.height = height;\n        this.i = 0;\n        this.cursor = _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.iter(gutter.markers, viewport.from);\n    }\n    addElement(view, block, markers) {\n        let { gutter } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;\n        if (this.i == gutter.elements.length) {\n            let newElt = new GutterElement(view, height, above, markers);\n            gutter.elements.push(newElt);\n            gutter.dom.appendChild(newElt.dom);\n        } else {\n            gutter.elements[this.i].update(view, height, above, markers);\n        }\n        this.height = block.bottom;\n        this.i++;\n    }\n    line(view, line, extraMarkers) {\n        let localMarkers = [];\n        advanceCursor(this.cursor, localMarkers, line.from);\n        if (extraMarkers.length) localMarkers = localMarkers.concat(extraMarkers);\n        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);\n        if (forLine) localMarkers.unshift(forLine);\n        let gutter = this.gutter;\n        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements) return;\n        this.addElement(view, line, localMarkers);\n    }\n    widget(view, block) {\n        let marker = this.gutter.config.widgetMarker(view, block.widget, block), markers = marker ? [\n            marker\n        ] : null;\n        for (let cls of view.state.facet(gutterWidgetClass)){\n            let marker = cls(view, block.widget, block);\n            if (marker) (markers || (markers = [])).push(marker);\n        }\n        if (markers) this.addElement(view, block, markers);\n    }\n    finish() {\n        let gutter = this.gutter;\n        while(gutter.elements.length > this.i){\n            let last = gutter.elements.pop();\n            gutter.dom.removeChild(last.dom);\n            last.destroy();\n        }\n    }\n}\nclass SingleGutterView {\n    constructor(view, config){\n        this.view = view;\n        this.config = config;\n        this.elements = [];\n        this.spacer = null;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n        for(let prop in config.domEventHandlers){\n            this.dom.addEventListener(prop, (event)=>{\n                let target = event.target, y;\n                if (target != this.dom && this.dom.contains(target)) {\n                    while(target.parentNode != this.dom)target = target.parentNode;\n                    let rect = target.getBoundingClientRect();\n                    y = (rect.top + rect.bottom) / 2;\n                } else {\n                    y = event.clientY;\n                }\n                let line = view.lineBlockAtHeight(y - view.documentTop);\n                if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();\n            });\n        }\n        this.markers = asArray(config.markers(view));\n        if (config.initialSpacer) {\n            this.spacer = new GutterElement(view, 0, 0, [\n                config.initialSpacer(view)\n            ]);\n            this.dom.appendChild(this.spacer.dom);\n            this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n        }\n    }\n    update(update) {\n        let prevMarkers = this.markers;\n        this.markers = asArray(this.config.markers(update.view));\n        if (this.spacer && this.config.updateSpacer) {\n            let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n            if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [\n                updated\n            ]);\n        }\n        let vp = update.view.viewport;\n        return !_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);\n    }\n    destroy() {\n        for (let elt of this.elements)elt.destroy();\n    }\n}\nclass GutterElement {\n    constructor(view, height, above, markers){\n        this.height = -1;\n        this.above = 0;\n        this.markers = [];\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutterElement\";\n        this.update(view, height, above, markers);\n    }\n    update(view, height, above, markers) {\n        if (this.height != height) {\n            this.height = height;\n            this.dom.style.height = height + \"px\";\n        }\n        if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n        if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);\n    }\n    setMarkers(view, markers) {\n        let cls = \"cm-gutterElement\", domPos = this.dom.firstChild;\n        for(let iNew = 0, iOld = 0;;){\n            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;\n            if (marker) {\n                let c = marker.elementClass;\n                if (c) cls += \" \" + c;\n                for(let i = iOld; i < this.markers.length; i++)if (this.markers[i].compare(marker)) {\n                    skipTo = i;\n                    matched = true;\n                    break;\n                }\n            } else {\n                skipTo = this.markers.length;\n            }\n            while(iOld < skipTo){\n                let next = this.markers[iOld++];\n                if (next.toDOM) {\n                    next.destroy(domPos);\n                    let after = domPos.nextSibling;\n                    domPos.remove();\n                    domPos = after;\n                }\n            }\n            if (!marker) break;\n            if (marker.toDOM) {\n                if (matched) domPos = domPos.nextSibling;\n                else this.dom.insertBefore(marker.toDOM(view), domPos);\n            }\n            if (matched) iOld++;\n        }\n        this.dom.className = cls;\n        this.markers = markers;\n    }\n    destroy() {\n        this.setMarkers(null, []); // First argument not used unless creating markers\n    }\n}\nfunction sameMarkers(a, b) {\n    if (a.length != b.length) return false;\n    for(let i = 0; i < a.length; i++)if (!a[i].compare(b[i])) return false;\n    return true;\n}\n/**\nFacet used to provide markers to the line number gutter.\n*/ const lineNumberMarkers = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\n/**\nFacet used to create markers in the line number gutter next to widgets.\n*/ const lineNumberWidgetMarker = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define();\nconst lineNumberConfig = /*@__PURE__*/ _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.Facet.define({\n    combine (values) {\n        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_2__.combineConfig)(values, {\n            formatNumber: String,\n            domEventHandlers: {}\n        }, {\n            domEventHandlers (a, b) {\n                let result = Object.assign({}, a);\n                for(let event in b){\n                    let exists = result[event], add = b[event];\n                    result[event] = exists ? (view, line, event)=>exists(view, line, event) || add(view, line, event) : add;\n                }\n                return result;\n            }\n        });\n    }\n});\nclass NumberMarker extends GutterMarker {\n    constructor(number){\n        super();\n        this.number = number;\n    }\n    eq(other) {\n        return this.number == other.number;\n    }\n    toDOM() {\n        return document.createTextNode(this.number);\n    }\n}\nfunction formatNumber(view, number) {\n    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\nconst lineNumberGutter = /*@__PURE__*/ activeGutters.compute([\n    lineNumberConfig\n], (state)=>({\n        class: \"cm-lineNumbers\",\n        renderEmptyElements: false,\n        markers (view) {\n            return view.state.facet(lineNumberMarkers);\n        },\n        lineMarker (view, line, others) {\n            if (others.some((m)=>m.toDOM)) return null;\n            return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n        },\n        widgetMarker: (view, widget, block)=>{\n            for (let m of view.state.facet(lineNumberWidgetMarker)){\n                let result = m(view, widget, block);\n                if (result) return result;\n            }\n            return null;\n        },\n        lineMarkerChange: (update)=>update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),\n        initialSpacer (view) {\n            return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n        },\n        updateSpacer (spacer, update) {\n            let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n            return max == spacer.number ? spacer : new NumberMarker(max);\n        },\n        domEventHandlers: state.facet(lineNumberConfig).domEventHandlers\n    }));\n/**\nCreate a line number gutter extension.\n*/ function lineNumbers(config = {}) {\n    return [\n        lineNumberConfig.of(config),\n        gutters(),\n        lineNumberGutter\n    ];\n}\nfunction maxLineNumber(lines) {\n    let last = 9;\n    while(last < lines)last = last * 10 + 9;\n    return last;\n}\nconst activeLineGutterMarker = /*@__PURE__*/ new class extends GutterMarker {\n    constructor(){\n        super(...arguments);\n        this.elementClass = \"cm-activeLineGutter\";\n    }\n};\nconst activeLineGutterHighlighter = /*@__PURE__*/ gutterLineClass.compute([\n    \"selection\"\n], (state)=>{\n    let marks = [], last = -1;\n    for (let range of state.selection.ranges){\n        let linePos = state.doc.lineAt(range.head).from;\n        if (linePos > last) {\n            last = linePos;\n            marks.push(activeLineGutterMarker.range(linePos));\n        }\n    }\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_2__.RangeSet.of(marks);\n});\n/**\nReturns an extension that adds a `cm-activeLineGutter` class to\nall gutter elements on the [active\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\n*/ function highlightActiveLineGutter() {\n    return activeLineGutterHighlighter;\n}\nfunction matcher(decorator) {\n    return ViewPlugin.define((view)=>({\n            decorations: decorator.createDeco(view),\n            update (u) {\n                this.decorations = decorator.updateDeco(u, this.decorations);\n            }\n        }), {\n        decorations: (v)=>v.decorations\n    });\n}\nconst tabDeco = /*@__PURE__*/ Decoration.mark({\n    class: \"cm-highlightTab\"\n});\nconst spaceDeco = /*@__PURE__*/ Decoration.mark({\n    class: \"cm-highlightSpace\"\n});\nconst whitespaceHighlighter = /*@__PURE__*/ matcher(/*@__PURE__*/ new MatchDecorator({\n    regexp: /\\t| /g,\n    decoration: (match)=>match[0] == \"\t\" ? tabDeco : spaceDeco,\n    boundary: /\\S/\n}));\n/**\nReturns an extension that highlights whitespace, adding a\n`cm-highlightSpace` class to stretches of spaces, and a\n`cm-highlightTab` class to individual tab characters. By default,\nthe former are shown as faint dots, and the latter as arrows.\n*/ function highlightWhitespace() {\n    return whitespaceHighlighter;\n}\nconst trailingHighlighter = /*@__PURE__*/ matcher(/*@__PURE__*/ new MatchDecorator({\n    regexp: /\\s+$/g,\n    decoration: /*@__PURE__*/ Decoration.mark({\n        class: \"cm-trailingSpace\"\n    }),\n    boundary: /\\S/\n}));\n/**\nReturns an extension that adds a `cm-trailingSpace` class to all\ntrailing whitespace.\n*/ function highlightTrailingWhitespace() {\n    return trailingHighlighter;\n}\n/**\n@internal\n*/ const __test = {\n    HeightMap,\n    HeightOracle,\n    MeasuredHeights,\n    QueryType,\n    ChangedRange,\n    computeOrder,\n    moveVisually,\n    clearHeightChangeFlag,\n    getHeightChangeFlag: ()=>heightChangeFlag\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcVM7QUFDN1A7QUFDVztBQUVuRCxTQUFTeUIsYUFBYUMsSUFBSTtJQUN0QixJQUFJQztJQUNKLDhEQUE4RDtJQUM5RCw0REFBNEQ7SUFDNUQsWUFBWTtJQUNaLElBQUlELEtBQUtFLFFBQVEsSUFBSSxJQUFJO1FBQ3JCRCxTQUFTRCxLQUFLRCxZQUFZLEdBQUdDLE9BQU9BLEtBQUtHLGFBQWE7SUFDMUQsT0FDSztRQUNERixTQUFTRDtJQUNiO0lBQ0EsT0FBT0MsT0FBT0YsWUFBWTtBQUM5QjtBQUNBLFNBQVNLLFNBQVNDLEdBQUcsRUFBRUMsSUFBSTtJQUN2QixPQUFPQSxPQUFPRCxPQUFPQyxRQUFRRCxJQUFJRCxRQUFRLENBQUNFLEtBQUtKLFFBQVEsSUFBSSxJQUFJSSxLQUFLQyxVQUFVLEdBQUdELFFBQVE7QUFDN0Y7QUFDQSxTQUFTRSxhQUFhSCxHQUFHLEVBQUVJLFNBQVM7SUFDaEMsSUFBSSxDQUFDQSxVQUFVQyxVQUFVLEVBQ3JCLE9BQU87SUFDWCxJQUFJO1FBQ0EsK0RBQStEO1FBQy9ELDhEQUE4RDtRQUM5RCxXQUFXO1FBQ1gsT0FBT04sU0FBU0MsS0FBS0ksVUFBVUMsVUFBVTtJQUM3QyxFQUNBLE9BQU9DLEdBQUc7UUFDTixPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNDLGVBQWVQLEdBQUc7SUFDdkIsSUFBSUEsSUFBSUgsUUFBUSxJQUFJLEdBQ2hCLE9BQU9XLFVBQVVSLEtBQUssR0FBR0EsSUFBSVMsU0FBUyxDQUFDQyxNQUFNLEVBQUVDLGNBQWM7U0FDNUQsSUFBSVgsSUFBSUgsUUFBUSxJQUFJLEdBQ3JCLE9BQU9HLElBQUlXLGNBQWM7U0FFekIsT0FBTyxFQUFFO0FBQ2pCO0FBQ0EscUVBQXFFO0FBQ3JFLGtFQUFrRTtBQUNs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LHFCQUFxQixJQUFNMTBCO0FBQWlCO0FBRXNtQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hhY2tuaWNoZS8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci92aWV3L2Rpc3QvaW5kZXguanM/ODdjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0LCBSYW5nZVNldCwgTWFwTW9kZSwgUmFuZ2VWYWx1ZSwgZmluZENsdXN0ZXJCcmVhaywgRWRpdG9yU2VsZWN0aW9uLCBGYWNldCwgU3RhdGVFZmZlY3QsIENoYW5nZVNldCwgZmluZENvbHVtbiwgQ2hhckNhdGVnb3J5LCBFZGl0b3JTdGF0ZSwgQW5ub3RhdGlvbiwgVHJhbnNhY3Rpb24sIFByZWMsIGNvZGVQb2ludEF0LCBjb2RlUG9pbnRTaXplLCBjb21iaW5lQ29uZmlnLCBTdGF0ZUZpZWxkLCBSYW5nZVNldEJ1aWxkZXIsIGNvdW50Q29sdW1uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xuaW1wb3J0IHsga2V5TmFtZSwgYmFzZSwgc2hpZnQgfSBmcm9tICd3M2Mta2V5bmFtZSc7XG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihyb290KSB7XG4gICAgbGV0IHRhcmdldDtcbiAgICAvLyBCcm93c2VycyBkaWZmZXIgb24gd2hldGhlciBzaGFkb3cgcm9vdHMgaGF2ZSBhIGdldFNlbGVjdGlvblxuICAgIC8vIG1ldGhvZC4gSWYgaXQgZXhpc3RzLCB1c2UgdGhhdCwgb3RoZXJ3aXNlLCBjYWxsIGl0IG9uIHRoZVxuICAgIC8vIGRvY3VtZW50LlxuICAgIGlmIChyb290Lm5vZGVUeXBlID09IDExKSB7IC8vIFNoYWRvdyByb290XG4gICAgICAgIHRhcmdldCA9IHJvb3QuZ2V0U2VsZWN0aW9uID8gcm9vdCA6IHJvb3Qub3duZXJEb2N1bWVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldCA9IHJvb3Q7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQuZ2V0U2VsZWN0aW9uKCk7XG59XG5mdW5jdGlvbiBjb250YWlucyhkb20sIG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSA/IGRvbSA9PSBub2RlIHx8IGRvbS5jb250YWlucyhub2RlLm5vZGVUeXBlICE9IDEgPyBub2RlLnBhcmVudE5vZGUgOiBub2RlKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uKGRvbSwgc2VsZWN0aW9uKSB7XG4gICAgaWYgKCFzZWxlY3Rpb24uYW5jaG9yTm9kZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEZpcmVmb3ggd2lsbCByYWlzZSAncGVybWlzc2lvbiBkZW5pZWQnIGVycm9ycyB3aGVuIGFjY2Vzc2luZ1xuICAgICAgICAvLyBwcm9wZXJ0aWVzIG9mIGBzZWwuYW5jaG9yTm9kZWAgd2hlbiBpdCdzIGluIGEgZ2VuZXJhdGVkIENTU1xuICAgICAgICAvLyBlbGVtZW50LlxuICAgICAgICByZXR1cm4gY29udGFpbnMoZG9tLCBzZWxlY3Rpb24uYW5jaG9yTm9kZSk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGllbnRSZWN0c0Zvcihkb20pIHtcbiAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiB0ZXh0UmFuZ2UoZG9tLCAwLCBkb20ubm9kZVZhbHVlLmxlbmd0aCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgcmV0dXJuIGRvbS5nZXRDbGllbnRSZWN0cygpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIFtdO1xufVxuLy8gU2NhbnMgZm9yd2FyZCBhbmQgYmFja3dhcmQgdGhyb3VnaCBET00gcG9zaXRpb25zIGVxdWl2YWxlbnQgdG8gdGhlXG4vLyBnaXZlbiBvbmUgdG8gc2VlIGlmIHRoZSB0d28gYXJlIGluIHRoZSBzYW1lIHBsYWNlIChpLmUuIGFmdGVyIGFcbi8vIHRleHQgbm9kZSB2cyBhdCB0aGUgZW5kIG9mIHRoYXQgdGV4dCBub2RlKVxuZnVuY3Rpb24gaXNFcXVpdmFsZW50UG9zaXRpb24obm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYpIHtcbiAgICByZXR1cm4gdGFyZ2V0Tm9kZSA/IChzY2FuRm9yKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmLCAtMSkgfHxcbiAgICAgICAgc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgMSkpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBkb21JbmRleChub2RlKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOzsgaW5kZXgrKykge1xuICAgICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0Jsb2NrRWxlbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMSAmJiAvXihESVZ8UHxMSXxVTHxPTHxCTE9DS1FVT1RFfEREfERUfEhcXGR8U0VDVElPTnxQUkUpJC8udGVzdChub2RlLm5vZGVOYW1lKTtcbn1cbmZ1bmN0aW9uIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIGRpcikge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvZmYgPT0gKGRpciA8IDAgPyAwIDogbWF4T2Zmc2V0KG5vZGUpKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gXCJESVZcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgb2ZmID0gZG9tSW5kZXgobm9kZSkgKyAoZGlyIDwgMCA/IDAgOiAxKTtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZiArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG5vZGUuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkaXIgPCAwID8gbWF4T2Zmc2V0KG5vZGUpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1heE9mZnNldChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBmbGF0dGVuUmVjdChyZWN0LCBsZWZ0KSB7XG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICByZXR1cm4geyBsZWZ0OiB4LCByaWdodDogeCwgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LmJvdHRvbSB9O1xufVxuZnVuY3Rpb24gd2luZG93UmVjdCh3aW4pIHtcbiAgICBsZXQgdnAgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gICAgaWYgKHZwKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogMCwgcmlnaHQ6IHZwLndpZHRoLFxuICAgICAgICAgICAgdG9wOiAwLCBib3R0b206IHZwLmhlaWdodFxuICAgICAgICB9O1xuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiB3aW4uaW5uZXJXaWR0aCxcbiAgICAgICAgdG9wOiAwLCBib3R0b206IHdpbi5pbm5lckhlaWdodCB9O1xufVxuZnVuY3Rpb24gZ2V0U2NhbGUoZWx0LCByZWN0KSB7XG4gICAgbGV0IHNjYWxlWCA9IHJlY3Qud2lkdGggLyBlbHQub2Zmc2V0V2lkdGg7XG4gICAgbGV0IHNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gZWx0Lm9mZnNldEhlaWdodDtcbiAgICBpZiAoc2NhbGVYID4gMC45OTUgJiYgc2NhbGVYIDwgMS4wMDUgfHwgIWlzRmluaXRlKHNjYWxlWCkgfHwgTWF0aC5hYnMocmVjdC53aWR0aCAtIGVsdC5vZmZzZXRXaWR0aCkgPCAxKVxuICAgICAgICBzY2FsZVggPSAxO1xuICAgIGlmIChzY2FsZVkgPiAwLjk5NSAmJiBzY2FsZVkgPCAxLjAwNSB8fCAhaXNGaW5pdGUoc2NhbGVZKSB8fCBNYXRoLmFicyhyZWN0LmhlaWdodCAtIGVsdC5vZmZzZXRIZWlnaHQpIDwgMSlcbiAgICAgICAgc2NhbGVZID0gMTtcbiAgICByZXR1cm4geyBzY2FsZVgsIHNjYWxlWSB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsUmVjdEludG9WaWV3KGRvbSwgcmVjdCwgc2lkZSwgeCwgeSwgeE1hcmdpbiwgeU1hcmdpbiwgbHRyKSB7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbSwgc3RvcCA9IGZhbHNlOyBjdXIgJiYgIXN0b3A7KSB7XG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSkgeyAvLyBFbGVtZW50XG4gICAgICAgICAgICBsZXQgYm91bmRpbmcsIHRvcCA9IGN1ciA9PSBkb2MuYm9keTtcbiAgICAgICAgICAgIGxldCBzY2FsZVggPSAxLCBzY2FsZVkgPSAxO1xuICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgIGJvdW5kaW5nID0gd2luZG93UmVjdCh3aW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKC9eKGZpeGVkfHN0aWNreSkkLy50ZXN0KGdldENvbXB1dGVkU3R5bGUoY3VyKS5wb3NpdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuc2Nyb2xsSGVpZ2h0IDw9IGN1ci5jbGllbnRIZWlnaHQgJiYgY3VyLnNjcm9sbFdpZHRoIDw9IGN1ci5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlY3QgPSBjdXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgKHsgc2NhbGVYLCBzY2FsZVkgfSA9IGdldFNjYWxlKGN1ciwgcmVjdCkpO1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzY3JvbGxiYXIgd2lkdGggaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIGJvdW5kaW5nID0geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBjdXIuY2xpZW50V2lkdGggKiBzY2FsZVgsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBjdXIuY2xpZW50SGVpZ2h0ICogc2NhbGVZIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbW92ZVggPSAwLCBtb3ZlWSA9IDA7XG4gICAgICAgICAgICBpZiAoeSA9PSBcIm5lYXJlc3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LnRvcCA8IGJvdW5kaW5nLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QudG9wIC0gKGJvdW5kaW5nLnRvcCArIHlNYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA+IDAgJiYgcmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20gKyBtb3ZlWSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVZID0gcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIChyZWN0LnRvcCAtIG1vdmVZKSA8IGJvdW5kaW5nLnRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVZID0gcmVjdC50b3AgLSAoYm91bmRpbmcudG9wICsgeU1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3RIZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wLCBib3VuZGluZ0hlaWdodCA9IGJvdW5kaW5nLmJvdHRvbSAtIGJvdW5kaW5nLnRvcDtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0VG9wID0geSA9PSBcImNlbnRlclwiICYmIHJlY3RIZWlnaHQgPD0gYm91bmRpbmdIZWlnaHQgPyByZWN0LnRvcCArIHJlY3RIZWlnaHQgLyAyIC0gYm91bmRpbmdIZWlnaHQgLyAyIDpcbiAgICAgICAgICAgICAgICAgICAgeSA9PSBcInN0YXJ0XCIgfHwgeSA9PSBcImNlbnRlclwiICYmIHNpZGUgPCAwID8gcmVjdC50b3AgLSB5TWFyZ2luIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QuYm90dG9tIC0gYm91bmRpbmdIZWlnaHQgKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgIG1vdmVZID0gdGFyZ2V0VG9wIC0gYm91bmRpbmcudG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPT0gXCJuZWFyZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IHJlY3QubGVmdCAtIChib3VuZGluZy5sZWZ0ICsgeE1hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWRlID4gMCAmJiByZWN0LnJpZ2h0ID4gYm91bmRpbmcucmlnaHQgKyBtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQgKyBtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5sZWZ0IC0gKGJvdW5kaW5nLmxlZnQgKyB4TWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0TGVmdCA9IHggPT0gXCJjZW50ZXJcIiA/IHJlY3QubGVmdCArIChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDIgLSAoYm91bmRpbmcucmlnaHQgLSBib3VuZGluZy5sZWZ0KSAvIDIgOlxuICAgICAgICAgICAgICAgICAgICAoeCA9PSBcInN0YXJ0XCIpID09IGx0ciA/IHJlY3QubGVmdCAtIHhNYXJnaW4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5yaWdodCAtIChib3VuZGluZy5yaWdodCAtIGJvdW5kaW5nLmxlZnQpICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICBtb3ZlWCA9IHRhcmdldExlZnQgLSBib3VuZGluZy5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgICAgICB3aW4uc2Nyb2xsQnkobW92ZVgsIG1vdmVZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3ZlZFggPSAwLCBtb3ZlZFkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZVkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGN1ci5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIuc2Nyb2xsVG9wICs9IG1vdmVZIC8gc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWRZID0gKGN1ci5zY3JvbGxUb3AgLSBzdGFydCkgKiBzY2FsZVk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBjdXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxMZWZ0ICs9IG1vdmVYIC8gc2NhbGVYO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZWRYID0gKGN1ci5zY3JvbGxMZWZ0IC0gc3RhcnQpICogc2NhbGVYO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IHJlY3QubGVmdCAtIG1vdmVkWCwgdG9wOiByZWN0LnRvcCAtIG1vdmVkWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0IC0gbW92ZWRYLCBib3R0b206IHJlY3QuYm90dG9tIC0gbW92ZWRZIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlZFggJiYgTWF0aC5hYnMobW92ZWRYIC0gbW92ZVgpIDwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBcIm5lYXJlc3RcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmVkWSAmJiBNYXRoLmFicyhtb3ZlZFkgLSBtb3ZlWSkgPCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IFwibmVhcmVzdFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZy50b3AgfHwgcmVjdC5ib3R0b20gPiBib3VuZGluZy5ib3R0b20gfHxcbiAgICAgICAgICAgICAgICByZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0IHx8IHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodClcbiAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBNYXRoLm1heChyZWN0LmxlZnQsIGJvdW5kaW5nLmxlZnQpLCByaWdodDogTWF0aC5taW4ocmVjdC5yaWdodCwgYm91bmRpbmcucmlnaHQpLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IE1hdGgubWF4KHJlY3QudG9wLCBib3VuZGluZy50b3ApLCBib3R0b206IE1hdGgubWluKHJlY3QuYm90dG9tLCBib3VuZGluZy5ib3R0b20pIH07XG4gICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxMSkgeyAvLyBBIHNoYWRvdyByb290XG4gICAgICAgICAgICBjdXIgPSBjdXIuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2Nyb2xsYWJsZVBhcmVudHMoZG9tKSB7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB4LCB5O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbS5wYXJlbnROb2RlOyBjdXI7KSB7XG4gICAgICAgIGlmIChjdXIgPT0gZG9jLmJvZHkgfHwgKHggJiYgeSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1ci5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoIXkgJiYgY3VyLnNjcm9sbEhlaWdodCA+IGN1ci5jbGllbnRIZWlnaHQpXG4gICAgICAgICAgICAgICAgeSA9IGN1cjtcbiAgICAgICAgICAgIGlmICgheCAmJiBjdXIuc2Nyb2xsV2lkdGggPiBjdXIuY2xpZW50V2lkdGgpXG4gICAgICAgICAgICAgICAgeCA9IGN1cjtcbiAgICAgICAgICAgIGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyLm5vZGVUeXBlID09IDExKSB7XG4gICAgICAgICAgICBjdXIgPSBjdXIuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHgsIHkgfTtcbn1cbmNsYXNzIERPTVNlbGVjdGlvblN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBlcShkb21TZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yTm9kZSA9PSBkb21TZWwuYW5jaG9yTm9kZSAmJiB0aGlzLmFuY2hvck9mZnNldCA9PSBkb21TZWwuYW5jaG9yT2Zmc2V0ICYmXG4gICAgICAgICAgICB0aGlzLmZvY3VzTm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIHRoaXMuZm9jdXNPZmZzZXQgPT0gZG9tU2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgICBzZXRSYW5nZShyYW5nZSkge1xuICAgICAgICBsZXQgeyBhbmNob3JOb2RlLCBmb2N1c05vZGUgfSA9IHJhbmdlO1xuICAgICAgICAvLyBDbGlwIG9mZnNldHMgdG8gbm9kZSBzaXplIHRvIGF2b2lkIGNyYXNoZXMgd2hlbiBTYWZhcmkgcmVwb3J0cyBib2d1cyBvZmZzZXRzICgjMTE1MilcbiAgICAgICAgdGhpcy5zZXQoYW5jaG9yTm9kZSwgTWF0aC5taW4ocmFuZ2UuYW5jaG9yT2Zmc2V0LCBhbmNob3JOb2RlID8gbWF4T2Zmc2V0KGFuY2hvck5vZGUpIDogMCksIGZvY3VzTm9kZSwgTWF0aC5taW4ocmFuZ2UuZm9jdXNPZmZzZXQsIGZvY3VzTm9kZSA/IG1heE9mZnNldChmb2N1c05vZGUpIDogMCkpO1xuICAgIH1cbiAgICBzZXQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IGFuY2hvck5vZGU7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gYW5jaG9yT2Zmc2V0O1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IGZvY3VzTm9kZTtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IGZvY3VzT2Zmc2V0O1xuICAgIH1cbn1cbmxldCBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gbnVsbDtcbi8vIEZlYXR1cmUtZGV0ZWN0cyBzdXBwb3J0IGZvciAuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KSwgYW5kIHVzZXNcbi8vIGEgZmFsbGJhY2sga2x1ZGdlIHdoZW4gbm90IHN1cHBvcnRlZC5cbmZ1bmN0aW9uIGZvY3VzUHJldmVudFNjcm9sbChkb20pIHtcbiAgICBpZiAoZG9tLnNldEFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGRvbS5zZXRBY3RpdmUoKTsgLy8gaW4gSUVcbiAgICBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKTtcbiAgICBsZXQgc3RhY2sgPSBbXTtcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgc3RhY2sucHVzaChjdXIsIGN1ci5zY3JvbGxUb3AsIGN1ci5zY3JvbGxMZWZ0KTtcbiAgICAgICAgaWYgKGN1ciA9PSBjdXIub3duZXJEb2N1bWVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCA9PSBudWxsID8ge1xuICAgICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSB7IHByZXZlbnRTY3JvbGw6IHRydWUgfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZWx0ID0gc3RhY2tbaSsrXSwgdG9wID0gc3RhY2tbaSsrXSwgbGVmdCA9IHN0YWNrW2krK107XG4gICAgICAgICAgICBpZiAoZWx0LnNjcm9sbFRvcCAhPSB0b3ApXG4gICAgICAgICAgICAgICAgZWx0LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgICAgICAgIGlmIChlbHQuc2Nyb2xsTGVmdCAhPSBsZWZ0KVxuICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBzY3JhdGNoUmFuZ2U7XG5mdW5jdGlvbiB0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgbGV0IHJhbmdlID0gc2NyYXRjaFJhbmdlIHx8IChzY3JhdGNoUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpKTtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgdG8pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20pO1xuICAgIHJldHVybiByYW5nZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoS2V5KGVsdCwgbmFtZSwgY29kZSwgbW9kcykge1xuICAgIGxldCBvcHRpb25zID0geyBrZXk6IG5hbWUsIGNvZGU6IG5hbWUsIGtleUNvZGU6IGNvZGUsIHdoaWNoOiBjb2RlLCBjYW5jZWxhYmxlOiB0cnVlIH07XG4gICAgaWYgKG1vZHMpXG4gICAgICAgICh7IGFsdEtleTogb3B0aW9ucy5hbHRLZXksIGN0cmxLZXk6IG9wdGlvbnMuY3RybEtleSwgc2hpZnRLZXk6IG9wdGlvbnMuc2hpZnRLZXksIG1ldGFLZXk6IG9wdGlvbnMubWV0YUtleSB9ID0gbW9kcyk7XG4gICAgbGV0IGRvd24gPSBuZXcgS2V5Ym9hcmRFdmVudChcImtleWRvd25cIiwgb3B0aW9ucyk7XG4gICAgZG93bi5zeW50aGV0aWMgPSB0cnVlO1xuICAgIGVsdC5kaXNwYXRjaEV2ZW50KGRvd24pO1xuICAgIGxldCB1cCA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5dXBcIiwgb3B0aW9ucyk7XG4gICAgdXAuc3ludGhldGljID0gdHJ1ZTtcbiAgICBlbHQuZGlzcGF0Y2hFdmVudCh1cCk7XG4gICAgcmV0dXJuIGRvd24uZGVmYXVsdFByZXZlbnRlZCB8fCB1cC5kZWZhdWx0UHJldmVudGVkO1xufVxuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT0gOSB8fCBub2RlLm5vZGVUeXBlID09IDExICYmIG5vZGUuaG9zdCkpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuYXNzaWduZWRTbG90IHx8IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbGVhckF0dHJpYnV0ZXMobm9kZSkge1xuICAgIHdoaWxlIChub2RlLmF0dHJpYnV0ZXMubGVuZ3RoKVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZU5vZGUobm9kZS5hdHRyaWJ1dGVzWzBdKTtcbn1cbmZ1bmN0aW9uIGF0RWxlbWVudFN0YXJ0KGRvYywgc2VsZWN0aW9uKSB7XG4gICAgbGV0IG5vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlIHx8IHNlbGVjdGlvbi5hbmNob3JOb2RlICE9IG5vZGUgfHwgc2VsZWN0aW9uLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBTYWZhcmkgY2FuIHJlcG9ydCBib2d1cyBvZmZzZXRzICgjMTE1MilcbiAgICBvZmZzZXQgPSBNYXRoLm1pbihvZmZzZXQsIG1heE9mZnNldChub2RlKSk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXYuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwcmV2O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlID09IGRvYykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1Njcm9sbGVkVG9Cb3R0b20oZWx0KSB7XG4gICAgcmV0dXJuIGVsdC5zY3JvbGxUb3AgPiBNYXRoLm1heCgxLCBlbHQuc2Nyb2xsSGVpZ2h0IC0gZWx0LmNsaWVudEhlaWdodCAtIDQpO1xufVxuZnVuY3Rpb24gdGV4dE5vZGVCZWZvcmUoc3RhcnROb2RlLCBzdGFydE9mZnNldCkge1xuICAgIGZvciAobGV0IG5vZGUgPSBzdGFydE5vZGUsIG9mZnNldCA9IHN0YXJ0T2Zmc2V0OzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiBub2RlLCBvZmZzZXQ6IG9mZnNldCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIG9mZnNldCA9IG1heE9mZnNldChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgJiYgIWlzQmxvY2tFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHROb2RlQWZ0ZXIoc3RhcnROb2RlLCBzdGFydE9mZnNldCkge1xuICAgIGZvciAobGV0IG5vZGUgPSBzdGFydE5vZGUsIG9mZnNldCA9IHN0YXJ0T2Zmc2V0OzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyAmJiBvZmZzZXQgPCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG5vZGUsIG9mZnNldDogb2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAmJiAhaXNCbG9ja0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpICsgMTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgRE9NUG9zIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvZmZzZXQsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnByZWNpc2UgPSBwcmVjaXNlO1xuICAgIH1cbiAgICBzdGF0aWMgYmVmb3JlKGRvbSwgcHJlY2lzZSkgeyByZXR1cm4gbmV3IERPTVBvcyhkb20ucGFyZW50Tm9kZSwgZG9tSW5kZXgoZG9tKSwgcHJlY2lzZSk7IH1cbiAgICBzdGF0aWMgYWZ0ZXIoZG9tLCBwcmVjaXNlKSB7IHJldHVybiBuZXcgRE9NUG9zKGRvbS5wYXJlbnROb2RlLCBkb21JbmRleChkb20pICsgMSwgcHJlY2lzZSk7IH1cbn1cbmNvbnN0IG5vQ2hpbGRyZW4gPSBbXTtcbmNsYXNzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IG51bGw7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBnZXQgcG9zQXRTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQucG9zQmVmb3JlKHRoaXMpIDogMDtcbiAgICB9XG4gICAgZ2V0IHBvc0F0RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIHBvc0JlZm9yZSh2aWV3KSB7XG4gICAgICAgIGxldCBwb3MgPSB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCA9PSB2aWV3KVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGQubGVuZ3RoICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY2hpbGQgaW4gcG9zQmVmb3JlXCIpO1xuICAgIH1cbiAgICBwb3NBZnRlcih2aWV3KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc0JlZm9yZSh2aWV3KSArIHZpZXcubGVuZ3RoO1xuICAgIH1cbiAgICBzeW5jKHZpZXcsIHRyYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzICYgMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi8pIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmRvbTtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbnVsbCwgbmV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZmxhZ3MgJiA3IC8qIFZpZXdGbGFnLkRpcnR5ICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQuZG9tICYmIChuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50VmlldyA9IENvbnRlbnRWaWV3LmdldChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudFZpZXcgfHwgIWNvbnRlbnRWaWV3LnBhcmVudCAmJiBjb250ZW50Vmlldy5jYW5SZXVzZURPTShjaGlsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQucmV1c2VET00obmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmZsYWdzICY9IH43IC8qIFZpZXdGbGFnLkRpcnR5ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2sgJiYgIXRyYWNrLndyaXR0ZW4gJiYgdHJhY2subm9kZSA9PSBwYXJlbnQgJiYgbmV4dCAhPSBjaGlsZC5kb20pXG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dCAhPSBjaGlsZC5kb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcm0kMShuZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQuZG9tLCBuZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldiA9IGNoaWxkLmRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBwcmV2ID8gcHJldi5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKG5leHQgJiYgdHJhY2sgJiYgdHJhY2subm9kZSA9PSBwYXJlbnQpXG4gICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAobmV4dClcbiAgICAgICAgICAgICAgICBuZXh0ID0gcm0kMShuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZsYWdzICYgMSAvKiBWaWV3RmxhZy5DaGlsZERpcnR5ICovKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5mbGFncyAmIDcgLyogVmlld0ZsYWcuRGlydHkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmZsYWdzICY9IH43IC8qIFZpZXdGbGFnLkRpcnR5ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXVzZURPTShfZG9tKSB7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBhZnRlcjtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy5kb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJpYXMgPSBtYXhPZmZzZXQobm9kZSkgPT0gMCA/IDAgOiBvZmZzZXQgPT0gMCA/IC0xIDogMTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChiaWFzID09IDAgJiYgcGFyZW50LmZpcnN0Q2hpbGQgIT0gcGFyZW50Lmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQuZmlyc3RDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpYXMgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYmlhcyA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmlhcyA8IDApXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBub2RlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZ0ZXIgPT0gdGhpcy5kb20uZmlyc3RDaGlsZClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB3aGlsZSAoYWZ0ZXIgJiYgIUNvbnRlbnRWaWV3LmdldChhZnRlcikpXG4gICAgICAgICAgICBhZnRlciA9IGFmdGVyLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5kb20gPT0gYWZ0ZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjaGlsZC5sZW5ndGggKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZChmcm9tLCB0bywgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgZnJvbUkgPSAtMSwgZnJvbVN0YXJ0ID0gLTEsIHRvSSA9IC0xLCB0b0VuZCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gb2Zmc2V0LCBwcmV2RW5kID0gb2Zmc2V0OyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gcG9zICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGZyb20gJiYgZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRvbUJvdW5kc0Fyb3VuZChmcm9tLCB0bywgcG9zKTtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gZnJvbSAmJiBmcm9tSSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGZyb21JID0gaTtcbiAgICAgICAgICAgICAgICBmcm9tU3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zID4gdG8gJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0b0kgPSBpO1xuICAgICAgICAgICAgICAgIHRvRW5kID0gcHJldkVuZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZFbmQgPSBlbmQ7XG4gICAgICAgICAgICBwb3MgPSBlbmQgKyBjaGlsZC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb206IGZyb21TdGFydCwgdG86IHRvRW5kIDwgMCA/IG9mZnNldCArIHRoaXMubGVuZ3RoIDogdG9FbmQsXG4gICAgICAgICAgICBzdGFydERPTTogKGZyb21JID8gdGhpcy5jaGlsZHJlbltmcm9tSSAtIDFdLmRvbS5uZXh0U2libGluZyA6IG51bGwpIHx8IHRoaXMuZG9tLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBlbmRET006IHRvSSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHRvSSA+PSAwID8gdGhpcy5jaGlsZHJlblt0b0ldLmRvbSA6IG51bGwgfTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGFuZFBhcmVudCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgfD0gMiAvKiBWaWV3RmxhZy5Ob2RlRGlydHkgKi87XG4gICAgICAgIHRoaXMubWFya1BhcmVudHNEaXJ0eShhbmRQYXJlbnQpO1xuICAgIH1cbiAgICBtYXJrUGFyZW50c0RpcnR5KGNoaWxkTGlzdCkge1xuICAgICAgICBmb3IgKGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDsgcGFyZW50OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRMaXN0KVxuICAgICAgICAgICAgICAgIHBhcmVudC5mbGFncyB8PSAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZmxhZ3MgJiAxIC8qIFZpZXdGbGFnLkNoaWxkRGlydHkgKi8pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcGFyZW50LmZsYWdzIHw9IDEgLyogVmlld0ZsYWcuQ2hpbGREaXJ0eSAqLztcbiAgICAgICAgICAgIGNoaWxkTGlzdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICE9IHBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAodGhpcy5mbGFncyAmIDcgLyogVmlld0ZsYWcuRGlydHkgKi8pXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrUGFyZW50c0RpcnR5KHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldERPTShkb20pIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5kb20uY21WaWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBkb207XG4gICAgICAgIGRvbS5jbVZpZXcgPSB0aGlzO1xuICAgIH1cbiAgICBnZXQgcm9vdFZpZXcoKSB7XG4gICAgICAgIGZvciAobGV0IHYgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB2LnBhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgdiA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlQ2hpbGRyZW4oZnJvbSwgdG8sIGNoaWxkcmVuID0gbm9DaGlsZHJlbikge1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ID09IHRoaXMgJiYgY2hpbGRyZW4uaW5kZXhPZihjaGlsZCkgPCAwKVxuICAgICAgICAgICAgICAgIGNoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoIDwgMjUwKVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoZnJvbSwgdG8gLSBmcm9tLCAuLi5jaGlsZHJlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXS5jb25jYXQodGhpcy5jaGlsZHJlbi5zbGljZSgwLCBmcm9tKSwgY2hpbGRyZW4sIHRoaXMuY2hpbGRyZW4uc2xpY2UodG8pKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNoaWxkcmVuW2ldLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oX3JlYykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZ25vcmVFdmVudChfZXZlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY2hpbGRDdXJzb3IocG9zID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGlsZEN1cnNvcih0aGlzLmNoaWxkcmVuLCBwb3MsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB9XG4gICAgY2hpbGRQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZEN1cnNvcigpLmZpbmRQb3MocG9zLCBiaWFzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLnJlcGxhY2UoXCJWaWV3XCIsIFwiXCIpO1xuICAgICAgICByZXR1cm4gbmFtZSArICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgdGhpcy5jaGlsZHJlbi5qb2luKCkgKyBcIilcIiA6XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA/IFwiW1wiICsgKG5hbWUgPT0gXCJUZXh0XCIgPyB0aGlzLnRleHQgOiB0aGlzLmxlbmd0aCkgKyBcIl1cIiA6IFwiXCIpICtcbiAgICAgICAgICAgICh0aGlzLmJyZWFrQWZ0ZXIgPyBcIiNcIiA6IFwiXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KG5vZGUpIHsgcmV0dXJuIG5vZGUuY21WaWV3OyB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlzV2lkZ2V0KCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY2FuUmV1c2VET00ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLmNvbnN0cnVjdG9yID09IHRoaXMuY29uc3RydWN0b3IgJiYgISgodGhpcy5mbGFncyB8IG90aGVyLmZsYWdzKSAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pO1xuICAgIH1cbiAgICAvLyBXaGVuIHRoaXMgaXMgYSB6ZXJvLWxlbmd0aCB2aWV3IHdpdGggYSBzaWRlLCB0aGlzIHNob3VsZCByZXR1cm4gYVxuICAgIC8vIG51bWJlciA8PSAwIHRvIGluZGljYXRlIGl0IGlzIGJlZm9yZSBpdHMgcG9zaXRpb24sIG9yIGFcbiAgICAvLyBudW1iZXIgPiAwIHdoZW4gYWZ0ZXIgaXRzIHBvc2l0aW9uLlxuICAgIGdldFNpZGUoKSB7IHJldHVybiAwOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQgPT0gdGhpcylcbiAgICAgICAgICAgICAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB9XG59XG5Db250ZW50Vmlldy5wcm90b3R5cGUuYnJlYWtBZnRlciA9IDA7XG4vLyBSZW1vdmUgYSBET00gbm9kZSBhbmQgcmV0dXJuIGl0cyBuZXh0IHNpYmxpbmcuXG5mdW5jdGlvbiBybSQxKGRvbSkge1xuICAgIGxldCBuZXh0ID0gZG9tLm5leHRTaWJsaW5nO1xuICAgIGRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbSk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG5jbGFzcyBDaGlsZEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIHBvcywgaSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmkgPSBpO1xuICAgICAgICB0aGlzLm9mZiA9IDA7XG4gICAgfVxuICAgIGZpbmRQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAocG9zID4gdGhpcy5wb3MgfHwgcG9zID09IHRoaXMucG9zICYmXG4gICAgICAgICAgICAgICAgKGJpYXMgPiAwIHx8IHRoaXMuaSA9PSAwIHx8IHRoaXMuY2hpbGRyZW5bdGhpcy5pIC0gMV0uYnJlYWtBZnRlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZiA9IHBvcyAtIHRoaXMucG9zO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuWy0tdGhpcy5pXTtcbiAgICAgICAgICAgIHRoaXMucG9zIC09IG5leHQubGVuZ3RoICsgbmV4dC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlKHBhcmVudCwgZnJvbUksIGZyb21PZmYsIHRvSSwgdG9PZmYsIGluc2VydCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBsZXQgeyBjaGlsZHJlbiB9ID0gcGFyZW50O1xuICAgIGxldCBiZWZvcmUgPSBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlbltmcm9tSV0gOiBudWxsO1xuICAgIGxldCBsYXN0ID0gaW5zZXJ0Lmxlbmd0aCA/IGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIGxldCBicmVha0F0RW5kID0gbGFzdCA/IGxhc3QuYnJlYWtBZnRlciA6IGJyZWFrQXRTdGFydDtcbiAgICAvLyBDaGFuZ2Ugd2l0aGluIGEgc2luZ2xlIGNoaWxkXG4gICAgaWYgKGZyb21JID09IHRvSSAmJiBiZWZvcmUgJiYgIWJyZWFrQXRTdGFydCAmJiAhYnJlYWtBdEVuZCAmJiBpbnNlcnQubGVuZ3RoIDwgMiAmJlxuICAgICAgICBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgdG9PZmYsIGluc2VydC5sZW5ndGggPyBsYXN0IDogbnVsbCwgZnJvbU9mZiA9PSAwLCBvcGVuU3RhcnQsIG9wZW5FbmQpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHRvSSA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSBjaGlsZHJlblt0b0ldO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGVuZCBvZiB0aGUgY2hpbGQgYWZ0ZXIgdGhlIHVwZGF0ZSBpcyBwcmVzZXJ2ZWQgaW4gYGFmdGVyYFxuICAgICAgICBpZiAoYWZ0ZXIgJiYgKHRvT2ZmIDwgYWZ0ZXIubGVuZ3RoIHx8IGFmdGVyLmJyZWFrQWZ0ZXIgJiYgKGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC5icmVha0FmdGVyKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHNwbGl0dGluZyBhIGNoaWxkLCBzZXBhcmF0ZSBwYXJ0IG9mIGl0IHRvIGF2b2lkIHRoYXRcbiAgICAgICAgICAgIC8vIGJlaW5nIG1hbmdsZWQgd2hlbiB1cGRhdGluZyB0aGUgY2hpbGQgYmVmb3JlIHRoZSB1cGRhdGUuXG4gICAgICAgICAgICBpZiAoZnJvbUkgPT0gdG9JKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5zcGxpdCh0b09mZik7XG4gICAgICAgICAgICAgICAgdG9PZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIHJlcGxhY2VtZW50IHNob3VsZCBiZSBtZXJnZWQgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgcmVwbGFjaW5nIGVsZW1lbnQsIHVwZGF0ZSBgY29udGVudGBcbiAgICAgICAgICAgIGlmICghYnJlYWtBdEVuZCAmJiBsYXN0ICYmIGFmdGVyLm1lcmdlKDAsIHRvT2ZmLCBsYXN0LCB0cnVlLCAwLCBvcGVuRW5kKSkge1xuICAgICAgICAgICAgICAgIGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0gPSBhZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc3RhcnQgb2YgdGhlIGFmdGVyIGVsZW1lbnQsIGlmIG5lY2Vzc2FyeSwgYW5kXG4gICAgICAgICAgICAgICAgLy8gYWRkIGl0IHRvIGBjb250ZW50YC5cbiAgICAgICAgICAgICAgICBpZiAodG9PZmYgfHwgYWZ0ZXIuY2hpbGRyZW4ubGVuZ3RoICYmICFhZnRlci5jaGlsZHJlblswXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLm1lcmdlKDAsIHRvT2ZmLCBudWxsLCBmYWxzZSwgMCwgb3BlbkVuZCk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2goYWZ0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFmdGVyID09PSBudWxsIHx8IGFmdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZnRlci5icmVha0FmdGVyKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBhdCBgdG9JYCBpcyBlbnRpcmVseSBjb3ZlcmVkIGJ5IHRoaXMgcmFuZ2UuXG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBpdHMgbGluZSBicmVhaywgaWYgYW55LlxuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgbGFzdC5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVha0F0U3RhcnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGhhbmRsZWQgdGhlIG5leHQgZWxlbWVudCBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnRzXG4gICAgICAgIC8vIG5vdywgbWFrZSBzdXJlIGB0b0lgIHBvaW50cyBhZnRlciB0aGF0LlxuICAgICAgICB0b0krKztcbiAgICB9XG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgICBiZWZvcmUuYnJlYWtBZnRlciA9IGJyZWFrQXRTdGFydDtcbiAgICAgICAgaWYgKGZyb21PZmYgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIWJyZWFrQXRTdGFydCAmJiBpbnNlcnQubGVuZ3RoICYmIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCBiZWZvcmUubGVuZ3RoLCBpbnNlcnRbMF0sIGZhbHNlLCBvcGVuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlLmJyZWFrQWZ0ZXIgPSBpbnNlcnQuc2hpZnQoKS5icmVha0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbU9mZiA8IGJlZm9yZS5sZW5ndGggfHwgYmVmb3JlLmNoaWxkcmVuLmxlbmd0aCAmJiBiZWZvcmUuY2hpbGRyZW5bYmVmb3JlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlLm1lcmdlKGZyb21PZmYsIGJlZm9yZS5sZW5ndGgsIG51bGwsIGZhbHNlLCBvcGVuU3RhcnQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gbWVyZ2Ugd2lkZ2V0cyBvbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICB3aGlsZSAoZnJvbUkgPCB0b0kgJiYgaW5zZXJ0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoY2hpbGRyZW5bdG9JIC0gMV0uYmVjb21lKGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICB0b0ktLTtcbiAgICAgICAgICAgIGluc2VydC5wb3AoKTtcbiAgICAgICAgICAgIG9wZW5FbmQgPSBpbnNlcnQubGVuZ3RoID8gMCA6IG9wZW5TdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZHJlbltmcm9tSV0uYmVjb21lKGluc2VydFswXSkpIHtcbiAgICAgICAgICAgIGZyb21JKys7XG4gICAgICAgICAgICBpbnNlcnQuc2hpZnQoKTtcbiAgICAgICAgICAgIG9wZW5TdGFydCA9IGluc2VydC5sZW5ndGggPyAwIDogb3BlbkVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaW5zZXJ0Lmxlbmd0aCAmJiBmcm9tSSAmJiB0b0kgPCBjaGlsZHJlbi5sZW5ndGggJiYgIWNoaWxkcmVuW2Zyb21JIC0gMV0uYnJlYWtBZnRlciAmJlxuICAgICAgICBjaGlsZHJlblt0b0ldLm1lcmdlKDAsIDAsIGNoaWxkcmVuW2Zyb21JIC0gMV0sIGZhbHNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpKVxuICAgICAgICBmcm9tSS0tO1xuICAgIGlmIChmcm9tSSA8IHRvSSB8fCBpbnNlcnQubGVuZ3RoKVxuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkcmVuKGZyb21JLCB0b0ksIGluc2VydCk7XG59XG5mdW5jdGlvbiBtZXJnZUNoaWxkcmVuSW50byhwYXJlbnQsIGZyb20sIHRvLCBpbnNlcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGxldCBjdXIgPSBwYXJlbnQuY2hpbGRDdXJzb3IoKTtcbiAgICBsZXQgeyBpOiB0b0ksIG9mZjogdG9PZmYgfSA9IGN1ci5maW5kUG9zKHRvLCAxKTtcbiAgICBsZXQgeyBpOiBmcm9tSSwgb2ZmOiBmcm9tT2ZmIH0gPSBjdXIuZmluZFBvcyhmcm9tLCAtMSk7XG4gICAgbGV0IGRMZW4gPSBmcm9tIC0gdG87XG4gICAgZm9yIChsZXQgdmlldyBvZiBpbnNlcnQpXG4gICAgICAgIGRMZW4gKz0gdmlldy5sZW5ndGg7XG4gICAgcGFyZW50Lmxlbmd0aCArPSBkTGVuO1xuICAgIHJlcGxhY2VSYW5nZShwYXJlbnQsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBpbnNlcnQsIDAsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbmxldCBuYXYgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyBuYXZpZ2F0b3IgOiB7IHVzZXJBZ2VudDogXCJcIiwgdmVuZG9yOiBcIlwiLCBwbGF0Zm9ybTogXCJcIiB9O1xubGV0IGRvYyA9IHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiID8gZG9jdW1lbnQgOiB7IGRvY3VtZW50RWxlbWVudDogeyBzdHlsZToge30gfSB9O1xuY29uc3QgaWVfZWRnZSA9IC8qQF9fUFVSRV9fKi8vRWRnZVxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KTtcbmNvbnN0IGllX3VwdG8xMCA9IC8qQF9fUFVSRV9fKi8vTVNJRSBcXGQvLnRlc3QobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBpZV8xMXVwID0gLypAX19QVVJFX18qLy9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KTtcbmNvbnN0IGllID0gISEoaWVfdXB0bzEwIHx8IGllXzExdXAgfHwgaWVfZWRnZSk7XG5jb25zdCBnZWNrbyA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL2dlY2tvXFwvKFxcZCspL2kudGVzdChuYXYudXNlckFnZW50KTtcbmNvbnN0IGNocm9tZSA9ICFpZSAmJiAvKkBfX1BVUkVfXyovL0Nocm9tZVxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KTtcbmNvbnN0IHdlYmtpdCA9IFwid2Via2l0Rm9udFNtb290aGluZ1wiIGluIGRvYy5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5jb25zdCBzYWZhcmkgPSAhaWUgJiYgLypAX19QVVJFX18qLy9BcHBsZSBDb21wdXRlci8udGVzdChuYXYudmVuZG9yKTtcbmNvbnN0IGlvcyA9IHNhZmFyaSAmJiAoLypAX19QVVJFX18qLy9Nb2JpbGVcXC9cXHcrLy50ZXN0KG5hdi51c2VyQWdlbnQpIHx8IG5hdi5tYXhUb3VjaFBvaW50cyA+IDIpO1xudmFyIGJyb3dzZXIgPSB7XG4gICAgbWFjOiBpb3MgfHwgLypAX19QVVJFX18qLy9NYWMvLnRlc3QobmF2LnBsYXRmb3JtKSxcbiAgICB3aW5kb3dzOiAvKkBfX1BVUkVfXyovL1dpbi8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIGxpbnV4OiAvKkBfX1BVUkVfXyovL0xpbnV4fFgxMS8udGVzdChuYXYucGxhdGZvcm0pLFxuICAgIGllLFxuICAgIGllX3ZlcnNpb246IGllX3VwdG8xMCA/IGRvYy5kb2N1bWVudE1vZGUgfHwgNiA6IGllXzExdXAgPyAraWVfMTF1cFsxXSA6IGllX2VkZ2UgPyAraWVfZWRnZVsxXSA6IDAsXG4gICAgZ2Vja28sXG4gICAgZ2Vja29fdmVyc2lvbjogZ2Vja28gPyArKC8qQF9fUFVSRV9fKi8vRmlyZWZveFxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMCxcbiAgICBjaHJvbWU6ICEhY2hyb21lLFxuICAgIGNocm9tZV92ZXJzaW9uOiBjaHJvbWUgPyArY2hyb21lWzFdIDogMCxcbiAgICBpb3MsXG4gICAgYW5kcm9pZDogLypAX19QVVJFX18qLy9BbmRyb2lkXFxiLy50ZXN0KG5hdi51c2VyQWdlbnQpLFxuICAgIHdlYmtpdCxcbiAgICBzYWZhcmksXG4gICAgd2Via2l0X3ZlcnNpb246IHdlYmtpdCA/ICsoLypAX19QVVJFX18qLy9cXGJBcHBsZVdlYktpdFxcLyhcXGQrKS8uZXhlYyhuYXYudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMCxcbiAgICB0YWJTaXplOiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnRhYlNpemUgIT0gbnVsbCA/IFwidGFiLXNpemVcIiA6IFwiLW1vei10YWItc2l6ZVwiXG59O1xuXG5jb25zdCBNYXhKb2luTGVuID0gMjU2O1xuY2xhc3MgVGV4dFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3IodGV4dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDsgfVxuICAgIGNyZWF0ZURPTSh0ZXh0RE9NKSB7XG4gICAgICAgIHRoaXMuc2V0RE9NKHRleHRET00gfHwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50ZXh0KSk7XG4gICAgfVxuICAgIHN5bmModmlldywgdHJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRE9NKCk7XG4gICAgICAgIGlmICh0aGlzLmRvbS5ub2RlVmFsdWUgIT0gdGhpcy50ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHJhY2sgJiYgdHJhY2subm9kZSA9PSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICB0cmFjay53cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLm5vZGVWYWx1ZSA9IHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXVzZURPTShkb20pIHtcbiAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVET00oZG9tKTtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSkge1xuICAgICAgICBpZiAoKHRoaXMuZmxhZ3MgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKSB8fFxuICAgICAgICAgICAgc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIFRleHRWaWV3KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoIC0gKHRvIC0gZnJvbSkgKyBzb3VyY2UubGVuZ3RoID4gTWF4Sm9pbkxlbiB8fFxuICAgICAgICAgICAgICAgIChzb3VyY2UuZmxhZ3MgJiA4IC8qIFZpZXdGbGFnLkNvbXBvc2l0aW9uICovKSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBmcm9tKSArIChzb3VyY2UgPyBzb3VyY2UudGV4dCA6IFwiXCIpICsgdGhpcy50ZXh0LnNsaWNlKHRvKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBUZXh0Vmlldyh0aGlzLnRleHQuc2xpY2UoZnJvbSkpO1xuICAgICAgICB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgZnJvbSk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJlc3VsdC5mbGFncyB8PSB0aGlzLmZsYWdzICYgOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbm9kZSA9PSB0aGlzLmRvbSA/IG9mZnNldCA6IG9mZnNldCA/IHRoaXMudGV4dC5sZW5ndGggOiAwO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHsgcmV0dXJuIG5ldyBET01Qb3ModGhpcy5kb20sIHBvcyk7IH1cbiAgICBkb21Cb3VuZHNBcm91bmQoX2Zyb20sIF90bywgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IGZyb206IG9mZnNldCwgdG86IG9mZnNldCArIHRoaXMubGVuZ3RoLCBzdGFydERPTTogdGhpcy5kb20sIGVuZERPTTogdGhpcy5kb20ubmV4dFNpYmxpbmcgfTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiB0ZXh0Q29vcmRzKHRoaXMuZG9tLCBwb3MsIHNpZGUpO1xuICAgIH1cbn1cbmNsYXNzIE1hcmtWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKG1hcmssIGNoaWxkcmVuID0gW10sIGxlbmd0aCA9IDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBjaC5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIHNldEF0dHJzKGRvbSkge1xuICAgICAgICBjbGVhckF0dHJpYnV0ZXMoZG9tKTtcbiAgICAgICAgaWYgKHRoaXMubWFyay5jbGFzcylcbiAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSB0aGlzLm1hcmsuY2xhc3M7XG4gICAgICAgIGlmICh0aGlzLm1hcmsuYXR0cnMpXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMubWFyay5hdHRycylcbiAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIHRoaXMubWFyay5hdHRyc1tuYW1lXSk7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIGNhblJldXNlRE9NKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5jYW5SZXVzZURPTShvdGhlcikgJiYgISgodGhpcy5mbGFncyB8IG90aGVyLmZsYWdzKSAmIDggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pO1xuICAgIH1cbiAgICByZXVzZURPTShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IHRoaXMubWFyay50YWdOYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi8gfCAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW5jKHZpZXcsIHRyYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLnNldEF0dHJzKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5tYXJrLnRhZ05hbWUpKSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmxhZ3MgJiA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi8pXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJzKHRoaXMuZG9tKTtcbiAgICAgICAgc3VwZXIuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIF9oYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgKCEoc291cmNlIGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgc291cmNlLm1hcmsuZXEodGhpcy5tYXJrKSkgfHxcbiAgICAgICAgICAgIChmcm9tICYmIG9wZW5TdGFydCA8PSAwKSB8fCAodG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbWVyZ2VDaGlsZHJlbkludG8odGhpcywgZnJvbSwgdG8sIHNvdXJjZSA/IHNvdXJjZS5jaGlsZHJlbi5zbGljZSgpIDogW10sIG9wZW5TdGFydCAtIDEsIG9wZW5FbmQgLSAxKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBvZmYgPSAwLCBkZXRhY2hGcm9tID0gLTEsIGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBlbHQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IGVuZCA9IG9mZiArIGVsdC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvZmYgPCBmcm9tID8gZWx0LnNwbGl0KGZyb20gLSBvZmYpIDogZWx0KTtcbiAgICAgICAgICAgIGlmIChkZXRhY2hGcm9tIDwgMCAmJiBvZmYgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICBkZXRhY2hGcm9tID0gaTtcbiAgICAgICAgICAgIG9mZiA9IGVuZDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5sZW5ndGggLSBmcm9tO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZyb207XG4gICAgICAgIGlmIChkZXRhY2hGcm9tID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gZGV0YWNoRnJvbTtcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrVmlldyh0aGlzLm1hcmssIHJlc3VsdCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBpbmxpbmVET01BdFBvcyh0aGlzLCBwb3MpO1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0luQ2hpbGRyZW4odGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0ZXh0Q29vcmRzKHRleHQsIHBvcywgc2lkZSkge1xuICAgIGxldCBsZW5ndGggPSB0ZXh0Lm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgaWYgKHBvcyA+IGxlbmd0aClcbiAgICAgICAgcG9zID0gbGVuZ3RoO1xuICAgIGxldCBmcm9tID0gcG9zLCB0byA9IHBvcywgZmxhdHRlbiA9IDA7XG4gICAgaWYgKHBvcyA9PSAwICYmIHNpZGUgPCAwIHx8IHBvcyA9PSBsZW5ndGggJiYgc2lkZSA+PSAwKSB7XG4gICAgICAgIGlmICghKGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuZ2Vja28pKSB7IC8vIFRoZXNlIGJyb3dzZXJzIHJlbGlhYmx5IHJldHVybiB2YWxpZCByZWN0YW5nbGVzIGZvciBlbXB0eSByYW5nZXNcbiAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBmcm9tLS07XG4gICAgICAgICAgICAgICAgZmxhdHRlbiA9IDE7XG4gICAgICAgICAgICB9IC8vIEZJWE1FIHRoaXMgaXMgd3JvbmcgaW4gUlRMIHRleHRcbiAgICAgICAgICAgIGVsc2UgaWYgKHRvIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgICAgICBmbGF0dGVuID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChzaWRlIDwgMClcbiAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgZWxzZSBpZiAodG8gPCBsZW5ndGgpXG4gICAgICAgICAgICB0bysrO1xuICAgIH1cbiAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UodGV4dCwgZnJvbSwgdG8pLmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCByZWN0ID0gcmVjdHNbKGZsYXR0ZW4gPyBmbGF0dGVuIDwgMCA6IHNpZGUgPj0gMCkgPyAwIDogcmVjdHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmICFmbGF0dGVuICYmIHJlY3Qud2lkdGggPT0gMClcbiAgICAgICAgcmVjdCA9IEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwocmVjdHMsIHIgPT4gci53aWR0aCkgfHwgcmVjdDtcbiAgICByZXR1cm4gZmxhdHRlbiA/IGZsYXR0ZW5SZWN0KHJlY3QsIGZsYXR0ZW4gPCAwKSA6IHJlY3QgfHwgbnVsbDtcbn1cbi8vIEFsc28gdXNlZCBmb3IgY29sbGFwc2VkIHJhbmdlcyB0aGF0IGRvbid0IGhhdmUgYSBwbGFjZWhvbGRlciB3aWRnZXQhXG5jbGFzcyBXaWRnZXRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIHN0YXRpYyBjcmVhdGUod2lkZ2V0LCBsZW5ndGgsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXaWRnZXRWaWV3KHdpZGdldCwgbGVuZ3RoLCBzaWRlKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iod2lkZ2V0LCBsZW5ndGgsIHNpZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xuICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgIH1cbiAgICBzcGxpdChmcm9tKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBXaWRnZXRWaWV3LmNyZWF0ZSh0aGlzLndpZGdldCwgdGhpcy5sZW5ndGggLSBmcm9tLCB0aGlzLnNpZGUpO1xuICAgICAgICB0aGlzLmxlbmd0aCAtPSBmcm9tO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzeW5jKHZpZXcpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy53aWRnZXQudXBkYXRlRE9NKHRoaXMuZG9tLCB2aWV3KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZG9tICYmIHRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5zZXRET00odGhpcy53aWRnZXQudG9ET00odmlldykpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLndpZGdldC5lZGl0YWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2lkZSgpIHsgcmV0dXJuIHRoaXMuc2lkZTsgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UsIGhhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBXaWRnZXRWaWV3KSB8fCAhdGhpcy53aWRnZXQuY29tcGFyZShzb3VyY2Uud2lkZ2V0KSB8fFxuICAgICAgICAgICAgZnJvbSA+IDAgJiYgb3BlblN0YXJ0IDw9IDAgfHwgdG8gPCB0aGlzLmxlbmd0aCAmJiBvcGVuRW5kIDw9IDApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZyb20gKyAoc291cmNlID8gc291cmNlLmxlbmd0aCA6IDApICsgKHRoaXMubGVuZ3RoIC0gdG8pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFdpZGdldFZpZXcgJiYgb3RoZXIuc2lkZSA9PSB0aGlzLnNpZGUgJiZcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0LmNvbnN0cnVjdG9yID09IG90aGVyLndpZGdldC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLndpZGdldC5jb21wYXJlKG90aGVyLndpZGdldCkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkodHJ1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgIXRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSB0aGlzLndpZGdldDtcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0ID0gb3RoZXIud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBvdGhlci5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChldmVudCk7IH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBUZXh0LmVtcHR5O1xuICAgICAgICBsZXQgdG9wID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHRvcC5wYXJlbnQpXG4gICAgICAgICAgICB0b3AgPSB0b3AucGFyZW50O1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0b3AsIHRleHQgPSB2aWV3ICYmIHZpZXcuc3RhdGUuZG9jLCBzdGFydCA9IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgcmV0dXJuIHRleHQgPyB0ZXh0LnNsaWNlKHN0YXJ0LCBzdGFydCArIHRoaXMubGVuZ3RoKSA6IFRleHQuZW1wdHk7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gKHRoaXMubGVuZ3RoID8gcG9zID09IDAgOiB0aGlzLnNpZGUgPiAwKVxuICAgICAgICAgICAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKVxuICAgICAgICAgICAgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20sIHBvcyA9PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHRoaXMud2lkZ2V0LmNvb3Jkc0F0KHRoaXMuZG9tLCBwb3MsIHNpZGUpO1xuICAgICAgICBpZiAoY3VzdG9tKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgbGV0IHJlY3RzID0gdGhpcy5kb20uZ2V0Q2xpZW50UmVjdHMoKSwgcmVjdCA9IG51bGw7XG4gICAgICAgIGlmICghcmVjdHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBmcm9tQmFjayA9IHRoaXMuc2lkZSA/IHRoaXMuc2lkZSA8IDAgOiBwb3MgPiAwO1xuICAgICAgICBmb3IgKGxldCBpID0gZnJvbUJhY2sgPyByZWN0cy5sZW5ndGggLSAxIDogMDs7IGkgKz0gKGZyb21CYWNrID8gLTEgOiAxKSkge1xuICAgICAgICAgICAgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKHBvcyA+IDAgPyBpID09IDAgOiBpID09IHJlY3RzLmxlbmd0aCAtIDEgfHwgcmVjdC50b3AgPCByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhdHRlblJlY3QocmVjdCwgIWZyb21CYWNrKTtcbiAgICB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBpc1dpZGdldCgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiB0aGlzLndpZGdldC5pc0hpZGRlbjsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy53aWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgfVxufVxuLy8gVGhlc2UgYXJlIGRyYXduIGFyb3VuZCB1bmVkaXRhYmxlIHdpZGdldHMgdG8gYXZvaWQgYSBudW1iZXIgb2Zcbi8vIGJyb3dzZXIgYnVncyB0aGF0IHNob3cgdXAgd2hlbiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IG5leHQgdG9cbi8vIHVuZWRpdGFibGUgaW5saW5lIGNvbnRlbnQuXG5jbGFzcyBXaWRnZXRCdWZmZXJWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHNpZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIDA7IH1cbiAgICBtZXJnZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgYmVjb21lKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFdpZGdldEJ1ZmZlclZpZXcgJiYgb3RoZXIuc2lkZSA9PSB0aGlzLnNpZGU7XG4gICAgfVxuICAgIHNwbGl0KCkgeyByZXR1cm4gbmV3IFdpZGdldEJ1ZmZlclZpZXcodGhpcy5zaWRlKTsgfVxuICAgIHN5bmMoKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiY20td2lkZ2V0QnVmZmVyXCI7XG4gICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXRET00oZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gdGhpcy5zaWRlOyB9XG4gICAgZG9tQXRQb3MocG9zKSB7IHJldHVybiB0aGlzLnNpZGUgPiAwID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSkgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20pOyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKCkgeyByZXR1cm4gMDsgfVxuICAgIGRvbUJvdW5kc0Fyb3VuZCgpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBjb29yZHNBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgICAgICByZXR1cm4gVGV4dC5lbXB0eTtcbiAgICB9XG4gICAgZ2V0IGlzSGlkZGVuKCkgeyByZXR1cm4gdHJ1ZTsgfVxufVxuVGV4dFZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gV2lkZ2V0Vmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBXaWRnZXRCdWZmZXJWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IG5vQ2hpbGRyZW47XG5mdW5jdGlvbiBpbmxpbmVET01BdFBvcyhwYXJlbnQsIHBvcykge1xuICAgIGxldCBkb20gPSBwYXJlbnQuZG9tLCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQsIGkgPSAwO1xuICAgIGZvciAobGV0IG9mZiA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgY2hpbGQubGVuZ3RoO1xuICAgICAgICBpZiAoZW5kID09IG9mZiAmJiBjaGlsZC5nZXRTaWRlKCkgPD0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAocG9zID4gb2ZmICYmIHBvcyA8IGVuZCAmJiBjaGlsZC5kb20ucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQuZG9tQXRQb3MocG9zIC0gb2ZmKTtcbiAgICAgICAgaWYgKHBvcyA8PSBvZmYpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgb2ZmID0gZW5kO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICBsZXQgcHJldiA9IGNoaWxkcmVuW2ogLSAxXTtcbiAgICAgICAgaWYgKHByZXYuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIHByZXYuZG9tQXRQb3MocHJldi5sZW5ndGgpO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaTsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5bal07XG4gICAgICAgIGlmIChuZXh0LmRvbS5wYXJlbnROb2RlID09IGRvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUF0UG9zKDApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERPTVBvcyhkb20sIDApO1xufVxuLy8gQXNzdW1lcyBgdmlld2AsIGlmIGEgbWFyayB2aWV3LCBoYXMgcHJlY2lzZWx5IDEgY2hpbGQuXG5mdW5jdGlvbiBqb2luSW5saW5lSW50byhwYXJlbnQsIHZpZXcsIG9wZW4pIHtcbiAgICBsZXQgbGFzdCwgeyBjaGlsZHJlbiB9ID0gcGFyZW50O1xuICAgIGlmIChvcGVuID4gMCAmJiB2aWV3IGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgY2hpbGRyZW4ubGVuZ3RoICYmXG4gICAgICAgIChsYXN0ID0gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0pIGluc3RhbmNlb2YgTWFya1ZpZXcgJiYgbGFzdC5tYXJrLmVxKHZpZXcubWFyaykpIHtcbiAgICAgICAgam9pbklubGluZUludG8obGFzdCwgdmlldy5jaGlsZHJlblswXSwgb3BlbiAtIDEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaCh2aWV3KTtcbiAgICAgICAgdmlldy5zZXRQYXJlbnQocGFyZW50KTtcbiAgICB9XG4gICAgcGFyZW50Lmxlbmd0aCArPSB2aWV3Lmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNvb3Jkc0luQ2hpbGRyZW4odmlldywgcG9zLCBzaWRlKSB7XG4gICAgbGV0IGJlZm9yZSA9IG51bGwsIGJlZm9yZVBvcyA9IC0xLCBhZnRlciA9IG51bGwsIGFmdGVyUG9zID0gLTE7XG4gICAgZnVuY3Rpb24gc2Nhbih2aWV3LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZiA9IDA7IGkgPCB2aWV3LmNoaWxkcmVuLmxlbmd0aCAmJiBvZmYgPD0gcG9zOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHZpZXcuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FuKGNoaWxkLCBwb3MgLSBvZmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoIWFmdGVyIHx8IGFmdGVyLmlzSGlkZGVuICYmIHNpZGUgPiAwKSAmJlxuICAgICAgICAgICAgICAgICAgICAoZW5kID4gcG9zIHx8IG9mZiA9PSBlbmQgJiYgY2hpbGQuZ2V0U2lkZSgpID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJQb3MgPSBwb3MgLSBvZmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9mZiA8IHBvcyB8fCAob2ZmID09IGVuZCAmJiBjaGlsZC5nZXRTaWRlKCkgPCAwKSAmJiAhY2hpbGQuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZVBvcyA9IHBvcyAtIG9mZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2Nhbih2aWV3LCBwb3MpO1xuICAgIGxldCB0YXJnZXQgPSAoc2lkZSA8IDAgPyBiZWZvcmUgOiBhZnRlcikgfHwgYmVmb3JlIHx8IGFmdGVyO1xuICAgIGlmICh0YXJnZXQpXG4gICAgICAgIHJldHVybiB0YXJnZXQuY29vcmRzQXQoTWF0aC5tYXgoMCwgdGFyZ2V0ID09IGJlZm9yZSA/IGJlZm9yZVBvcyA6IGFmdGVyUG9zKSwgc2lkZSk7XG4gICAgcmV0dXJuIGZhbGxiYWNrUmVjdCh2aWV3KTtcbn1cbmZ1bmN0aW9uIGZhbGxiYWNrUmVjdCh2aWV3KSB7XG4gICAgbGV0IGxhc3QgPSB2aWV3LmRvbS5sYXN0Q2hpbGQ7XG4gICAgaWYgKCFsYXN0KVxuICAgICAgICByZXR1cm4gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IobGFzdCk7XG4gICAgcmV0dXJuIHJlY3RzW3JlY3RzLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbWJpbmVBdHRycyhzb3VyY2UsIHRhcmdldCkge1xuICAgIGZvciAobGV0IG5hbWUgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChuYW1lID09IFwiY2xhc3NcIiAmJiB0YXJnZXQuY2xhc3MpXG4gICAgICAgICAgICB0YXJnZXQuY2xhc3MgKz0gXCIgXCIgKyBzb3VyY2UuY2xhc3M7XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiICYmIHRhcmdldC5zdHlsZSlcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZSArPSBcIjtcIiArIHNvdXJjZS5zdHlsZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gc291cmNlW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuY29uc3Qgbm9BdHRycyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gYXR0cnNFcShhLCBiLCBpZ25vcmUpIHtcbiAgICBpZiAoYSA9PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIWEpXG4gICAgICAgIGEgPSBub0F0dHJzO1xuICAgIGlmICghYilcbiAgICAgICAgYiA9IG5vQXR0cnM7XG4gICAgbGV0IGtleXNBID0gT2JqZWN0LmtleXMoYSksIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgaWYgKGtleXNBLmxlbmd0aCAtIChpZ25vcmUgJiYga2V5c0EuaW5kZXhPZihpZ25vcmUpID4gLTEgPyAxIDogMCkgIT1cbiAgICAgICAga2V5c0IubGVuZ3RoIC0gKGlnbm9yZSAmJiBrZXlzQi5pbmRleE9mKGlnbm9yZSkgPiAtMSA/IDEgOiAwKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzQSkge1xuICAgICAgICBpZiAoa2V5ICE9IGlnbm9yZSAmJiAoa2V5c0IuaW5kZXhPZihrZXkpID09IC0xIHx8IGFba2V5XSAhPT0gYltrZXldKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB1cGRhdGVBdHRycyhkb20sIHByZXYsIGF0dHJzKSB7XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBpZiAocHJldilcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcmV2KVxuICAgICAgICAgICAgaWYgKCEoYXR0cnMgJiYgbmFtZSBpbiBhdHRycykpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PSBcInN0eWxlXCIpXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgaWYgKGF0dHJzKVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgaWYgKCEocHJldiAmJiBwcmV2W25hbWVdID09IGF0dHJzW25hbWVdKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gZ2V0QXR0cnMoZG9tKSB7XG4gICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBhdHRyID0gZG9tLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG59XG5cbi8qKlxuV2lkZ2V0cyBhZGRlZCB0byB0aGUgY29udGVudCBhcmUgZGVzY3JpYmVkIGJ5IHN1YmNsYXNzZXMgb2YgdGhpc1xuY2xhc3MuIFVzaW5nIGEgZGVzY3JpcHRpb24gb2JqZWN0IGxpa2UgdGhhdCBtYWtlcyBpdCBwb3NzaWJsZSB0b1xuZGVsYXkgY3JlYXRpbmcgb2YgdGhlIERPTSBzdHJ1Y3R1cmUgZm9yIGEgd2lkZ2V0IHVudGlsIGl0IGlzXG5uZWVkZWQsIGFuZCB0byBhdm9pZCByZWRyYXdpbmcgd2lkZ2V0cyBldmVuIGlmIHRoZSBkZWNvcmF0aW9uc1xudGhhdCBkZWZpbmUgdGhlbSBhcmUgcmVjcmVhdGVkLlxuKi9cbmNsYXNzIFdpZGdldFR5cGUge1xuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBpbnN0YW5jZSB0byBhbm90aGVyIGluc3RhbmNlIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAgKFR5cGVTY3JpcHQgY2FuJ3QgZXhwcmVzcyB0aGlzLCBidXQgb25seSBpbnN0YW5jZXMgb2YgdGhlIHNhbWVcbiAgICBzcGVjaWZpYyBjbGFzcyB3aWxsIGJlIHBhc3NlZCB0byB0aGlzIG1ldGhvZC4pIFRoaXMgaXMgdXNlZCB0b1xuICAgIGF2b2lkIHJlZHJhd2luZyB3aWRnZXRzIHdoZW4gdGhleSBhcmUgcmVwbGFjZWQgYnkgYSBuZXdcbiAgICBkZWNvcmF0aW9uIG9mIHRoZSBzYW1lIHR5cGUuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGp1c3RcbiAgICByZXR1cm5zIGBmYWxzZWAsIHdoaWNoIHdpbGwgY2F1c2UgbmV3IGluc3RhbmNlcyBvZiB0aGUgd2lkZ2V0IHRvXG4gICAgYWx3YXlzIGJlIHJlZHJhd24uXG4gICAgKi9cbiAgICBlcSh3aWRnZXQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgVXBkYXRlIGEgRE9NIGVsZW1lbnQgY3JlYXRlZCBieSBhIHdpZGdldCBvZiB0aGUgc2FtZSB0eXBlIChidXRcbiAgICBkaWZmZXJlbnQsIG5vbi1gZXFgIGNvbnRlbnQpIHRvIHJlZmxlY3QgdGhpcyB3aWRnZXQuIE1heSByZXR1cm5cbiAgICB0cnVlIHRvIGluZGljYXRlIHRoYXQgaXQgY291bGQgdXBkYXRlLCBmYWxzZSB0byBpbmRpY2F0ZSBpdFxuICAgIGNvdWxkbid0IChpbiB3aGljaCBjYXNlIHRoZSB3aWRnZXQgd2lsbCBiZSByZWRyYXduKS4gVGhlIGRlZmF1bHRcbiAgICBpbXBsZW1lbnRhdGlvbiBqdXN0IHJldHVybnMgZmFsc2UuXG4gICAgKi9cbiAgICB1cGRhdGVET00oZG9tLCB2aWV3KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLmNvbnN0cnVjdG9yID09IG90aGVyLmNvbnN0cnVjdG9yICYmIHRoaXMuZXEob3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZXN0aW1hdGVkIGhlaWdodCB0aGlzIHdpZGdldCB3aWxsIGhhdmUsIHRvIGJlIHVzZWQgd2hlblxuICAgIGVzdGltYXRpbmcgdGhlIGhlaWdodCBvZiBjb250ZW50IHRoYXQgaGFzbid0IGJlZW4gZHJhd24uIE1heVxuICAgIHJldHVybiAtMSB0byBpbmRpY2F0ZSB5b3UgZG9uJ3Qga25vdy4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICByZXR1cm5zIC0xLlxuICAgICovXG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIC0xOyB9XG4gICAgLyoqXG4gICAgRm9yIGlubGluZSB3aWRnZXRzIHRoYXQgYXJlIGRpc3BsYXllZCBpbmxpbmUgKGFzIG9wcG9zZWQgdG9cbiAgICBgaW5saW5lLWJsb2NrYCkgYW5kIGludHJvZHVjZSBsaW5lIGJyZWFrcyAodGhyb3VnaCBgPGJyPmAgdGFnc1xuICAgIG9yIHRleHR1YWwgbmV3bGluZXMpLCB0aGlzIG11c3QgaW5kaWNhdGUgdGhlIGFtb3VudCBvZiBsaW5lXG4gICAgYnJlYWtzIHRoZXkgaW50cm9kdWNlLiBEZWZhdWx0cyB0byAwLlxuICAgICovXG4gICAgZ2V0IGxpbmVCcmVha3MoKSB7IHJldHVybiAwOyB9XG4gICAgLyoqXG4gICAgQ2FuIGJlIHVzZWQgdG8gY29uZmlndXJlIHdoaWNoIGtpbmRzIG9mIGV2ZW50cyBpbnNpZGUgdGhlIHdpZGdldFxuICAgIHNob3VsZCBiZSBpZ25vcmVkIGJ5IHRoZSBlZGl0b3IuIFRoZSBkZWZhdWx0IGlzIHRvIGlnbm9yZSBhbGxcbiAgICBldmVudHMuXG4gICAgKi9cbiAgICBpZ25vcmVFdmVudChldmVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIC8qKlxuICAgIE92ZXJyaWRlIHRoZSB3YXkgc2NyZWVuIGNvb3JkaW5hdGVzIGZvciBwb3NpdGlvbnMgYXQvaW4gdGhlXG4gICAgd2lkZ2V0IGFyZSBmb3VuZC4gYHBvc2Agd2lsbCBiZSB0aGUgb2Zmc2V0IGludG8gdGhlIHdpZGdldCwgYW5kXG4gICAgYHNpZGVgIHRoZSBzaWRlIG9mIHRoZSBwb3NpdGlvbiB0aGF0IGlzIGJlaW5nIHF1ZXJpZWTigJRsZXNzIHRoYW5cbiAgICB6ZXJvIGZvciBiZWZvcmUsIGdyZWF0ZXIgdGhhbiB6ZXJvIGZvciBhZnRlciwgYW5kIHplcm8gZm9yXG4gICAgZGlyZWN0bHkgYXQgdGhhdCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGNvb3Jkc0F0KGRvbSwgcG9zLCBzaWRlKSB7IHJldHVybiBudWxsOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaXNIaWRkZW4oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGVkaXRhYmxlKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvKipcbiAgICBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBhbiBpbnN0YW5jZSBvZiB0aGUgd2lkZ2V0IGlzIHJlbW92ZWRcbiAgICBmcm9tIHRoZSBlZGl0b3Igdmlldy5cbiAgICAqL1xuICAgIGRlc3Ryb3koZG9tKSB7IH1cbn1cbi8qKlxuVGhlIGRpZmZlcmVudCB0eXBlcyBvZiBibG9ja3MgdGhhdCBjYW4gb2NjdXIgaW4gYW4gZWRpdG9yIHZpZXcuXG4qL1xudmFyIEJsb2NrVHlwZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKEJsb2NrVHlwZSkge1xuICAgIC8qKlxuICAgIEEgbGluZSBvZiB0ZXh0LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIlRleHRcIl0gPSAwXSA9IFwiVGV4dFwiO1xuICAgIC8qKlxuICAgIEEgYmxvY2sgd2lkZ2V0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcG9zaXRpb24gYWZ0ZXIgaXQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0QmVmb3JlXCJdID0gMV0gPSBcIldpZGdldEJlZm9yZVwiO1xuICAgIC8qKlxuICAgIEEgYmxvY2sgd2lkZ2V0IGFzc29jaWF0ZWQgd2l0aCB0aGUgcG9zaXRpb24gYmVmb3JlIGl0LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldEFmdGVyXCJdID0gMl0gPSBcIldpZGdldEFmdGVyXCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgW3JlcGxhY2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ecmVwbGFjZSkgYSByYW5nZSBvZiBjb250ZW50LlxuICAgICovXG4gICAgQmxvY2tUeXBlW0Jsb2NrVHlwZVtcIldpZGdldFJhbmdlXCJdID0gM10gPSBcIldpZGdldFJhbmdlXCI7XG5yZXR1cm4gQmxvY2tUeXBlfSkoQmxvY2tUeXBlIHx8IChCbG9ja1R5cGUgPSB7fSkpO1xuLyoqXG5BIGRlY29yYXRpb24gcHJvdmlkZXMgaW5mb3JtYXRpb24gb24gaG93IHRvIGRyYXcgb3Igc3R5bGUgYSBwaWVjZVxub2YgY29udGVudC4gWW91J2xsIHVzdWFsbHkgdXNlIGl0IHdyYXBwZWQgaW4gYVxuW2BSYW5nZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUmFuZ2UpLCB3aGljaCBhZGRzIGEgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbi5cbkBub25hYnN0cmFjdFxuKi9cbmNsYXNzIERlY29yYXRpb24gZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXJ0U2lkZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbmRTaWRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHdpZGdldCwgXG4gICAgLyoqXG4gICAgVGhlIGNvbmZpZyBvYmplY3QgdXNlZCB0byBjcmVhdGUgdGhpcyBkZWNvcmF0aW9uLiBZb3UgY2FuXG4gICAgaW5jbHVkZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgaW4gdGhlcmUgdG8gc3RvcmUgbWV0YWRhdGEgYWJvdXRcbiAgICB5b3VyIGRlY29yYXRpb24uXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RhcnRTaWRlID0gc3RhcnRTaWRlO1xuICAgICAgICB0aGlzLmVuZFNpZGUgPSBlbmRTaWRlO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0UmVsZXZhbnQoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgZGVjb3JhdGlvbiwgd2hpY2ggaW5mbHVlbmNlcyB0aGUgc3R5bGluZyBvZiB0aGVcbiAgICBjb250ZW50IGluIGl0cyByYW5nZS4gTmVzdGVkIG1hcmsgZGVjb3JhdGlvbnMgd2lsbCBjYXVzZSBuZXN0ZWRcbiAgICBET00gZWxlbWVudHMgdG8gYmUgY3JlYXRlZC4gTmVzdGluZyBvcmRlciBpcyBkZXRlcm1pbmVkIGJ5XG4gICAgcHJlY2VkZW5jZSBvZiB0aGUgW2ZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kZWNvcmF0aW9ucyksIHdpdGhcbiAgICB0aGUgaGlnaGVyLXByZWNlZGVuY2UgZGVjb3JhdGlvbnMgY3JlYXRpbmcgdGhlIGlubmVyIERPTSBub2Rlcy5cbiAgICBTdWNoIGVsZW1lbnRzIGFyZSBzcGxpdCBvbiBsaW5lIGJvdW5kYXJpZXMgYW5kIG9uIHRoZSBib3VuZGFyaWVzXG4gICAgb2YgbG93ZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucy5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXJrKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrRGVjb3JhdGlvbihzcGVjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGRpc3BsYXlzIGEgRE9NIGVsZW1lbnQgYXQgdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgd2lkZ2V0KHNwZWMpIHtcbiAgICAgICAgbGV0IHNpZGUgPSBNYXRoLm1heCgtMTAwMDAsIE1hdGgubWluKDEwMDAwLCBzcGVjLnNpZGUgfHwgMCkpLCBibG9jayA9ICEhc3BlYy5ibG9jaztcbiAgICAgICAgc2lkZSArPSAoYmxvY2sgJiYgIXNwZWMuaW5saW5lT3JkZXIpXG4gICAgICAgICAgICA/IChzaWRlID4gMCA/IDMwMDAwMDAwMCAvKiBTaWRlLkJsb2NrQWZ0ZXIgKi8gOiAtNDAwMDAwMDAwIC8qIFNpZGUuQmxvY2tCZWZvcmUgKi8pXG4gICAgICAgICAgICA6IChzaWRlID4gMCA/IDEwMDAwMDAwMCAvKiBTaWRlLklubGluZUFmdGVyICovIDogLTEwMDAwMDAwMCAvKiBTaWRlLklubGluZUJlZm9yZSAqLyk7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnREZWNvcmF0aW9uKHNwZWMsIHNpZGUsIHNpZGUsIGJsb2NrLCBzcGVjLndpZGdldCB8fCBudWxsLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJlcGxhY2UgZGVjb3JhdGlvbiB3aGljaCByZXBsYWNlcyB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aFxuICAgIGEgd2lkZ2V0LCBvciBzaW1wbHkgaGlkZXMgaXQuXG4gICAgKi9cbiAgICBzdGF0aWMgcmVwbGFjZShzcGVjKSB7XG4gICAgICAgIGxldCBibG9jayA9ICEhc3BlYy5ibG9jaywgc3RhcnRTaWRlLCBlbmRTaWRlO1xuICAgICAgICBpZiAoc3BlYy5pc0Jsb2NrR2FwKSB7XG4gICAgICAgICAgICBzdGFydFNpZGUgPSAtNTAwMDAwMDAwIC8qIFNpZGUuR2FwU3RhcnQgKi87XG4gICAgICAgICAgICBlbmRTaWRlID0gNDAwMDAwMDAwIC8qIFNpZGUuR2FwRW5kICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gZ2V0SW5jbHVzaXZlKHNwZWMsIGJsb2NrKTtcbiAgICAgICAgICAgIHN0YXJ0U2lkZSA9IChzdGFydCA/IChibG9jayA/IC0zMDAwMDAwMDAgLyogU2lkZS5CbG9ja0luY1N0YXJ0ICovIDogLTEgLyogU2lkZS5JbmxpbmVJbmNTdGFydCAqLykgOiA1MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNTdGFydCAqLykgLSAxO1xuICAgICAgICAgICAgZW5kU2lkZSA9IChlbmQgPyAoYmxvY2sgPyAyMDAwMDAwMDAgLyogU2lkZS5CbG9ja0luY0VuZCAqLyA6IDEgLyogU2lkZS5JbmxpbmVJbmNFbmQgKi8pIDogLTYwMDAwMDAwMCAvKiBTaWRlLk5vbkluY0VuZCAqLykgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnREZWNvcmF0aW9uKHNwZWMsIHN0YXJ0U2lkZSwgZW5kU2lkZSwgYmxvY2ssIHNwZWMud2lkZ2V0IHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBsaW5lIGRlY29yYXRpb24sIHdoaWNoIGNhbiBhZGQgRE9NIGF0dHJpYnV0ZXMgdG8gdGhlXG4gICAgbGluZSBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgbGluZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZURlY29yYXRpb24oc3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgW2BEZWNvcmF0aW9uU2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25TZXQpIGZyb20gdGhlIGdpdmVuXG4gICAgZGVjb3JhdGVkIHJhbmdlIG9yIHJhbmdlcy4gSWYgdGhlIHJhbmdlcyBhcmVuJ3QgYWxyZWFkeSBzb3J0ZWQsXG4gICAgcGFzcyBgdHJ1ZWAgZm9yIGBzb3J0YCB0byBtYWtlIHRoZSBsaWJyYXJ5IHNvcnQgdGhlbSBmb3IgeW91LlxuICAgICovXG4gICAgc3RhdGljIHNldChvZiwgc29ydCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZVNldC5vZihvZiwgc29ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaGFzSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy53aWRnZXQgPyB0aGlzLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgPiAtMSA6IGZhbHNlOyB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgZGVjb3JhdGlvbnMuXG4qL1xuRGVjb3JhdGlvbi5ub25lID0gUmFuZ2VTZXQuZW1wdHk7XG5jbGFzcyBNYXJrRGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gZ2V0SW5jbHVzaXZlKHNwZWMpO1xuICAgICAgICBzdXBlcihzdGFydCA/IC0xIC8qIFNpZGUuSW5saW5lSW5jU3RhcnQgKi8gOiA1MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNTdGFydCAqLywgZW5kID8gMSAvKiBTaWRlLklubGluZUluY0VuZCAqLyA6IC02MDAwMDAwMDAgLyogU2lkZS5Ob25JbmNFbmQgKi8sIG51bGwsIHNwZWMpO1xuICAgICAgICB0aGlzLnRhZ05hbWUgPSBzcGVjLnRhZ05hbWUgfHwgXCJzcGFuXCI7XG4gICAgICAgIHRoaXMuY2xhc3MgPSBzcGVjLmNsYXNzIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBzcGVjLmF0dHJpYnV0ZXMgfHwgbnVsbDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIG90aGVyIGluc3RhbmNlb2YgTWFya0RlY29yYXRpb24gJiZcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ05hbWUgPT0gb3RoZXIudGFnTmFtZSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLmNsYXNzIHx8ICgoX2EgPSB0aGlzLmF0dHJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xhc3MpKSA9PSAob3RoZXIuY2xhc3MgfHwgKChfYiA9IG90aGVyLmF0dHJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2xhc3MpKSAmJlxuICAgICAgICAgICAgICAgIGF0dHJzRXEodGhpcy5hdHRycywgb3RoZXIuYXR0cnMsIFwiY2xhc3NcIik7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAoZnJvbSA+PSB0bylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTWFyayBkZWNvcmF0aW9ucyBtYXkgbm90IGJlIGVtcHR5XCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbk1hcmtEZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IGZhbHNlO1xuY2xhc3MgTGluZURlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHN1cGVyKC0yMDAwMDAwMDAgLyogU2lkZS5MaW5lICovLCAtMjAwMDAwMDAwIC8qIFNpZGUuTGluZSAqLywgbnVsbCwgc3BlYyk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIExpbmVEZWNvcmF0aW9uICYmXG4gICAgICAgICAgICB0aGlzLnNwZWMuY2xhc3MgPT0gb3RoZXIuc3BlYy5jbGFzcyAmJlxuICAgICAgICAgICAgYXR0cnNFcSh0aGlzLnNwZWMuYXR0cmlidXRlcywgb3RoZXIuc3BlYy5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmICh0byAhPSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJMaW5lIGRlY29yYXRpb24gcmFuZ2VzIG11c3QgYmUgemVyby1sZW5ndGhcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuTGluZURlY29yYXRpb24ucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrQmVmb3JlO1xuTGluZURlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbmNsYXNzIFBvaW50RGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMsIHN0YXJ0U2lkZSwgZW5kU2lkZSwgYmxvY2ssIHdpZGdldCwgaXNSZXBsYWNlKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0U2lkZSwgZW5kU2lkZSwgd2lkZ2V0LCBzcGVjKTtcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2NrO1xuICAgICAgICB0aGlzLmlzUmVwbGFjZSA9IGlzUmVwbGFjZTtcbiAgICAgICAgdGhpcy5tYXBNb2RlID0gIWJsb2NrID8gTWFwTW9kZS5UcmFja0RlbCA6IHN0YXJ0U2lkZSA8PSAwID8gTWFwTW9kZS5UcmFja0JlZm9yZSA6IE1hcE1vZGUuVHJhY2tBZnRlcjtcbiAgICB9XG4gICAgLy8gT25seSByZWxldmFudCB3aGVuIHRoaXMuYmxvY2sgPT0gdHJ1ZVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFNpZGUgIT0gdGhpcy5lbmRTaWRlID8gQmxvY2tUeXBlLldpZGdldFJhbmdlXG4gICAgICAgICAgICA6IHRoaXMuc3RhcnRTaWRlIDw9IDAgPyBCbG9ja1R5cGUuV2lkZ2V0QmVmb3JlIDogQmxvY2tUeXBlLldpZGdldEFmdGVyO1xuICAgIH1cbiAgICBnZXQgaGVpZ2h0UmVsZXZhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrIHx8ICEhdGhpcy53aWRnZXQgJiYgKHRoaXMud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA+PSA1IHx8IHRoaXMud2lkZ2V0LmxpbmVCcmVha3MgPiAwKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uICYmXG4gICAgICAgICAgICB3aWRnZXRzRXEodGhpcy53aWRnZXQsIG90aGVyLndpZGdldCkgJiZcbiAgICAgICAgICAgIHRoaXMuYmxvY2sgPT0gb3RoZXIuYmxvY2sgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTaWRlID09IG90aGVyLnN0YXJ0U2lkZSAmJiB0aGlzLmVuZFNpZGUgPT0gb3RoZXIuZW5kU2lkZTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVwbGFjZSAmJiAoZnJvbSA+IHRvIHx8IChmcm9tID09IHRvICYmIHRoaXMuc3RhcnRTaWRlID4gMCAmJiB0aGlzLmVuZFNpZGUgPD0gMCkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHJhbmdlIGZvciByZXBsYWNlbWVudCBkZWNvcmF0aW9uXCIpO1xuICAgICAgICBpZiAoIXRoaXMuaXNSZXBsYWNlICYmIHRvICE9IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIldpZGdldCBkZWNvcmF0aW9ucyBjYW4gb25seSBoYXZlIHplcm8tbGVuZ3RoIHJhbmdlc1wiKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJhbmdlKGZyb20sIHRvKTtcbiAgICB9XG59XG5Qb2ludERlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbmZ1bmN0aW9uIGdldEluY2x1c2l2ZShzcGVjLCBibG9jayA9IGZhbHNlKSB7XG4gICAgbGV0IHsgaW5jbHVzaXZlU3RhcnQ6IHN0YXJ0LCBpbmNsdXNpdmVFbmQ6IGVuZCB9ID0gc3BlYztcbiAgICBpZiAoc3RhcnQgPT0gbnVsbClcbiAgICAgICAgc3RhcnQgPSBzcGVjLmluY2x1c2l2ZTtcbiAgICBpZiAoZW5kID09IG51bGwpXG4gICAgICAgIGVuZCA9IHNwZWMuaW5jbHVzaXZlO1xuICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCAhPT0gbnVsbCAmJiBzdGFydCAhPT0gdm9pZCAwID8gc3RhcnQgOiBibG9jaywgZW5kOiBlbmQgIT09IG51bGwgJiYgZW5kICE9PSB2b2lkIDAgPyBlbmQgOiBibG9jayB9O1xufVxuZnVuY3Rpb24gd2lkZ2V0c0VxKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PSBiIHx8ICEhKGEgJiYgYiAmJiBhLmNvbXBhcmUoYikpO1xufVxuZnVuY3Rpb24gYWRkUmFuZ2UoZnJvbSwgdG8sIHJhbmdlcywgbWFyZ2luID0gMCkge1xuICAgIGxldCBsYXN0ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgPj0gMCAmJiByYW5nZXNbbGFzdF0gKyBtYXJnaW4gPj0gZnJvbSlcbiAgICAgICAgcmFuZ2VzW2xhc3RdID0gTWF0aC5tYXgocmFuZ2VzW2xhc3RdLCB0byk7XG4gICAgZWxzZVxuICAgICAgICByYW5nZXMucHVzaChmcm9tLCB0byk7XG59XG5cbmNsYXNzIExpbmVWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBudWxsO1xuICAgICAgICB0aGlzLmJyZWFrQWZ0ZXIgPSAwO1xuICAgIH1cbiAgICAvLyBDb25zdW1lcyBzb3VyY2VcbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBoYXNTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIExpbmVWaWV3KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHNvdXJjZS50cmFuc2ZlckRPTSh0aGlzKTsgLy8gUmV1c2Ugc291cmNlLmRvbSB3aGVuIGFwcHJvcHJpYXRlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1N0YXJ0KVxuICAgICAgICAgICAgdGhpcy5zZXREZWNvKHNvdXJjZSA/IHNvdXJjZS5hdHRycyA6IG51bGwpO1xuICAgICAgICBtZXJnZUNoaWxkcmVuSW50byh0aGlzLCBmcm9tLCB0bywgc291cmNlID8gc291cmNlLmNoaWxkcmVuLnNsaWNlKCkgOiBbXSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGF0KSB7XG4gICAgICAgIGxldCBlbmQgPSBuZXcgTGluZVZpZXc7XG4gICAgICAgIGVuZC5icmVha0FmdGVyID0gdGhpcy5icmVha0FmdGVyO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBlbmQ7XG4gICAgICAgIGxldCB7IGksIG9mZiB9ID0gdGhpcy5jaGlsZFBvcyhhdCk7XG4gICAgICAgIGlmIChvZmYpIHtcbiAgICAgICAgICAgIGVuZC5hcHBlbmQodGhpcy5jaGlsZHJlbltpXS5zcGxpdChvZmYpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ubWVyZ2Uob2ZmLCB0aGlzLmNoaWxkcmVuW2ldLmxlbmd0aCwgbnVsbCwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGorKylcbiAgICAgICAgICAgIGVuZC5hcHBlbmQodGhpcy5jaGlsZHJlbltqXSwgMCk7XG4gICAgICAgIHdoaWxlIChpID4gMCAmJiB0aGlzLmNoaWxkcmVuW2kgLSAxXS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bLS1pXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gaTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBhdDtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG4gICAgdHJhbnNmZXJET00ob3RoZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgb3RoZXIuc2V0RE9NKHRoaXMuZG9tKTtcbiAgICAgICAgb3RoZXIucHJldkF0dHJzID0gdGhpcy5wcmV2QXR0cnMgPT09IHVuZGVmaW5lZCA/IHRoaXMuYXR0cnMgOiB0aGlzLnByZXZBdHRycztcbiAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZG9tID0gbnVsbDtcbiAgICB9XG4gICAgc2V0RGVjbyhhdHRycykge1xuICAgICAgICBpZiAoIWF0dHJzRXEodGhpcy5hdHRycywgYXR0cnMpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBlbmQoY2hpbGQsIG9wZW5TdGFydCkge1xuICAgICAgICBqb2luSW5saW5lSW50byh0aGlzLCBjaGlsZCwgb3BlblN0YXJ0KTtcbiAgICB9XG4gICAgLy8gT25seSBjYWxsZWQgd2hlbiBidWlsZGluZyBhIGxpbmUgdmlldyBpbiBDb250ZW50QnVpbGRlclxuICAgIGFkZExpbmVEZWNvKGRlY28pIHtcbiAgICAgICAgbGV0IGF0dHJzID0gZGVjby5zcGVjLmF0dHJpYnV0ZXMsIGNscyA9IGRlY28uc3BlYy5jbGFzcztcbiAgICAgICAgaWYgKGF0dHJzKVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGNvbWJpbmVBdHRycyhhdHRycywgdGhpcy5hdHRycyB8fCB7fSk7XG4gICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gY29tYmluZUF0dHJzKHsgY2xhc3M6IGNscyB9LCB0aGlzLmF0dHJzIHx8IHt9KTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBpbmxpbmVET01BdFBvcyh0aGlzLCBwb3MpO1xuICAgIH1cbiAgICByZXVzZURPTShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiRElWXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5mbGFncyB8PSA0IC8qIFZpZXdGbGFnLkF0dHJzRGlydHkgKi8gfCAyIC8qIFZpZXdGbGFnLk5vZGVEaXJ0eSAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzeW5jKHZpZXcsIHRyYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgICAgICAgdGhpcy5zZXRET00oZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycyA/IG51bGwgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mbGFncyAmIDQgLyogVmlld0ZsYWcuQXR0cnNEaXJ0eSAqLykge1xuICAgICAgICAgICAgY2xlYXJBdHRyaWJ1dGVzKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmV2QXR0cnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMucHJldkF0dHJzLCB0aGlzLmF0dHJzKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1saW5lXCIpO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuc3luYyh2aWV3LCB0cmFjayk7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5kb20ubGFzdENoaWxkO1xuICAgICAgICB3aGlsZSAobGFzdCAmJiBDb250ZW50Vmlldy5nZXQobGFzdCkgaW5zdGFuY2VvZiBNYXJrVmlldylcbiAgICAgICAgICAgIGxhc3QgPSBsYXN0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFsYXN0IHx8ICF0aGlzLmxlbmd0aCB8fFxuICAgICAgICAgICAgbGFzdC5ub2RlTmFtZSAhPSBcIkJSXCIgJiYgKChfYSA9IENvbnRlbnRWaWV3LmdldChsYXN0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRWRpdGFibGUpID09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKCFicm93c2VyLmlvcyB8fCAhdGhpcy5jaGlsZHJlbi5zb21lKGNoID0+IGNoIGluc3RhbmNlb2YgVGV4dFZpZXcpKSkge1xuICAgICAgICAgICAgbGV0IGhhY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiQlJcIik7XG4gICAgICAgICAgICBoYWNrLmNtSWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGhhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgdGhpcy5sZW5ndGggPiAyMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgdG90YWxXaWR0aCA9IDAsIHRleHRIZWlnaHQ7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXcpIHx8IC9bXiAtfl0vLnRlc3QoY2hpbGQudGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihjaGlsZC5kb20pO1xuICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdG90YWxXaWR0aCArPSByZWN0c1swXS53aWR0aDtcbiAgICAgICAgICAgIHRleHRIZWlnaHQgPSByZWN0c1swXS5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0b3RhbFdpZHRoID8gbnVsbCA6IHtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCxcbiAgICAgICAgICAgIGNoYXJXaWR0aDogdG90YWxXaWR0aCAvIHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgdGV4dEhlaWdodFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBjb29yZHNJbkNoaWxkcmVuKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgICAgIC8vIENvcnJlY3QgcmVjdGFuZ2xlIGhlaWdodCBmb3IgZW1wdHkgbGluZXMgd2hlbiB0aGUgcmV0dXJuZWRcbiAgICAgICAgLy8gaGVpZ2h0IGlzIGxhcmdlciB0aGFuIHRoZSB0ZXh0IGhlaWdodC5cbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiByZWN0ICYmIHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBsZXQgeyBoZWlnaHRPcmFjbGUgfSA9IHRoaXMucGFyZW50LnZpZXcudmlld1N0YXRlLCBoZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGhlaWdodCAtIGhlaWdodE9yYWNsZS5saW5lSGVpZ2h0KSA8IDIgJiYgaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQgPCBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IChoZWlnaHQgLSBoZWlnaHRPcmFjbGUudGV4dEhlaWdodCkgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHRvcDogcmVjdC50b3AgKyBkaXN0LCBib3R0b206IHJlY3QuYm90dG9tIC0gZGlzdCwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5sZWZ0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIGJlY29tZShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBMaW5lVmlldyAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAwICYmIG90aGVyLmNoaWxkcmVuLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICBhdHRyc0VxKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSAmJiB0aGlzLmJyZWFrQWZ0ZXIgPT0gb3RoZXIuYnJlYWtBZnRlcjtcbiAgICB9XG4gICAgY292ZXJzKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHN0YXRpYyBmaW5kKGRvY1ZpZXcsIHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IGRvY1ZpZXcuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBibG9jayA9IGRvY1ZpZXcuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGJsb2NrLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrIGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9jaztcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiA9IGVuZCArIGJsb2NrLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY2xhc3MgQmxvY2tXaWRnZXRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHdpZGdldCwgbGVuZ3RoLCBkZWNvKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5kZWNvID0gZGVjbztcbiAgICAgICAgdGhpcy5icmVha0FmdGVyID0gMDtcbiAgICAgICAgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX3Rha2VEZWNvLCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA9PSAwID8gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSkgOiBET01Qb3MuYWZ0ZXIodGhpcy5kb20sIHBvcyA9PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIHNwbGl0KGF0KSB7XG4gICAgICAgIGxldCBsZW4gPSB0aGlzLmxlbmd0aCAtIGF0O1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGF0O1xuICAgICAgICBsZXQgZW5kID0gbmV3IEJsb2NrV2lkZ2V0Vmlldyh0aGlzLndpZGdldCwgbGVuLCB0aGlzLmRlY28pO1xuICAgICAgICBlbmQuYnJlYWtBZnRlciA9IHRoaXMuYnJlYWtBZnRlcjtcbiAgICAgICAgcmV0dXJuIGVuZDtcbiAgICB9XG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gbm9DaGlsZHJlbjsgfVxuICAgIHN5bmModmlldykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20sIHZpZXcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucHJldldpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMucHJldldpZGdldCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh2aWV3KSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2lkZ2V0LmVkaXRhYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC52aWV3LnN0YXRlLmRvYy5zbGljZSh0aGlzLnBvc0F0U3RhcnQsIHRoaXMucG9zQXRFbmQpIDogVGV4dC5lbXB0eTtcbiAgICB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGJlY29tZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiZcbiAgICAgICAgICAgIG90aGVyLndpZGdldC5jb25zdHJ1Y3RvciA9PSB0aGlzLndpZGdldC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgaWYgKCFvdGhlci53aWRnZXQuY29tcGFyZSh0aGlzLndpZGdldCkpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGlydHkodHJ1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20gJiYgIXRoaXMucHJldldpZGdldClcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZXaWRnZXQgPSB0aGlzLndpZGdldDtcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0ID0gb3RoZXIud2lkZ2V0O1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBvdGhlci5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmRlY28gPSBvdGhlci5kZWNvO1xuICAgICAgICAgICAgdGhpcy5icmVha0FmdGVyID0gb3RoZXIuYnJlYWtBZnRlcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRoaXMud2lkZ2V0Lmlnbm9yZUV2ZW50KGV2ZW50KTsgfVxuICAgIGdldCBpc0VkaXRhYmxlKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaXNXaWRnZXQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCBjdXN0b20gPSB0aGlzLndpZGdldC5jb29yZHNBdCh0aGlzLmRvbSwgcG9zLCBzaWRlKTtcbiAgICAgICAgaWYgKGN1c3RvbSlcbiAgICAgICAgICAgIHJldHVybiBjdXN0b207XG4gICAgICAgIGlmICh0aGlzLndpZGdldCBpbnN0YW5jZW9mIEJsb2NrR2FwV2lkZ2V0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBmbGF0dGVuUmVjdCh0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdGhpcy5sZW5ndGggPyBwb3MgPT0gMCA6IHNpZGUgPD0gMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy53aWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgfVxuICAgIGNvdmVycyhzaWRlKSB7XG4gICAgICAgIGxldCB7IHN0YXJ0U2lkZSwgZW5kU2lkZSB9ID0gdGhpcy5kZWNvO1xuICAgICAgICByZXR1cm4gc3RhcnRTaWRlID09IGVuZFNpZGUgPyBmYWxzZSA6IHNpZGUgPCAwID8gc3RhcnRTaWRlIDwgMCA6IGVuZFNpZGUgPiAwO1xuICAgIH1cbn1cbmNsYXNzIEJsb2NrR2FwV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IoaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsdC5jbGFzc05hbWUgPSBcImNtLWdhcFwiO1xuICAgICAgICB0aGlzLnVwZGF0ZURPTShlbHQpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuaGVpZ2h0ID09IHRoaXMuaGVpZ2h0OyB9XG4gICAgdXBkYXRlRE9NKGVsdCkge1xuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgZWRpdGFibGUoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIHRoaXMuaGVpZ2h0OyB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuXG5jbGFzcyBDb250ZW50QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoZG9jLCBwb3MsIGVuZCwgZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3IpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvciA9IGRpc2FsbG93QmxvY2tFZmZlY3RzRm9yO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmVha0F0U3RhcnQgPSAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgdGhpcy5idWZmZXJNYXJrcyA9IFtdO1xuICAgICAgICAvLyBTZXQgdG8gZmFsc2UgZGlyZWN0bHkgYWZ0ZXIgYSB3aWRnZXQgdGhhdCBjb3ZlcnMgdGhlIHBvc2l0aW9uIGFmdGVyIGl0XG4gICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICB0aGlzLm9wZW5TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLm9wZW5FbmQgPSAtMTtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBkb2MuaXRlcigpO1xuICAgICAgICB0aGlzLnNraXAgPSBwb3M7XG4gICAgfVxuICAgIHBvc0NvdmVyZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuYnJlYWtBdFN0YXJ0ICYmIHRoaXMuZG9jLmxpbmVBdCh0aGlzLnBvcykuZnJvbSAhPSB0aGlzLnBvcztcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gIShsYXN0LmJyZWFrQWZ0ZXIgfHwgbGFzdCBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldyAmJiBsYXN0LmRlY28uZW5kU2lkZSA8IDApO1xuICAgIH1cbiAgICBnZXRMaW5lKCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VyTGluZSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnB1c2godGhpcy5jdXJMaW5lID0gbmV3IExpbmVWaWV3KTtcbiAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmN1ckxpbmU7XG4gICAgfVxuICAgIGZsdXNoQnVmZmVyKGFjdGl2ZSA9IHRoaXMuYnVmZmVyTWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lLmFwcGVuZCh3cmFwTWFya3MobmV3IFdpZGdldEJ1ZmZlclZpZXcoLTEpLCBhY3RpdmUpLCBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogQnVmLk5vICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEJsb2NrV2lkZ2V0KHZpZXcpIHtcbiAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRlbnQucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgZmluaXNoKG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlciAmJiBvcGVuRW5kIDw9IHRoaXMuYnVmZmVyTWFya3MubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgaWYgKCF0aGlzLnBvc0NvdmVyZWQoKSAmJlxuICAgICAgICAgICAgIShvcGVuRW5kICYmIHRoaXMuY29udGVudC5sZW5ndGggJiYgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldykpXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoKTtcbiAgICB9XG4gICAgYnVpbGRUZXh0KGxlbmd0aCwgYWN0aXZlLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHRPZmYgPT0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCB7IHZhbHVlLCBsaW5lQnJlYWssIGRvbmUgfSA9IHRoaXMuY3Vyc29yLm5leHQodGhpcy5za2lwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW4gb3V0IG9mIHRleHQgY29udGVudCB3aGVuIGRyYXdpbmcgaW5saW5lIHZpZXdzXCIpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lQnJlYWspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvc0NvdmVyZWQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0uYnJlYWtBZnRlciA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnJlYWtBdFN0YXJ0ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbHVzaEJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRha2UgPSBNYXRoLm1pbih0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmLCBsZW5ndGgsIDUxMiAvKiBULkNodW5rICovKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoYWN0aXZlLnNsaWNlKGFjdGl2ZS5sZW5ndGggLSBvcGVuU3RhcnQpKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpLmFwcGVuZCh3cmFwTWFya3MobmV3IFRleHRWaWV3KHRoaXMudGV4dC5zbGljZSh0aGlzLnRleHRPZmYsIHRoaXMudGV4dE9mZiArIHRha2UpKSwgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuYXRDdXJzb3JQb3MgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50ZXh0T2ZmICs9IHRha2U7XG4gICAgICAgICAgICBsZW5ndGggLT0gdGFrZTtcbiAgICAgICAgICAgIG9wZW5TdGFydCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Bhbihmcm9tLCB0bywgYWN0aXZlLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgdGhpcy5idWlsZFRleHQodG8gLSBmcm9tLCBhY3RpdmUsIG9wZW5TdGFydCk7XG4gICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB9XG4gICAgcG9pbnQoZnJvbSwgdG8sIGRlY28sIGFjdGl2ZSwgb3BlblN0YXJ0LCBpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0ZvcltpbmRleF0gJiYgZGVjbyBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgaWYgKGRlY28uYmxvY2spXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCbG9jayBkZWNvcmF0aW9ucyBtYXkgbm90IGJlIHNwZWNpZmllZCB2aWEgcGx1Z2luc1wiKTtcbiAgICAgICAgICAgIGlmICh0byA+IHRoaXMuZG9jLmxpbmVBdCh0aGlzLnBvcykudG8pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEZWNvcmF0aW9ucyB0aGF0IHJlcGxhY2UgbGluZSBicmVha3MgbWF5IG5vdCBiZSBzcGVjaWZpZWQgdmlhIHBsdWdpbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKGRlY28gaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlY28uc3RhcnRTaWRlID4gMCAmJiAhdGhpcy5wb3NDb3ZlcmVkKCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmxvY2tXaWRnZXQobmV3IEJsb2NrV2lkZ2V0VmlldyhkZWNvLndpZGdldCB8fCBOdWxsV2lkZ2V0LmJsb2NrLCBsZW4sIGRlY28pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB2aWV3ID0gV2lkZ2V0Vmlldy5jcmVhdGUoZGVjby53aWRnZXQgfHwgTnVsbFdpZGdldC5pbmxpbmUsIGxlbiwgbGVuID8gMCA6IGRlY28uc3RhcnRTaWRlKTtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yQmVmb3JlID0gdGhpcy5hdEN1cnNvclBvcyAmJiAhdmlldy5pc0VkaXRhYmxlICYmIG9wZW5TdGFydCA8PSBhY3RpdmUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIChmcm9tIDwgdG8gfHwgZGVjby5zdGFydFNpZGUgPiAwKTtcbiAgICAgICAgICAgICAgICBsZXQgY3Vyc29yQWZ0ZXIgPSAhdmlldy5pc0VkaXRhYmxlICYmIChmcm9tIDwgdG8gfHwgb3BlblN0YXJ0ID4gYWN0aXZlLmxlbmd0aCB8fCBkZWNvLnN0YXJ0U2lkZSA8PSAwKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIgPT0gMiAvKiBCdWYuSWZDdXJzb3IgKi8gJiYgIWN1cnNvckJlZm9yZSAmJiAhdmlldy5pc0VkaXRhYmxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIEJ1Zi5ObyAqLztcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKGFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvckJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lLmFwcGVuZCh3cmFwTWFya3MobmV3IFdpZGdldEJ1ZmZlclZpZXcoMSksIGFjdGl2ZSksIG9wZW5TdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5TdGFydCA9IGFjdGl2ZS5sZW5ndGggKyBNYXRoLm1heCgwLCBvcGVuU3RhcnQgLSBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluZS5hcHBlbmQod3JhcE1hcmtzKHZpZXcsIGFjdGl2ZSksIG9wZW5TdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IGN1cnNvckFmdGVyO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9ICFjdXJzb3JBZnRlciA/IDAgLyogQnVmLk5vICovIDogZnJvbSA8IHRvIHx8IG9wZW5TdGFydCA+IGFjdGl2ZS5sZW5ndGggPyAxIC8qIEJ1Zi5ZZXMgKi8gOiAyIC8qIEJ1Zi5JZkN1cnNvciAqLztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlck1hcmtzID0gYWN0aXZlLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS5mcm9tID09IHRoaXMucG9zKSB7IC8vIExpbmUgZGVjb3JhdGlvblxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCkuYWRkTGluZURlY28oZGVjbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgLy8gQWR2YW5jZSB0aGUgaXRlcmF0b3IgcGFzdCB0aGUgcmVwbGFjZWQgY29udGVudFxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dE9mZiArIGxlbiA8PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcCArPSBsZW4gLSAodGhpcy50ZXh0Lmxlbmd0aCAtIHRoaXMudGV4dE9mZik7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcGVuU3RhcnQgPCAwKVxuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQ7XG4gICAgfVxuICAgIHN0YXRpYyBidWlsZCh0ZXh0LCBmcm9tLCB0bywgZGVjb3JhdGlvbnMsIGR5bmFtaWNEZWNvcmF0aW9uTWFwKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IENvbnRlbnRCdWlsZGVyKHRleHQsIGZyb20sIHRvLCBkeW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgIGJ1aWxkZXIub3BlbkVuZCA9IFJhbmdlU2V0LnNwYW5zKGRlY29yYXRpb25zLCBmcm9tLCB0bywgYnVpbGRlcik7XG4gICAgICAgIGlmIChidWlsZGVyLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICBidWlsZGVyLm9wZW5TdGFydCA9IGJ1aWxkZXIub3BlbkVuZDtcbiAgICAgICAgYnVpbGRlci5maW5pc2goYnVpbGRlci5vcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcE1hcmtzKHZpZXcsIGFjdGl2ZSkge1xuICAgIGZvciAobGV0IG1hcmsgb2YgYWN0aXZlKVxuICAgICAgICB2aWV3ID0gbmV3IE1hcmtWaWV3KG1hcmssIFt2aWV3XSwgdmlldy5sZW5ndGgpO1xuICAgIHJldHVybiB2aWV3O1xufVxuY2xhc3MgTnVsbFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLnRhZyA9PSB0aGlzLnRhZzsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnRhZyk7IH1cbiAgICB1cGRhdGVET00oZWx0KSB7IHJldHVybiBlbHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSB0aGlzLnRhZzsgfVxuICAgIGdldCBpc0hpZGRlbigpIHsgcmV0dXJuIHRydWU7IH1cbn1cbk51bGxXaWRnZXQuaW5saW5lID0gLypAX19QVVJFX18qL25ldyBOdWxsV2lkZ2V0KFwic3BhblwiKTtcbk51bGxXaWRnZXQuYmxvY2sgPSAvKkBfX1BVUkVfXyovbmV3IE51bGxXaWRnZXQoXCJkaXZcIik7XG5cbi8qKlxuVXNlZCB0byBpbmRpY2F0ZSBbdGV4dCBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24pLlxuKi9cbnZhciBEaXJlY3Rpb24gPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgICAvLyAoVGhlc2UgYXJlIGNob3NlbiB0byBtYXRjaCB0aGUgYmFzZSBsZXZlbHMsIGluIGJpZGkgYWxnb3JpdGhtXG4gICAgLy8gdGVybXMsIG9mIHNwYW5zIGluIHRoYXQgZGlyZWN0aW9uLilcbiAgICAvKipcbiAgICBMZWZ0LXRvLXJpZ2h0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkxUUlwiXSA9IDBdID0gXCJMVFJcIjtcbiAgICAvKipcbiAgICBSaWdodC10by1sZWZ0LlxuICAgICovXG4gICAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIlJUTFwiXSA9IDFdID0gXCJSVExcIjtcbnJldHVybiBEaXJlY3Rpb259KShEaXJlY3Rpb24gfHwgKERpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBMVFIgPSBEaXJlY3Rpb24uTFRSLCBSVEwgPSBEaXJlY3Rpb24uUlRMO1xuLy8gRGVjb2RlIGEgc3RyaW5nIHdpdGggZWFjaCB0eXBlIGVuY29kZWQgYXMgbG9nMih0eXBlKVxuZnVuY3Rpb24gZGVjKHN0cikge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goMSA8PCArc3RyW2ldKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQ2hhcmFjdGVyIHR5cGVzIGZvciBjb2RlcG9pbnRzIDAgdG8gMHhmOFxuY29uc3QgTG93VHlwZXMgPSAvKkBfX1BVUkVfXyovZGVjKFwiODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg2NjY4ODg4ODg3ODc4MzMzMzMzMzMzMzc4ODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODc4NjY2Njg4ODgwODg4ODg2NjMzODA4ODgzMDg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDhcIik7XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMHg2MDAgdG8gMHg2ZjlcbmNvbnN0IEFyYWJpY1R5cGVzID0gLypAX19QVVJFX18qL2RlYyhcIjQ0NDQ0NDg4MjY2MjcyODg5OTk5OTk5OTk5OTIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk5OTk5OTk5OTk5OTk5OTQ0NDQ0NDQ0NDQ2NDQyMjI4MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI5OTk5OTk5NDk5OTk5OTkyMjk5ODk5OTkyMjMzMzMzMzMzMzNcIik7XG5jb25zdCBCcmFja2V0cyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpLCBCcmFja2V0U3RhY2sgPSBbXTtcbi8vIFRoZXJlJ3MgYSBsb3QgbW9yZSBpblxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvUHVibGljL1VDRC9sYXRlc3QvdWNkL0JpZGlCcmFja2V0cy50eHQsXG4vLyB3aGljaCBhcmUgbGVmdCBvdXQgdG8ga2VlcCBjb2RlIHNpemUgZG93bi5cbmZvciAobGV0IHAgb2YgW1wiKClcIiwgXCJbXVwiLCBcInt9XCJdKSB7XG4gICAgbGV0IGwgPSAvKkBfX1BVUkVfXyovcC5jaGFyQ29kZUF0KDApLCByID0gLypAX19QVVJFX18qL3AuY2hhckNvZGVBdCgxKTtcbiAgICBCcmFja2V0c1tsXSA9IHI7XG4gICAgQnJhY2tldHNbcl0gPSAtbDtcbn1cbmZ1bmN0aW9uIGNoYXJUeXBlKGNoKSB7XG4gICAgcmV0dXJuIGNoIDw9IDB4ZjcgPyBMb3dUeXBlc1tjaF0gOlxuICAgICAgICAweDU5MCA8PSBjaCAmJiBjaCA8PSAweDVmNCA/IDIgLyogVC5SICovIDpcbiAgICAgICAgICAgIDB4NjAwIDw9IGNoICYmIGNoIDw9IDB4NmY5ID8gQXJhYmljVHlwZXNbY2ggLSAweDYwMF0gOlxuICAgICAgICAgICAgICAgIDB4NmVlIDw9IGNoICYmIGNoIDw9IDB4OGFjID8gNCAvKiBULkFMICovIDpcbiAgICAgICAgICAgICAgICAgICAgMHgyMDAwIDw9IGNoICYmIGNoIDw9IDB4MjAwYyA/IDI1NiAvKiBULk5JICovIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmI1MCA8PSBjaCAmJiBjaCA8PSAweGZkZmYgPyA0IC8qIFQuQUwgKi8gOiAxIC8qIFQuTCAqLztcbn1cbmNvbnN0IEJpZGlSRSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXFx1ZmI1MC1cXHVmZGZmXS87XG4vKipcblJlcHJlc2VudHMgYSBjb250aWd1b3VzIHJhbmdlIG9mIHRleHQgdGhhdCBoYXMgYSBzaW5nbGUgZGlyZWN0aW9uXG4oYXMgaW4gbGVmdC10by1yaWdodCBvciByaWdodC10by1sZWZ0KS5cbiovXG5jbGFzcyBCaWRpU3BhbiB7XG4gICAgLyoqXG4gICAgVGhlIGRpcmVjdGlvbiBvZiB0aGlzIHNwYW4uXG4gICAgKi9cbiAgICBnZXQgZGlyKCkgeyByZXR1cm4gdGhpcy5sZXZlbCAlIDIgPyBSVEwgOiBMVFI7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgc3BhbiAocmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lKS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHNwYW4uXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIFtcImJpZGlcbiAgICBsZXZlbFwiXShodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI5LyNCYXNpY19EaXNwbGF5X0FsZ29yaXRobSlcbiAgICBvZiB0aGUgc3BhbiAoaW4gdGhpcyBjb250ZXh0LCAwIG1lYW5zXG4gICAgbGVmdC10by1yaWdodCwgMSBtZWFucyByaWdodC10by1sZWZ0LCAyIG1lYW5zIGxlZnQtdG8tcmlnaHRcbiAgICBudW1iZXIgaW5zaWRlIHJpZ2h0LXRvLWxlZnQgdGV4dCkuXG4gICAgKi9cbiAgICBsZXZlbCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzaWRlKGVuZCwgZGlyKSB7IHJldHVybiAodGhpcy5kaXIgPT0gZGlyKSA9PSBlbmQgPyB0aGlzLnRvIDogdGhpcy5mcm9tOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3J3YXJkKGZvcndhcmQsIGRpcikgeyByZXR1cm4gZm9yd2FyZCA9PSAodGhpcy5kaXIgPT0gZGlyKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZpbmQob3JkZXIsIGluZGV4LCBsZXZlbCwgYXNzb2MpIHtcbiAgICAgICAgbGV0IG1heWJlID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzcGFuID0gb3JkZXJbaV07XG4gICAgICAgICAgICBpZiAoc3Bhbi5mcm9tIDw9IGluZGV4ICYmIHNwYW4udG8gPj0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Bhbi5sZXZlbCA9PSBsZXZlbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBtdWx0aXBsZSBzcGFucyBtYXRjaCwgaWYgYXNzb2MgIT0gMCwgdGFrZSB0aGUgb25lIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBjb3ZlcnMgdGhhdCBzaWRlLCBvdGhlcndpc2UgdGFrZSB0aGUgb25lIHdpdGggdGhlIG1pbmltdW1cbiAgICAgICAgICAgICAgICAvLyBsZXZlbC5cbiAgICAgICAgICAgICAgICBpZiAobWF5YmUgPCAwIHx8IChhc3NvYyAhPSAwID8gKGFzc29jIDwgMCA/IHNwYW4uZnJvbSA8IGluZGV4IDogc3Bhbi50byA+IGluZGV4KSA6IG9yZGVyW21heWJlXS5sZXZlbCA+IHNwYW4ubGV2ZWwpKVxuICAgICAgICAgICAgICAgICAgICBtYXliZSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICByZXR1cm4gbWF5YmU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNvbGF0ZXNFcShhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBpQSA9IGFbaV0sIGlCID0gYltpXTtcbiAgICAgICAgaWYgKGlBLmZyb20gIT0gaUIuZnJvbSB8fCBpQS50byAhPSBpQi50byB8fCBpQS5kaXJlY3Rpb24gIT0gaUIuZGlyZWN0aW9uIHx8ICFpc29sYXRlc0VxKGlBLmlubmVyLCBpQi5pbm5lcikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUmV1c2VkIGFycmF5IG9mIGNoYXJhY3RlciB0eXBlc1xuY29uc3QgdHlwZXMgPSBbXTtcbi8vIEZpbGwgaW4gdGhlIGNoYXJhY3RlciB0eXBlcyAoaW4gYHR5cGVzYCkgZnJvbSBgZnJvbWAgdG8gYHRvYCBhbmRcbi8vIGFwcGx5IFcgbm9ybWFsaXphdGlvbiBydWxlcy5cbmZ1bmN0aW9uIGNvbXB1dGVDaGFyVHlwZXMobGluZSwgckZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGZvciAobGV0IGlJID0gMDsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgbGV0IHByZXZUeXBlID0gaUkgPyAyNTYgLyogVC5OSSAqLyA6IG91dGVyVHlwZTtcbiAgICAgICAgLy8gVzEuIEV4YW1pbmUgZWFjaCBub24tc3BhY2luZyBtYXJrIChOU00pIGluIHRoZSBsZXZlbCBydW4sIGFuZFxuICAgICAgICAvLyBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiB0aGUgcHJldmlvdXNcbiAgICAgICAgLy8gY2hhcmFjdGVyLiBJZiB0aGUgTlNNIGlzIGF0IHRoZSBzdGFydCBvZiB0aGUgbGV2ZWwgcnVuLCBpdCB3aWxsXG4gICAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzb3IuXG4gICAgICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIEFMLCBvciBzb3IpIGlzIGZvdW5kLiBJZiBhblxuICAgICAgICAvLyBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljXG4gICAgICAgIC8vIG51bWJlci5cbiAgICAgICAgLy8gVzMuIENoYW5nZSBhbGwgQUxzIHRvIFIuXG4gICAgICAgIC8vIChMZWZ0IGFmdGVyIHRoaXM6IEwsIFIsIEVOLCBBTiwgRVQsIENTLCBOSSlcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb20sIHByZXYgPSBwcmV2VHlwZSwgcHJldlN0cm9uZyA9IHByZXZUeXBlOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBjaGFyVHlwZShsaW5lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gNTEyIC8qIFQuTlNNICovKVxuICAgICAgICAgICAgICAgIHR5cGUgPSBwcmV2O1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA4IC8qIFQuRU4gKi8gJiYgcHJldlN0cm9uZyA9PSA0IC8qIFQuQUwgKi8pXG4gICAgICAgICAgICAgICAgdHlwZSA9IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICB0eXBlc1tpXSA9IHR5cGUgPT0gNCAvKiBULkFMICovID8gMiAvKiBULlIgKi8gOiB0eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgJiA3IC8qIFQuU3Ryb25nICovKVxuICAgICAgICAgICAgICAgIHByZXZTdHJvbmcgPSB0eXBlO1xuICAgICAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVzUuIEEgc2VxdWVuY2Ugb2YgRXVyb3BlYW4gdGVybWluYXRvcnMgYWRqYWNlbnQgdG8gRXVyb3BlYW5cbiAgICAgICAgLy8gbnVtYmVycyBjaGFuZ2VzIHRvIGFsbCBFdXJvcGVhbiBudW1iZXJzLlxuICAgICAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcbiAgICAgICAgLy8gTmV1dHJhbC5cbiAgICAgICAgLy8gVzcuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW4gTCBpc1xuICAgICAgICAvLyBmb3VuZCwgdGhlbiBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBMLlxuICAgICAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTiwgTkkpXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tLCBwcmV2ID0gcHJldlR5cGUsIHByZXZTdHJvbmcgPSBwcmV2VHlwZTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZSA9PSAxMjggLyogVC5DUyAqLykge1xuICAgICAgICAgICAgICAgIGlmIChpIDwgdG8gLSAxICYmIHByZXYgPT0gdHlwZXNbaSArIDFdICYmIChwcmV2ICYgMjQgLyogVC5OdW0gKi8pKVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gdHlwZXNbaV0gPSBwcmV2O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbaV0gPSAyNTYgLyogVC5OSSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gNjQgLyogVC5FVCAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZW5kIDwgdG8gJiYgdHlwZXNbZW5kXSA9PSA2NCAvKiBULkVUICovKVxuICAgICAgICAgICAgICAgICAgICBlbmQrKztcbiAgICAgICAgICAgICAgICBsZXQgcmVwbGFjZSA9IChpICYmIHByZXYgPT0gOCAvKiBULkVOICovKSB8fCAoZW5kIDwgclRvICYmIHR5cGVzW2VuZF0gPT0gOCAvKiBULkVOICovKSA/IChwcmV2U3Ryb25nID09IDEgLyogVC5MICovID8gMSAvKiBULkwgKi8gOiA4IC8qIFQuRU4gKi8pIDogMjU2IC8qIFQuTkkgKi87XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBlbmQ7IGorKylcbiAgICAgICAgICAgICAgICAgICAgdHlwZXNbal0gPSByZXBsYWNlO1xuICAgICAgICAgICAgICAgIGkgPSBlbmQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA4IC8qIFQuRU4gKi8gJiYgcHJldlN0cm9uZyA9PSAxIC8qIFQuTCAqLykge1xuICAgICAgICAgICAgICAgIHR5cGVzW2ldID0gMSAvKiBULkwgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlICYgNyAvKiBULlN0cm9uZyAqLylcbiAgICAgICAgICAgICAgICBwcmV2U3Ryb25nID0gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFByb2Nlc3MgYnJhY2tldHMgdGhyb3VnaG91dCBhIHJ1biBzZXF1ZW5jZS5cbmZ1bmN0aW9uIHByb2Nlc3NCcmFja2V0UGFpcnMobGluZSwgckZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGxldCBvcHBvc2l0ZVR5cGUgPSBvdXRlclR5cGUgPT0gMSAvKiBULkwgKi8gPyAyIC8qIFQuUiAqLyA6IDEgLyogVC5MICovO1xuICAgIGZvciAobGV0IGlJID0gMCwgc0kgPSAwLCBjb250ZXh0ID0gMDsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgLy8gTjAuIFByb2Nlc3MgYnJhY2tldCBwYWlycyBpbiBhbiBpc29sYXRpbmcgcnVuIHNlcXVlbmNlXG4gICAgICAgIC8vIHNlcXVlbnRpYWxseSBpbiB0aGUgbG9naWNhbCBvcmRlciBvZiB0aGUgdGV4dCBwb3NpdGlvbnMgb2YgdGhlXG4gICAgICAgIC8vIG9wZW5pbmcgcGFpcmVkIGJyYWNrZXRzIHVzaW5nIHRoZSBsb2dpYyBnaXZlbiBiZWxvdy4gV2l0aGluIHRoaXNcbiAgICAgICAgLy8gc2NvcGUsIGJpZGlyZWN0aW9uYWwgdHlwZXMgRU4gYW5kIEFOIGFyZSB0cmVhdGVkIGFzIFIuXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tLCBjaCwgYnIsIHR5cGU7IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBLZWVwcyBbc3RhcnRJbmRleCwgdHlwZSwgc3Ryb25nU2Vlbl0gdHJpcGxlcyBmb3IgZWFjaCBvcGVuXG4gICAgICAgICAgICAvLyBicmFja2V0IG9uIEJyYWNrZXRTdGFjay5cbiAgICAgICAgICAgIGlmIChiciA9IEJyYWNrZXRzW2NoID0gbGluZS5jaGFyQ29kZUF0KGkpXSkge1xuICAgICAgICAgICAgICAgIGlmIChiciA8IDApIHsgLy8gQ2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNKID0gc0kgLSAzOyBzSiA+PSAwOyBzSiAtPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQnJhY2tldFN0YWNrW3NKICsgMV0gPT0gLWJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZsYWdzID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSAoZmxhZ3MgJiAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLykgPyBvdXRlclR5cGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGZsYWdzICYgNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi8pID8gMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxhZ3MgJiAxIC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUJlZm9yZSAqLykgPyBvcHBvc2l0ZVR5cGUgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzW2ldID0gdHlwZXNbQnJhY2tldFN0YWNrW3NKXV0gPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNJID0gc0o7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQnJhY2tldFN0YWNrLmxlbmd0aCA9PSAxODkgLyogQnJhY2tldGVkLk1heERlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NJKytdID0gY2g7XG4gICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHR5cGUgPSB0eXBlc1tpXSkgPT0gMiAvKiBULlIgKi8gfHwgdHlwZSA9PSAxIC8qIFQuTCAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbWJlZCA9IHR5cGUgPT0gb3V0ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBlbWJlZCA/IDAgOiAxIC8qIEJyYWNrZXRlZC5PcHBvc2l0ZUJlZm9yZSAqLztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzSiA9IHNJIC0gMzsgc0ogPj0gMDsgc0ogLT0gMykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIgJiAyIC8qIEJyYWNrZXRlZC5FbWJlZEluc2lkZSAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW1iZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSiArIDJdIHw9IDIgLyogQnJhY2tldGVkLkVtYmVkSW5zaWRlICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciAmIDQgLyogQnJhY2tldGVkLk9wcG9zaXRlSW5zaWRlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NKICsgMl0gfD0gNCAvKiBCcmFja2V0ZWQuT3Bwb3NpdGVJbnNpZGUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzTmV1dHJhbHMockZyb20sIHJUbywgaXNvbGF0ZXMsIG91dGVyVHlwZSkge1xuICAgIGZvciAobGV0IGlJID0gMCwgcHJldiA9IG91dGVyVHlwZTsgaUkgPD0gaXNvbGF0ZXMubGVuZ3RoOyBpSSsrKSB7XG4gICAgICAgIGxldCBmcm9tID0gaUkgPyBpc29sYXRlc1tpSSAtIDFdLnRvIDogckZyb20sIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgbmV1dHJhbHMgdGFrZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gc3Vycm91bmRpbmcgc3Ryb25nIHRleHQgaWYgdGhlIHRleHQgb24gYm90aCBzaWRlcyBoYXMgdGhlIHNhbWVcbiAgICAgICAgLy8gZGlyZWN0aW9uLiBFdXJvcGVhbiBhbmQgQXJhYmljIG51bWJlcnMgYWN0IGFzIGlmIHRoZXkgd2VyZSBSIGluXG4gICAgICAgIC8vIHRlcm1zIG9mIHRoZWlyIGluZmx1ZW5jZSBvbiBuZXV0cmFscy4gU3RhcnQtb2YtbGV2ZWwtcnVuIChzb3IpXG4gICAgICAgIC8vIGFuZCBlbmQtb2YtbGV2ZWwtcnVuIChlb3IpIGFyZSB1c2VkIGF0IGxldmVsIHJ1biBib3VuZGFyaWVzLlxuICAgICAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBuZXV0cmFscyB0YWtlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTilcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzspIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgICAgICBpZiAodHlwZSA9PSAyNTYgLyogVC5OSSAqLykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPT0gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpSSA9PSBpc29sYXRlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpc29sYXRlc1tpSSsrXS50bztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gaUkgPCBpc29sYXRlcy5sZW5ndGggPyBpc29sYXRlc1tpSV0uZnJvbSA6IHJUbztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1tlbmRdID09IDI1NiAvKiBULk5JICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBiZWZvcmVMID0gcHJldiA9PSAxIC8qIFQuTCAqLztcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXJMID0gKGVuZCA8IHJUbyA/IHR5cGVzW2VuZF0gOiBvdXRlclR5cGUpID09IDEgLyogVC5MICovO1xuICAgICAgICAgICAgICAgIGxldCByZXBsYWNlID0gYmVmb3JlTCA9PSBhZnRlckwgPyAoYmVmb3JlTCA/IDEgLyogVC5MICovIDogMiAvKiBULlIgKi8pIDogb3V0ZXJUeXBlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBlbmQsIGpJID0gaUksIGZyb21KID0gakkgPyBpc29sYXRlc1tqSSAtIDFdLnRvIDogckZyb207IGogPiBpOykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PSBmcm9tSikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGlzb2xhdGVzWy0takldLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tSiA9IGpJID8gaXNvbGF0ZXNbakkgLSAxXS50byA6IHJGcm9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzWy0tal0gPSByZXBsYWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IHR5cGU7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gRmluZCB0aGUgY29udGlndW91cyByYW5nZXMgb2YgY2hhcmFjdGVyIHR5cGVzIGluIGEgZ2l2ZW4gcmFuZ2UsIGFuZFxuLy8gZW1pdCBzcGFucyBmb3IgdGhlbS4gRmxpcCB0aGUgb3JkZXIgb2YgdGhlIHNwYW5zIGFzIGFwcHJvcHJpYXRlXG4vLyBiYXNlZCBvbiB0aGUgbGV2ZWwsIGFuZCBjYWxsIHRocm91Z2ggdG8gY29tcHV0ZSB0aGUgc3BhbnMgZm9yXG4vLyBpc29sYXRlcyBhdCB0aGUgcHJvcGVyIHBvaW50LlxuZnVuY3Rpb24gZW1pdFNwYW5zKGxpbmUsIGZyb20sIHRvLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgb3JkZXIpIHtcbiAgICBsZXQgb3VyVHlwZSA9IGxldmVsICUgMiA/IDIgLyogVC5SICovIDogMSAvKiBULkwgKi87XG4gICAgaWYgKChsZXZlbCAlIDIpID09IChiYXNlTGV2ZWwgJSAyKSkgeyAvLyBTYW1lIGRpciBhcyBiYXNlIGRpcmVjdGlvbiwgZG9uJ3QgZmxpcFxuICAgICAgICBmb3IgKGxldCBpQ2ggPSBmcm9tLCBpSSA9IDA7IGlDaCA8IHRvOykge1xuICAgICAgICAgICAgLy8gU2NhbiBhIHNlY3Rpb24gb2YgY2hhcmFjdGVycyBpbiBkaXJlY3Rpb24gb3VyVHlwZSwgdW5sZXNzXG4gICAgICAgICAgICAvLyB0aGVyZSdzIGFub3RoZXIgdHlwZSBvZiBjaGFyIHJpZ2h0IGFmdGVyIGlDaCwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAgICAgLy8gd2Ugc2NhbiBhIHNlY3Rpb24gb2Ygb3RoZXIgY2hhcmFjdGVycyAod2hpY2gsIGlmIG91clR5cGUgPT1cbiAgICAgICAgICAgIC8vIFQuTCwgbWF5IGNvbnRhaW4gYm90aCBULlIgYW5kIFQuQU4gY2hhcnMpLlxuICAgICAgICAgICAgbGV0IHNhbWVEaXIgPSB0cnVlLCBpc051bSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlJID09IGlzb2xhdGVzLmxlbmd0aCB8fCBpQ2ggPCBpc29sYXRlc1tpSV0uZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdHlwZXNbaUNoXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBvdXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVEaXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXNOdW0gPSBuZXh0ID09IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSG9sZHMgYW4gYXJyYXkgb2YgaXNvbGF0ZXMgdG8gcGFzcyB0byBhIHJlY3Vyc2l2ZSBjYWxsIGlmIHdlXG4gICAgICAgICAgICAvLyBtdXN0IHJlY3Vyc2UgKHRvIGRpc3Rpbmd1aXNoIFQuQU4gaW5zaWRlIGFuIFJUTCBzZWN0aW9uIGluXG4gICAgICAgICAgICAvLyBMVFIgdGV4dCksIG51bGwgaWYgd2UgY2FuIGVtaXQgZGlyZWN0bHlcbiAgICAgICAgICAgIGxldCByZWN1cnNlID0gIXNhbWVEaXIgJiYgb3VyVHlwZSA9PSAxIC8qIFQuTCAqLyA/IFtdIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBsb2NhbExldmVsID0gc2FtZURpciA/IGxldmVsIDogbGV2ZWwgKyAxO1xuICAgICAgICAgICAgbGV0IGlTY2FuID0gaUNoO1xuICAgICAgICAgICAgcnVuOiBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlJIDwgaXNvbGF0ZXMubGVuZ3RoICYmIGlTY2FuID09IGlzb2xhdGVzW2lJXS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzbyA9IGlzb2xhdGVzW2lJXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NhbiBhaGVhZCB0byB2ZXJpZnkgdGhhdCB0aGVyZSBpcyBhbm90aGVyIGNoYXIgaW4gdGhpcyBkaXIgYWZ0ZXIgdGhlIGlzb2xhdGUocylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzYW1lRGlyKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdXB0byA9IGlzby50bywgakkgPSBpSSArIDE7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHRvID09IHRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpJIDwgaXNvbGF0ZXMubGVuZ3RoICYmIGlzb2xhdGVzW2pJXS5mcm9tID09IHVwdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwdG8gPSBpc29sYXRlc1tqSSsrXS50bztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlc1t1cHRvXSA9PSBvdXJUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaUkrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3Vyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2UucHVzaChpc28pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzby5mcm9tID4gaUNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlDaCwgaXNvLmZyb20sIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXJTd2FwID0gKGlzby5kaXJlY3Rpb24gPT0gTFRSKSAhPSAhKGxvY2FsTGV2ZWwgJSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTZWN0aW9uT3JkZXIobGluZSwgZGlyU3dhcCA/IGxldmVsICsgMSA6IGxldmVsLCBiYXNlTGV2ZWwsIGlzby5pbm5lciwgaXNvLmZyb20sIGlzby50bywgb3JkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaUNoID0gaXNvLnRvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlTY2FuID0gaXNvLnRvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpU2NhbiA9PSB0byB8fCAoc2FtZURpciA/IHR5cGVzW2lTY2FuXSAhPSBvdXJUeXBlIDogdHlwZXNbaVNjYW5dID09IG91clR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaVNjYW4rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjdXJzZSlcbiAgICAgICAgICAgICAgICBlbWl0U3BhbnMobGluZSwgaUNoLCBpU2NhbiwgbGV2ZWwgKyAxLCBiYXNlTGV2ZWwsIHJlY3Vyc2UsIG9yZGVyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlDaCA8IGlTY2FuKVxuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlDaCwgaVNjYW4sIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgIGlDaCA9IGlTY2FuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJdGVyYXRlIGluIHJldmVyc2UgdG8gZmxpcCB0aGUgc3BhbiBvcmRlci4gU2FtZSBjb2RlIGFnYWluLCBidXRcbiAgICAgICAgLy8gZ29pbmcgZnJvbSB0aGUgYmFjayBvZiB0aGUgc2VjdGlvbiB0byB0aGUgZnJvbnRcbiAgICAgICAgZm9yIChsZXQgaUNoID0gdG8sIGlJID0gaXNvbGF0ZXMubGVuZ3RoOyBpQ2ggPiBmcm9tOykge1xuICAgICAgICAgICAgbGV0IHNhbWVEaXIgPSB0cnVlLCBpc051bSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpSSB8fCBpQ2ggPiBpc29sYXRlc1tpSSAtIDFdLnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0eXBlc1tpQ2ggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBvdXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbWVEaXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaXNOdW0gPSBuZXh0ID09IDE2IC8qIFQuQU4gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlY3Vyc2UgPSAhc2FtZURpciAmJiBvdXJUeXBlID09IDEgLyogVC5MICovID8gW10gOiBudWxsO1xuICAgICAgICAgICAgbGV0IGxvY2FsTGV2ZWwgPSBzYW1lRGlyID8gbGV2ZWwgOiBsZXZlbCArIDE7XG4gICAgICAgICAgICBsZXQgaVNjYW4gPSBpQ2g7XG4gICAgICAgICAgICBydW46IGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBpZiAoaUkgJiYgaVNjYW4gPT0gaXNvbGF0ZXNbaUkgLSAxXS50bykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc28gPSBpc29sYXRlc1stLWlJXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NhbiBhaGVhZCB0byB2ZXJpZnkgdGhhdCB0aGVyZSBpcyBhbm90aGVyIGNoYXIgaW4gdGhpcyBkaXIgYWZ0ZXIgdGhlIGlzb2xhdGUocylcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzYW1lRGlyKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdXB0byA9IGlzby5mcm9tLCBqSSA9IGlJOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXB0byA9PSBmcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBydW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpJICYmIGlzb2xhdGVzW2pJIC0gMV0udG8gPT0gdXB0bylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXB0byA9IGlzb2xhdGVzWy0takldLmZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZXNbdXB0byAtIDFdID09IG91clR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJ1bjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzZS5wdXNoKGlzbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNvLnRvIDwgaUNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlzby50bywgaUNoLCBsb2NhbExldmVsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGlyU3dhcCA9IChpc28uZGlyZWN0aW9uID09IExUUikgIT0gIShsb2NhbExldmVsICUgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlU2VjdGlvbk9yZGVyKGxpbmUsIGRpclN3YXAgPyBsZXZlbCArIDEgOiBsZXZlbCwgYmFzZUxldmVsLCBpc28uaW5uZXIsIGlzby5mcm9tLCBpc28udG8sIG9yZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlDaCA9IGlzby5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlTY2FuID0gaXNvLmZyb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuID09IGZyb20gfHwgKHNhbWVEaXIgPyB0eXBlc1tpU2NhbiAtIDFdICE9IG91clR5cGUgOiB0eXBlc1tpU2NhbiAtIDFdID09IG91clR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaVNjYW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVjdXJzZSlcbiAgICAgICAgICAgICAgICBlbWl0U3BhbnMobGluZSwgaVNjYW4sIGlDaCwgbGV2ZWwgKyAxLCBiYXNlTGV2ZWwsIHJlY3Vyc2UsIG9yZGVyKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlTY2FuIDwgaUNoKVxuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGlTY2FuLCBpQ2gsIGxvY2FsTGV2ZWwpKTtcbiAgICAgICAgICAgIGlDaCA9IGlTY2FuO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBsZXZlbCwgYmFzZUxldmVsLCBpc29sYXRlcywgZnJvbSwgdG8sIG9yZGVyKSB7XG4gICAgbGV0IG91dGVyVHlwZSA9IChsZXZlbCAlIDIgPyAyIC8qIFQuUiAqLyA6IDEgLyogVC5MICovKTtcbiAgICBjb21wdXRlQ2hhclR5cGVzKGxpbmUsIGZyb20sIHRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKTtcbiAgICBwcm9jZXNzQnJhY2tldFBhaXJzKGxpbmUsIGZyb20sIHRvLCBpc29sYXRlcywgb3V0ZXJUeXBlKTtcbiAgICBwcm9jZXNzTmV1dHJhbHMoZnJvbSwgdG8sIGlzb2xhdGVzLCBvdXRlclR5cGUpO1xuICAgIGVtaXRTcGFucyhsaW5lLCBmcm9tLCB0bywgbGV2ZWwsIGJhc2VMZXZlbCwgaXNvbGF0ZXMsIG9yZGVyKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVPcmRlcihsaW5lLCBkaXJlY3Rpb24sIGlzb2xhdGVzKSB7XG4gICAgaWYgKCFsaW5lKVxuICAgICAgICByZXR1cm4gW25ldyBCaWRpU3BhbigwLCAwLCBkaXJlY3Rpb24gPT0gUlRMID8gMSA6IDApXTtcbiAgICBpZiAoZGlyZWN0aW9uID09IExUUiAmJiAhaXNvbGF0ZXMubGVuZ3RoICYmICFCaWRpUkUudGVzdChsaW5lKSlcbiAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsaW5lLmxlbmd0aCk7XG4gICAgaWYgKGlzb2xhdGVzLmxlbmd0aClcbiAgICAgICAgd2hpbGUgKGxpbmUubGVuZ3RoID4gdHlwZXMubGVuZ3RoKVxuICAgICAgICAgICAgdHlwZXNbdHlwZXMubGVuZ3RoXSA9IDI1NiAvKiBULk5JICovOyAvLyBNYWtlIHN1cmUgdHlwZXMgYXJyYXkgaGFzIG5vIGdhcHNcbiAgICBsZXQgb3JkZXIgPSBbXSwgbGV2ZWwgPSBkaXJlY3Rpb24gPT0gTFRSID8gMCA6IDE7XG4gICAgY29tcHV0ZVNlY3Rpb25PcmRlcihsaW5lLCBsZXZlbCwgbGV2ZWwsIGlzb2xhdGVzLCAwLCBsaW5lLmxlbmd0aCwgb3JkZXIpO1xuICAgIHJldHVybiBvcmRlcjtcbn1cbmZ1bmN0aW9uIHRyaXZpYWxPcmRlcihsZW5ndGgpIHtcbiAgICByZXR1cm4gW25ldyBCaWRpU3BhbigwLCBsZW5ndGgsIDApXTtcbn1cbmxldCBtb3ZlZE92ZXIgPSBcIlwiO1xuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBtb3ZlcyBzdHJpY3RseSB2aXN1YWxseSwgd2l0aG91dCBjb25jZXJuIGZvciBhXG4vLyB0cmF2ZXJzYWwgdmlzaXRpbmcgZXZlcnkgbG9naWNhbCBwb3NpdGlvbiBpbiB0aGUgc3RyaW5nLiBJdCB3aWxsXG4vLyBzdGlsbCBkbyBzbyBmb3Igc2ltcGxlIGlucHV0LCBidXQgc2l0dWF0aW9ucyBsaWtlIG11bHRpcGxlIGlzb2xhdGVzXG4vLyB3aXRoIHRoZSBzYW1lIGxldmVsIG5leHQgdG8gZWFjaCBvdGhlciwgb3IgdGV4dCBnb2luZyBhZ2FpbnN0IHRoZVxuLy8gbWFpbiBkaXIgYXQgdGhlIGVuZCBvZiB0aGUgbGluZSwgd2lsbCBtYWtlIHNvbWUgcG9zaXRpb25zXG4vLyB1bnJlYWNoYWJsZSB3aXRoIHRoaXMgbW90aW9uLiBFYWNoIHZpc2libGUgY3Vyc29yIHBvc2l0aW9uIHdpbGxcbi8vIGNvcnJlc3BvbmQgdG8gdGhlIGxvd2VyLWxldmVsIGJpZGkgc3BhbiB0aGF0IHRvdWNoZXMgaXQuXG4vL1xuLy8gVGhlIGFsdGVybmF0aXZlIHdvdWxkIGJlIHRvIHNvbHZlIGFuIG9yZGVyIGdsb2JhbGx5IGZvciBhIGdpdmVuXG4vLyBsaW5lLCBtYWtpbmcgc3VyZSB0aGF0IGl0IGluY2x1ZGVzIGV2ZXJ5IHBvc2l0aW9uLCBidXQgdGhhdCB3b3VsZFxuLy8gcmVxdWlyZSBhc3NvY2lhdGluZyBub24tY2Fub25pY2FsIChoaWdoZXIgYmlkaSBzcGFuIGxldmVsKVxuLy8gcG9zaXRpb25zIHdpdGggYSBnaXZlbiB2aXN1YWwgcG9zaXRpb24sIHdoaWNoIGlzIGxpa2VseSB0byBjb25mdXNlXG4vLyBwZW9wbGUuIChBbmQgd291bGQgZ2VuZXJhbGx5IGJlIGEgbG90IG1vcmUgY29tcGxpY2F0ZWQuKVxuZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGxpbmUsIG9yZGVyLCBkaXIsIHN0YXJ0LCBmb3J3YXJkKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBzdGFydEluZGV4ID0gc3RhcnQuaGVhZCAtIGxpbmUuZnJvbTtcbiAgICBsZXQgc3BhbkkgPSBCaWRpU3Bhbi5maW5kKG9yZGVyLCBzdGFydEluZGV4LCAoX2EgPSBzdGFydC5iaWRpTGV2ZWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xLCBzdGFydC5hc3NvYyk7XG4gICAgbGV0IHNwYW4gPSBvcmRlcltzcGFuSV0sIHNwYW5FbmQgPSBzcGFuLnNpZGUoZm9yd2FyZCwgZGlyKTtcbiAgICAvLyBFbmQgb2Ygc3BhblxuICAgIGlmIChzdGFydEluZGV4ID09IHNwYW5FbmQpIHtcbiAgICAgICAgbGV0IG5leHRJID0gc3BhbkkgKz0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICAgICAgaWYgKG5leHRJIDwgMCB8fCBuZXh0SSA+PSBvcmRlci5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgc3BhbiA9IG9yZGVyW3NwYW5JID0gbmV4dEldO1xuICAgICAgICBzdGFydEluZGV4ID0gc3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpO1xuICAgICAgICBzcGFuRW5kID0gc3Bhbi5zaWRlKGZvcndhcmQsIGRpcik7XG4gICAgfVxuICAgIGxldCBuZXh0SW5kZXggPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgc3RhcnRJbmRleCwgc3Bhbi5mb3J3YXJkKGZvcndhcmQsIGRpcikpO1xuICAgIGlmIChuZXh0SW5kZXggPCBzcGFuLmZyb20gfHwgbmV4dEluZGV4ID4gc3Bhbi50bylcbiAgICAgICAgbmV4dEluZGV4ID0gc3BhbkVuZDtcbiAgICBtb3ZlZE92ZXIgPSBsaW5lLnRleHQuc2xpY2UoTWF0aC5taW4oc3RhcnRJbmRleCwgbmV4dEluZGV4KSwgTWF0aC5tYXgoc3RhcnRJbmRleCwgbmV4dEluZGV4KSk7XG4gICAgbGV0IG5leHRTcGFuID0gc3BhbkkgPT0gKGZvcndhcmQgPyBvcmRlci5sZW5ndGggLSAxIDogMCkgPyBudWxsIDogb3JkZXJbc3BhbkkgKyAoZm9yd2FyZCA/IDEgOiAtMSldO1xuICAgIGlmIChuZXh0U3BhbiAmJiBuZXh0SW5kZXggPT0gc3BhbkVuZCAmJiBuZXh0U3Bhbi5sZXZlbCArIChmb3J3YXJkID8gMCA6IDEpIDwgc3Bhbi5sZXZlbClcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dFNwYW4uc2lkZSghZm9yd2FyZCwgZGlyKSArIGxpbmUuZnJvbSwgbmV4dFNwYW4uZm9yd2FyZChmb3J3YXJkLCBkaXIpID8gMSA6IC0xLCBuZXh0U3Bhbi5sZXZlbCk7XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dEluZGV4ICsgbGluZS5mcm9tLCBzcGFuLmZvcndhcmQoZm9yd2FyZCwgZGlyKSA/IC0xIDogMSwgc3Bhbi5sZXZlbCk7XG59XG5mdW5jdGlvbiBhdXRvRGlyZWN0aW9uKHRleHQsIGZyb20sIHRvKSB7XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgIGxldCB0eXBlID0gY2hhclR5cGUodGV4dC5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gMSAvKiBULkwgKi8pXG4gICAgICAgICAgICByZXR1cm4gTFRSO1xuICAgICAgICBpZiAodHlwZSA9PSAyIC8qIFQuUiAqLyB8fCB0eXBlID09IDQgLyogVC5BTCAqLylcbiAgICAgICAgICAgIHJldHVybiBSVEw7XG4gICAgfVxuICAgIHJldHVybiBMVFI7XG59XG5cbmNvbnN0IGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZHJhZ01vdmVzU2VsZWN0aW9uJDEgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBtb3VzZVNlbGVjdGlvblN0eWxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZXhjZXB0aW9uU2luayA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHVwZGF0ZUxpc3RlbmVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgaW5wdXRIYW5kbGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZm9jdXNDaGFuZ2VFZmZlY3QgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBjbGlwYm9hcmRJbnB1dEZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGNsaXBib2FyZE91dHB1dEZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHBlckxpbmVUZXh0RGlyZWN0aW9uID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuY29uc3QgbmF0aXZlU2VsZWN0aW9uSGlkZGVuID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geClcbn0pO1xuY29uc3Qgc2Nyb2xsSGFuZGxlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNsYXNzIFNjcm9sbFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IocmFuZ2UsIHkgPSBcIm5lYXJlc3RcIiwgeCA9IFwibmVhcmVzdFwiLCB5TWFyZ2luID0gNSwgeE1hcmdpbiA9IDUsIFxuICAgIC8vIFRoaXMgZGF0YSBzdHJ1Y3R1cmUgaXMgYWJ1c2VkIHRvIGFsc28gc3RvcmUgcHJlY2lzZSBzY3JvbGxcbiAgICAvLyBzbmFwc2hvdHMsIGluc3RlYWQgb2YgYSBgc2Nyb2xsSW50b1ZpZXdgIHJlcXVlc3QuIFdoZW4gdGhpc1xuICAgIC8vIGZsYWcgaXMgYHRydWVgLCBgcmFuZ2VgIHBvaW50cyBhdCBhIHBvc2l0aW9uIGluIHRoZSByZWZlcmVuY2VcbiAgICAvLyBsaW5lLCBgeU1hcmdpbmAgaG9sZHMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdG9wIG9mIHRoYXRcbiAgICAvLyBsaW5lIGFuZCB0aGUgdG9wIG9mIHRoZSBlZGl0b3IsIGFuZCBgeE1hcmdpbmAgaG9sZHMgdGhlXG4gICAgLy8gZWRpdG9yJ3MgYHNjcm9sbExlZnRgLlxuICAgIGlzU25hcHNob3QgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueU1hcmdpbiA9IHlNYXJnaW47XG4gICAgICAgIHRoaXMueE1hcmdpbiA9IHhNYXJnaW47XG4gICAgICAgIHRoaXMuaXNTbmFwc2hvdCA9IGlzU25hcHNob3Q7XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmVtcHR5ID8gdGhpcyA6XG4gICAgICAgICAgICBuZXcgU2Nyb2xsVGFyZ2V0KHRoaXMucmFuZ2UubWFwKGNoYW5nZXMpLCB0aGlzLnksIHRoaXMueCwgdGhpcy55TWFyZ2luLCB0aGlzLnhNYXJnaW4sIHRoaXMuaXNTbmFwc2hvdCk7XG4gICAgfVxuICAgIGNsaXAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2UudG8gPD0gc3RhdGUuZG9jLmxlbmd0aCA/IHRoaXMgOlxuICAgICAgICAgICAgbmV3IFNjcm9sbFRhcmdldChFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHN0YXRlLmRvYy5sZW5ndGgpLCB0aGlzLnksIHRoaXMueCwgdGhpcy55TWFyZ2luLCB0aGlzLnhNYXJnaW4sIHRoaXMuaXNTbmFwc2hvdCk7XG4gICAgfVxufVxuY29uc3Qgc2Nyb2xsSW50b1ZpZXcgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiAodCwgY2gpID0+IHQubWFwKGNoKSB9KTtcbmNvbnN0IHNldEVkaXRDb250ZXh0Rm9ybWF0dGluZyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuTG9nIG9yIHJlcG9ydCBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uIGluIGNsaWVudCBjb2RlLiBTaG91bGRcbnByb2JhYmx5IG9ubHkgYmUgdXNlZCBieSBleHRlbnNpb24gY29kZSB0aGF0IGFsbG93cyBjbGllbnQgY29kZSB0b1xucHJvdmlkZSBmdW5jdGlvbnMsIGFuZCBjYWxscyB0aG9zZSBmdW5jdGlvbnMgaW4gYSBjb250ZXh0IHdoZXJlIGFuXG5leGNlcHRpb24gY2FuJ3QgYmUgcHJvcGFnYXRlZCB0byBjYWxsaW5nIGNvZGUgaW4gYSByZWFzb25hYmxlIHdheVxuKGZvciBleGFtcGxlIHdoZW4gaW4gYW4gZXZlbnQgaGFuZGxlcikuXG5cbkVpdGhlciBjYWxscyBhIGhhbmRsZXIgcmVnaXN0ZXJlZCB3aXRoXG5bYEVkaXRvclZpZXcuZXhjZXB0aW9uU2lua2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmV4Y2VwdGlvblNpbmspLFxuYHdpbmRvdy5vbmVycm9yYCwgaWYgZGVmaW5lZCwgb3IgYGNvbnNvbGUuZXJyb3JgIChpbiB3aGljaCBjYXNlXG5pdCdsbCBwYXNzIGBjb250ZXh0YCwgd2hlbiBnaXZlbiwgYXMgZmlyc3QgYXJndW1lbnQpLlxuKi9cbmZ1bmN0aW9uIGxvZ0V4Y2VwdGlvbihzdGF0ZSwgZXhjZXB0aW9uLCBjb250ZXh0KSB7XG4gICAgbGV0IGhhbmRsZXIgPSBzdGF0ZS5mYWNldChleGNlcHRpb25TaW5rKTtcbiAgICBpZiAoaGFuZGxlci5sZW5ndGgpXG4gICAgICAgIGhhbmRsZXJbMF0oZXhjZXB0aW9uKTtcbiAgICBlbHNlIGlmICh3aW5kb3cub25lcnJvcilcbiAgICAgICAgd2luZG93Lm9uZXJyb3IoU3RyaW5nKGV4Y2VwdGlvbiksIGNvbnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBleGNlcHRpb24pO1xuICAgIGVsc2UgaWYgKGNvbnRleHQpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoY29udGV4dCArIFwiOlwiLCBleGNlcHRpb24pO1xuICAgIGVsc2VcbiAgICAgICAgY29uc29sZS5lcnJvcihleGNlcHRpb24pO1xufVxuY29uc3QgZWRpdGFibGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB0cnVlIH0pO1xubGV0IG5leHRQbHVnaW5JRCA9IDA7XG5jb25zdCB2aWV3UGx1Z2luID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5WaWV3IHBsdWdpbnMgYXNzb2NpYXRlIHN0YXRlZnVsIHZhbHVlcyB3aXRoIGEgdmlldy4gVGhleSBjYW5cbmluZmx1ZW5jZSB0aGUgd2F5IHRoZSBjb250ZW50IGlzIGRyYXduLCBhbmQgYXJlIG5vdGlmaWVkIG9mIHRoaW5nc1xudGhhdCBoYXBwZW4gaW4gdGhlIHZpZXcuXG4qL1xuY2xhc3MgVmlld1BsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpZCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjcmVhdGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tRXZlbnRIYW5kbGVycywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkb21FdmVudE9ic2VydmVycywgYnVpbGRFeHRlbnNpb25zKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRIYW5kbGVycyA9IGRvbUV2ZW50SGFuZGxlcnM7XG4gICAgICAgIHRoaXMuZG9tRXZlbnRPYnNlcnZlcnMgPSBkb21FdmVudE9ic2VydmVycztcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBidWlsZEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHBsdWdpbiBmcm9tIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZVxuICAgIHBsdWdpbidzIHZhbHVlLCBnaXZlbiBhbiBlZGl0b3Igdmlldy5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY3JlYXRlLCBzcGVjKSB7XG4gICAgICAgIGNvbnN0IHsgZXZlbnRIYW5kbGVycywgZXZlbnRPYnNlcnZlcnMsIHByb3ZpZGUsIGRlY29yYXRpb25zOiBkZWNvIH0gPSBzcGVjIHx8IHt9O1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdQbHVnaW4obmV4dFBsdWdpbklEKyssIGNyZWF0ZSwgZXZlbnRIYW5kbGVycywgZXZlbnRPYnNlcnZlcnMsIHBsdWdpbiA9PiB7XG4gICAgICAgICAgICBsZXQgZXh0ID0gW3ZpZXdQbHVnaW4ub2YocGx1Z2luKV07XG4gICAgICAgICAgICBpZiAoZGVjbylcbiAgICAgICAgICAgICAgICBleHQucHVzaChkZWNvcmF0aW9ucy5vZih2aWV3ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBsdWdpbkluc3QgPSB2aWV3LnBsdWdpbihwbHVnaW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luSW5zdCA/IGRlY28ocGx1Z2luSW5zdCkgOiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGUpXG4gICAgICAgICAgICAgICAgZXh0LnB1c2gocHJvdmlkZShwbHVnaW4pKTtcbiAgICAgICAgICAgIHJldHVybiBleHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBwbHVnaW4gZm9yIGEgY2xhc3Mgd2hvc2UgY29uc3RydWN0b3IgdGFrZXMgYSBzaW5nbGVcbiAgICBlZGl0b3IgdmlldyBhcyBhcmd1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tQ2xhc3MoY2xzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+IG5ldyBjbHModmlldyksIHNwZWMpO1xuICAgIH1cbn1cbmNsYXNzIFBsdWdpbkluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8vIFdoZW4gc3RhcnRpbmcgYW4gdXBkYXRlLCBhbGwgcGx1Z2lucyBoYXZlIHRoaXMgZmllbGQgc2V0IHRvIHRoZVxuICAgICAgICAvLyB1cGRhdGUgb2JqZWN0LCBpbmRpY2F0aW5nIHRoZXkgbmVlZCB0byBiZSB1cGRhdGVkLiBXaGVuIGZpbmlzaGVkXG4gICAgICAgIC8vIHVwZGF0aW5nLCBpdCBpcyBzZXQgdG8gYGZhbHNlYC4gUmV0cmlldmluZyBhIHBsdWdpbiB0aGF0IG5lZWRzIHRvXG4gICAgICAgIC8vIGJlIHVwZGF0ZWQgd2l0aCBgdmlldy5wbHVnaW5gIGZvcmNlcyBhbiBlYWdlciB1cGRhdGUuXG4gICAgICAgIHRoaXMubXVzdFVwZGF0ZSA9IG51bGw7XG4gICAgICAgIC8vIFRoaXMgaXMgbnVsbCB3aGVuIHRoZSBwbHVnaW4gaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIGJ1dFxuICAgICAgICAvLyBpbml0aWFsaXplZCBvbiB0aGUgZmlyc3QgdXBkYXRlLlxuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB9XG4gICAgdXBkYXRlKHZpZXcpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zcGVjKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3BlYy5jcmVhdGUodmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlLCBcIkNvZGVNaXJyb3IgcGx1Z2luIGNyYXNoZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm11c3RVcGRhdGUpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGUgPSB0aGlzLm11c3RVcGRhdGU7XG4gICAgICAgICAgICB0aGlzLm11c3RVcGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHVwZGF0ZS5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5kZXN0cm95KVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZXN0cm95KHZpZXcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlLCBcIkNvZGVNaXJyb3IgcGx1Z2luIGNyYXNoZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfVxufVxuY29uc3QgZWRpdG9yQXR0cmlidXRlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGNvbnRlbnRBdHRyaWJ1dGVzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLy8gUHJvdmlkZSBkZWNvcmF0aW9uc1xuY29uc3QgZGVjb3JhdGlvbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBvdXRlckRlY29yYXRpb25zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYXRvbWljUmFuZ2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYmlkaUlzb2xhdGVkUmFuZ2VzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuZnVuY3Rpb24gZ2V0SXNvbGF0ZWRSYW5nZXModmlldywgbGluZSkge1xuICAgIGxldCBpc29sYXRlcyA9IHZpZXcuc3RhdGUuZmFjZXQoYmlkaUlzb2xhdGVkUmFuZ2VzKTtcbiAgICBpZiAoIWlzb2xhdGVzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGlzb2xhdGVzO1xuICAgIGxldCBzZXRzID0gaXNvbGF0ZXMubWFwKGkgPT4gaSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gaSh2aWV3KSA6IGkpO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBSYW5nZVNldC5zcGFucyhzZXRzLCBsaW5lLmZyb20sIGxpbmUudG8sIHtcbiAgICAgICAgcG9pbnQoKSB7IH0sXG4gICAgICAgIHNwYW4oZnJvbURvYywgdG9Eb2MsIGFjdGl2ZSwgb3Blbikge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBmcm9tRG9jIC0gbGluZS5mcm9tLCB0byA9IHRvRG9jIC0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGxldmVsID0gcmVzdWx0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFjdGl2ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSwgb3Blbi0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpcmVjdGlvbiA9IGFjdGl2ZVtpXS5zcGVjLmJpZGlJc29sYXRlLCB1cGRhdGU7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBhdXRvRGlyZWN0aW9uKGxpbmUudGV4dCwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgIGlmIChvcGVuID4gMCAmJiBsZXZlbC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKHVwZGF0ZSA9IGxldmVsW2xldmVsLmxlbmd0aCAtIDFdKS50byA9PSBmcm9tICYmIHVwZGF0ZS5kaXJlY3Rpb24gPT0gZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZS50byA9IHRvO1xuICAgICAgICAgICAgICAgICAgICBsZXZlbCA9IHVwZGF0ZS5pbm5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZGQgPSB7IGZyb20sIHRvLCBkaXJlY3Rpb24sIGlubmVyOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICBsZXZlbC5wdXNoKGFkZCk7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsID0gYWRkLmlubmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBzY3JvbGxNYXJnaW5zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsTWFyZ2lucyh2aWV3KSB7XG4gICAgbGV0IGxlZnQgPSAwLCByaWdodCA9IDAsIHRvcCA9IDAsIGJvdHRvbSA9IDA7XG4gICAgZm9yIChsZXQgc291cmNlIG9mIHZpZXcuc3RhdGUuZmFjZXQoc2Nyb2xsTWFyZ2lucykpIHtcbiAgICAgICAgbGV0IG0gPSBzb3VyY2Uodmlldyk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBpZiAobS5sZWZ0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIG0ubGVmdCk7XG4gICAgICAgICAgICBpZiAobS5yaWdodCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgocmlnaHQsIG0ucmlnaHQpO1xuICAgICAgICAgICAgaWYgKG0udG9wICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBtLnRvcCk7XG4gICAgICAgICAgICBpZiAobS5ib3R0b20gIT0gbnVsbClcbiAgICAgICAgICAgICAgICBib3R0b20gPSBNYXRoLm1heChib3R0b20sIG0uYm90dG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfTtcbn1cbmNvbnN0IHN0eWxlTW9kdWxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY2xhc3MgQ2hhbmdlZFJhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tQSwgdG9BLCBmcm9tQiwgdG9CKSB7XG4gICAgICAgIHRoaXMuZnJvbUEgPSBmcm9tQTtcbiAgICAgICAgdGhpcy50b0EgPSB0b0E7XG4gICAgICAgIHRoaXMuZnJvbUIgPSBmcm9tQjtcbiAgICAgICAgdGhpcy50b0IgPSB0b0I7XG4gICAgfVxuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VkUmFuZ2UoTWF0aC5taW4odGhpcy5mcm9tQSwgb3RoZXIuZnJvbUEpLCBNYXRoLm1heCh0aGlzLnRvQSwgb3RoZXIudG9BKSwgTWF0aC5taW4odGhpcy5mcm9tQiwgb3RoZXIuZnJvbUIpLCBNYXRoLm1heCh0aGlzLnRvQiwgb3RoZXIudG9CKSk7XG4gICAgfVxuICAgIGFkZFRvU2V0KHNldCkge1xuICAgICAgICBsZXQgaSA9IHNldC5sZW5ndGgsIG1lID0gdGhpcztcbiAgICAgICAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHNldFtpIC0gMV07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZnJvbUEgPiBtZS50b0EpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UudG9BIDwgbWUuZnJvbUEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBtZSA9IG1lLmpvaW4ocmFuZ2UpO1xuICAgICAgICAgICAgc2V0LnNwbGljZShpIC0gMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0LnNwbGljZShpLCAwLCBtZSk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIHN0YXRpYyBleHRlbmRXaXRoUmFuZ2VzKGRpZmYsIHJhbmdlcykge1xuICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZEkgPSAwLCBySSA9IDAsIHBvc0EgPSAwLCBwb3NCID0gMDs7IGRJKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZEkgPT0gZGlmZi5sZW5ndGggPyBudWxsIDogZGlmZltkSV0sIG9mZiA9IHBvc0EgLSBwb3NCO1xuICAgICAgICAgICAgbGV0IGVuZCA9IG5leHQgPyBuZXh0LmZyb21CIDogMWU5O1xuICAgICAgICAgICAgd2hpbGUgKHJJIDwgcmFuZ2VzLmxlbmd0aCAmJiByYW5nZXNbckldIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbckldLCB0byA9IHJhbmdlc1tySSArIDFdO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tQiA9IE1hdGgubWF4KHBvc0IsIGZyb20pLCB0b0IgPSBNYXRoLm1pbihlbmQsIHRvKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUIgPD0gdG9CKVxuICAgICAgICAgICAgICAgICAgICBuZXcgQ2hhbmdlZFJhbmdlKGZyb21CICsgb2ZmLCB0b0IgKyBvZmYsIGZyb21CLCB0b0IpLmFkZFRvU2V0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvID4gZW5kKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJJICs9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIG5ldyBDaGFuZ2VkUmFuZ2UobmV4dC5mcm9tQSwgbmV4dC50b0EsIG5leHQuZnJvbUIsIG5leHQudG9CKS5hZGRUb1NldChyZXN1bHQpO1xuICAgICAgICAgICAgcG9zQSA9IG5leHQudG9BO1xuICAgICAgICAgICAgcG9zQiA9IG5leHQudG9CO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5WaWV3IFtwbHVnaW5zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1BsdWdpbikgYXJlIGdpdmVuIGluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcywgd2hpY2ggZGVzY3JpYmUgd2hhdCBoYXBwZW5lZCwgd2hlbmV2ZXIgdGhlIHZpZXcgaXMgdXBkYXRlZC5cbiovXG5jbGFzcyBWaWV3VXBkYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgZWRpdG9yIHZpZXcgdGhhdCB0aGUgdXBkYXRlIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICAqL1xuICAgIHZpZXcsIFxuICAgIC8qKlxuICAgIFRoZSBuZXcgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSB0cmFuc2FjdGlvbnMgaW52b2x2ZWQgaW4gdGhlIHVwZGF0ZS4gTWF5IGJlIGVtcHR5LlxuICAgICovXG4gICAgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbGFncyA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucylcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcyA9IHRoaXMuY2hhbmdlcy5jb21wb3NlKHRyLmNoYW5nZXMpO1xuICAgICAgICBsZXQgY2hhbmdlZFJhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLmNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpID0+IGNoYW5nZWRSYW5nZXMucHVzaChuZXcgQ2hhbmdlZFJhbmdlKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpKSk7XG4gICAgICAgIHRoaXMuY2hhbmdlZFJhbmdlcyA9IGNoYW5nZWRSYW5nZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlld1VwZGF0ZSh2aWV3LCBzdGF0ZSwgdHJhbnNhY3Rpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIFt2aWV3cG9ydF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudmlld3BvcnQpIG9yXG4gICAgW3Zpc2libGUgcmFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy52aXNpYmxlUmFuZ2VzKSBjaGFuZ2VkIGluIHRoaXNcbiAgICB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW5cbiAgICBbYHZpZXdwb3J0Q2hhbmdlZGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3VXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCkgaXMgdHJ1ZVxuICAgIGFuZCB0aGUgdmlld3BvcnQgY2hhbmdlIGlzIG5vdCBqdXN0IHRoZSByZXN1bHQgb2YgbWFwcGluZyBpdCBpblxuICAgIHJlc3BvbnNlIHRvIGRvY3VtZW50IGNoYW5nZXMuXG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRNb3ZlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgOCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0TW92ZWQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGhlaWdodCBvZiBhIGJsb2NrIGVsZW1lbnQgaW4gdGhlIGVkaXRvclxuICAgIGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgaGVpZ2h0Q2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgd2hlbiB0aGUgZG9jdW1lbnQgd2FzIG1vZGlmaWVkIG9yIHRoZSBzaXplIG9mIHRoZVxuICAgIGVkaXRvciwgb3IgZWxlbWVudHMgd2l0aGluIHRoZSBlZGl0b3IsIGNoYW5nZWQuXG4gICAgKi9cbiAgICBnZXQgZ2VvbWV0cnlDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NDaGFuZ2VkIHx8ICh0aGlzLmZsYWdzICYgKDE2IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi8gfCAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSkgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyB1cGRhdGUgaW5kaWNhdGVzIGEgZm9jdXMgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IGZvY3VzQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBVcGRhdGVGbGFnLkZvY3VzICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIGRvY3VtZW50IGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNoYW5nZXMuZW1wdHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiB3YXMgZXhwbGljaXRseSBzZXQgaW4gdGhpcyB1cGRhdGUuXG4gICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uU2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5zZWxlY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgPT0gMCAmJiB0aGlzLnRyYW5zYWN0aW9ucy5sZW5ndGggPT0gMDsgfVxufVxuXG5jbGFzcyBEb2NWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aDsgfVxuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwID0gW2ZhbHNlXTtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VkID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNDb21wb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubWFya2VkRm9yQ29tcG9zaXRpb24gPSBuZXcgU2V0O1xuICAgICAgICB0aGlzLmVkaXRDb250ZXh0Rm9ybWF0dGluZyA9IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgdGhpcy5sYXN0Q29tcG9zaXRpb25BZnRlckN1cnNvciA9IGZhbHNlO1xuICAgICAgICAvLyBUcmFjayBhIG1pbmltdW0gd2lkdGggZm9yIHRoZSBlZGl0b3IuIFdoZW4gbWVhc3VyaW5nIHNpemVzIGluXG4gICAgICAgIC8vIG1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHMsIHRoaXMgaXMgdXBkYXRlZCB0byBwb2ludCBhdCB0aGUgd2lkdGhcbiAgICAgICAgLy8gb2YgYSBnaXZlbiBlbGVtZW50IGFuZCBpdHMgZXh0ZW50IGluIHRoZSBkb2N1bWVudC4gV2hlbiBhIGNoYW5nZVxuICAgICAgICAvLyBoYXBwZW5zIGluIHRoYXQgcmFuZ2UsIHRoZXNlIGFyZSByZXNldC4gVGhhdCB3YXksIG9uY2Ugd2UndmUgc2VlblxuICAgICAgICAvLyBhIGxpbmUvZWxlbWVudCBvZiBhIGdpdmVuIGxlbmd0aCwgd2Uga2VlcCB0aGUgZWRpdG9yIHdpZGUgZW5vdWdoXG4gICAgICAgIC8vIHRvIGZpdCBhdCBsZWFzdCB0aGF0IGVsZW1lbnQsIHVudGlsIGl0IGlzIGNoYW5nZWQsIGF0IHdoaWNoIHBvaW50XG4gICAgICAgIC8vIHdlIGZvcmdldCBpdCBhZ2Fpbi5cbiAgICAgICAgdGhpcy5taW5XaWR0aCA9IDA7XG4gICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gMDtcbiAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gMDtcbiAgICAgICAgLy8gVHJhY2sgd2hldGhlciB0aGUgRE9NIHNlbGVjdGlvbiB3YXMgc2V0IGluIGEgbG9zc3kgd2F5LCBzbyB0aGF0XG4gICAgICAgIC8vIHdlIGRvbid0IG1lc3MgaXQgdXAgd2hlbiByZWFkaW5nIGl0IGJhY2sgaXRcbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBudWxsO1xuICAgICAgICB0aGlzLmltcHJlY2lzZUhlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFVzZWQgYnkgdGhlIHJlc2l6ZSBvYnNlcnZlciB0byBpZ25vcmUgcmVzaXplcyB0aGF0IHdlIGNhdXNlZFxuICAgICAgICAvLyBvdXJzZWx2ZXNcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5zZXRET00odmlldy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtuZXcgTGluZVZpZXddO1xuICAgICAgICB0aGlzLmNoaWxkcmVuWzBdLnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVEZWNvKCk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5uZXIoW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKV0sIDAsIG51bGwpO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgdGhlIGRvY3VtZW50IHZpZXcgdG8gYSBnaXZlbiBzdGF0ZS5cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNoYW5nZWRSYW5nZXMgPSB1cGRhdGUuY2hhbmdlZFJhbmdlcztcbiAgICAgICAgaWYgKHRoaXMubWluV2lkdGggPiAwICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWNoYW5nZWRSYW5nZXMuZXZlcnkoKHsgZnJvbUEsIHRvQSB9KSA9PiB0b0EgPCB0aGlzLm1pbldpZHRoRnJvbSB8fCBmcm9tQSA+IHRoaXMubWluV2lkdGhUbykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gdGhpcy5taW5XaWR0aEZyb20gPSB0aGlzLm1pbldpZHRoVG8gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5taW5XaWR0aEZyb20sIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhUbyA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLm1pbldpZHRoVG8sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlRWRpdENvbnRleHRGb3JtYXR0aW5nKHVwZGF0ZSk7XG4gICAgICAgIGxldCByZWFkQ29tcG9zaXRpb25BdCA9IC0xO1xuICAgICAgICBpZiAodGhpcy52aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDAgJiYgIXRoaXMudmlldy5vYnNlcnZlci5lZGl0Q29udGV4dCkge1xuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMuZG9tQ2hhbmdlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5ld1NlbClcbiAgICAgICAgICAgICAgICByZWFkQ29tcG9zaXRpb25BdCA9IHRoaXMuZG9tQ2hhbmdlZC5uZXdTZWwuaGVhZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0b3VjaGVzQ29tcG9zaXRpb24odXBkYXRlLmNoYW5nZXMsIHRoaXMuaGFzQ29tcG9zaXRpb24pICYmICF1cGRhdGUuc2VsZWN0aW9uU2V0KVxuICAgICAgICAgICAgICAgIHJlYWRDb21wb3NpdGlvbkF0ID0gdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uID0gcmVhZENvbXBvc2l0aW9uQXQgPiAtMSA/IGZpbmRDb21wb3NpdGlvblJhbmdlKHRoaXMudmlldywgdXBkYXRlLmNoYW5nZXMsIHJlYWRDb21wb3NpdGlvbkF0KSA6IG51bGw7XG4gICAgICAgIHRoaXMuZG9tQ2hhbmdlZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hcmtlZEZvckNvbXBvc2l0aW9uLmNsZWFyKCk7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5oYXNDb21wb3NpdGlvbjtcbiAgICAgICAgICAgIGNoYW5nZWRSYW5nZXMgPSBuZXcgQ2hhbmdlZFJhbmdlKGZyb20sIHRvLCB1cGRhdGUuY2hhbmdlcy5tYXBQb3MoZnJvbSwgLTEpLCB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModG8sIDEpKVxuICAgICAgICAgICAgICAgIC5hZGRUb1NldChjaGFuZ2VkUmFuZ2VzLnNsaWNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbiA/IHsgZnJvbTogY29tcG9zaXRpb24ucmFuZ2UuZnJvbUIsIHRvOiBjb21wb3NpdGlvbi5yYW5nZS50b0IgfSA6IG51bGw7XG4gICAgICAgIC8vIFdoZW4gdGhlIERPTSBub2RlcyBhcm91bmQgdGhlIHNlbGVjdGlvbiBhcmUgbW92ZWQgdG8gYW5vdGhlclxuICAgICAgICAvLyBwYXJlbnQsIENocm9tZSBzb21ldGltZXMgcmVwb3J0cyBhIGRpZmZlcmVudCBzZWxlY3Rpb24gdGhyb3VnaFxuICAgICAgICAvLyBnZXRTZWxlY3Rpb24gdGhhbiB0aGUgb25lIHRoYXQgaXQgYWN0dWFsbHkgc2hvd3MgdG8gdGhlIHVzZXIuXG4gICAgICAgIC8vIFRoaXMgZm9yY2VzIGEgc2VsZWN0aW9uIHVwZGF0ZSB3aGVuIGxpbmVzIGFyZSBqb2luZWQgdG8gd29ya1xuICAgICAgICAvLyBhcm91bmQgdGhhdC4gSXNzdWUgIzU0XG4gICAgICAgIGlmICgoYnJvd3Nlci5pZSB8fCBicm93c2VyLmNocm9tZSkgJiYgIWNvbXBvc2l0aW9uICYmIHVwZGF0ZSAmJlxuICAgICAgICAgICAgdXBkYXRlLnN0YXRlLmRvYy5saW5lcyAhPSB1cGRhdGUuc3RhcnRTdGF0ZS5kb2MubGluZXMpXG4gICAgICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgbGV0IHByZXZEZWNvID0gdGhpcy5kZWNvcmF0aW9ucywgZGVjbyA9IHRoaXMudXBkYXRlRGVjbygpO1xuICAgICAgICBsZXQgZGVjb0RpZmYgPSBmaW5kQ2hhbmdlZERlY28ocHJldkRlY28sIGRlY28sIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgY2hhbmdlZFJhbmdlcyA9IENoYW5nZWRSYW5nZS5leHRlbmRXaXRoUmFuZ2VzKGNoYW5nZWRSYW5nZXMsIGRlY29EaWZmKTtcbiAgICAgICAgaWYgKCEodGhpcy5mbGFncyAmIDcgLyogVmlld0ZsYWcuRGlydHkgKi8pICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5uZXIoY2hhbmdlZFJhbmdlcywgdXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCwgY29tcG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFVwZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2VkIGJ5IHVwZGF0ZSBhbmQgdGhlIGNvbnN0cnVjdG9yIGRvIHBlcmZvcm0gdGhlIGFjdHVhbCBET01cbiAgICAvLyB1cGRhdGVcbiAgICB1cGRhdGVJbm5lcihjaGFuZ2VzLCBvbGRMZW5ndGgsIGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMudmlldy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihjaGFuZ2VzLCBvbGRMZW5ndGgsIGNvbXBvc2l0aW9uKTtcbiAgICAgICAgbGV0IHsgb2JzZXJ2ZXIgfSA9IHRoaXMudmlldztcbiAgICAgICAgb2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIC8vIExvY2sgdGhlIGhlaWdodCBkdXJpbmcgcmVkcmF3aW5nLCBzaW5jZSBDaHJvbWUgc29tZXRpbWVzXG4gICAgICAgICAgICAvLyBtZXNzZXMgd2l0aCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGR1cmluZyBET00gbXV0YXRpb24gKHRob3VnaFxuICAgICAgICAgICAgLy8gbm8gcmVsYXlvdXQgaXMgdHJpZ2dlcmVkIGFuZCBJIGNhbm5vdCBpbWFnaW5lIGhvdyBpdCBjYW5cbiAgICAgICAgICAgIC8vIHJlY29tcHV0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdpdGhvdXQgYSBsYXlvdXQpXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSB0aGlzLnZpZXcudmlld1N0YXRlLmNvbnRlbnRIZWlnaHQgLyB0aGlzLnZpZXcuc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuZmxleEJhc2lzID0gdGhpcy5taW5XaWR0aCA/IHRoaXMubWluV2lkdGggKyBcInB4XCIgOiBcIlwiO1xuICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzLCB3aGVuIERPTSBtdXRhdGlvbnMgb2NjdXIgZGlyZWN0bHlcbiAgICAgICAgICAgIC8vIGFyb3VuZCB0aGUgc2VsZWN0aW9uLCBnZXQgY29uZnVzZWQgYW5kIHJlcG9ydCBhIGRpZmZlcmVudFxuICAgICAgICAgICAgLy8gc2VsZWN0aW9uIGZyb20gdGhlIG9uZSBpdCBkaXNwbGF5cyAoaXNzdWUgIzIxOCkuIFRoaXMgdHJpZXNcbiAgICAgICAgICAgIC8vIHRvIGRldGVjdCB0aGF0IHNpdHVhdGlvbi5cbiAgICAgICAgICAgIGxldCB0cmFjayA9IGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuaW9zID8geyBub2RlOiBvYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUsIHdyaXR0ZW46IGZhbHNlIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnN5bmModGhpcy52aWV3LCB0cmFjayk7XG4gICAgICAgICAgICB0aGlzLmZsYWdzICY9IH43IC8qIFZpZXdGbGFnLkRpcnR5ICovO1xuICAgICAgICAgICAgaWYgKHRyYWNrICYmICh0cmFjay53cml0dGVuIHx8IG9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSAhPSB0cmFjay5ub2RlKSlcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9IFwiXCI7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1hcmtlZEZvckNvbXBvc2l0aW9uLmZvckVhY2goY1ZpZXcgPT4gY1ZpZXcuZmxhZ3MgJj0gfjggLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi8pO1xuICAgICAgICBsZXQgZ2FwcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy52aWV3LnZpZXdwb3J0LmZyb20gfHwgdGhpcy52aWV3LnZpZXdwb3J0LnRvIDwgdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldyAmJiBjaGlsZC53aWRnZXQgaW5zdGFuY2VvZiBCbG9ja0dhcFdpZGdldClcbiAgICAgICAgICAgICAgICAgICAgZ2Fwcy5wdXNoKGNoaWxkLmRvbSk7XG4gICAgICAgIG9ic2VydmVyLnVwZGF0ZUdhcHMoZ2Fwcyk7XG4gICAgfVxuICAgIHVwZGF0ZUNoaWxkcmVuKGNoYW5nZXMsIG9sZExlbmd0aCwgY29tcG9zaXRpb24pIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IGNvbXBvc2l0aW9uID8gY29tcG9zaXRpb24ucmFuZ2UuYWRkVG9TZXQoY2hhbmdlcy5zbGljZSgpKSA6IGNoYW5nZXM7XG4gICAgICAgIGxldCBjdXJzb3IgPSB0aGlzLmNoaWxkQ3Vyc29yKG9sZExlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSByYW5nZXMubGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID49IDAgPyByYW5nZXNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCFuZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHsgZnJvbUEsIHRvQSwgZnJvbUIsIHRvQiB9ID0gbmV4dCwgY29udGVudCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQ7XG4gICAgICAgICAgICBpZiAoY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucmFuZ2UuZnJvbUIgPCB0b0IgJiYgY29tcG9zaXRpb24ucmFuZ2UudG9CID4gZnJvbUIpIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gQ29udGVudEJ1aWxkZXIuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgZnJvbUIsIGNvbXBvc2l0aW9uLnJhbmdlLmZyb21CLCB0aGlzLmRlY29yYXRpb25zLCB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwKTtcbiAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBDb250ZW50QnVpbGRlci5idWlsZCh0aGlzLnZpZXcuc3RhdGUuZG9jLCBjb21wb3NpdGlvbi5yYW5nZS50b0IsIHRvQiwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCk7XG4gICAgICAgICAgICAgICAgYnJlYWtBdFN0YXJ0ID0gYmVmb3JlLmJyZWFrQXRTdGFydDtcbiAgICAgICAgICAgICAgICBvcGVuU3RhcnQgPSBiZWZvcmUub3BlblN0YXJ0O1xuICAgICAgICAgICAgICAgIG9wZW5FbmQgPSBhZnRlci5vcGVuRW5kO1xuICAgICAgICAgICAgICAgIGxldCBjb21wTGluZSA9IHRoaXMuY29tcG9zaXRpb25WaWV3KGNvbXBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIuYnJlYWtBdFN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBMaW5lLmJyZWFrQWZ0ZXIgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhZnRlci5jb250ZW50Lmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wTGluZS5tZXJnZShjb21wTGluZS5sZW5ndGgsIGNvbXBMaW5lLmxlbmd0aCwgYWZ0ZXIuY29udGVudFswXSwgZmFsc2UsIGFmdGVyLm9wZW5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcExpbmUuYnJlYWtBZnRlciA9IGFmdGVyLmNvbnRlbnRbMF0uYnJlYWtBZnRlcjtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIuY29udGVudC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlLmNvbnRlbnQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBMaW5lLm1lcmdlKDAsIDAsIGJlZm9yZS5jb250ZW50W2JlZm9yZS5jb250ZW50Lmxlbmd0aCAtIDFdLCB0cnVlLCAwLCBiZWZvcmUub3BlbkVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlLmNvbnRlbnQucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBiZWZvcmUuY29udGVudC5jb25jYXQoY29tcExpbmUpLmNvbmNhdChhZnRlci5jb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICh7IGNvbnRlbnQsIGJyZWFrQXRTdGFydCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPVxuICAgICAgICAgICAgICAgICAgICBDb250ZW50QnVpbGRlci5idWlsZCh0aGlzLnZpZXcuc3RhdGUuZG9jLCBmcm9tQiwgdG9CLCB0aGlzLmRlY29yYXRpb25zLCB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgeyBpOiB0b0ksIG9mZjogdG9PZmYgfSA9IGN1cnNvci5maW5kUG9zKHRvQSwgMSk7XG4gICAgICAgICAgICBsZXQgeyBpOiBmcm9tSSwgb2ZmOiBmcm9tT2ZmIH0gPSBjdXJzb3IuZmluZFBvcyhmcm9tQSwgLTEpO1xuICAgICAgICAgICAgcmVwbGFjZVJhbmdlKHRoaXMsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvc2l0aW9uKVxuICAgICAgICAgICAgdGhpcy5maXhDb21wb3NpdGlvbkRPTShjb21wb3NpdGlvbik7XG4gICAgfVxuICAgIHVwZGF0ZUVkaXRDb250ZXh0Rm9ybWF0dGluZyh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5lZGl0Q29udGV4dEZvcm1hdHRpbmcgPSB0aGlzLmVkaXRDb250ZXh0Rm9ybWF0dGluZy5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCB0ciBvZiB1cGRhdGUudHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRFZGl0Q29udGV4dEZvcm1hdHRpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHRGb3JtYXR0aW5nID0gZWZmZWN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9zaXRpb25WaWV3KGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIGxldCBjdXIgPSBuZXcgVGV4dFZpZXcoY29tcG9zaXRpb24udGV4dC5ub2RlVmFsdWUpO1xuICAgICAgICBjdXIuZmxhZ3MgfD0gOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLztcbiAgICAgICAgZm9yIChsZXQgeyBkZWNvIH0gb2YgY29tcG9zaXRpb24ubWFya3MpXG4gICAgICAgICAgICBjdXIgPSBuZXcgTWFya1ZpZXcoZGVjbywgW2N1cl0sIGN1ci5sZW5ndGgpO1xuICAgICAgICBsZXQgbGluZSA9IG5ldyBMaW5lVmlldztcbiAgICAgICAgbGluZS5hcHBlbmQoY3VyLCAwKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIGZpeENvbXBvc2l0aW9uRE9NKGNvbXBvc2l0aW9uKSB7XG4gICAgICAgIGxldCBmaXggPSAoZG9tLCBjVmlldykgPT4ge1xuICAgICAgICAgICAgY1ZpZXcuZmxhZ3MgfD0gOCAvKiBWaWV3RmxhZy5Db21wb3NpdGlvbiAqLyB8IChjVmlldy5jaGlsZHJlbi5zb21lKGMgPT4gYy5mbGFncyAmIDcgLyogVmlld0ZsYWcuRGlydHkgKi8pID8gMSAvKiBWaWV3RmxhZy5DaGlsZERpcnR5ICovIDogMCk7XG4gICAgICAgICAgICB0aGlzLm1hcmtlZEZvckNvbXBvc2l0aW9uLmFkZChjVmlldyk7XG4gICAgICAgICAgICBsZXQgcHJldiA9IENvbnRlbnRWaWV3LmdldChkb20pO1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldiAhPSBjVmlldylcbiAgICAgICAgICAgICAgICBwcmV2LmRvbSA9IG51bGw7XG4gICAgICAgICAgICBjVmlldy5zZXRET00oZG9tKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuY2hpbGRQb3MoY29tcG9zaXRpb24ucmFuZ2UuZnJvbUIsIDEpO1xuICAgICAgICBsZXQgY1ZpZXcgPSB0aGlzLmNoaWxkcmVuW3Bvcy5pXTtcbiAgICAgICAgZml4KGNvbXBvc2l0aW9uLmxpbmUsIGNWaWV3KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGNvbXBvc2l0aW9uLm1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gLTE7IGktLSkge1xuICAgICAgICAgICAgcG9zID0gY1ZpZXcuY2hpbGRQb3MocG9zLm9mZiwgMSk7XG4gICAgICAgICAgICBjVmlldyA9IGNWaWV3LmNoaWxkcmVuW3Bvcy5pXTtcbiAgICAgICAgICAgIGZpeChpID49IDAgPyBjb21wb3NpdGlvbi5tYXJrc1tpXS5ub2RlIDogY29tcG9zaXRpb24udGV4dCwgY1ZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFN5bmMgdGhlIERPTSBzZWxlY3Rpb24gdG8gdGhpcy5zdGF0ZS5zZWxlY3Rpb25cbiAgICB1cGRhdGVTZWxlY3Rpb24obXVzdFJlYWQgPSBmYWxzZSwgZnJvbVBvaW50ZXIgPSBmYWxzZSkge1xuICAgICAgICBpZiAobXVzdFJlYWQgfHwgIXRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZS5mb2N1c05vZGUpXG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBhY3RpdmVFbHQgPSB0aGlzLnZpZXcucm9vdC5hY3RpdmVFbGVtZW50LCBmb2N1c2VkID0gYWN0aXZlRWx0ID09IHRoaXMuZG9tO1xuICAgICAgICBsZXQgc2VsZWN0aW9uTm90Rm9jdXMgPSAhZm9jdXNlZCAmJiAhKHRoaXMudmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgfHwgdGhpcy5kb20udGFiSW5kZXggPiAtMSkgJiZcbiAgICAgICAgICAgIGhhc1NlbGVjdGlvbih0aGlzLmRvbSwgdGhpcy52aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlKSAmJiAhKGFjdGl2ZUVsdCAmJiB0aGlzLmRvbS5jb250YWlucyhhY3RpdmVFbHQpKTtcbiAgICAgICAgaWYgKCEoZm9jdXNlZCB8fCBmcm9tUG9pbnRlciB8fCBzZWxlY3Rpb25Ob3RGb2N1cykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBmb3JjZSA9IHRoaXMuZm9yY2VTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgbGV0IG1haW4gPSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIGxldCBhbmNob3IgPSB0aGlzLm1vdmVUb0xpbmUodGhpcy5kb21BdFBvcyhtYWluLmFuY2hvcikpO1xuICAgICAgICBsZXQgaGVhZCA9IG1haW4uZW1wdHkgPyBhbmNob3IgOiB0aGlzLm1vdmVUb0xpbmUodGhpcy5kb21BdFBvcyhtYWluLmhlYWQpKTtcbiAgICAgICAgLy8gQWx3YXlzIHJlc2V0IG9uIEZpcmVmb3ggd2hlbiBuZXh0IHRvIGFuIHVuZWRpdGFibGUgbm9kZSB0b1xuICAgICAgICAvLyBhdm9pZCBpbnZpc2libGUgY3Vyc29yIGJ1Z3MgKCMxMTEpXG4gICAgICAgIGlmIChicm93c2VyLmdlY2tvICYmIG1haW4uZW1wdHkgJiYgIXRoaXMuaGFzQ29tcG9zaXRpb24gJiYgYmV0d2VlblVuZWRpdGFibGUoYW5jaG9yKSkge1xuICAgICAgICAgICAgbGV0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IGFuY2hvci5ub2RlLmluc2VydEJlZm9yZShkdW1teSwgYW5jaG9yLm5vZGUuY2hpbGROb2Rlc1thbmNob3Iub2Zmc2V0XSB8fCBudWxsKSk7XG4gICAgICAgICAgICBhbmNob3IgPSBoZWFkID0gbmV3IERPTVBvcyhkdW1teSwgMCk7XG4gICAgICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRvbVNlbCA9IHRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGhlcmUsIG9yIGluIGFuIGVxdWl2YWxlbnQgcG9zaXRpb24sIGRvbid0IHRvdWNoIGl0XG4gICAgICAgIGlmIChmb3JjZSB8fCAhZG9tU2VsLmZvY3VzTm9kZSB8fCAoIWlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0LCBkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCkgfHxcbiAgICAgICAgICAgICFpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkLm5vZGUsIGhlYWQub2Zmc2V0LCBkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpKSAmJiAhdGhpcy5zdXBwcmVzc1dpZGdldEN1cnNvckNoYW5nZShkb21TZWwsIG1haW4pKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgQW5kcm9pZCB3aWxsIGhpZGUgdGhlIHZpcnR1YWwga2V5Ym9hcmQgd2hlbiB0YXBwaW5nXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIGFuIHVuZWRpdGFibGUgbm9kZSwgYW5kIG5vdCBicmluZyBpdCBiYWNrIHdoZW4gd2VcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSBjdXJzb3IgdG8gaXRzIHByb3BlciBwb3NpdGlvbi4gVGhpcyB0cmllcyB0b1xuICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIGtleWJvYXJkIGJ5IGN5Y2xpbmcgZm9jdXMuXG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSAmJiB0aGlzLmRvbS5jb250YWlucyhkb21TZWwuZm9jdXNOb2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICBpblVuZWRpdGFibGUoZG9tU2VsLmZvY3VzTm9kZSwgdGhpcy5kb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmF3U2VsID0gZ2V0U2VsZWN0aW9uKHRoaXMudmlldy5yb290KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJhd1NlbCkgO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1haW4uZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29yayBhcm91bmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYxMjA3NlxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRUbyA9IG5leHRUb1VuZWRpdGFibGUoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRUbyAmJiBuZXh0VG8gIT0gKDEgLyogTmV4dFRvLkJlZm9yZSAqLyB8IDIgLyogTmV4dFRvLkFmdGVyICovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gKG5leHRUbyA9PSAxIC8qIE5leHRUby5CZWZvcmUgKi8gPyB0ZXh0Tm9kZUJlZm9yZSA6IHRleHROb2RlQWZ0ZXIpKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gbmV3IERPTVBvcyh0ZXh0Lm5vZGUsIHRleHQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByYXdTZWwuY29sbGFwc2UoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbi5iaWRpTGV2ZWwgIT0gbnVsbCAmJiByYXdTZWwuY2FyZXRCaWRpTGV2ZWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1NlbC5jYXJldEJpZGlMZXZlbCA9IG1haW4uYmlkaUxldmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyYXdTZWwuZXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdGlvbi5leHRlbmQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuICdpbnZlcnRlZCcgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIChvbmUgd2hlcmUgdGhlIGZvY3VzIGlzIGJlZm9yZSB0aGUgYW5jaG9yKSwgYnV0IG5vdCBhbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJvd3NlcnMgc3VwcG9ydCBpdCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5jb2xsYXBzZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSB3aWxsIGlnbm9yZSB0aGUgY2FsbCBhYm92ZSB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaGlkZGVuLCBhbmQgdGhlbiByYWlzZSBhbiBlcnJvciBvbiB0aGUgY2FsbCB0byBleHRlbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gKCM5NDApLlxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmV4dGVuZChoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmltaXRpdmUgKElFKSB3YXlcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW4uYW5jaG9yID4gbWFpbi5oZWFkKVxuICAgICAgICAgICAgICAgICAgICAgICAgW2FuY2hvciwgaGVhZF0gPSBbaGVhZCwgYW5jaG9yXTtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJhd1NlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk5vdEZvY3VzICYmIHRoaXMudmlldy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlRWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlRWx0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuc2V0U2VsZWN0aW9uUmFuZ2UoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmltcHJlY2lzZUFuY2hvciA9IGFuY2hvci5wcmVjaXNlID8gbnVsbCA6IG5ldyBET01Qb3MoZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xuICAgICAgICB0aGlzLmltcHJlY2lzZUhlYWQgPSBoZWFkLnByZWNpc2UgPyBudWxsIDogbmV3IERPTVBvcyhkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgICAvLyBJZiBhIHplcm8tbGVuZ3RoIHdpZGdldCBpcyBpbnNlcnRlZCBuZXh0IHRvIHRoZSBjdXJzb3IgZHVyaW5nXG4gICAgLy8gY29tcG9zaXRpb24sIGF2b2lkIG1vdmluZyBpdCBhY3Jvc3MgaXQgYW5kIGRpc3J1cHRpbmcgdGhlXG4gICAgLy8gY29tcG9zaXRpb24uXG4gICAgc3VwcHJlc3NXaWRnZXRDdXJzb3JDaGFuZ2Uoc2VsLCBjdXJzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ29tcG9zaXRpb24gJiYgY3Vyc29yLmVtcHR5ICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQsIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KSAmJlxuICAgICAgICAgICAgdGhpcy5wb3NGcm9tRE9NKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCkgPT0gY3Vyc29yLmhlYWQ7XG4gICAgfVxuICAgIGVuZm9yY2VDdXJzb3JBc3NvYygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcG9zaXRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIGN1cnNvciA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICAgICAgbGV0IHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICBpZiAoIXNlbCB8fCAhY3Vyc29yLmVtcHR5IHx8ICFjdXJzb3IuYXNzb2MgfHwgIXNlbC5tb2RpZnkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lID0gTGluZVZpZXcuZmluZCh0aGlzLCBjdXJzb3IuaGVhZCk7XG4gICAgICAgIGlmICghbGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGxpbmVTdGFydCA9IGxpbmUucG9zQXRTdGFydDtcbiAgICAgICAgaWYgKGN1cnNvci5oZWFkID09IGxpbmVTdGFydCB8fCBjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgKyBsaW5lLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGJlZm9yZSA9IHRoaXMuY29vcmRzQXQoY3Vyc29yLmhlYWQsIC0xKSwgYWZ0ZXIgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAxKTtcbiAgICAgICAgaWYgKCFiZWZvcmUgfHwgIWFmdGVyIHx8IGJlZm9yZS5ib3R0b20gPiBhZnRlci50b3ApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkb20gPSB0aGlzLmRvbUF0UG9zKGN1cnNvci5oZWFkICsgY3Vyc29yLmFzc29jKTtcbiAgICAgICAgc2VsLmNvbGxhcHNlKGRvbS5ub2RlLCBkb20ub2Zmc2V0KTtcbiAgICAgICAgc2VsLm1vZGlmeShcIm1vdmVcIiwgY3Vyc29yLmFzc29jIDwgMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiLCBcImxpbmVib3VuZGFyeVwiKTtcbiAgICAgICAgLy8gVGhpcyBjYW4gZ28gd3JvbmcgaW4gY29ybmVyIGNhc2VzIGxpa2Ugc2luZ2xlLWNoYXJhY3RlciBsaW5lcyxcbiAgICAgICAgLy8gc28gY2hlY2sgYW5kIHJlc2V0IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgdmlldy5vYnNlcnZlci5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IG5ld1JhbmdlID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5ld1JhbmdlLmFuY2hvck5vZGUsIG5ld1JhbmdlLmFuY2hvck9mZnNldCkgIT0gY3Vyc29yLmZyb20pXG4gICAgICAgICAgICBzZWwuY29sbGFwc2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gSWYgYSBwb3NpdGlvbiBpcyBpbi9uZWFyIGEgYmxvY2sgd2lkZ2V0LCBtb3ZlIGl0IHRvIGEgbmVhcmJ5IHRleHRcbiAgICAvLyBsaW5lLCBzaW5jZSB3ZSBkb24ndCB3YW50IHRoZSBjdXJzb3IgaW5zaWRlIGEgYmxvY2sgd2lkZ2V0LlxuICAgIG1vdmVUb0xpbmUocG9zKSB7XG4gICAgICAgIC8vIEJsb2NrIHdpZGdldHMgd2lsbCByZXR1cm4gcG9zaXRpb25zIGJlZm9yZS9hZnRlciB0aGVtLCB3aGljaFxuICAgICAgICAvLyBhcmUgdGh1cyBkaXJlY3RseSBpbiB0aGUgZG9jdW1lbnQgRE9NIGVsZW1lbnQuXG4gICAgICAgIGxldCBkb20gPSB0aGlzLmRvbSwgbmV3UG9zO1xuICAgICAgICBpZiAocG9zLm5vZGUgIT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvcy5vZmZzZXQ7ICFuZXdQb3MgJiYgaSA8IGRvbS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChkb20uY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IHZpZXcuZG9tQXRQb3MoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHBvcy5vZmZzZXQgLSAxOyAhbmV3UG9zICYmIGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChkb20uY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICBpZiAodmlldyBpbnN0YW5jZW9mIExpbmVWaWV3KVxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IHZpZXcuZG9tQXRQb3Modmlldy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdQb3MgPyBuZXcgRE9NUG9zKG5ld1Bvcy5ub2RlLCBuZXdQb3Mub2Zmc2V0LCB0cnVlKSA6IHBvcztcbiAgICB9XG4gICAgbmVhcmVzdChkb20pIHtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7KSB7XG4gICAgICAgICAgICBsZXQgZG9tVmlldyA9IENvbnRlbnRWaWV3LmdldChjdXIpO1xuICAgICAgICAgICAgaWYgKGRvbVZpZXcgJiYgZG9tVmlldy5yb290VmlldyA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb21WaWV3O1xuICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCB2aWV3ID0gdGhpcy5uZWFyZXN0KG5vZGUpO1xuICAgICAgICBpZiAoIXZpZXcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBmaW5kIHBvc2l0aW9uIGZvciBhIERPTSBwb3NpdGlvbiBvdXRzaWRlIG9mIHRoZSBkb2N1bWVudFwiKTtcbiAgICAgICAgcmV0dXJuIHZpZXcubG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkgKyB2aWV3LnBvc0F0U3RhcnQ7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICBsZXQgeyBpLCBvZmYgfSA9IHRoaXMuY2hpbGRDdXJzb3IoKS5maW5kUG9zKHBvcywgLTEpO1xuICAgICAgICBmb3IgKDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAob2ZmIDwgY2hpbGQubGVuZ3RoIHx8IGNoaWxkIGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBvZmYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldLmRvbUF0UG9zKG9mZik7XG4gICAgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgYmVzdCA9IG51bGwsIGJlc3RQb3MgPSAwO1xuICAgICAgICBmb3IgKGxldCBvZmYgPSB0aGlzLmxlbmd0aCwgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZiAtIGNoaWxkLmJyZWFrQWZ0ZXIsIHN0YXJ0ID0gZW5kIC0gY2hpbGQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA8IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChzdGFydCA8PSBwb3MgJiYgKHN0YXJ0IDwgcG9zIHx8IGNoaWxkLmNvdmVycygtMSkpICYmIChlbmQgPiBwb3MgfHwgY2hpbGQuY292ZXJzKDEpKSAmJlxuICAgICAgICAgICAgICAgICghYmVzdCB8fCBjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3ICYmICEoYmVzdCBpbnN0YW5jZW9mIExpbmVWaWV3ICYmIHNpZGUgPj0gMCkpKSB7XG4gICAgICAgICAgICAgICAgYmVzdCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGJlc3RQb3MgPSBzdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJlc3QgJiYgc3RhcnQgPT0gcG9zICYmIGVuZCA9PSBwb3MgJiYgY2hpbGQgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgTWF0aC5hYnMoc2lkZSkgPCAyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmRlY28uc3RhcnRTaWRlIDwgMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSlcbiAgICAgICAgICAgICAgICAgICAgYmVzdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgPSBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdCA/IGJlc3QuY29vcmRzQXQocG9zIC0gYmVzdFBvcywgc2lkZSkgOiBudWxsO1xuICAgIH1cbiAgICBjb29yZHNGb3JDaGFyKHBvcykge1xuICAgICAgICBsZXQgeyBpLCBvZmYgfSA9IHRoaXMuY2hpbGRQb3MocG9zLCAxKSwgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIExpbmVWaWV3KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyBpLCBvZmY6IGNoaWxkT2ZmIH0gPSBjaGlsZC5jaGlsZFBvcyhvZmYsIDEpO1xuICAgICAgICAgICAgZm9yICg7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBjaGlsZC5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIGlmICgoY2hpbGQgPSBjaGlsZC5jaGlsZHJlbltpXSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiA9IGNoaWxkT2ZmO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBlbmQgPSBmaW5kQ2x1c3RlckJyZWFrKGNoaWxkLnRleHQsIG9mZik7XG4gICAgICAgIGlmIChlbmQgPT0gb2ZmKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCByZWN0cyA9IHRleHRSYW5nZShjaGlsZC5kb20sIG9mZiwgZW5kKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKGkgPT0gcmVjdHMubGVuZ3RoIC0gMSB8fCByZWN0LnRvcCA8IHJlY3QuYm90dG9tICYmIHJlY3QubGVmdCA8IHJlY3QucmlnaHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModmlld3BvcnQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCB7IGZyb20sIHRvIH0gPSB2aWV3cG9ydDtcbiAgICAgICAgbGV0IGNvbnRlbnRXaWR0aCA9IHRoaXMudmlldy5jb250ZW50RE9NLmNsaWVudFdpZHRoO1xuICAgICAgICBsZXQgaXNXaWRlciA9IGNvbnRlbnRXaWR0aCA+IE1hdGgubWF4KHRoaXMudmlldy5zY3JvbGxET00uY2xpZW50V2lkdGgsIHRoaXMubWluV2lkdGgpICsgMTtcbiAgICAgICAgbGV0IHdpZGVzdCA9IC0xLCBsdHIgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmIChwb3MgPj0gZnJvbSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZFJlY3QgPSBjaGlsZC5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGRSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2lkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBjaGlsZC5kb20ubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBsYXN0ID8gY2xpZW50UmVjdHNGb3IobGFzdCkgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tyZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IGx0ciA/IHJlY3QucmlnaHQgLSBjaGlsZFJlY3QubGVmdCA6IGNoaWxkUmVjdC5yaWdodCAtIHJlY3QubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aCA+IHdpZGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGVzdCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGggPSBjb250ZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0ZXh0RGlyZWN0aW9uQXQocG9zKSB7XG4gICAgICAgIGxldCB7IGkgfSA9IHRoaXMuY2hpbGRQb3MocG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUodGhpcy5jaGlsZHJlbltpXS5kb20pLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gRGlyZWN0aW9uLlJUTCA6IERpcmVjdGlvbi5MVFI7XG4gICAgfVxuICAgIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgTGluZVZpZXcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyZSA9IGNoaWxkLm1lYXN1cmVUZXh0U2l6ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyB3b3JrYWJsZSBsaW5lIGV4aXN0cywgZm9yY2UgYSBsYXlvdXQgb2YgYSBtZWFzdXJhYmxlIGVsZW1lbnRcbiAgICAgICAgbGV0IGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0O1xuICAgICAgICBkdW1teS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIjtcbiAgICAgICAgZHVtbXkuc3R5bGUud2lkdGggPSBcIjk5OTk5cHhcIjtcbiAgICAgICAgZHVtbXkuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIGR1bW15LnRleHRDb250ZW50ID0gXCJhYmMgZGVmIGdoaSBqa2wgbW5vIHBxciBzdHVcIjtcbiAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChkdW1teSk7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IGNsaWVudFJlY3RzRm9yKGR1bW15LmZpcnN0Q2hpbGQpWzBdO1xuICAgICAgICAgICAgbGluZUhlaWdodCA9IGR1bW15LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgIGNoYXJXaWR0aCA9IHJlY3QgPyByZWN0LndpZHRoIC8gMjcgOiA3O1xuICAgICAgICAgICAgdGV4dEhlaWdodCA9IHJlY3QgPyByZWN0LmhlaWdodCA6IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBkdW1teS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCB9O1xuICAgIH1cbiAgICBjaGlsZEN1cnNvcihwb3MgPSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAvLyBNb3ZlIGJhY2sgdG8gc3RhcnQgb2YgbGFzdCBlbGVtZW50IHdoZW4gcG9zc2libGUsIHNvIHRoYXRcbiAgICAgICAgLy8gYENoaWxkQ3Vyc29yLmZpbmRQb3NgIGRvZXNuJ3QgaGF2ZSB0byBkZWFsIHdpdGggdGhlIGVkZ2UgY2FzZVxuICAgICAgICAvLyBvZiBiZWluZyBhZnRlciB0aGUgbGFzdCBlbGVtZW50LlxuICAgICAgICBsZXQgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgIHBvcyAtPSB0aGlzLmNoaWxkcmVuWy0taV0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbmV3IENoaWxkQ3Vyc29yKHRoaXMuY2hpbGRyZW4sIHBvcywgaSk7XG4gICAgfVxuICAgIGNvbXB1dGVCbG9ja0dhcERlY28oKSB7XG4gICAgICAgIGxldCBkZWNvID0gW10sIHZzID0gdGhpcy52aWV3LnZpZXdTdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA9PSB2cy52aWV3cG9ydHMubGVuZ3RoID8gbnVsbCA6IHZzLnZpZXdwb3J0c1tpXTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBuZXh0ID8gbmV4dC5mcm9tIC0gMSA6IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+IHBvcykge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSAodnMubGluZUJsb2NrQXQoZW5kKS5ib3R0b20gLSB2cy5saW5lQmxvY2tBdChwb3MpLnRvcCkgLyB0aGlzLnZpZXcuc2NhbGVZO1xuICAgICAgICAgICAgICAgIGRlY28ucHVzaChEZWNvcmF0aW9uLnJlcGxhY2Uoe1xuICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBCbG9ja0dhcFdpZGdldChoZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc0Jsb2NrR2FwOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pLnJhbmdlKHBvcywgZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwb3MgPSBuZXh0LnRvICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoZGVjbyk7XG4gICAgfVxuICAgIHVwZGF0ZURlY28oKSB7XG4gICAgICAgIGxldCBpID0gMTtcbiAgICAgICAgbGV0IGFsbERlY28gPSB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLm1hcChkID0+IHtcbiAgICAgICAgICAgIGxldCBkeW5hbWljID0gdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcFtpKytdID0gdHlwZW9mIGQgPT0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWMgPyBkKHRoaXMudmlldykgOiBkO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGR5bmFtaWNPdXRlciA9IGZhbHNlLCBvdXRlckRlY28gPSB0aGlzLnZpZXcuc3RhdGUuZmFjZXQob3V0ZXJEZWNvcmF0aW9ucykubWFwKChkLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgZHluYW1pYyA9IHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgICAgIGlmIChkeW5hbWljKVxuICAgICAgICAgICAgICAgIGR5bmFtaWNPdXRlciA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZHluYW1pYyA/IGQodGhpcy52aWV3KSA6IGQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3V0ZXJEZWNvLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcFtpKytdID0gZHluYW1pY091dGVyO1xuICAgICAgICAgICAgYWxsRGVjby5wdXNoKFJhbmdlU2V0LmpvaW4ob3V0ZXJEZWNvKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IFtcbiAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHRGb3JtYXR0aW5nLFxuICAgICAgICAgICAgLi4uYWxsRGVjbyxcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUJsb2NrR2FwRGVjbygpLFxuICAgICAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5saW5lR2FwRGVjb1xuICAgICAgICBdO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMuZGVjb3JhdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcFtpKytdID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRpb25zO1xuICAgIH1cbiAgICBzY3JvbGxJbnRvVmlldyh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRhcmdldC5pc1NuYXBzaG90KSB7XG4gICAgICAgICAgICBsZXQgcmVmID0gdGhpcy52aWV3LnZpZXdTdGF0ZS5saW5lQmxvY2tBdCh0YXJnZXQucmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCA9IHJlZi50b3AgLSB0YXJnZXQueU1hcmdpbjtcbiAgICAgICAgICAgIHRoaXMudmlldy5zY3JvbGxET00uc2Nyb2xsTGVmdCA9IHRhcmdldC54TWFyZ2luO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgdGhpcy52aWV3LnN0YXRlLmZhY2V0KHNjcm9sbEhhbmRsZXIpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKHRoaXMudmlldywgdGFyZ2V0LnJhbmdlLCB0YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMudmlldy5zdGF0ZSwgZSwgXCJzY3JvbGwgaGFuZGxlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgeyByYW5nZSB9ID0gdGFyZ2V0O1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuY29vcmRzQXQocmFuZ2UuaGVhZCwgcmFuZ2UuZW1wdHkgPyByYW5nZS5hc3NvYyA6IHJhbmdlLmhlYWQgPiByYW5nZS5hbmNob3IgPyAtMSA6IDEpLCBvdGhlcjtcbiAgICAgICAgaWYgKCFyZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5ICYmIChvdGhlciA9IHRoaXMuY29vcmRzQXQocmFuZ2UuYW5jaG9yLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gLTEgOiAxKSkpXG4gICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBNYXRoLm1pbihyZWN0LmxlZnQsIG90aGVyLmxlZnQpLCB0b3A6IE1hdGgubWluKHJlY3QudG9wLCBvdGhlci50b3ApLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChyZWN0LnJpZ2h0LCBvdGhlci5yaWdodCksIGJvdHRvbTogTWF0aC5tYXgocmVjdC5ib3R0b20sIG90aGVyLmJvdHRvbSkgfTtcbiAgICAgICAgbGV0IG1hcmdpbnMgPSBnZXRTY3JvbGxNYXJnaW5zKHRoaXMudmlldyk7XG4gICAgICAgIGxldCB0YXJnZXRSZWN0ID0ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gbWFyZ2lucy5sZWZ0LCB0b3A6IHJlY3QudG9wIC0gbWFyZ2lucy50b3AsXG4gICAgICAgICAgICByaWdodDogcmVjdC5yaWdodCArIG1hcmdpbnMucmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gKyBtYXJnaW5zLmJvdHRvbVxuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0IH0gPSB0aGlzLnZpZXcuc2Nyb2xsRE9NO1xuICAgICAgICBzY3JvbGxSZWN0SW50b1ZpZXcodGhpcy52aWV3LnNjcm9sbERPTSwgdGFyZ2V0UmVjdCwgcmFuZ2UuaGVhZCA8IHJhbmdlLmFuY2hvciA/IC0xIDogMSwgdGFyZ2V0LngsIHRhcmdldC55LCBNYXRoLm1heChNYXRoLm1pbih0YXJnZXQueE1hcmdpbiwgb2Zmc2V0V2lkdGgpLCAtb2Zmc2V0V2lkdGgpLCBNYXRoLm1heChNYXRoLm1pbih0YXJnZXQueU1hcmdpbiwgb2Zmc2V0SGVpZ2h0KSwgLW9mZnNldEhlaWdodCksIHRoaXMudmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJldHdlZW5VbmVkaXRhYmxlKHBvcykge1xuICAgIHJldHVybiBwb3Mubm9kZS5ub2RlVHlwZSA9PSAxICYmIHBvcy5ub2RlLmZpcnN0Q2hpbGQgJiZcbiAgICAgICAgKHBvcy5vZmZzZXQgPT0gMCB8fCBwb3Mubm9kZS5jaGlsZE5vZGVzW3Bvcy5vZmZzZXQgLSAxXS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSAmJlxuICAgICAgICAocG9zLm9mZnNldCA9PSBwb3Mubm9kZS5jaGlsZE5vZGVzLmxlbmd0aCB8fCBwb3Mubm9kZS5jaGlsZE5vZGVzW3Bvcy5vZmZzZXRdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpO1xufVxuZnVuY3Rpb24gZmluZENvbXBvc2l0aW9uTm9kZSh2aWV3LCBoZWFkUG9zKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKCFzZWwuZm9jdXNOb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgdGV4dEJlZm9yZSA9IHRleHROb2RlQmVmb3JlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgbGV0IHRleHRBZnRlciA9IHRleHROb2RlQWZ0ZXIoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICBsZXQgdGV4dE5vZGUgPSB0ZXh0QmVmb3JlIHx8IHRleHRBZnRlcjtcbiAgICBpZiAodGV4dEFmdGVyICYmIHRleHRCZWZvcmUgJiYgdGV4dEFmdGVyLm5vZGUgIT0gdGV4dEJlZm9yZS5ub2RlKSB7XG4gICAgICAgIGxldCBkZXNjQWZ0ZXIgPSBDb250ZW50Vmlldy5nZXQodGV4dEFmdGVyLm5vZGUpO1xuICAgICAgICBpZiAoIWRlc2NBZnRlciB8fCBkZXNjQWZ0ZXIgaW5zdGFuY2VvZiBUZXh0VmlldyAmJiBkZXNjQWZ0ZXIudGV4dCAhPSB0ZXh0QWZ0ZXIubm9kZS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIHRleHROb2RlID0gdGV4dEFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXcuZG9jVmlldy5sYXN0Q29tcG9zaXRpb25BZnRlckN1cnNvcikge1xuICAgICAgICAgICAgbGV0IGRlc2NCZWZvcmUgPSBDb250ZW50Vmlldy5nZXQodGV4dEJlZm9yZS5ub2RlKTtcbiAgICAgICAgICAgIGlmICghKCFkZXNjQmVmb3JlIHx8IGRlc2NCZWZvcmUgaW5zdGFuY2VvZiBUZXh0VmlldyAmJiBkZXNjQmVmb3JlLnRleHQgIT0gdGV4dEJlZm9yZS5ub2RlLm5vZGVWYWx1ZSkpXG4gICAgICAgICAgICAgICAgdGV4dE5vZGUgPSB0ZXh0QWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5kb2NWaWV3Lmxhc3RDb21wb3NpdGlvbkFmdGVyQ3Vyc29yID0gdGV4dE5vZGUgIT0gdGV4dEJlZm9yZTtcbiAgICBpZiAoIXRleHROb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZnJvbSA9IGhlYWRQb3MgLSB0ZXh0Tm9kZS5vZmZzZXQ7XG4gICAgcmV0dXJuIHsgZnJvbSwgdG86IGZyb20gKyB0ZXh0Tm9kZS5ub2RlLm5vZGVWYWx1ZS5sZW5ndGgsIG5vZGU6IHRleHROb2RlLm5vZGUgfTtcbn1cbmZ1bmN0aW9uIGZpbmRDb21wb3NpdGlvblJhbmdlKHZpZXcsIGNoYW5nZXMsIGhlYWRQb3MpIHtcbiAgICBsZXQgZm91bmQgPSBmaW5kQ29tcG9zaXRpb25Ob2RlKHZpZXcsIGhlYWRQb3MpO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB7IG5vZGU6IHRleHROb2RlLCBmcm9tLCB0byB9ID0gZm91bmQsIHRleHQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWU7XG4gICAgLy8gRG9uJ3QgdHJ5IHRvIHByZXNlcnZlIG11bHRpLWxpbmUgY29tcG9zaXRpb25zXG4gICAgaWYgKC9bXFxuXFxyXS8udGVzdCh0ZXh0KSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHZpZXcuc3RhdGUuZG9jLnNsaWNlU3RyaW5nKGZvdW5kLmZyb20sIGZvdW5kLnRvKSAhPSB0ZXh0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgaW52ID0gY2hhbmdlcy5pbnZlcnRlZERlc2M7XG4gICAgbGV0IHJhbmdlID0gbmV3IENoYW5nZWRSYW5nZShpbnYubWFwUG9zKGZyb20pLCBpbnYubWFwUG9zKHRvKSwgZnJvbSwgdG8pO1xuICAgIGxldCBtYXJrcyA9IFtdO1xuICAgIGZvciAobGV0IHBhcmVudCA9IHRleHROb2RlLnBhcmVudE5vZGU7OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBsZXQgcGFyZW50VmlldyA9IENvbnRlbnRWaWV3LmdldChwYXJlbnQpO1xuICAgICAgICBpZiAocGFyZW50VmlldyBpbnN0YW5jZW9mIE1hcmtWaWV3KVxuICAgICAgICAgICAgbWFya3MucHVzaCh7IG5vZGU6IHBhcmVudCwgZGVjbzogcGFyZW50Vmlldy5tYXJrIH0pO1xuICAgICAgICBlbHNlIGlmIChwYXJlbnRWaWV3IGluc3RhbmNlb2YgTGluZVZpZXcgfHwgcGFyZW50Lm5vZGVOYW1lID09IFwiRElWXCIgJiYgcGFyZW50LnBhcmVudE5vZGUgPT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIHRleHQ6IHRleHROb2RlLCBtYXJrcywgbGluZTogcGFyZW50IH07XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudCAhPSB2aWV3LmNvbnRlbnRET00pXG4gICAgICAgICAgICBtYXJrcy5wdXNoKHsgbm9kZTogcGFyZW50LCBkZWNvOiBuZXcgTWFya0RlY29yYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGdldEF0dHJzKHBhcmVudCksXG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6IHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICB9KSB9KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV4dFRvVW5lZGl0YWJsZShub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKG9mZnNldCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiA/IDEgLyogTmV4dFRvLkJlZm9yZSAqLyA6IDApIHxcbiAgICAgICAgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggJiYgbm9kZS5jaGlsZE5vZGVzW29mZnNldF0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiA/IDIgLyogTmV4dFRvLkFmdGVyICovIDogMCk7XG59XG5sZXQgRGVjb3JhdGlvbkNvbXBhcmF0b3IkMSA9IGNsYXNzIERlY29yYXRpb25Db21wYXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gW107XG4gICAgfVxuICAgIGNvbXBhcmVSYW5nZShmcm9tLCB0bykgeyBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzKTsgfVxuICAgIGNvbXBhcmVQb2ludChmcm9tLCB0bykgeyBhZGRSYW5nZShmcm9tLCB0bywgdGhpcy5jaGFuZ2VzKTsgfVxuICAgIGJvdW5kQ2hhbmdlKHBvcykgeyBhZGRSYW5nZShwb3MsIHBvcywgdGhpcy5jaGFuZ2VzKTsgfVxufTtcbmZ1bmN0aW9uIGZpbmRDaGFuZ2VkRGVjbyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3IkMTtcbiAgICBSYW5nZVNldC5jb21wYXJlKGEsIGIsIGRpZmYsIGNvbXApO1xuICAgIHJldHVybiBjb21wLmNoYW5nZXM7XG59XG5mdW5jdGlvbiBpblVuZWRpdGFibGUobm9kZSwgaW5zaWRlKSB7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTsgY3VyICYmIGN1ciAhPSBpbnNpZGU7IGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PSAxICYmIGN1ci5jb250ZW50RWRpdGFibGUgPT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdG91Y2hlc0NvbXBvc2l0aW9uKGNoYW5nZXMsIGNvbXBvc2l0aW9uKSB7XG4gICAgbGV0IHRvdWNoZWQgPSBmYWxzZTtcbiAgICBpZiAoY29tcG9zaXRpb24pXG4gICAgICAgIGNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IGNvbXBvc2l0aW9uLnRvICYmIHRvID4gY29tcG9zaXRpb24uZnJvbSlcbiAgICAgICAgICAgICAgICB0b3VjaGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIHRvdWNoZWQ7XG59XG5cbmZ1bmN0aW9uIGdyb3VwQXQoc3RhdGUsIHBvcywgYmlhcyA9IDEpIHtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBsaW5lUG9zID0gcG9zIC0gbGluZS5mcm9tO1xuICAgIGlmIChsaW5lLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpO1xuICAgIGlmIChsaW5lUG9zID09IDApXG4gICAgICAgIGJpYXMgPSAxO1xuICAgIGVsc2UgaWYgKGxpbmVQb3MgPT0gbGluZS5sZW5ndGgpXG4gICAgICAgIGJpYXMgPSAtMTtcbiAgICBsZXQgZnJvbSA9IGxpbmVQb3MsIHRvID0gbGluZVBvcztcbiAgICBpZiAoYmlhcyA8IDApXG4gICAgICAgIGZyb20gPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgbGluZVBvcywgZmFsc2UpO1xuICAgIGVsc2VcbiAgICAgICAgdG8gPSBmaW5kQ2x1c3RlckJyZWFrKGxpbmUudGV4dCwgbGluZVBvcyk7XG4gICAgbGV0IGNhdCA9IGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgd2hpbGUgKGZyb20gPiAwKSB7XG4gICAgICAgIGxldCBwcmV2ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGZyb20sIGZhbHNlKTtcbiAgICAgICAgaWYgKGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKHByZXYsIGZyb20pKSAhPSBjYXQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZnJvbSA9IHByZXY7XG4gICAgfVxuICAgIHdoaWxlICh0byA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHRvKTtcbiAgICAgICAgaWYgKGNhdGVnb3JpemUobGluZS50ZXh0LnNsaWNlKHRvLCBuZXh0KSkgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHRvID0gbmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tICsgbGluZS5mcm9tLCB0byArIGxpbmUuZnJvbSk7XG59XG4vLyBTZWFyY2ggdGhlIERPTSBmb3IgdGhlIHtub2RlLCBvZmZzZXR9IHBvc2l0aW9uIGNsb3Nlc3QgdG8gdGhlIGdpdmVuXG4vLyBjb29yZGluYXRlcy4gVmVyeSBpbmVmZmljaWVudCBhbmQgY3J1ZGUsIGJ1dCBjYW4gdXN1YWxseSBiZSBhdm9pZGVkXG4vLyBieSBjYWxsaW5nIGNhcmV0KFBvc2l0aW9ufFJhbmdlKUZyb21Qb2ludCBpbnN0ZWFkLlxuZnVuY3Rpb24gZ2V0ZHgoeCwgcmVjdCkge1xuICAgIHJldHVybiByZWN0LmxlZnQgPiB4ID8gcmVjdC5sZWZ0IC0geCA6IE1hdGgubWF4KDAsIHggLSByZWN0LnJpZ2h0KTtcbn1cbmZ1bmN0aW9uIGdldGR5KHksIHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC50b3AgPiB5ID8gcmVjdC50b3AgLSB5IDogTWF0aC5tYXgoMCwgeSAtIHJlY3QuYm90dG9tKTtcbn1cbmZ1bmN0aW9uIHlPdmVybGFwKGEsIGIpIHtcbiAgICByZXR1cm4gYS50b3AgPCBiLmJvdHRvbSAtIDEgJiYgYS5ib3R0b20gPiBiLnRvcCArIDE7XG59XG5mdW5jdGlvbiB1cFRvcChyZWN0LCB0b3ApIHtcbiAgICByZXR1cm4gdG9wIDwgcmVjdC50b3AgPyB7IHRvcCwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCwgYm90dG9tOiByZWN0LmJvdHRvbSB9IDogcmVjdDtcbn1cbmZ1bmN0aW9uIHVwQm90KHJlY3QsIGJvdHRvbSkge1xuICAgIHJldHVybiBib3R0b20gPiByZWN0LmJvdHRvbSA/IHsgdG9wOiByZWN0LnRvcCwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCwgYm90dG9tIH0gOiByZWN0O1xufVxuZnVuY3Rpb24gZG9tUG9zQXRDb29yZHMocGFyZW50LCB4LCB5KSB7XG4gICAgbGV0IGNsb3Nlc3QsIGNsb3Nlc3RSZWN0LCBjbG9zZXN0WCwgY2xvc2VzdFksIGNsb3Nlc3RPdmVybGFwID0gZmFsc2U7XG4gICAgbGV0IGFib3ZlLCBiZWxvdywgYWJvdmVSZWN0LCBiZWxvd1JlY3Q7XG4gICAgZm9yIChsZXQgY2hpbGQgPSBwYXJlbnQuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbGV0IHJlY3RzID0gY2xpZW50UmVjdHNGb3IoY2hpbGQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RSZWN0ICYmIHlPdmVybGFwKGNsb3Nlc3RSZWN0LCByZWN0KSlcbiAgICAgICAgICAgICAgICByZWN0ID0gdXBUb3AodXBCb3QocmVjdCwgY2xvc2VzdFJlY3QuYm90dG9tKSwgY2xvc2VzdFJlY3QudG9wKTtcbiAgICAgICAgICAgIGxldCBkeCA9IGdldGR4KHgsIHJlY3QpLCBkeSA9IGdldGR5KHksIHJlY3QpO1xuICAgICAgICAgICAgaWYgKGR4ID09IDAgJiYgZHkgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubm9kZVR5cGUgPT0gMyA/IGRvbVBvc0luVGV4dChjaGlsZCwgeCwgeSkgOiBkb21Qb3NBdENvb3JkcyhjaGlsZCwgeCwgeSk7XG4gICAgICAgICAgICBpZiAoIWNsb3Nlc3QgfHwgY2xvc2VzdFkgPiBkeSB8fCBjbG9zZXN0WSA9PSBkeSAmJiBjbG9zZXN0WCA+IGR4KSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0WCA9IGR4O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RZID0gZHk7XG4gICAgICAgICAgICAgICAgbGV0IHNpZGUgPSBkeSA/ICh5IDwgcmVjdC50b3AgPyAtMSA6IDEpIDogZHggPyAoeCA8IHJlY3QubGVmdCA/IC0xIDogMSkgOiAwO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RPdmVybGFwID0gIXNpZGUgfHwgKHNpZGUgPiAwID8gaSA8IHJlY3RzLmxlbmd0aCAtIDEgOiBpID4gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHggPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh5ID4gcmVjdC5ib3R0b20gJiYgKCFhYm92ZVJlY3QgfHwgYWJvdmVSZWN0LmJvdHRvbSA8IHJlY3QuYm90dG9tKSkge1xuICAgICAgICAgICAgICAgICAgICBhYm92ZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBhYm92ZVJlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh5IDwgcmVjdC50b3AgJiYgKCFiZWxvd1JlY3QgfHwgYmVsb3dSZWN0LnRvcCA+IHJlY3QudG9wKSkge1xuICAgICAgICAgICAgICAgICAgICBiZWxvdyA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBiZWxvd1JlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFib3ZlUmVjdCAmJiB5T3ZlcmxhcChhYm92ZVJlY3QsIHJlY3QpKSB7XG4gICAgICAgICAgICAgICAgYWJvdmVSZWN0ID0gdXBCb3QoYWJvdmVSZWN0LCByZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZWxvd1JlY3QgJiYgeU92ZXJsYXAoYmVsb3dSZWN0LCByZWN0KSkge1xuICAgICAgICAgICAgICAgIGJlbG93UmVjdCA9IHVwVG9wKGJlbG93UmVjdCwgcmVjdC50b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhYm92ZVJlY3QgJiYgYWJvdmVSZWN0LmJvdHRvbSA+PSB5KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBhYm92ZTtcbiAgICAgICAgY2xvc2VzdFJlY3QgPSBhYm92ZVJlY3Q7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJlbG93UmVjdCAmJiBiZWxvd1JlY3QudG9wIDw9IHkpIHtcbiAgICAgICAgY2xvc2VzdCA9IGJlbG93O1xuICAgICAgICBjbG9zZXN0UmVjdCA9IGJlbG93UmVjdDtcbiAgICB9XG4gICAgaWYgKCFjbG9zZXN0KVxuICAgICAgICByZXR1cm4geyBub2RlOiBwYXJlbnQsIG9mZnNldDogMCB9O1xuICAgIGxldCBjbGlwWCA9IE1hdGgubWF4KGNsb3Nlc3RSZWN0LmxlZnQsIE1hdGgubWluKGNsb3Nlc3RSZWN0LnJpZ2h0LCB4KSk7XG4gICAgaWYgKGNsb3Nlc3Qubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIGRvbVBvc0luVGV4dChjbG9zZXN0LCBjbGlwWCwgeSk7XG4gICAgaWYgKGNsb3Nlc3RPdmVybGFwICYmIGNsb3Nlc3QuY29udGVudEVkaXRhYmxlICE9IFwiZmFsc2VcIilcbiAgICAgICAgcmV0dXJuIGRvbVBvc0F0Q29vcmRzKGNsb3Nlc3QsIGNsaXBYLCB5KTtcbiAgICBsZXQgb2Zmc2V0ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChwYXJlbnQuY2hpbGROb2RlcywgY2xvc2VzdCkgK1xuICAgICAgICAoeCA+PSAoY2xvc2VzdFJlY3QubGVmdCArIGNsb3Nlc3RSZWN0LnJpZ2h0KSAvIDIgPyAxIDogMCk7XG4gICAgcmV0dXJuIHsgbm9kZTogcGFyZW50LCBvZmZzZXQgfTtcbn1cbmZ1bmN0aW9uIGRvbVBvc0luVGV4dChub2RlLCB4LCB5KSB7XG4gICAgbGV0IGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICBsZXQgY2xvc2VzdE9mZnNldCA9IC0xLCBjbG9zZXN0RFkgPSAxZTksIGdlbmVyYWxTaWRlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxldCByZWN0cyA9IHRleHRSYW5nZShub2RlLCBpLCBpICsgMSkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZWN0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICAgIGlmIChyZWN0LnRvcCA9PSByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghZ2VuZXJhbFNpZGUpXG4gICAgICAgICAgICAgICAgZ2VuZXJhbFNpZGUgPSB4IC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgbGV0IGR5ID0gKHJlY3QudG9wID4geSA/IHJlY3QudG9wIC0geSA6IHkgLSByZWN0LmJvdHRvbSkgLSAxO1xuICAgICAgICAgICAgaWYgKHJlY3QubGVmdCAtIDEgPD0geCAmJiByZWN0LnJpZ2h0ICsgMSA+PSB4ICYmIGR5IDwgY2xvc2VzdERZKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0geCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCBhZnRlciA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmdlY2tvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBSVEwgb24gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGdldHRpbmcgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY3RzIGZvciBlbXB0eSByYW5nZXMuXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0QmVmb3JlID0gdGV4dFJhbmdlKG5vZGUsIGkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjdEJlZm9yZS5sZWZ0ID09IHJlY3QucmlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICBhZnRlciA9ICFyaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGR5IDw9IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogaSArIChhZnRlciA/IDEgOiAwKSB9O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RPZmZzZXQgPSBpICsgKGFmdGVyID8gMSA6IDApO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3REWSA9IGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG5vZGUsIG9mZnNldDogY2xvc2VzdE9mZnNldCA+IC0xID8gY2xvc2VzdE9mZnNldCA6IGdlbmVyYWxTaWRlID4gMCA/IG5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IDAgfTtcbn1cbmZ1bmN0aW9uIHBvc0F0Q29vcmRzKHZpZXcsIGNvb3JkcywgcHJlY2lzZSwgYmlhcyA9IC0xKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgY29udGVudCA9IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZG9jVG9wID0gY29udGVudC50b3AgKyB2aWV3LnZpZXdTdGF0ZS5wYWRkaW5nVG9wO1xuICAgIGxldCBibG9jaywgeyBkb2NIZWlnaHQgfSA9IHZpZXcudmlld1N0YXRlO1xuICAgIGxldCB7IHgsIHkgfSA9IGNvb3JkcywgeU9mZnNldCA9IHkgLSBkb2NUb3A7XG4gICAgaWYgKHlPZmZzZXQgPCAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBpZiAoeU9mZnNldCA+IGRvY0hlaWdodClcbiAgICAgICAgcmV0dXJuIHZpZXcuc3RhdGUuZG9jLmxlbmd0aDtcbiAgICAvLyBTY2FuIGZvciBhIHRleHQgYmxvY2sgbmVhciB0aGUgcXVlcmllZCB5IHBvc2l0aW9uXG4gICAgZm9yIChsZXQgaGFsZkxpbmUgPSB2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUudGV4dEhlaWdodCAvIDIsIGJvdW5jZWQgPSBmYWxzZTs7KSB7XG4gICAgICAgIGJsb2NrID0gdmlldy5lbGVtZW50QXRIZWlnaHQoeU9mZnNldCk7XG4gICAgICAgIGlmIChibG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIC8vIE1vdmUgdGhlIHkgcG9zaXRpb24gb3V0IG9mIHRoaXMgYmxvY2tcbiAgICAgICAgICAgIHlPZmZzZXQgPSBiaWFzID4gMCA/IGJsb2NrLmJvdHRvbSArIGhhbGZMaW5lIDogYmxvY2sudG9wIC0gaGFsZkxpbmU7XG4gICAgICAgICAgICBpZiAoeU9mZnNldCA+PSAwICYmIHlPZmZzZXQgPD0gZG9jSGVpZ2h0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRvY3VtZW50IGNvbnNpc3RzIGVudGlyZWx5IG9mIHJlcGxhY2VkIHdpZGdldHMsIHdlXG4gICAgICAgICAgICAvLyB3b24ndCBmaW5kIGEgdGV4dCBibG9jaywgc28gcmV0dXJuIDBcbiAgICAgICAgICAgIGlmIChib3VuY2VkKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVjaXNlID8gbnVsbCA6IDA7XG4gICAgICAgICAgICBib3VuY2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJpYXMgPSAtYmlhcztcbiAgICAgICAgfVxuICAgIH1cbiAgICB5ID0gZG9jVG9wICsgeU9mZnNldDtcbiAgICBsZXQgbGluZVN0YXJ0ID0gYmxvY2suZnJvbTtcbiAgICAvLyBJZiB0aGlzIGlzIG91dHNpZGUgb2YgdGhlIHJlbmRlcmVkIHZpZXdwb3J0LCB3ZSBjYW4ndCBkZXRlcm1pbmUgYSBwb3NpdGlvblxuICAgIGlmIChsaW5lU3RhcnQgPCB2aWV3LnZpZXdwb3J0LmZyb20pXG4gICAgICAgIHJldHVybiB2aWV3LnZpZXdwb3J0LmZyb20gPT0gMCA/IDAgOiBwcmVjaXNlID8gbnVsbCA6IHBvc0F0Q29vcmRzSW1wcmVjaXNlKHZpZXcsIGNvbnRlbnQsIGJsb2NrLCB4LCB5KTtcbiAgICBpZiAobGluZVN0YXJ0ID4gdmlldy52aWV3cG9ydC50bylcbiAgICAgICAgcmV0dXJuIHZpZXcudmlld3BvcnQudG8gPT0gdmlldy5zdGF0ZS5kb2MubGVuZ3RoID8gdmlldy5zdGF0ZS5kb2MubGVuZ3RoIDpcbiAgICAgICAgICAgIHByZWNpc2UgPyBudWxsIDogcG9zQXRDb29yZHNJbXByZWNpc2UodmlldywgY29udGVudCwgYmxvY2ssIHgsIHkpO1xuICAgIC8vIFByZWZlciBTaGFkb3dSb290T3JEb2N1bWVudC5lbGVtZW50RnJvbVBvaW50IGlmIHByZXNlbnQsIGZhbGwgYmFjayB0byBkb2N1bWVudCBpZiBub3RcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcbiAgICBsZXQgcm9vdCA9IHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50ID8gdmlldy5yb290IDogZG9jO1xuICAgIGxldCBlbGVtZW50ID0gcm9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIGlmIChlbGVtZW50ICYmICF2aWV3LmNvbnRlbnRET00uY29udGFpbnMoZWxlbWVudCkpXG4gICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIHVuZXhwZWN0ZWQsIGNsaXAgeCBhdCB0aGUgc2lkZXMgb2YgdGhlIGNvbnRlbnQgYXJlYSBhbmQgdHJ5IGFnYWluXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHggPSBNYXRoLm1heChjb250ZW50LmxlZnQgKyAxLCBNYXRoLm1pbihjb250ZW50LnJpZ2h0IC0gMSwgeCkpO1xuICAgICAgICBlbGVtZW50ID0gcm9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgICBpZiAoZWxlbWVudCAmJiAhdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGVsZW1lbnQpKVxuICAgICAgICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgfVxuICAgIC8vIFRoZXJlJ3MgdmlzaWJsZSBlZGl0b3IgY29udGVudCB1bmRlciB0aGUgcG9pbnQsIHNvIHdlIGNhbiB0cnlcbiAgICAvLyB1c2luZyBjYXJldChQb3NpdGlvbnxSYW5nZSlGcm9tUG9pbnQgYXMgYSBzaG9ydGN1dFxuICAgIGxldCBub2RlLCBvZmZzZXQgPSAtMTtcbiAgICBpZiAoZWxlbWVudCAmJiAoKF9hID0gdmlldy5kb2NWaWV3Lm5lYXJlc3QoZWxlbWVudCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0VkaXRhYmxlKSAhPSBmYWxzZSkge1xuICAgICAgICBpZiAoZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgIGlmIChwb3MpXG4gICAgICAgICAgICAgICAgKHsgb2Zmc2V0Tm9kZTogbm9kZSwgb2Zmc2V0IH0gPSBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgICh7IHN0YXJ0Q29udGFpbmVyOiBub2RlLCBzdGFydE9mZnNldDogb2Zmc2V0IH0gPSByYW5nZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF2aWV3LmNvbnRlbnRET00uY29udGFpbnMobm9kZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgYnJvd3Nlci5zYWZhcmkgJiYgaXNTdXNwaWNpb3VzU2FmYXJpQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSB8fFxuICAgICAgICAgICAgICAgICAgICBicm93c2VyLmNocm9tZSAmJiBpc1N1c3BpY2lvdXNDaHJvbWVDYXJldFJlc3VsdChub2RlLCBvZmZzZXQsIHgpKVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENocm9tZSB3aWxsIHJldHVybiBvZmZzZXRzIGludG8gPGlucHV0PiBlbGVtZW50cyB3aXRob3V0IGNoaWxkXG4gICAgICAgIC8vIG5vZGVzLCB3aGljaCB3aWxsIGxlYWQgdG8gYSBudWxsIGRlcmVmIGJlbG93LCBzbyBjbGlwIHRoZVxuICAgICAgICAvLyBvZmZzZXQgdG8gdGhlIG5vZGUgc2l6ZS5cbiAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgICAgICBvZmZzZXQgPSBNYXRoLm1pbihtYXhPZmZzZXQobm9kZSksIG9mZnNldCk7XG4gICAgfVxuICAgIC8vIE5vIGx1Y2ssIGRvIG91ciBvd24gKHBvdGVudGlhbGx5IGV4cGVuc2l2ZSkgc2VhcmNoXG4gICAgaWYgKCFub2RlIHx8ICF2aWV3LmRvY1ZpZXcuZG9tLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgIGxldCBsaW5lID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIGxpbmVTdGFydCk7XG4gICAgICAgIGlmICghbGluZSlcbiAgICAgICAgICAgIHJldHVybiB5T2Zmc2V0ID4gYmxvY2sudG9wICsgYmxvY2suaGVpZ2h0IC8gMiA/IGJsb2NrLnRvIDogYmxvY2suZnJvbTtcbiAgICAgICAgKHsgbm9kZSwgb2Zmc2V0IH0gPSBkb21Qb3NBdENvb3JkcyhsaW5lLmRvbSwgeCwgeSkpO1xuICAgIH1cbiAgICBsZXQgbmVhcmVzdCA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KG5vZGUpO1xuICAgIGlmICghbmVhcmVzdClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKG5lYXJlc3QuaXNXaWRnZXQgJiYgKChfYiA9IG5lYXJlc3QuZG9tKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iubm9kZVR5cGUpID09IDEpIHtcbiAgICAgICAgbGV0IHJlY3QgPSBuZWFyZXN0LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIGNvb3Jkcy55IDwgcmVjdC50b3AgfHwgY29vcmRzLnkgPD0gcmVjdC5ib3R0b20gJiYgY29vcmRzLnggPD0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMlxuICAgICAgICAgICAgPyBuZWFyZXN0LnBvc0F0U3RhcnQgOiBuZWFyZXN0LnBvc0F0RW5kO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5lYXJlc3QubG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkgKyBuZWFyZXN0LnBvc0F0U3RhcnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcG9zQXRDb29yZHNJbXByZWNpc2UodmlldywgY29udGVudFJlY3QsIGJsb2NrLCB4LCB5KSB7XG4gICAgbGV0IGludG8gPSBNYXRoLnJvdW5kKCh4IC0gY29udGVudFJlY3QubGVmdCkgKiB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCk7XG4gICAgaWYgKHZpZXcubGluZVdyYXBwaW5nICYmIGJsb2NrLmhlaWdodCA+IHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgKiAxLjUpIHtcbiAgICAgICAgbGV0IHRleHRIZWlnaHQgPSB2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUudGV4dEhlaWdodDtcbiAgICAgICAgbGV0IGxpbmUgPSBNYXRoLmZsb29yKCh5IC0gYmxvY2sudG9wIC0gKHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLSB0ZXh0SGVpZ2h0KSAqIDAuNSkgLyB0ZXh0SGVpZ2h0KTtcbiAgICAgICAgaW50byArPSBsaW5lICogdmlldy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVMZW5ndGg7XG4gICAgfVxuICAgIGxldCBjb250ZW50ID0gdmlldy5zdGF0ZS5zbGljZURvYyhibG9jay5mcm9tLCBibG9jay50byk7XG4gICAgcmV0dXJuIGJsb2NrLmZyb20gKyBmaW5kQ29sdW1uKGNvbnRlbnQsIGludG8sIHZpZXcuc3RhdGUudGFiU2l6ZSk7XG59XG4vLyBJbiBjYXNlIG9mIGEgaGlnaCBsaW5lIGhlaWdodCwgU2FmYXJpJ3MgY2FyZXRSYW5nZUZyb21Qb2ludCB0cmVhdHNcbi8vIHRoZSBzcGFjZSBiZXR3ZWVuIGxpbmVzIGFzIGJlbG9uZ2luZyB0byB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlXG4vLyBsaW5lIGJlZm9yZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVjdCBzdWNoIGEgcmVzdWx0IHNvIHRoYXQgaXQgY2FuIGJlXG4vLyBpZ25vcmVkIChpc3N1ZSAjNDAxKS5cbmZ1bmN0aW9uIGlzU3VzcGljaW91c1NhZmFyaUNhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkge1xuICAgIGxldCBsZW47XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMyB8fCBvZmZzZXQgIT0gKGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZzsgbmV4dDsgbmV4dCA9IG5leHQubmV4dFNpYmxpbmcpXG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlICE9IDEgfHwgbmV4dC5ub2RlTmFtZSAhPSBcIkJSXCIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRleHRSYW5nZShub2RlLCBsZW4gLSAxLCBsZW4pLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgPiB4O1xufVxuLy8gQ2hyb21lIHdpbGwgbW92ZSBwb3NpdGlvbnMgYmV0d2VlbiBsaW5lcyB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHQgbGluZVxuZnVuY3Rpb24gaXNTdXNwaWNpb3VzQ2hyb21lQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSB7XG4gICAgaWYgKG9mZnNldCAhPSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTs7KSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEgfHwgcGFyZW50LmZpcnN0Q2hpbGQgIT0gY3VyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocGFyZW50LmNsYXNzTGlzdC5jb250YWlucyhcImNtLWxpbmVcIikpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY3VyID0gcGFyZW50O1xuICAgIH1cbiAgICBsZXQgcmVjdCA9IG5vZGUubm9kZVR5cGUgPT0gMSA/IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgOiB0ZXh0UmFuZ2Uobm9kZSwgMCwgTWF0aC5tYXgobm9kZS5ub2RlVmFsdWUubGVuZ3RoLCAxKSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHggLSByZWN0LmxlZnQgPiA1O1xufVxuZnVuY3Rpb24gYmxvY2tBdCh2aWV3LCBwb3MpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQocG9zKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShsaW5lLnR5cGUpKVxuICAgICAgICBmb3IgKGxldCBsIG9mIGxpbmUudHlwZSkge1xuICAgICAgICAgICAgaWYgKGwudG8gPiBwb3MgfHwgbC50byA9PSBwb3MgJiYgKGwudG8gPT0gbGluZS50byB8fCBsLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGxpbmU7XG59XG5mdW5jdGlvbiBtb3ZlVG9MaW5lQm91bmRhcnkodmlldywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKSB7XG4gICAgbGV0IGxpbmUgPSBibG9ja0F0KHZpZXcsIHN0YXJ0LmhlYWQpO1xuICAgIGxldCBjb29yZHMgPSAhaW5jbHVkZVdyYXAgfHwgbGluZS50eXBlICE9IEJsb2NrVHlwZS5UZXh0IHx8ICEodmlldy5saW5lV3JhcHBpbmcgfHwgbGluZS53aWRnZXRMaW5lQnJlYWtzKSA/IG51bGxcbiAgICAgICAgOiB2aWV3LmNvb3Jkc0F0UG9zKHN0YXJ0LmFzc29jIDwgMCAmJiBzdGFydC5oZWFkID4gbGluZS5mcm9tID8gc3RhcnQuaGVhZCAtIDEgOiBzdGFydC5oZWFkKTtcbiAgICBpZiAoY29vcmRzKSB7XG4gICAgICAgIGxldCBlZGl0b3JSZWN0ID0gdmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCBkaXJlY3Rpb24gPSB2aWV3LnRleHREaXJlY3Rpb25BdChsaW5lLmZyb20pO1xuICAgICAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGZvcndhcmQgPT0gKGRpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSKSA/IGVkaXRvclJlY3QucmlnaHQgLSAxIDogZWRpdG9yUmVjdC5sZWZ0ICsgMSxcbiAgICAgICAgICAgIHk6IChjb29yZHMudG9wICsgY29vcmRzLmJvdHRvbSkgLyAyIH0pO1xuICAgICAgICBpZiAocG9zICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIGZvcndhcmQgPyAtMSA6IDEpO1xuICAgIH1cbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmb3J3YXJkID8gbGluZS50byA6IGxpbmUuZnJvbSwgZm9yd2FyZCA/IC0xIDogMSk7XG59XG5mdW5jdGlvbiBtb3ZlQnlDaGFyKHZpZXcsIHN0YXJ0LCBmb3J3YXJkLCBieSkge1xuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHN0YXJ0LmhlYWQpLCBzcGFucyA9IHZpZXcuYmlkaVNwYW5zKGxpbmUpO1xuICAgIGxldCBkaXJlY3Rpb24gPSB2aWV3LnRleHREaXJlY3Rpb25BdChsaW5lLmZyb20pO1xuICAgIGZvciAobGV0IGN1ciA9IHN0YXJ0LCBjaGVjayA9IG51bGw7Oykge1xuICAgICAgICBsZXQgbmV4dCA9IG1vdmVWaXN1YWxseShsaW5lLCBzcGFucywgZGlyZWN0aW9uLCBjdXIsIGZvcndhcmQpLCBjaGFyID0gbW92ZWRPdmVyO1xuICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgIGlmIChsaW5lLm51bWJlciA9PSAoZm9yd2FyZCA/IHZpZXcuc3RhdGUuZG9jLmxpbmVzIDogMSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgIGNoYXIgPSBcIlxcblwiO1xuICAgICAgICAgICAgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmUobGluZS5udW1iZXIgKyAoZm9yd2FyZCA/IDEgOiAtMSkpO1xuICAgICAgICAgICAgc3BhbnMgPSB2aWV3LmJpZGlTcGFucyhsaW5lKTtcbiAgICAgICAgICAgIG5leHQgPSB2aWV3LnZpc3VhbExpbmVTaWRlKGxpbmUsICFmb3J3YXJkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoZWNrKSB7XG4gICAgICAgICAgICBpZiAoIWJ5KVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgY2hlY2sgPSBieShjaGFyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghY2hlY2soY2hhcikpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH1cbiAgICAgICAgY3VyID0gbmV4dDtcbiAgICB9XG59XG5mdW5jdGlvbiBieUdyb3VwKHZpZXcsIHBvcywgc3RhcnQpIHtcbiAgICBsZXQgY2F0ZWdvcml6ZSA9IHZpZXcuc3RhdGUuY2hhckNhdGVnb3JpemVyKHBvcyk7XG4gICAgbGV0IGNhdCA9IGNhdGVnb3JpemUoc3RhcnQpO1xuICAgIHJldHVybiAobmV4dCkgPT4ge1xuICAgICAgICBsZXQgbmV4dENhdCA9IGNhdGVnb3JpemUobmV4dCk7XG4gICAgICAgIGlmIChjYXQgPT0gQ2hhckNhdGVnb3J5LlNwYWNlKVxuICAgICAgICAgICAgY2F0ID0gbmV4dENhdDtcbiAgICAgICAgcmV0dXJuIGNhdCA9PSBuZXh0Q2F0O1xuICAgIH07XG59XG5mdW5jdGlvbiBtb3ZlVmVydGljYWxseSh2aWV3LCBzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpIHtcbiAgICBsZXQgc3RhcnRQb3MgPSBzdGFydC5oZWFkLCBkaXIgPSBmb3J3YXJkID8gMSA6IC0xO1xuICAgIGlmIChzdGFydFBvcyA9PSAoZm9yd2FyZCA/IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCA6IDApKVxuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihzdGFydFBvcywgc3RhcnQuYXNzb2MpO1xuICAgIGxldCBnb2FsID0gc3RhcnQuZ29hbENvbHVtbiwgc3RhcnRZO1xuICAgIGxldCByZWN0ID0gdmlldy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBzdGFydENvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3Moc3RhcnRQb3MsIHN0YXJ0LmFzc29jIHx8IC0xKSwgZG9jVG9wID0gdmlldy5kb2N1bWVudFRvcDtcbiAgICBpZiAoc3RhcnRDb29yZHMpIHtcbiAgICAgICAgaWYgKGdvYWwgPT0gbnVsbClcbiAgICAgICAgICAgIGdvYWwgPSBzdGFydENvb3Jkcy5sZWZ0IC0gcmVjdC5sZWZ0O1xuICAgICAgICBzdGFydFkgPSBkaXIgPCAwID8gc3RhcnRDb29yZHMudG9wIDogc3RhcnRDb29yZHMuYm90dG9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LnZpZXdTdGF0ZS5saW5lQmxvY2tBdChzdGFydFBvcyk7XG4gICAgICAgIGlmIChnb2FsID09IG51bGwpXG4gICAgICAgICAgICBnb2FsID0gTWF0aC5taW4ocmVjdC5yaWdodCAtIHJlY3QubGVmdCwgdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGggKiAoc3RhcnRQb3MgLSBsaW5lLmZyb20pKTtcbiAgICAgICAgc3RhcnRZID0gKGRpciA8IDAgPyBsaW5lLnRvcCA6IGxpbmUuYm90dG9tKSArIGRvY1RvcDtcbiAgICB9XG4gICAgbGV0IHJlc29sdmVkR29hbCA9IHJlY3QubGVmdCArIGdvYWw7XG4gICAgbGV0IGRpc3QgPSBkaXN0YW5jZSAhPT0gbnVsbCAmJiBkaXN0YW5jZSAhPT0gdm9pZCAwID8gZGlzdGFuY2UgOiAodmlldy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQgPj4gMSk7XG4gICAgZm9yIChsZXQgZXh0cmEgPSAwOzsgZXh0cmEgKz0gMTApIHtcbiAgICAgICAgbGV0IGN1clkgPSBzdGFydFkgKyAoZGlzdCArIGV4dHJhKSAqIGRpcjtcbiAgICAgICAgbGV0IHBvcyA9IHBvc0F0Q29vcmRzKHZpZXcsIHsgeDogcmVzb2x2ZWRHb2FsLCB5OiBjdXJZIH0sIGZhbHNlLCBkaXIpO1xuICAgICAgICBpZiAoY3VyWSA8IHJlY3QudG9wIHx8IGN1clkgPiByZWN0LmJvdHRvbSB8fCAoZGlyIDwgMCA/IHBvcyA8IHN0YXJ0UG9zIDogcG9zID4gc3RhcnRQb3MpKSB7XG4gICAgICAgICAgICBsZXQgY2hhclJlY3QgPSB2aWV3LmRvY1ZpZXcuY29vcmRzRm9yQ2hhcihwb3MpO1xuICAgICAgICAgICAgbGV0IGFzc29jID0gIWNoYXJSZWN0IHx8IGN1clkgPCBjaGFyUmVjdC50b3AgPyAtMSA6IDE7XG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIGFzc29jLCB1bmRlZmluZWQsIGdvYWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2tpcEF0b21pY1JhbmdlcyhhdG9tcywgcG9zLCBiaWFzKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbW92ZWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBzZXQgb2YgYXRvbXMpIHtcbiAgICAgICAgICAgIHNldC5iZXR3ZWVuKHBvcyAtIDEsIHBvcyArIDEsIChmcm9tLCB0bywgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBwb3MgPCB0bykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2lkZSA9IG1vdmVkIHx8IGJpYXMgfHwgKHBvcyAtIGZyb20gPCB0byAtIHBvcyA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNpZGUgPCAwID8gZnJvbSA6IHRvO1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHNpZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb3ZlZClcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxufVxuZnVuY3Rpb24gc2tpcEF0b21zKHZpZXcsIG9sZFBvcywgcG9zKSB7XG4gICAgbGV0IG5ld1BvcyA9IHNraXBBdG9taWNSYW5nZXModmlldy5zdGF0ZS5mYWNldChhdG9taWNSYW5nZXMpLm1hcChmID0+IGYodmlldykpLCBwb3MuZnJvbSwgb2xkUG9zLmhlYWQgPiBwb3MuZnJvbSA/IC0xIDogMSk7XG4gICAgcmV0dXJuIG5ld1BvcyA9PSBwb3MuZnJvbSA/IHBvcyA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV3UG9zLCBuZXdQb3MgPCBwb3MuZnJvbSA/IDEgOiAtMSk7XG59XG5cbmNvbnN0IExpbmVCcmVha1BsYWNlaG9sZGVyID0gXCJcXHVmZmZmXCI7XG5jbGFzcyBET01SZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvaW50cywgc3RhdGUpIHtcbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMubGluZVNlcGFyYXRvciA9IHN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpO1xuICAgIH1cbiAgICBhcHBlbmQodGV4dCkge1xuICAgICAgICB0aGlzLnRleHQgKz0gdGV4dDtcbiAgICB9XG4gICAgbGluZUJyZWFrKCkge1xuICAgICAgICB0aGlzLnRleHQgKz0gTGluZUJyZWFrUGxhY2Vob2xkZXI7XG4gICAgfVxuICAgIHJlYWRSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmICghc3RhcnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHBhcmVudCA9IHN0YXJ0LnBhcmVudE5vZGU7XG4gICAgICAgIGZvciAobGV0IGN1ciA9IHN0YXJ0OzspIHtcbiAgICAgICAgICAgIHRoaXMuZmluZFBvaW50QmVmb3JlKHBhcmVudCwgY3VyKTtcbiAgICAgICAgICAgIGxldCBvbGRMZW4gPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5yZWFkTm9kZShjdXIpO1xuICAgICAgICAgICAgbGV0IG5leHQgPSBjdXIubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSBlbmQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgdmlldyA9IENvbnRlbnRWaWV3LmdldChjdXIpLCBuZXh0VmlldyA9IENvbnRlbnRWaWV3LmdldChuZXh0KTtcbiAgICAgICAgICAgIGlmICh2aWV3ICYmIG5leHRWaWV3ID8gdmlldy5icmVha0FmdGVyIDpcbiAgICAgICAgICAgICAgICAodmlldyA/IHZpZXcuYnJlYWtBZnRlciA6IGlzQmxvY2tFbGVtZW50KGN1cikpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpc0Jsb2NrRWxlbWVudChuZXh0KSAmJiAoY3VyLm5vZGVOYW1lICE9IFwiQlJcIiB8fCBjdXIuY21JZ25vcmUpICYmIHRoaXMudGV4dC5sZW5ndGggPiBvbGRMZW4pKVxuICAgICAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluZFBvaW50QmVmb3JlKHBhcmVudCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlYWRUZXh0Tm9kZShub2RlKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gbm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSlcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoICsgTWF0aC5taW4ocG9pbnQub2Zmc2V0LCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IDAsIHJlID0gdGhpcy5saW5lU2VwYXJhdG9yID8gbnVsbCA6IC9cXHJcXG4/fFxcbi9nOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0QnJlYWsgPSAtMSwgYnJlYWtTaXplID0gMSwgbTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBuZXh0QnJlYWsgPSB0ZXh0LmluZGV4T2YodGhpcy5saW5lU2VwYXJhdG9yLCBvZmYpO1xuICAgICAgICAgICAgICAgIGJyZWFrU2l6ZSA9IHRoaXMubGluZVNlcGFyYXRvci5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtID0gcmUuZXhlYyh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIG5leHRCcmVhayA9IG0uaW5kZXg7XG4gICAgICAgICAgICAgICAgYnJlYWtTaXplID0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcGVuZCh0ZXh0LnNsaWNlKG9mZiwgbmV4dEJyZWFrIDwgMCA/IHRleHQubGVuZ3RoIDogbmV4dEJyZWFrKSk7XG4gICAgICAgICAgICBpZiAobmV4dEJyZWFrIDwgMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRoaXMubGluZUJyZWFrKCk7XG4gICAgICAgICAgICBpZiAoYnJlYWtTaXplID4gMSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSAmJiBwb2ludC5wb3MgPiB0aGlzLnRleHQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQucG9zIC09IGJyZWFrU2l6ZSAtIDE7XG4gICAgICAgICAgICBvZmYgPSBuZXh0QnJlYWsgKyBicmVha1NpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5jbUlnbm9yZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQobm9kZSk7XG4gICAgICAgIGxldCBmcm9tVmlldyA9IHZpZXcgJiYgdmlldy5vdmVycmlkZURPTVRleHQ7XG4gICAgICAgIGlmIChmcm9tVmlldyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRQb2ludEluc2lkZShub2RlLCBmcm9tVmlldy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZyb21WaWV3Lml0ZXIoKTsgIWkubmV4dCgpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgaWYgKGkubGluZUJyZWFrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVCcmVhaygpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQoaS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRUZXh0Tm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVOYW1lID09IFwiQlJcIikge1xuICAgICAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFJhbmdlKG5vZGUuZmlyc3RDaGlsZCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZFBvaW50QmVmb3JlKG5vZGUsIG5leHQpIHtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlICYmIG5vZGUuY2hpbGROb2Rlc1twb2ludC5vZmZzZXRdID09IG5leHQpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgZmluZFBvaW50SW5zaWRlKG5vZGUsIGxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0aGlzLnBvaW50cylcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMgPyBwb2ludC5ub2RlID09IG5vZGUgOiBub2RlLmNvbnRhaW5zKHBvaW50Lm5vZGUpKVxuICAgICAgICAgICAgICAgIHBvaW50LnBvcyA9IHRoaXMudGV4dC5sZW5ndGggKyAoaXNBdEVuZChub2RlLCBwb2ludC5ub2RlLCBwb2ludC5vZmZzZXQpID8gbGVuZ3RoIDogMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNBdEVuZChwYXJlbnQsIG5vZGUsIG9mZnNldCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCFub2RlIHx8IG9mZnNldCA8IG1heE9mZnNldChub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpICsgMTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG59XG5jbGFzcyBET01Qb2ludCB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnBvcyA9IC0xO1xuICAgIH1cbn1cblxuY2xhc3MgRE9NQ2hhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBzdGFydCwgZW5kLCB0eXBlT3Zlcikge1xuICAgICAgICB0aGlzLnR5cGVPdmVyID0gdHlwZU92ZXI7XG4gICAgICAgIHRoaXMuYm91bmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb21DaGFuZ2VkID0gc3RhcnQgPiAtMTtcbiAgICAgICAgbGV0IHsgaW1wcmVjaXNlSGVhZDogaUhlYWQsIGltcHJlY2lzZUFuY2hvcjogaUFuY2hvciB9ID0gdmlldy5kb2NWaWV3O1xuICAgICAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSAmJiBzdGFydCA+IC0xKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgY2hhbmdlcyB3aGVuIHRoZSBlZGl0b3IgaXMgcmVhZC1vbmx5XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnQgPiAtMSAmJiAodGhpcy5ib3VuZHMgPSB2aWV3LmRvY1ZpZXcuZG9tQm91bmRzQXJvdW5kKHN0YXJ0LCBlbmQsIDApKSkge1xuICAgICAgICAgICAgbGV0IHNlbFBvaW50cyA9IGlIZWFkIHx8IGlBbmNob3IgPyBbXSA6IHNlbGVjdGlvblBvaW50cyh2aWV3KTtcbiAgICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRE9NUmVhZGVyKHNlbFBvaW50cywgdmlldy5zdGF0ZSk7XG4gICAgICAgICAgICByZWFkZXIucmVhZFJhbmdlKHRoaXMuYm91bmRzLnN0YXJ0RE9NLCB0aGlzLmJvdW5kcy5lbmRET00pO1xuICAgICAgICAgICAgdGhpcy50ZXh0ID0gcmVhZGVyLnRleHQ7XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IHNlbGVjdGlvbkZyb21Qb2ludHMoc2VsUG9pbnRzLCB0aGlzLmJvdW5kcy5mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkb21TZWwgPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICAgICAgbGV0IGhlYWQgPSBpSGVhZCAmJiBpSGVhZC5ub2RlID09IGRvbVNlbC5mb2N1c05vZGUgJiYgaUhlYWQub2Zmc2V0ID09IGRvbVNlbC5mb2N1c09mZnNldCB8fFxuICAgICAgICAgICAgICAgICFjb250YWlucyh2aWV3LmNvbnRlbnRET00sIGRvbVNlbC5mb2N1c05vZGUpXG4gICAgICAgICAgICAgICAgPyB2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWRcbiAgICAgICAgICAgICAgICA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCk7XG4gICAgICAgICAgICBsZXQgYW5jaG9yID0gaUFuY2hvciAmJiBpQW5jaG9yLm5vZGUgPT0gZG9tU2VsLmFuY2hvck5vZGUgJiYgaUFuY2hvci5vZmZzZXQgPT0gZG9tU2VsLmFuY2hvck9mZnNldCB8fFxuICAgICAgICAgICAgICAgICFjb250YWlucyh2aWV3LmNvbnRlbnRET00sIGRvbVNlbC5hbmNob3JOb2RlKVxuICAgICAgICAgICAgICAgID8gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3JcbiAgICAgICAgICAgICAgICA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIGlPUyB3aWxsIHJlZnVzZSB0byBzZWxlY3QgdGhlIGJsb2NrIGdhcHMgd2hlbiBkb2luZ1xuICAgICAgICAgICAgLy8gc2VsZWN0LWFsbC5cbiAgICAgICAgICAgIC8vIENocm9tZSB3aWxsIHB1dCB0aGUgc2VsZWN0aW9uICppbnNpZGUqIHRoZW0sIGNvbmZ1c2luZ1xuICAgICAgICAgICAgLy8gcG9zRnJvbURPTVxuICAgICAgICAgICAgbGV0IHZwID0gdmlldy52aWV3cG9ydDtcbiAgICAgICAgICAgIGlmICgoYnJvd3Nlci5pb3MgfHwgYnJvd3Nlci5jaHJvbWUpICYmIHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiYgaGVhZCAhPSBhbmNob3IgJiZcbiAgICAgICAgICAgICAgICAodnAuZnJvbSA+IDAgfHwgdnAudG8gPCB2aWV3LnN0YXRlLmRvYy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihoZWFkLCBhbmNob3IpLCB0byA9IE1hdGgubWF4KGhlYWQsIGFuY2hvcik7XG4gICAgICAgICAgICAgICAgbGV0IG9mZkZyb20gPSB2cC5mcm9tIC0gZnJvbSwgb2ZmVG8gPSB2cC50byAtIHRvO1xuICAgICAgICAgICAgICAgIGlmICgob2ZmRnJvbSA9PSAwIHx8IG9mZkZyb20gPT0gMSB8fCBmcm9tID09IDApICYmIChvZmZUbyA9PSAwIHx8IG9mZlRvID09IC0xIHx8IHRvID09IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvciA9IHZpZXcuc3RhdGUuZG9jLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5RE9NQ2hhbmdlKHZpZXcsIGRvbUNoYW5nZSkge1xuICAgIGxldCBjaGFuZ2U7XG4gICAgbGV0IHsgbmV3U2VsIH0gPSBkb21DaGFuZ2UsIHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IGxhc3RLZXkgPSB2aWV3LmlucHV0U3RhdGUubGFzdEtleVRpbWUgPiBEYXRlLm5vdygpIC0gMTAwID8gdmlldy5pbnB1dFN0YXRlLmxhc3RLZXlDb2RlIDogLTE7XG4gICAgaWYgKGRvbUNoYW5nZS5ib3VuZHMpIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGRvbUNoYW5nZS5ib3VuZHM7XG4gICAgICAgIGxldCBwcmVmZXJyZWRQb3MgPSBzZWwuZnJvbSwgcHJlZmVycmVkU2lkZSA9IG51bGw7XG4gICAgICAgIC8vIFByZWZlciBhbmNob3JpbmcgdG8gZW5kIHdoZW4gQmFja3NwYWNlIGlzIHByZXNzZWQgKG9yLCBvblxuICAgICAgICAvLyBBbmRyb2lkLCB3aGVuIHNvbWV0aGluZyB3YXMgZGVsZXRlZClcbiAgICAgICAgaWYgKGxhc3RLZXkgPT09IDggfHwgYnJvd3Nlci5hbmRyb2lkICYmIGRvbUNoYW5nZS50ZXh0Lmxlbmd0aCA8IHRvIC0gZnJvbSkge1xuICAgICAgICAgICAgcHJlZmVycmVkUG9zID0gc2VsLnRvO1xuICAgICAgICAgICAgcHJlZmVycmVkU2lkZSA9IFwiZW5kXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpZmYgPSBmaW5kRGlmZih2aWV3LnN0YXRlLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0bywgTGluZUJyZWFrUGxhY2Vob2xkZXIpLCBkb21DaGFuZ2UudGV4dCwgcHJlZmVycmVkUG9zIC0gZnJvbSwgcHJlZmVycmVkU2lkZSk7XG4gICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgaW5zZXJ0cyB0d28gbmV3bGluZXMgd2hlbiBwcmVzc2luZyBzaGlmdC1lbnRlciBhdCB0aGVcbiAgICAgICAgICAgIC8vIGVuZCBvZiBhIGxpbmUuIERvbUNoYW5nZSBkcm9wcyBvbmUgb2YgdGhvc2UuXG4gICAgICAgICAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgbGFzdEtleSA9PSAxMyAmJlxuICAgICAgICAgICAgICAgIGRpZmYudG9CID09IGRpZmYuZnJvbSArIDIgJiYgZG9tQ2hhbmdlLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikgPT0gTGluZUJyZWFrUGxhY2Vob2xkZXIgKyBMaW5lQnJlYWtQbGFjZWhvbGRlcilcbiAgICAgICAgICAgICAgICBkaWZmLnRvQi0tO1xuICAgICAgICAgICAgY2hhbmdlID0geyBmcm9tOiBmcm9tICsgZGlmZi5mcm9tLCB0bzogZnJvbSArIGRpZmYudG9BLFxuICAgICAgICAgICAgICAgIGluc2VydDogVGV4dC5vZihkb21DaGFuZ2UudGV4dC5zbGljZShkaWZmLmZyb20sIGRpZmYudG9CKS5zcGxpdChMaW5lQnJlYWtQbGFjZWhvbGRlcikpIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U2VsICYmICghdmlldy5oYXNGb2N1cyAmJiB2aWV3LnN0YXRlLmZhY2V0KGVkaXRhYmxlKSB8fCBuZXdTZWwubWFpbi5lcShzZWwpKSkge1xuICAgICAgICBuZXdTZWwgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIWNoYW5nZSAmJiAhbmV3U2VsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFjaGFuZ2UgJiYgZG9tQ2hhbmdlLnR5cGVPdmVyICYmICFzZWwuZW1wdHkgJiYgbmV3U2VsICYmIG5ld1NlbC5tYWluLmVtcHR5KSB7XG4gICAgICAgIC8vIEhldXJpc3RpYyB0byBub3RpY2UgdHlwaW5nIG92ZXIgYSBzZWxlY3RlZCBjaGFyYWN0ZXJcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiB2aWV3LnN0YXRlLmRvYy5zbGljZShzZWwuZnJvbSwgc2VsLnRvKSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICgoYnJvd3Nlci5tYWMgfHwgYnJvd3Nlci5hbmRyb2lkKSAmJiBjaGFuZ2UgJiYgY2hhbmdlLmZyb20gPT0gY2hhbmdlLnRvICYmIGNoYW5nZS5mcm9tID09IHNlbC5oZWFkIC0gMSAmJlxuICAgICAgICAvXlxcLiA/JC8udGVzdChjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkpICYmIHZpZXcuY29udGVudERPTS5nZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiKSA9PSBcIm9mZlwiKSB7XG4gICAgICAgIC8vIERldGVjdCBpbnNlcnQtcGVyaW9kLW9uLWRvdWJsZS1zcGFjZSBNYWMgYW5kIEFuZHJvaWQgYmVoYXZpb3IsXG4gICAgICAgIC8vIGFuZCB0cmFuc2Zvcm0gaXQgaW50byBhIHJlZ3VsYXIgc3BhY2UgaW5zZXJ0LlxuICAgICAgICBpZiAobmV3U2VsICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDIpXG4gICAgICAgICAgICBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5ld1NlbC5tYWluLmFuY2hvciAtIDEsIG5ld1NlbC5tYWluLmhlYWQgLSAxKTtcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IGNoYW5nZS50bywgaW5zZXJ0OiBUZXh0Lm9mKFtjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkucmVwbGFjZShcIi5cIiwgXCIgXCIpXSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hhbmdlICYmIGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiZcbiAgICAgICAgKGNoYW5nZS5mcm9tICE9IHNlbC5mcm9tIHx8IGNoYW5nZS50byAhPSBzZWwudG8pICYmXG4gICAgICAgIChzZWwudG8gLSBzZWwuZnJvbSkgLSAoY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20pIDw9IDQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGNoYW5nZSBpcyBpbnNpZGUgdGhlIHNlbGVjdGlvbiBhbmQgY292ZXJzIG1vc3Qgb2YgaXQsXG4gICAgICAgIC8vIGFzc3VtZSBpdCBpcyBhIHNlbGVjdGlvbiByZXBsYWNlICh3aXRoIGlkZW50aWNhbCBjaGFyYWN0ZXJzIGF0XG4gICAgICAgIC8vIHRoZSBzdGFydC9lbmQgbm90IGluY2x1ZGVkIGluIHRoZSBkaWZmKVxuICAgICAgICBjaGFuZ2UgPSB7XG4gICAgICAgICAgICBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50byxcbiAgICAgICAgICAgIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIGNoYW5nZS5mcm9tKS5hcHBlbmQoY2hhbmdlLmluc2VydCkuYXBwZW5kKHZpZXcuc3RhdGUuZG9jLnNsaWNlKGNoYW5nZS50bywgc2VsLnRvKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgY2hhbmdlICYmIGNoYW5nZS5mcm9tID09IGNoYW5nZS50byAmJiBjaGFuZ2UuZnJvbSA9PSBzZWwuaGVhZCAmJlxuICAgICAgICBjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCkgPT0gXCJcXG4gXCIgJiYgdmlldy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgLy8gSW4gQ2hyb21lLCBpZiB5b3UgaW5zZXJ0IGEgc3BhY2UgYXQgdGhlIHN0YXJ0IG9mIGEgd3JhcHBlZFxuICAgICAgICAvLyBsaW5lLCBpdCB3aWxsIGFjdHVhbGx5IGluc2VydCBhIG5ld2xpbmUgYW5kIGEgc3BhY2UsIGNhdXNpbmcgYVxuICAgICAgICAvLyBib2d1cyBuZXcgbGluZSB0byBiZSBjcmVhdGVkIGluIENvZGVNaXJyb3IgKCM5NjgpXG4gICAgICAgIGlmIChuZXdTZWwpXG4gICAgICAgICAgICBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5ld1NlbC5tYWluLmFuY2hvciAtIDEsIG5ld1NlbC5tYWluLmhlYWQgLSAxKTtcbiAgICAgICAgY2hhbmdlID0geyBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50bywgaW5zZXJ0OiBUZXh0Lm9mKFtcIiBcIl0pIH07XG4gICAgfVxuICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5RE9NQ2hhbmdlSW5uZXIodmlldywgY2hhbmdlLCBuZXdTZWwsIGxhc3RLZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXdTZWwgJiYgIW5ld1NlbC5tYWluLmVxKHNlbCkpIHtcbiAgICAgICAgbGV0IHNjcm9sbEludG9WaWV3ID0gZmFsc2UsIHVzZXJFdmVudCA9IFwic2VsZWN0XCI7XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvblRpbWUgPiBEYXRlLm5vdygpIC0gNTApIHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbiA9PSBcInNlbGVjdFwiKVxuICAgICAgICAgICAgICAgIHNjcm9sbEludG9WaWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIHVzZXJFdmVudCA9IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2VsZWN0aW9uT3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBzZWxlY3Rpb246IG5ld1NlbCwgc2Nyb2xsSW50b1ZpZXcsIHVzZXJFdmVudCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlET01DaGFuZ2VJbm5lcih2aWV3LCBjaGFuZ2UsIG5ld1NlbCwgbGFzdEtleSA9IC0xKSB7XG4gICAgaWYgKGJyb3dzZXIuaW9zICYmIHZpZXcuaW5wdXRTdGF0ZS5mbHVzaElPU0tleShjaGFuZ2UpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAvLyBBbmRyb2lkIGJyb3dzZXJzIGRvbid0IGZpcmUgcmVhc29uYWJsZSBrZXkgZXZlbnRzIGZvciBlbnRlcixcbiAgICAvLyBiYWNrc3BhY2UsIG9yIGRlbGV0ZS4gU28gdGhpcyBkZXRlY3RzIGNoYW5nZXMgdGhhdCBsb29rIGxpa2VcbiAgICAvLyB0aGV5J3JlIGNhdXNlZCBieSB0aG9zZSBrZXlzLCBhbmQgcmVpbnRlcnByZXRzIHRoZW0gYXMga2V5XG4gICAgLy8gZXZlbnRzLiAoU29tZSBvZiB0aGVzZSBrZXlzIGFyZSBhbHNvIGhhbmRsZWQgYnkgYmVmb3JlaW5wdXRcbiAgICAvLyBldmVudHMgYW5kIHRoZSBwZW5kaW5nQW5kcm9pZEtleSBtZWNoYW5pc20sIGJ1dCB0aGF0J3Mgbm90XG4gICAgLy8gcmVsaWFibGUgaW4gYWxsIHNpdHVhdGlvbnMuKVxuICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiZcbiAgICAgICAgKChjaGFuZ2UudG8gPT0gc2VsLnRvICYmXG4gICAgICAgICAgICAvLyBHQm9hcmQgd2lsbCBzb21ldGltZXMgcmVtb3ZlIGEgc3BhY2UgaXQganVzdCBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gYWZ0ZXIgYSBjb21wbGV0aW9uIHdoZW4geW91IHByZXNzIGVudGVyXG4gICAgICAgICAgICAoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gfHwgY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gLSAxICYmIHZpZXcuc3RhdGUuc2xpY2VEb2MoY2hhbmdlLmZyb20sIHNlbC5mcm9tKSA9PSBcIiBcIikgJiZcbiAgICAgICAgICAgIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDEgJiYgY2hhbmdlLmluc2VydC5saW5lcyA9PSAyICYmXG4gICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiRW50ZXJcIiwgMTMpKSB8fFxuICAgICAgICAgICAgKChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAtIDEgJiYgY2hhbmdlLnRvID09IHNlbC50byAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAwIHx8XG4gICAgICAgICAgICAgICAgbGFzdEtleSA9PSA4ICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoIDwgY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20gJiYgY2hhbmdlLnRvID4gc2VsLmhlYWQpICYmXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBcIkJhY2tzcGFjZVwiLCA4KSkgfHxcbiAgICAgICAgICAgIChjaGFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICsgMSAmJiBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBcIkRlbGV0ZVwiLCA0NikpKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IHRleHQgPSBjaGFuZ2UuaW5zZXJ0LnRvU3RyaW5nKCk7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMClcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZysrO1xuICAgIGxldCBkZWZhdWx0VHI7XG4gICAgbGV0IGRlZmF1bHRJbnNlcnQgPSAoKSA9PiBkZWZhdWx0VHIgfHwgKGRlZmF1bHRUciA9IGFwcGx5RGVmYXVsdEluc2VydCh2aWV3LCBjaGFuZ2UsIG5ld1NlbCkpO1xuICAgIGlmICghdmlldy5zdGF0ZS5mYWNldChpbnB1dEhhbmRsZXIpLnNvbWUoaCA9PiBoKHZpZXcsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8sIHRleHQsIGRlZmF1bHRJbnNlcnQpKSlcbiAgICAgICAgdmlldy5kaXNwYXRjaChkZWZhdWx0SW5zZXJ0KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXBwbHlEZWZhdWx0SW5zZXJ0KHZpZXcsIGNoYW5nZSwgbmV3U2VsKSB7XG4gICAgbGV0IHRyLCBzdGFydFN0YXRlID0gdmlldy5zdGF0ZSwgc2VsID0gc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBpZiAoY2hhbmdlLmZyb20gPj0gc2VsLmZyb20gJiYgY2hhbmdlLnRvIDw9IHNlbC50byAmJiBjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSA+PSAoc2VsLnRvIC0gc2VsLmZyb20pIC8gMyAmJlxuICAgICAgICAoIW5ld1NlbCB8fCBuZXdTZWwubWFpbi5lbXB0eSAmJiBuZXdTZWwubWFpbi5mcm9tID09IGNoYW5nZS5mcm9tICsgY2hhbmdlLmluc2VydC5sZW5ndGgpICYmXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKSB7XG4gICAgICAgIGxldCBiZWZvcmUgPSBzZWwuZnJvbSA8IGNoYW5nZS5mcm9tID8gc3RhcnRTdGF0ZS5zbGljZURvYyhzZWwuZnJvbSwgY2hhbmdlLmZyb20pIDogXCJcIjtcbiAgICAgICAgbGV0IGFmdGVyID0gc2VsLnRvID4gY2hhbmdlLnRvID8gc3RhcnRTdGF0ZS5zbGljZURvYyhjaGFuZ2UudG8sIHNlbC50bykgOiBcIlwiO1xuICAgICAgICB0ciA9IHN0YXJ0U3RhdGUucmVwbGFjZVNlbGVjdGlvbih2aWV3LnN0YXRlLnRvVGV4dChiZWZvcmUgKyBjaGFuZ2UuaW5zZXJ0LnNsaWNlU3RyaW5nKDAsIHVuZGVmaW5lZCwgdmlldy5zdGF0ZS5saW5lQnJlYWspICsgYWZ0ZXIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBjaGFuZ2VzID0gc3RhcnRTdGF0ZS5jaGFuZ2VzKGNoYW5nZSk7XG4gICAgICAgIGxldCBtYWluU2VsID0gbmV3U2VsICYmIG5ld1NlbC5tYWluLnRvIDw9IGNoYW5nZXMubmV3TGVuZ3RoID8gbmV3U2VsLm1haW4gOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRyeSB0byBhcHBseSBhIGNvbXBvc2l0aW9uIGNoYW5nZSB0byBhbGwgY3Vyc29yc1xuICAgICAgICBpZiAoc3RhcnRTdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aCA+IDEgJiYgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwICYmXG4gICAgICAgICAgICBjaGFuZ2UudG8gPD0gc2VsLnRvICYmIGNoYW5nZS50byA+PSBzZWwudG8gLSAxMCkge1xuICAgICAgICAgICAgbGV0IHJlcGxhY2VkID0gdmlldy5zdGF0ZS5zbGljZURvYyhjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcbiAgICAgICAgICAgIGxldCBjb21wb3NpdGlvblJhbmdlLCBjb21wb3NpdGlvbiA9IG5ld1NlbCAmJiBmaW5kQ29tcG9zaXRpb25Ob2RlKHZpZXcsIG5ld1NlbC5tYWluLmhlYWQpO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRMZW4gPSBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCAtIChjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSk7XG4gICAgICAgICAgICAgICAgY29tcG9zaXRpb25SYW5nZSA9IHsgZnJvbTogY29tcG9zaXRpb24uZnJvbSwgdG86IGNvbXBvc2l0aW9uLnRvIC0gZExlbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcG9zaXRpb25SYW5nZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzZWwuaGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gc2VsLnRvIC0gY2hhbmdlLnRvLCBzaXplID0gc2VsLnRvIC0gc2VsLmZyb207XG4gICAgICAgICAgICB0ciA9IHN0YXJ0U3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgcmFuZ2UudG8gPT0gc2VsLnRvKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzLCByYW5nZTogbWFpblNlbCB8fCByYW5nZS5tYXAoY2hhbmdlcykgfTtcbiAgICAgICAgICAgICAgICBsZXQgdG8gPSByYW5nZS50byAtIG9mZnNldCwgZnJvbSA9IHRvIC0gcmVwbGFjZWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS50byAtIHJhbmdlLmZyb20gIT0gc2l6ZSB8fCB2aWV3LnN0YXRlLnNsaWNlRG9jKGZyb20sIHRvKSAhPSByZXBsYWNlZCB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGVyZSdzIG5vIHdheSB0byBtYWtlIG11bHRpcGxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZXMgaW4gdGhlIHNhbWUgbm9kZSB3b3JrIHdpdGhvdXQgYWJvcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9zaXRpb24sIHNvIGN1cnNvcnMgaW4gdGhlIGNvbXBvc2l0aW9uIHJhbmdlIGFyZVxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVkLlxuICAgICAgICAgICAgICAgICAgICByYW5nZS50byA+PSBjb21wb3NpdGlvblJhbmdlLmZyb20gJiYgcmFuZ2UuZnJvbSA8PSBjb21wb3NpdGlvblJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByYW5nZSB9O1xuICAgICAgICAgICAgICAgIGxldCByYW5nZUNoYW5nZXMgPSBzdGFydFN0YXRlLmNoYW5nZXMoeyBmcm9tLCB0bywgaW5zZXJ0OiBjaGFuZ2UuaW5zZXJ0IH0pLCBzZWxPZmYgPSByYW5nZS50byAtIHNlbC50bztcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzOiByYW5nZUNoYW5nZXMsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiAhbWFpblNlbCA/IHJhbmdlLm1hcChyYW5nZUNoYW5nZXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIEVkaXRvclNlbGVjdGlvbi5yYW5nZShNYXRoLm1heCgwLCBtYWluU2VsLmFuY2hvciArIHNlbE9mZiksIE1hdGgubWF4KDAsIG1haW5TZWwuaGVhZCArIHNlbE9mZikpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHIgPSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IG1haW5TZWwgJiYgc3RhcnRTdGF0ZS5zZWxlY3Rpb24ucmVwbGFjZVJhbmdlKG1haW5TZWwpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB1c2VyRXZlbnQgPSBcImlucHV0LnR5cGVcIjtcbiAgICBpZiAodmlldy5jb21wb3NpbmcgfHxcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSAmJiB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25FbmRlZEF0ID4gRGF0ZS5ub3coKSAtIDUwKSB7XG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdXNlckV2ZW50ICs9IFwiLmNvbXBvc2VcIjtcbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlKSB7XG4gICAgICAgICAgICB1c2VyRXZlbnQgKz0gXCIuc3RhcnRcIjtcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0U3RhdGUudXBkYXRlKHRyLCB7IHVzZXJFdmVudCwgc2Nyb2xsSW50b1ZpZXc6IHRydWUgfSk7XG59XG5mdW5jdGlvbiBmaW5kRGlmZihhLCBiLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpIHtcbiAgICBsZXQgbWluTGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgICBsZXQgZnJvbSA9IDA7XG4gICAgd2hpbGUgKGZyb20gPCBtaW5MZW4gJiYgYS5jaGFyQ29kZUF0KGZyb20pID09IGIuY2hhckNvZGVBdChmcm9tKSlcbiAgICAgICAgZnJvbSsrO1xuICAgIGlmIChmcm9tID09IG1pbkxlbiAmJiBhLmxlbmd0aCA9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHRvQSA9IGEubGVuZ3RoLCB0b0IgPSBiLmxlbmd0aDtcbiAgICB3aGlsZSAodG9BID4gMCAmJiB0b0IgPiAwICYmIGEuY2hhckNvZGVBdCh0b0EgLSAxKSA9PSBiLmNoYXJDb2RlQXQodG9CIC0gMSkpIHtcbiAgICAgICAgdG9BLS07XG4gICAgICAgIHRvQi0tO1xuICAgIH1cbiAgICBpZiAocHJlZmVycmVkU2lkZSA9PSBcImVuZFwiKSB7XG4gICAgICAgIGxldCBhZGp1c3QgPSBNYXRoLm1heCgwLCBmcm9tIC0gTWF0aC5taW4odG9BLCB0b0IpKTtcbiAgICAgICAgcHJlZmVycmVkUG9zIC09IHRvQSArIGFkanVzdCAtIGZyb207XG4gICAgfVxuICAgIGlmICh0b0EgPCBmcm9tICYmIGEubGVuZ3RoIDwgYi5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG1vdmUgPSBwcmVmZXJyZWRQb3MgPD0gZnJvbSAmJiBwcmVmZXJyZWRQb3MgPj0gdG9BID8gZnJvbSAtIHByZWZlcnJlZFBvcyA6IDA7XG4gICAgICAgIGZyb20gLT0gbW92ZTtcbiAgICAgICAgdG9CID0gZnJvbSArICh0b0IgLSB0b0EpO1xuICAgICAgICB0b0EgPSBmcm9tO1xuICAgIH1cbiAgICBlbHNlIGlmICh0b0IgPCBmcm9tKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IGZyb20gJiYgcHJlZmVycmVkUG9zID49IHRvQiA/IGZyb20gLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBmcm9tIC09IG1vdmU7XG4gICAgICAgIHRvQSA9IGZyb20gKyAodG9BIC0gdG9CKTtcbiAgICAgICAgdG9CID0gZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZnJvbSwgdG9BLCB0b0IgfTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvblBvaW50cyh2aWV3KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGlmICh2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB2aWV3LmNvbnRlbnRET00pXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgbGV0IHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH0gPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChhbmNob3JOb2RlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBET01Qb2ludChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpKTtcbiAgICAgICAgaWYgKGZvY3VzTm9kZSAhPSBhbmNob3JOb2RlIHx8IGZvY3VzT2Zmc2V0ICE9IGFuY2hvck9mZnNldClcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBET01Qb2ludChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Gcm9tUG9pbnRzKHBvaW50cywgYmFzZSkge1xuICAgIGlmIChwb2ludHMubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBhbmNob3IgPSBwb2ludHNbMF0ucG9zLCBoZWFkID0gcG9pbnRzLmxlbmd0aCA9PSAyID8gcG9pbnRzWzFdLnBvcyA6IGFuY2hvcjtcbiAgICByZXR1cm4gYW5jaG9yID4gLTEgJiYgaGVhZCA+IC0xID8gRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShhbmNob3IgKyBiYXNlLCBoZWFkICsgYmFzZSkgOiBudWxsO1xufVxuXG5jbGFzcyBJbnB1dFN0YXRlIHtcbiAgICBzZXRTZWxlY3Rpb25PcmlnaW4ob3JpZ2luKSB7XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEtleVRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RUb3VjaFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RGb2N1c1RpbWUgPSAwO1xuICAgICAgICB0aGlzLmxhc3RTY3JvbGxUb3AgPSAwO1xuICAgICAgICB0aGlzLmxhc3RTY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgLy8gT24gaU9TLCBzb21lIGtleXMgbmVlZCB0byBoYXZlIHRoZWlyIGRlZmF1bHQgYmVoYXZpb3IgaGFwcGVuXG4gICAgICAgIC8vIChhZnRlciB3aGljaCB3ZSByZXRyb2FjdGl2ZWx5IGhhbmRsZSB0aGVtIGFuZCByZXNldCB0aGUgRE9NKSB0b1xuICAgICAgICAvLyBhdm9pZCBtZXNzaW5nIHVwIHRoZSB2aXJ0dWFsIGtleWJvYXJkIHN0YXRlLlxuICAgICAgICB0aGlzLnBlbmRpbmdJT1NLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICBXaGVuIGVuYWJsZWQgKD4tMSksIHRhYiBwcmVzc2VzIGFyZSBub3QgZ2l2ZW4gdG8ga2V5IGhhbmRsZXJzLFxuICAgICAgICBsZWF2aW5nIHRoZSBicm93c2VyJ3MgZGVmYXVsdCBiZWhhdmlvci4gSWYgPjAsIHRoZSBtb2RlIGV4cGlyZXNcbiAgICAgICAgYXQgdGhhdCB0aW1lc3RhbXAsIGFuZCBhbnkgb3RoZXIga2V5cHJlc3MgY2xlYXJzIGl0LlxuICAgICAgICBFc2MgZW5hYmxlcyB0ZW1wb3JhcnkgdGFiIGZvY3VzIG1vZGUgZm9yIHR3byBzZWNvbmRzIHdoZW4gbm90XG4gICAgICAgIG90aGVyd2lzZSBoYW5kbGVkLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYkZvY3VzTW9kZSA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29udGV4dE1lbnUgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbEhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvLyAtMSBtZWFucyBub3QgaW4gYSBjb21wb3NpdGlvbi4gT3RoZXJ3aXNlLCB0aGlzIGNvdW50cyB0aGUgbnVtYmVyXG4gICAgICAgIC8vIG9mIGNoYW5nZXMgbWFkZSBkdXJpbmcgdGhlIGNvbXBvc2l0aW9uLiBUaGUgY291bnQgaXMgdXNlZCB0b1xuICAgICAgICAvLyBhdm9pZCB0cmVhdGluZyB0aGUgc3RhcnQgc3RhdGUgb2YgdGhlIGNvbXBvc2l0aW9uLCBiZWZvcmUgYW55XG4gICAgICAgIC8vIGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUsIGFzIHBhcnQgb2YgdGhlIGNvbXBvc2l0aW9uLlxuICAgICAgICB0aGlzLmNvbXBvc2luZyA9IC0xO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciB0aGUgbmV4dCBjaGFuZ2Ugc2hvdWxkIGJlIG1hcmtlZCBhcyBzdGFydGluZyB0aGVcbiAgICAgICAgLy8gY29tcG9zaXRpb24gKG51bGwgbWVhbnMgbm8gY29tcG9zaXRpb24sIHRydWUgbWVhbnMgbmV4dCBpcyB0aGVcbiAgICAgICAgLy8gZmlyc3QsIGZhbHNlIG1lYW5zIGZpcnN0IGhhcyBhbHJlYWR5IGJlZW4gbWFya2VkIGZvciB0aGlzXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uKVxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsO1xuICAgICAgICAvLyBFbmQgdGltZSBvZiB0aGUgcHJldmlvdXMgY29tcG9zaXRpb25cbiAgICAgICAgdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPSAwO1xuICAgICAgICAvLyBVc2VkIGluIGEga2x1ZGdlIHRvIGRldGVjdCB3aGVuIGFuIEVudGVyIGtleXByZXNzIHNob3VsZCBiZVxuICAgICAgICAvLyBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIGNvbXBvc2l0aW9uIG9uIFNhZmFyaSwgd2hpY2ggZmlyZXMgZXZlbnRzXG4gICAgICAgIC8vIGluIHRoZSB3cm9uZyBvcmRlclxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0tleSA9IGZhbHNlO1xuICAgICAgICAvLyBVc2VkIHRvIGNhdGVnb3JpemUgY2hhbmdlcyBhcyBwYXJ0IG9mIGEgY29tcG9zaXRpb24sIGV2ZW4gd2hlblxuICAgICAgICAvLyB0aGUgbXV0YXRpb24gZXZlbnRzIGZpcmUgc2hvcnRseSBhZnRlciB0aGUgY29tcG9zaXRpb25lbmQgZXZlbnRcbiAgICAgICAgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIC8vIFdoZW4gYSBkcmFnIGZyb20gdGhlIGVkaXRvciBpcyBhY3RpdmUsIHRoaXMgcG9pbnRzIGF0IHRoZSByYW5nZVxuICAgICAgICAvLyBiZWluZyBkcmFnZ2VkLlxuICAgICAgICB0aGlzLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVFdmVudCA9IHRoaXMuaGFuZGxlRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ub3RpZmllZEZvY3VzZWQgPSB2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICAvLyBPbiBTYWZhcmkgYWRkaW5nIGFuIGlucHV0IGV2ZW50IGhhbmRsZXIgc29tZWhvdyBwcmV2ZW50cyBhblxuICAgICAgICAvLyBpc3N1ZSB3aGVyZSB0aGUgY29tcG9zaXRpb24gdmFuaXNoZXMgd2hlbiB5b3UgcHJlc3MgZW50ZXIuXG4gICAgICAgIGlmIChicm93c2VyLnNhZmFyaSlcbiAgICAgICAgICAgIHZpZXcuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4gbnVsbCk7XG4gICAgICAgIGlmIChicm93c2VyLmdlY2tvKVxuICAgICAgICAgICAgZmlyZWZveENvcHlDdXRIYWNrKHZpZXcuY29udGVudERPTS5vd25lckRvY3VtZW50KTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudEJlbG9uZ3NUb0VkaXRvcih0aGlzLnZpZXcsIGV2ZW50KSB8fCB0aGlzLmlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJrZXlkb3duXCIgJiYgdGhpcy5rZXlkb3duKGV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMudmlldy51cGRhdGVTdGF0ZSAhPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi8pXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHRoaXMucnVuSGFuZGxlcnMoZXZlbnQudHlwZSwgZXZlbnQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5ydW5IYW5kbGVycyhldmVudC50eXBlLCBldmVudCk7XG4gICAgfVxuICAgIHJ1bkhhbmRsZXJzKHR5cGUsIGV2ZW50KSB7XG4gICAgICAgIGxldCBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbdHlwZV07XG4gICAgICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICAgICAgZm9yIChsZXQgb2JzZXJ2ZXIgb2YgaGFuZGxlcnMub2JzZXJ2ZXJzKVxuICAgICAgICAgICAgICAgIG9ic2VydmVyKHRoaXMudmlldywgZXZlbnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiBoYW5kbGVycy5oYW5kbGVycykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcih0aGlzLnZpZXcsIGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5zdXJlSGFuZGxlcnMocGx1Z2lucykge1xuICAgICAgICBsZXQgaGFuZGxlcnMgPSBjb21wdXRlSGFuZGxlcnMocGx1Z2lucyksIHByZXYgPSB0aGlzLmhhbmRsZXJzLCBkb20gPSB0aGlzLnZpZXcuY29udGVudERPTTtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBoYW5kbGVycylcbiAgICAgICAgICAgIGlmICh0eXBlICE9IFwic2Nyb2xsXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFzc2l2ZSA9ICFoYW5kbGVyc1t0eXBlXS5oYW5kbGVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGV4aXN0cyA9IHByZXZbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0cyAmJiBwYXNzaXZlICE9ICFleGlzdHMuaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuaGFuZGxlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBleGlzdHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5oYW5kbGVFdmVudCwgeyBwYXNzaXZlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCB0eXBlIGluIHByZXYpXG4gICAgICAgICAgICBpZiAodHlwZSAhPSBcInNjcm9sbFwiICYmICFoYW5kbGVyc1t0eXBlXSlcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIH1cbiAgICBrZXlkb3duKGV2ZW50KSB7XG4gICAgICAgIC8vIE11c3QgYWx3YXlzIHJ1biwgZXZlbiBpZiBhIGN1c3RvbSBoYW5kbGVyIGhhbmRsZWQgdGhlIGV2ZW50XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICB0aGlzLmxhc3RLZXlUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gOSAmJiB0aGlzLnRhYkZvY3VzTW9kZSA+IC0xICYmICghdGhpcy50YWJGb2N1c01vZGUgfHwgRGF0ZS5ub3coKSA8PSB0aGlzLnRhYkZvY3VzTW9kZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudGFiRm9jdXNNb2RlID4gMCAmJiBldmVudC5rZXlDb2RlICE9IDI3ICYmIG1vZGlmaWVyQ29kZXMuaW5kZXhPZihldmVudC5rZXlDb2RlKSA8IDApXG4gICAgICAgICAgICB0aGlzLnRhYkZvY3VzTW9kZSA9IC0xO1xuICAgICAgICAvLyBDaHJvbWUgZm9yIEFuZHJvaWQgdXN1YWxseSBkb2Vzbid0IGZpcmUgcHJvcGVyIGtleSBldmVudHMsIGJ1dFxuICAgICAgICAvLyBvY2Nhc2lvbmFsbHkgZG9lcywgdXN1YWxseSBzdXJyb3VuZGVkIGJ5IGEgYnVuY2ggb2YgY29tcGxpY2F0ZWRcbiAgICAgICAgLy8gY29tcG9zaXRpb24gY2hhbmdlcy4gV2hlbiBhbiBlbnRlciBvciBiYWNrc3BhY2Uga2V5IGV2ZW50IGlzXG4gICAgICAgIC8vIHNlZW4sIGhvbGQgb2ZmIG9uIGhhbmRsaW5nIERPTSBldmVudHMgZm9yIGEgYml0LCBhbmQgdGhlblxuICAgICAgICAvLyBkaXNwYXRjaCBpdC5cbiAgICAgICAgaWYgKGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSAmJiAhZXZlbnQuc3ludGhldGljICYmXG4gICAgICAgICAgICAoZXZlbnQua2V5Q29kZSA9PSAxMyB8fCBldmVudC5rZXlDb2RlID09IDgpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuZGVsYXlBbmRyb2lkS2V5KGV2ZW50LmtleSwgZXZlbnQua2V5Q29kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIEVudGVyIG9uIGlPUyBtYWtlcyB0aGVcbiAgICAgICAgLy8gdmlydHVhbCBrZXlib2FyZCBnZXQgc3R1Y2sgaW4gdGhlIHdyb25nIChsb3dlcmNhc2UpXG4gICAgICAgIC8vIHN0YXRlLiBTbyB3ZSBsZXQgaXQgZ28gdGhyb3VnaCwgYW5kIHRoZW4sIGluXG4gICAgICAgIC8vIGFwcGx5RE9NQ2hhbmdlLCBub3RpZnkga2V5IGhhbmRsZXJzIG9mIGl0IGFuZCByZXNldCB0b1xuICAgICAgICAvLyB0aGUgc3RhdGUgdGhleSBwcm9kdWNlLlxuICAgICAgICBsZXQgcGVuZGluZztcbiAgICAgICAgaWYgKGJyb3dzZXIuaW9zICYmICFldmVudC5zeW50aGV0aWMgJiYgIWV2ZW50LmFsdEtleSAmJiAhZXZlbnQubWV0YUtleSAmJlxuICAgICAgICAgICAgKChwZW5kaW5nID0gUGVuZGluZ0tleXMuZmluZChrZXkgPT4ga2V5LmtleUNvZGUgPT0gZXZlbnQua2V5Q29kZSkpICYmICFldmVudC5jdHJsS2V5IHx8XG4gICAgICAgICAgICAgICAgRW1hY3N5UGVuZGluZ0tleXMuaW5kZXhPZihldmVudC5rZXkpID4gLTEgJiYgZXZlbnQuY3RybEtleSAmJiAhZXZlbnQuc2hpZnRLZXkpKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdJT1NLZXkgPSBwZW5kaW5nIHx8IGV2ZW50O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmZsdXNoSU9TS2V5KCksIDI1MCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSAhPSAyMjkpXG4gICAgICAgICAgICB0aGlzLnZpZXcub2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZsdXNoSU9TS2V5KGNoYW5nZSkge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5wZW5kaW5nSU9TS2V5O1xuICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gVGhpcyBsb29rcyBsaWtlIGFuIGF1dG9jb3JyZWN0aW9uIGJlZm9yZSBFbnRlclxuICAgICAgICBpZiAoa2V5LmtleSA9PSBcIkVudGVyXCIgJiYgY2hhbmdlICYmIGNoYW5nZS5mcm9tIDwgY2hhbmdlLnRvICYmIC9eXFxTKyQvLnRlc3QoY2hhbmdlLmluc2VydC50b1N0cmluZygpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hLZXkodGhpcy52aWV3LmNvbnRlbnRET00sIGtleS5rZXksIGtleS5rZXlDb2RlLCBrZXkgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50ID8ga2V5IDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgaWdub3JlRHVyaW5nQ29tcG9zaXRpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCEvXmtleS8udGVzdChldmVudC50eXBlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nID4gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly93d3cuc3R1bS5kZS8yMDE2LzA2LzI0L2hhbmRsaW5nLWltZS1ldmVudHMtaW4tamF2YXNjcmlwdC8uXG4gICAgICAgIC8vIE9uIHNvbWUgaW5wdXQgbWV0aG9kIGVkaXRvcnMgKElNRXMpLCB0aGUgRW50ZXIga2V5IGlzIHVzZWQgdG9cbiAgICAgICAgLy8gY29uZmlybSBjaGFyYWN0ZXIgc2VsZWN0aW9uLiBPbiBTYWZhcmksIHdoZW4gRW50ZXIgaXMgcHJlc3NlZCxcbiAgICAgICAgLy8gY29tcG9zaXRpb25lbmQgYW5kIGtleWRvd24gZXZlbnRzIGFyZSBzb21ldGltZXMgZW1pdHRlZCBpbiB0aGVcbiAgICAgICAgLy8gd3Jvbmcgb3JkZXIuIFRoZSBrZXkgZXZlbnQgc2hvdWxkIHN0aWxsIGJlIGlnbm9yZWQsIGV2ZW4gd2hlblxuICAgICAgICAvLyBpdCBoYXBwZW5zIGFmdGVyIHRoZSBjb21wb3NpdGlvbmVuZCBldmVudC5cbiAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmICFicm93c2VyLmlvcyAmJiB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0tleSAmJiBEYXRlLm5vdygpIC0gdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPCAxMDApIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nS2V5ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0TW91c2VTZWxlY3Rpb24obW91c2VTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG1vdXNlU2VsZWN0aW9uO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIHRoaXMudmlldy5vYnNlcnZlci51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2VkQ29udGVudCAmJiB1cGRhdGUuZG9jQ2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dlZENvbnRlbnQgPSB0aGlzLmRyYWdnZWRDb250ZW50Lm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICB9XG59XG5mdW5jdGlvbiBiaW5kSGFuZGxlcihwbHVnaW4sIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlci5jYWxsKHBsdWdpbiwgZXZlbnQsIHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUhhbmRsZXJzKHBsdWdpbnMpIHtcbiAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmdW5jdGlvbiByZWNvcmQodHlwZSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0W3R5cGVdIHx8IChyZXN1bHRbdHlwZV0gPSB7IG9ic2VydmVyczogW10sIGhhbmRsZXJzOiBbXSB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICAgICAgbGV0IHNwZWMgPSBwbHVnaW4uc3BlYztcbiAgICAgICAgaWYgKHNwZWMgJiYgc3BlYy5kb21FdmVudEhhbmRsZXJzKVxuICAgICAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBzcGVjLmRvbUV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZiA9IHNwZWMuZG9tRXZlbnRIYW5kbGVyc1t0eXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoZilcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkKHR5cGUpLmhhbmRsZXJzLnB1c2goYmluZEhhbmRsZXIocGx1Z2luLnZhbHVlLCBmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChzcGVjICYmIHNwZWMuZG9tRXZlbnRPYnNlcnZlcnMpXG4gICAgICAgICAgICBmb3IgKGxldCB0eXBlIGluIHNwZWMuZG9tRXZlbnRPYnNlcnZlcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZiA9IHNwZWMuZG9tRXZlbnRPYnNlcnZlcnNbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCh0eXBlKS5vYnNlcnZlcnMucHVzaChiaW5kSGFuZGxlcihwbHVnaW4udmFsdWUsIGYpKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgdHlwZSBpbiBoYW5kbGVycylcbiAgICAgICAgcmVjb3JkKHR5cGUpLmhhbmRsZXJzLnB1c2goaGFuZGxlcnNbdHlwZV0pO1xuICAgIGZvciAobGV0IHR5cGUgaW4gb2JzZXJ2ZXJzKVxuICAgICAgICByZWNvcmQodHlwZSkub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXJzW3R5cGVdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgUGVuZGluZ0tleXMgPSBbXG4gICAgeyBrZXk6IFwiQmFja3NwYWNlXCIsIGtleUNvZGU6IDgsIGlucHV0VHlwZTogXCJkZWxldGVDb250ZW50QmFja3dhcmRcIiB9LFxuICAgIHsga2V5OiBcIkVudGVyXCIsIGtleUNvZGU6IDEzLCBpbnB1dFR5cGU6IFwiaW5zZXJ0UGFyYWdyYXBoXCIgfSxcbiAgICB7IGtleTogXCJFbnRlclwiLCBrZXlDb2RlOiAxMywgaW5wdXRUeXBlOiBcImluc2VydExpbmVCcmVha1wiIH0sXG4gICAgeyBrZXk6IFwiRGVsZXRlXCIsIGtleUNvZGU6IDQ2LCBpbnB1dFR5cGU6IFwiZGVsZXRlQ29udGVudEZvcndhcmRcIiB9XG5dO1xuY29uc3QgRW1hY3N5UGVuZGluZ0tleXMgPSBcImR0aGtvXCI7XG4vLyBLZXkgY29kZXMgZm9yIG1vZGlmaWVyIGtleXNcbmNvbnN0IG1vZGlmaWVyQ29kZXMgPSBbMTYsIDE3LCAxOCwgMjAsIDkxLCA5MiwgMjI0LCAyMjVdO1xuY29uc3QgZHJhZ1Njcm9sbE1hcmdpbiA9IDY7XG5mdW5jdGlvbiBkcmFnU2Nyb2xsU3BlZWQoZGlzdCkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBkaXN0KSAqIDAuNyArIDg7XG59XG5mdW5jdGlvbiBkaXN0KGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnMoYS5jbGllbnRYIC0gYi5jbGllbnRYKSwgTWF0aC5hYnMoYS5jbGllbnRZIC0gYi5jbGllbnRZKSk7XG59XG5jbGFzcyBNb3VzZVNlbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhcnRFdmVudCwgc3R5bGUsIG11c3RTZWxlY3QpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5zdGFydEV2ZW50ID0gc3RhcnRFdmVudDtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB0aGlzLm11c3RTZWxlY3QgPSBtdXN0U2VsZWN0O1xuICAgICAgICB0aGlzLnNjcm9sbFNwZWVkID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gLTE7XG4gICAgICAgIHRoaXMubGFzdEV2ZW50ID0gc3RhcnRFdmVudDtcbiAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnRzID0gc2Nyb2xsYWJsZVBhcmVudHModmlldy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5hdG9tcyA9IHZpZXcuc3RhdGUuZmFjZXQoYXRvbWljUmFuZ2VzKS5tYXAoZiA9PiBmKHZpZXcpKTtcbiAgICAgICAgbGV0IGRvYyA9IHZpZXcuY29udGVudERPTS5vd25lckRvY3VtZW50O1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdmUgPSB0aGlzLm1vdmUuYmluZCh0aGlzKSk7XG4gICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwID0gdGhpcy51cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5leHRlbmQgPSBzdGFydEV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICB0aGlzLm11bHRpcGxlID0gdmlldy5zdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5hbGxvd011bHRpcGxlU2VsZWN0aW9ucykgJiYgYWRkc1NlbGVjdGlvblJhbmdlKHZpZXcsIHN0YXJ0RXZlbnQpO1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gaXNJblByaW1hcnlTZWxlY3Rpb24odmlldywgc3RhcnRFdmVudCkgJiYgZ2V0Q2xpY2tUeXBlKHN0YXJ0RXZlbnQpID09IDEgPyBudWxsIDogZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0KGV2ZW50KSB7XG4gICAgICAgIC8vIFdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiB0aGUgc2VsZWN0aW9uLCBpbW1lZGlhdGVseSBhcHBseSB0aGVcbiAgICAgICAgLy8gZWZmZWN0IG9mIHN0YXJ0aW5nIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QoZXZlbnQpO1xuICAgIH1cbiAgICBtb3ZlKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5idXR0b25zID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nIHx8IHRoaXMuZHJhZ2dpbmcgPT0gbnVsbCAmJiBkaXN0KHRoaXMuc3RhcnRFdmVudCwgZXZlbnQpIDwgMTApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50ID0gZXZlbnQpO1xuICAgICAgICBsZXQgc3ggPSAwLCBzeSA9IDA7XG4gICAgICAgIGxldCBsZWZ0ID0gMCwgdG9wID0gMCwgcmlnaHQgPSB0aGlzLnZpZXcud2luLmlubmVyV2lkdGgsIGJvdHRvbSA9IHRoaXMudmlldy53aW4uaW5uZXJIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFBhcmVudHMueClcbiAgICAgICAgICAgICh7IGxlZnQsIHJpZ2h0IH0gPSB0aGlzLnNjcm9sbFBhcmVudHMueC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFBhcmVudHMueSlcbiAgICAgICAgICAgICh7IHRvcCwgYm90dG9tIH0gPSB0aGlzLnNjcm9sbFBhcmVudHMueS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIGxldCBtYXJnaW5zID0gZ2V0U2Nyb2xsTWFyZ2lucyh0aGlzLnZpZXcpO1xuICAgICAgICBpZiAoZXZlbnQuY2xpZW50WCAtIG1hcmdpbnMubGVmdCA8PSBsZWZ0ICsgZHJhZ1Njcm9sbE1hcmdpbilcbiAgICAgICAgICAgIHN4ID0gLWRyYWdTY3JvbGxTcGVlZChsZWZ0IC0gZXZlbnQuY2xpZW50WCk7XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmNsaWVudFggKyBtYXJnaW5zLnJpZ2h0ID49IHJpZ2h0IC0gZHJhZ1Njcm9sbE1hcmdpbilcbiAgICAgICAgICAgIHN4ID0gZHJhZ1Njcm9sbFNwZWVkKGV2ZW50LmNsaWVudFggLSByaWdodCk7XG4gICAgICAgIGlmIChldmVudC5jbGllbnRZIC0gbWFyZ2lucy50b3AgPD0gdG9wICsgZHJhZ1Njcm9sbE1hcmdpbilcbiAgICAgICAgICAgIHN5ID0gLWRyYWdTY3JvbGxTcGVlZCh0b3AgLSBldmVudC5jbGllbnRZKTtcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuY2xpZW50WSArIG1hcmdpbnMuYm90dG9tID49IGJvdHRvbSAtIGRyYWdTY3JvbGxNYXJnaW4pXG4gICAgICAgICAgICBzeSA9IGRyYWdTY3JvbGxTcGVlZChldmVudC5jbGllbnRZIC0gYm90dG9tKTtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxTcGVlZChzeCwgc3kpO1xuICAgIH1cbiAgICB1cChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpO1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxTcGVlZCgwLCAwKTtcbiAgICAgICAgbGV0IGRvYyA9IHRoaXMudmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24gPSB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IG51bGw7XG4gICAgfVxuICAgIHNldFNjcm9sbFNwZWVkKHN4LCBzeSkge1xuICAgICAgICB0aGlzLnNjcm9sbFNwZWVkID0geyB4OiBzeCwgeTogc3kgfTtcbiAgICAgICAgaWYgKHN4IHx8IHN5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxpbmcgPCAwKVxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsaW5nID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5zY3JvbGwoKSwgNTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nyb2xsaW5nID4gLTEpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5zY3JvbGxpbmcpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY3JvbGwoKSB7XG4gICAgICAgIGxldCB7IHgsIHkgfSA9IHRoaXMuc2Nyb2xsU3BlZWQ7XG4gICAgICAgIGlmICh4ICYmIHRoaXMuc2Nyb2xsUGFyZW50cy54KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBhcmVudHMueC5zY3JvbGxMZWZ0ICs9IHg7XG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSAmJiB0aGlzLnNjcm9sbFBhcmVudHMueSkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnRzLnkuc2Nyb2xsVG9wICs9IHk7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCB8fCB5KVxuICAgICAgICAgICAgdGhpcy52aWV3Lndpbi5zY3JvbGxCeSh4LCB5KTtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpO1xuICAgIH1cbiAgICBza2lwQXRvbXMoc2VsKSB7XG4gICAgICAgIGxldCByYW5nZXMgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHNlbC5yYW5nZXNbaV0sIHVwZGF0ZWQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvcyA9IHNraXBBdG9taWNSYW5nZXModGhpcy5hdG9tcywgcmFuZ2UuZnJvbSwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyAhPSByYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gc2tpcEF0b21pY1Jhbmdlcyh0aGlzLmF0b21zLCByYW5nZS5mcm9tLCAtMSk7XG4gICAgICAgICAgICAgICAgbGV0IHRvID0gc2tpcEF0b21pY1Jhbmdlcyh0aGlzLmF0b21zLCByYW5nZS50bywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gIT0gcmFuZ2UuZnJvbSB8fCB0byAhPSByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyYW5nZS5mcm9tID09IHJhbmdlLmFuY2hvciA/IGZyb20gOiB0bywgcmFuZ2UuZnJvbSA9PSByYW5nZS5oZWFkID8gZnJvbSA6IHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlcyA9IHNlbC5yYW5nZXMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZXNbaV0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXMgPyBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc2VsLm1haW5JbmRleCkgOiBzZWw7XG4gICAgfVxuICAgIHNlbGVjdChldmVudCkge1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzLCBzZWxlY3Rpb24gPSB0aGlzLnNraXBBdG9tcyh0aGlzLnN0eWxlLmdldChldmVudCwgdGhpcy5leHRlbmQsIHRoaXMubXVsdGlwbGUpKTtcbiAgICAgICAgaWYgKHRoaXMubXVzdFNlbGVjdCB8fCAhc2VsZWN0aW9uLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uLCB0aGlzLmRyYWdnaW5nID09PSBmYWxzZSkpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnBvaW50ZXJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubXVzdFNlbGVjdCA9IGZhbHNlO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpKSlcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLnN0eWxlLnVwZGF0ZSh1cGRhdGUpKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCksIDIwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRzU2VsZWN0aW9uUmFuZ2UodmlldywgZXZlbnQpIHtcbiAgICBsZXQgZmFjZXQgPSB2aWV3LnN0YXRlLmZhY2V0KGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlKTtcbiAgICByZXR1cm4gZmFjZXQubGVuZ3RoID8gZmFjZXRbMF0oZXZlbnQpIDogYnJvd3Nlci5tYWMgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleTtcbn1cbmZ1bmN0aW9uIGRyYWdNb3Zlc1NlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCBmYWNldCA9IHZpZXcuc3RhdGUuZmFjZXQoZHJhZ01vdmVzU2VsZWN0aW9uJDEpO1xuICAgIHJldHVybiBmYWNldC5sZW5ndGggPyBmYWNldFswXShldmVudCkgOiBicm93c2VyLm1hYyA/ICFldmVudC5hbHRLZXkgOiAhZXZlbnQuY3RybEtleTtcbn1cbmZ1bmN0aW9uIGlzSW5QcmltYXJ5U2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHsgbWFpbiB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKG1haW4uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBPbiBib3VuZGFyeSBjbGlja3MsIGNoZWNrIHdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBpbnNpZGUgdGhlXG4gICAgLy8gc2VsZWN0aW9uJ3MgY2xpZW50IHJlY3RhbmdsZXNcbiAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgaWYgKCFzZWwgfHwgc2VsLnJhbmdlQ291bnQgPT0gMClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IHJlY3RzID0gc2VsLmdldFJhbmdlQXQoMCkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByZWN0ID0gcmVjdHNbaV07XG4gICAgICAgIGlmIChyZWN0LmxlZnQgPD0gZXZlbnQuY2xpZW50WCAmJiByZWN0LnJpZ2h0ID49IGV2ZW50LmNsaWVudFggJiZcbiAgICAgICAgICAgIHJlY3QudG9wIDw9IGV2ZW50LmNsaWVudFkgJiYgcmVjdC5ib3R0b20gPj0gZXZlbnQuY2xpZW50WSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBldmVudEJlbG9uZ3NUb0VkaXRvcih2aWV3LCBldmVudCkge1xuICAgIGlmICghZXZlbnQuYnViYmxlcylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBub2RlID0gZXZlbnQudGFyZ2V0LCBjVmlldzsgbm9kZSAhPSB2aWV3LmNvbnRlbnRET007IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlID09IDExIHx8ICgoY1ZpZXcgPSBDb250ZW50Vmlldy5nZXQobm9kZSkpICYmIGNWaWV3Lmlnbm9yZUV2ZW50KGV2ZW50KSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBoYW5kbGVycyA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3Qgb2JzZXJ2ZXJzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG4vLyBUaGlzIGlzIHZlcnkgY3J1ZGUsIGJ1dCB1bmZvcnR1bmF0ZWx5IGJvdGggdGhlc2UgYnJvd3NlcnMgX3ByZXRlbmRfXG4vLyB0aGF0IHRoZXkgaGF2ZSBhIGNsaXBib2FyZCBBUEnigJRhbGwgdGhlIG9iamVjdHMgYW5kIG1ldGhvZHMgYXJlXG4vLyB0aGVyZSwgdGhleSBqdXN0IGRvbid0IHdvcmssIGFuZCB0aGV5IGFyZSBoYXJkIHRvIHRlc3QuXG5jb25zdCBicm9rZW5DbGlwYm9hcmRBUEkgPSAoYnJvd3Nlci5pZSAmJiBicm93c2VyLmllX3ZlcnNpb24gPCAxNSkgfHxcbiAgICAoYnJvd3Nlci5pb3MgJiYgYnJvd3Nlci53ZWJraXRfdmVyc2lvbiA8IDYwNCk7XG5mdW5jdGlvbiBjYXB0dXJlUGFzdGUodmlldykge1xuICAgIGxldCBwYXJlbnQgPSB2aWV3LmRvbS5wYXJlbnROb2RlO1xuICAgIGlmICghcGFyZW50KVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHRhcmdldCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIikpO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlKCk7XG4gICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnZhbHVlKTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiB0ZXh0RmlsdGVyKHN0YXRlLCBmYWNldCwgdGV4dCkge1xuICAgIGZvciAobGV0IGZpbHRlciBvZiBzdGF0ZS5mYWNldChmYWNldCkpXG4gICAgICAgIHRleHQgPSBmaWx0ZXIodGV4dCwgc3RhdGUpO1xuICAgIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gZG9QYXN0ZSh2aWV3LCBpbnB1dCkge1xuICAgIGlucHV0ID0gdGV4dEZpbHRlcih2aWV3LnN0YXRlLCBjbGlwYm9hcmRJbnB1dEZpbHRlciwgaW5wdXQpO1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjaGFuZ2VzLCBpID0gMSwgdGV4dCA9IHN0YXRlLnRvVGV4dChpbnB1dCk7XG4gICAgbGV0IGJ5TGluZSA9IHRleHQubGluZXMgPT0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGg7XG4gICAgbGV0IGxpbmV3aXNlID0gbGFzdExpbmV3aXNlQ29weSAhPSBudWxsICYmIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMuZXZlcnkociA9PiByLmVtcHR5KSAmJiBsYXN0TGluZXdpc2VDb3B5ID09IHRleHQudG9TdHJpbmcoKTtcbiAgICBpZiAobGluZXdpc2UpIHtcbiAgICAgICAgbGV0IGxhc3RMaW5lID0gLTE7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChyYW5nZS5mcm9tKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPT0gbGFzdExpbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgIGxhc3RMaW5lID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IHN0YXRlLnRvVGV4dCgoYnlMaW5lID8gdGV4dC5saW5lKGkrKykudGV4dCA6IGlucHV0KSArIHN0YXRlLmxpbmVCcmVhayk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IGxpbmUuZnJvbSwgaW5zZXJ0IH0sXG4gICAgICAgICAgICAgICAgcmFuZ2U6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuZnJvbSArIGluc2VydC5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChieUxpbmUpIHtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSB0ZXh0LmxpbmUoaSsrKTtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYW5nZXM6IHsgZnJvbTogcmFuZ2UuZnJvbSwgdG86IHJhbmdlLnRvLCBpbnNlcnQ6IGxpbmUudGV4dCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBsaW5lLmxlbmd0aCkgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUucmVwbGFjZVNlbGVjdGlvbih0ZXh0KTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaChjaGFuZ2VzLCB7XG4gICAgICAgIHVzZXJFdmVudDogXCJpbnB1dC5wYXN0ZVwiLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgIH0pO1xufVxub2JzZXJ2ZXJzLnNjcm9sbCA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsVG9wID0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdCA9IHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQ7XG59O1xuaGFuZGxlcnMua2V5ZG93biA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3RcIik7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcgJiYgdmlldy5pbnB1dFN0YXRlLnRhYkZvY3VzTW9kZSAhPSAwKVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUudGFiRm9jdXNNb2RlID0gRGF0ZS5ub3coKSArIDIwMDA7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbm9ic2VydmVycy50b3VjaHN0YXJ0ID0gKHZpZXcsIGUpID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA9IERhdGUubm93KCk7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdC5wb2ludGVyXCIpO1xufTtcbm9ic2VydmVycy50b3VjaG1vdmUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0LnBvaW50ZXJcIik7XG59O1xuaGFuZGxlcnMubW91c2Vkb3duID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmlldy5vYnNlcnZlci5mbHVzaCgpO1xuICAgIGlmICh2aWV3LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA+IERhdGUubm93KCkgLSAyMDAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIElnbm9yZSB0b3VjaCBpbnRlcmFjdGlvblxuICAgIGxldCBzdHlsZSA9IG51bGw7XG4gICAgZm9yIChsZXQgbWFrZVN0eWxlIG9mIHZpZXcuc3RhdGUuZmFjZXQobW91c2VTZWxlY3Rpb25TdHlsZSkpIHtcbiAgICAgICAgc3R5bGUgPSBtYWtlU3R5bGUodmlldywgZXZlbnQpO1xuICAgICAgICBpZiAoc3R5bGUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFzdHlsZSAmJiBldmVudC5idXR0b24gPT0gMClcbiAgICAgICAgc3R5bGUgPSBiYXNpY01vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50KTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgbGV0IG11c3RGb2N1cyA9ICF2aWV3Lmhhc0ZvY3VzO1xuICAgICAgICB2aWV3LmlucHV0U3RhdGUuc3RhcnRNb3VzZVNlbGVjdGlvbihuZXcgTW91c2VTZWxlY3Rpb24odmlldywgZXZlbnQsIHN0eWxlLCBtdXN0Rm9jdXMpKTtcbiAgICAgICAgaWYgKG11c3RGb2N1cylcbiAgICAgICAgICAgIHZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBmb2N1c1ByZXZlbnRTY3JvbGwodmlldy5jb250ZW50RE9NKTtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aXZlID0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSAmJiAhYWN0aXZlLmNvbnRhaW5zKHZpZXcuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5ibHVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgbGV0IG1vdXNlU2VsID0gdmlldy5pbnB1dFN0YXRlLm1vdXNlU2VsZWN0aW9uO1xuICAgICAgICBpZiAobW91c2VTZWwpIHtcbiAgICAgICAgICAgIG1vdXNlU2VsLnN0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBtb3VzZVNlbC5kcmFnZ2luZyA9PT0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmZ1bmN0aW9uIHJhbmdlRm9yQ2xpY2sodmlldywgcG9zLCBiaWFzLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gMSkgeyAvLyBTaW5nbGUgY2xpY2tcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBiaWFzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PSAyKSB7IC8vIERvdWJsZSBjbGlja1xuICAgICAgICByZXR1cm4gZ3JvdXBBdCh2aWV3LnN0YXRlLCBwb3MsIGJpYXMpO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gVHJpcGxlIGNsaWNrXG4gICAgICAgIGxldCB2aXN1YWwgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgcG9zKSwgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh2aXN1YWwgPyB2aXN1YWwucG9zQXRFbmQgOiBwb3MpO1xuICAgICAgICBsZXQgZnJvbSA9IHZpc3VhbCA/IHZpc3VhbC5wb3NBdFN0YXJ0IDogbGluZS5mcm9tLCB0byA9IHZpc3VhbCA/IHZpc3VhbC5wb3NBdEVuZCA6IGxpbmUudG87XG4gICAgICAgIGlmICh0byA8IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCAmJiB0byA9PSBsaW5lLnRvKVxuICAgICAgICAgICAgdG8rKztcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxubGV0IGluc2lkZSA9ICh4LCB5LCByZWN0KSA9PiB5ID49IHJlY3QudG9wICYmIHkgPD0gcmVjdC5ib3R0b20gJiYgeCA+PSByZWN0LmxlZnQgJiYgeCA8PSByZWN0LnJpZ2h0O1xuLy8gVHJ5IHRvIGRldGVybWluZSwgZm9yIHRoZSBnaXZlbiBjb29yZGluYXRlcywgYXNzb2NpYXRlZCB3aXRoIHRoZVxuLy8gZ2l2ZW4gcG9zaXRpb24sIHdoZXRoZXIgdGhleSBhcmUgcmVsYXRlZCB0byB0aGUgZWxlbWVudCBiZWZvcmUgb3Jcbi8vIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBwb3NpdGlvbi5cbmZ1bmN0aW9uIGZpbmRQb3NpdGlvblNpZGUodmlldywgcG9zLCB4LCB5KSB7XG4gICAgbGV0IGxpbmUgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgcG9zKTtcbiAgICBpZiAoIWxpbmUpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGxldCBvZmYgPSBwb3MgLSBsaW5lLnBvc0F0U3RhcnQ7XG4gICAgLy8gTGluZSBib3VuZGFyaWVzIHBvaW50IGludG8gdGhlIGxpbmVcbiAgICBpZiAob2ZmID09IDApXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChvZmYgPT0gbGluZS5sZW5ndGgpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAvLyBQb3NpdGlvbnMgb24gdG9wIG9mIGFuIGVsZW1lbnQgcG9pbnQgYXQgdGhhdCBlbGVtZW50XG4gICAgbGV0IGJlZm9yZSA9IGxpbmUuY29vcmRzQXQob2ZmLCAtMSk7XG4gICAgaWYgKGJlZm9yZSAmJiBpbnNpZGUoeCwgeSwgYmVmb3JlKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGxldCBhZnRlciA9IGxpbmUuY29vcmRzQXQob2ZmLCAxKTtcbiAgICBpZiAoYWZ0ZXIgJiYgaW5zaWRlKHgsIHksIGFmdGVyKSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhIGxpbmUgd3JhcCBwb2ludC4gUGljayBiZWZvcmUgaWYgdGhlIHBvaW50IGlzXG4gICAgLy8gYWJvdmUgaXRzIGJvdHRvbS5cbiAgICByZXR1cm4gYmVmb3JlICYmIGJlZm9yZS5ib3R0b20gPj0geSA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5UG9zKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcbiAgICByZXR1cm4geyBwb3MsIGJpYXM6IGZpbmRQb3NpdGlvblNpZGUodmlldywgcG9zLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSB9O1xufVxuY29uc3QgQmFkTW91c2VEZXRhaWwgPSBicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMTtcbmxldCBsYXN0TW91c2VEb3duID0gbnVsbCwgbGFzdE1vdXNlRG93bkNvdW50ID0gMCwgbGFzdE1vdXNlRG93blRpbWUgPSAwO1xuZnVuY3Rpb24gZ2V0Q2xpY2tUeXBlKGV2ZW50KSB7XG4gICAgaWYgKCFCYWRNb3VzZURldGFpbClcbiAgICAgICAgcmV0dXJuIGV2ZW50LmRldGFpbDtcbiAgICBsZXQgbGFzdCA9IGxhc3RNb3VzZURvd24sIGxhc3RUaW1lID0gbGFzdE1vdXNlRG93blRpbWU7XG4gICAgbGFzdE1vdXNlRG93biA9IGV2ZW50O1xuICAgIGxhc3RNb3VzZURvd25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gbGFzdE1vdXNlRG93bkNvdW50ID0gIWxhc3QgfHwgKGxhc3RUaW1lID4gRGF0ZS5ub3coKSAtIDQwMCAmJiBNYXRoLmFicyhsYXN0LmNsaWVudFggLSBldmVudC5jbGllbnRYKSA8IDIgJiZcbiAgICAgICAgTWF0aC5hYnMobGFzdC5jbGllbnRZIC0gZXZlbnQuY2xpZW50WSkgPCAyKSA/IChsYXN0TW91c2VEb3duQ291bnQgKyAxKSAlIDMgOiAxO1xufVxuZnVuY3Rpb24gYmFzaWNNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCBzdGFydCA9IHF1ZXJ5UG9zKHZpZXcsIGV2ZW50KSwgdHlwZSA9IGdldENsaWNrVHlwZShldmVudCk7XG4gICAgbGV0IHN0YXJ0U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQucG9zID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHN0YXJ0LnBvcyk7XG4gICAgICAgICAgICAgICAgc3RhcnRTZWwgPSBzdGFydFNlbC5tYXAodXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQoZXZlbnQsIGV4dGVuZCwgbXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBxdWVyeVBvcyh2aWV3LCBldmVudCksIHJlbW92ZWQ7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSByYW5nZUZvckNsaWNrKHZpZXcsIGN1ci5wb3MsIGN1ci5iaWFzLCB0eXBlKTtcbiAgICAgICAgICAgIGlmIChzdGFydC5wb3MgIT0gY3VyLnBvcyAmJiAhZXh0ZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0UmFuZ2UgPSByYW5nZUZvckNsaWNrKHZpZXcsIHN0YXJ0LnBvcywgc3RhcnQuYmlhcywgdHlwZSk7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBNYXRoLm1pbihzdGFydFJhbmdlLmZyb20sIHJhbmdlLmZyb20pLCB0byA9IE1hdGgubWF4KHN0YXJ0UmFuZ2UudG8sIHJhbmdlLnRvKTtcbiAgICAgICAgICAgICAgICByYW5nZSA9IGZyb20gPCByYW5nZS5mcm9tID8gRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGZyb20sIHRvKSA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZSh0bywgZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXh0ZW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbC5yZXBsYWNlUmFuZ2Uoc3RhcnRTZWwubWFpbi5leHRlbmQocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG11bHRpcGxlICYmIHR5cGUgPT0gMSAmJiBzdGFydFNlbC5yYW5nZXMubGVuZ3RoID4gMSAmJiAocmVtb3ZlZCA9IHJlbW92ZVJhbmdlQXJvdW5kKHN0YXJ0U2VsLCBjdXIucG9zKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgICAgICAgICBlbHNlIGlmIChtdWx0aXBsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtyYW5nZV0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVJhbmdlQXJvdW5kKHNlbCwgcG9zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgICBpZiAoZnJvbSA8PSBwb3MgJiYgdG8gPj0gcG9zKVxuICAgICAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsLnJhbmdlcy5zbGljZSgwLCBpKS5jb25jYXQoc2VsLnJhbmdlcy5zbGljZShpICsgMSkpLCBzZWwubWFpbkluZGV4ID09IGkgPyAwIDogc2VsLm1haW5JbmRleCAtIChzZWwubWFpbkluZGV4ID4gaSA/IDEgOiAwKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuaGFuZGxlcnMuZHJhZ3N0YXJ0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgbGV0IHsgc2VsZWN0aW9uOiB7IG1haW46IHJhbmdlIH0gfSA9IHZpZXcuc3RhdGU7XG4gICAgaWYgKGV2ZW50LnRhcmdldC5kcmFnZ2FibGUpIHtcbiAgICAgICAgbGV0IGNWaWV3ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3QoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKGNWaWV3ICYmIGNWaWV3LmlzV2lkZ2V0KSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGNWaWV3LnBvc0F0U3RhcnQsIHRvID0gZnJvbSArIGNWaWV3Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChmcm9tID49IHJhbmdlLnRvIHx8IHRvIDw9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB7IGlucHV0U3RhdGUgfSA9IHZpZXc7XG4gICAgaWYgKGlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24pXG4gICAgICAgIGlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24uZHJhZ2dpbmcgPSB0cnVlO1xuICAgIGlucHV0U3RhdGUuZHJhZ2dlZENvbnRlbnQgPSByYW5nZTtcbiAgICBpZiAoZXZlbnQuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiVGV4dFwiLCB0ZXh0RmlsdGVyKHZpZXcuc3RhdGUsIGNsaXBib2FyZE91dHB1dEZpbHRlciwgdmlldy5zdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50bykpKTtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcImNvcHlNb3ZlXCI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5oYW5kbGVycy5kcmFnZW5kID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmRyYWdnZWRDb250ZW50ID0gbnVsbDtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZnVuY3Rpb24gZHJvcFRleHQodmlldywgZXZlbnQsIHRleHQsIGRpcmVjdCkge1xuICAgIHRleHQgPSB0ZXh0RmlsdGVyKHZpZXcuc3RhdGUsIGNsaXBib2FyZElucHV0RmlsdGVyLCB0ZXh0KTtcbiAgICBpZiAoIXRleHQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZHJvcFBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcbiAgICBsZXQgeyBkcmFnZ2VkQ29udGVudCB9ID0gdmlldy5pbnB1dFN0YXRlO1xuICAgIGxldCBkZWwgPSBkaXJlY3QgJiYgZHJhZ2dlZENvbnRlbnQgJiYgZHJhZ01vdmVzU2VsZWN0aW9uKHZpZXcsIGV2ZW50KVxuICAgICAgICA/IHsgZnJvbTogZHJhZ2dlZENvbnRlbnQuZnJvbSwgdG86IGRyYWdnZWRDb250ZW50LnRvIH0gOiBudWxsO1xuICAgIGxldCBpbnMgPSB7IGZyb206IGRyb3BQb3MsIGluc2VydDogdGV4dCB9O1xuICAgIGxldCBjaGFuZ2VzID0gdmlldy5zdGF0ZS5jaGFuZ2VzKGRlbCA/IFtkZWwsIGluc10gOiBpbnMpO1xuICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgc2VsZWN0aW9uOiB7IGFuY2hvcjogY2hhbmdlcy5tYXBQb3MoZHJvcFBvcywgLTEpLCBoZWFkOiBjaGFuZ2VzLm1hcFBvcyhkcm9wUG9zLCAxKSB9LFxuICAgICAgICB1c2VyRXZlbnQ6IGRlbCA/IFwibW92ZS5kcm9wXCIgOiBcImlucHV0LmRyb3BcIlxuICAgIH0pO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IG51bGw7XG59XG5oYW5kbGVycy5kcm9wID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IGZpbGVzID0gZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgIGlmIChmaWxlcyAmJiBmaWxlcy5sZW5ndGgpIHsgLy8gRm9yIGEgZmlsZSBkcm9wLCByZWFkIHRoZSBmaWxlJ3MgdGV4dC5cbiAgICAgICAgbGV0IHRleHQgPSBBcnJheShmaWxlcy5sZW5ndGgpLCByZWFkID0gMDtcbiAgICAgICAgbGV0IGZpbmlzaEZpbGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoKytyZWFkID09IGZpbGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBkcm9wVGV4dCh2aWV3LCBldmVudCwgdGV4dC5maWx0ZXIocyA9PiBzICE9IG51bGwpLmpvaW4odmlldy5zdGF0ZS5saW5lQnJlYWspLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcjtcbiAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZmluaXNoRmlsZTtcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEvW1xceDAwLVxceDA4XFx4MGUtXFx4MWZdezJ9Ly50ZXN0KHJlYWRlci5yZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICB0ZXh0W2ldID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBmaW5pc2hGaWxlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHRleHQgPSBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBkcm9wVGV4dCh2aWV3LCBldmVudCwgdGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuaGFuZGxlcnMucGFzdGUgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdmlldy5vYnNlcnZlci5mbHVzaCgpO1xuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZG9QYXN0ZSh2aWV3LCBkYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpIHx8IGRhdGEuZ2V0RGF0YShcInRleHQvdXJpLWxpc3RcIikpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVQYXN0ZSh2aWV3KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5mdW5jdGlvbiBjYXB0dXJlQ29weSh2aWV3LCB0ZXh0KSB7XG4gICAgLy8gVGhlIGV4dHJhIHdyYXBwZXIgaXMgc29tZWhvdyBuZWNlc3Nhcnkgb24gSUUvRWRnZSB0byBwcmV2ZW50IHRoZVxuICAgIC8vIGNvbnRlbnQgZnJvbSBiZWluZyBtYW5nbGVkIHdoZW4gaXQgaXMgcHV0IG9udG8gdGhlIGNsaXBib2FyZFxuICAgIGxldCBwYXJlbnQgPSB2aWV3LmRvbS5wYXJlbnROb2RlO1xuICAgIGlmICghcGFyZW50KVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHRhcmdldCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIikpO1xuICAgIHRhcmdldC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICB0YXJnZXQudmFsdWUgPSB0ZXh0O1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIHRhcmdldC5zZWxlY3Rpb25FbmQgPSB0ZXh0Lmxlbmd0aDtcbiAgICB0YXJnZXQuc2VsZWN0aW9uU3RhcnQgPSAwO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0YXJnZXQucmVtb3ZlKCk7XG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB9LCA1MCk7XG59XG5mdW5jdGlvbiBjb3BpZWRSYW5nZShzdGF0ZSkge1xuICAgIGxldCBjb250ZW50ID0gW10sIHJhbmdlcyA9IFtdLCBsaW5ld2lzZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpXG4gICAgICAgIGlmICghcmFuZ2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50bykpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICB9XG4gICAgaWYgKCFjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAvLyBOb3RoaW5nIHNlbGVjdGVkLCBkbyBhIGxpbmUtd2lzZSBjb3B5XG4gICAgICAgIGxldCB1cHRvID0gLTE7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSB9IG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmVBdChmcm9tKTtcbiAgICAgICAgICAgIGlmIChsaW5lLm51bWJlciA+IHVwdG8pIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2gobGluZS50ZXh0KTtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IE1hdGgubWluKHN0YXRlLmRvYy5sZW5ndGgsIGxpbmUudG8gKyAxKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwdG8gPSBsaW5lLm51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBsaW5ld2lzZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB7IHRleHQ6IHRleHRGaWx0ZXIoc3RhdGUsIGNsaXBib2FyZE91dHB1dEZpbHRlciwgY29udGVudC5qb2luKHN0YXRlLmxpbmVCcmVhaykpLCByYW5nZXMsIGxpbmV3aXNlIH07XG59XG5sZXQgbGFzdExpbmV3aXNlQ29weSA9IG51bGw7XG5oYW5kbGVycy5jb3B5ID0gaGFuZGxlcnMuY3V0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgbGV0IHsgdGV4dCwgcmFuZ2VzLCBsaW5ld2lzZSB9ID0gY29waWVkUmFuZ2Uodmlldy5zdGF0ZSk7XG4gICAgaWYgKCF0ZXh0ICYmICFsaW5ld2lzZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxhc3RMaW5ld2lzZUNvcHkgPSBsaW5ld2lzZSA/IHRleHQgOiBudWxsO1xuICAgIGlmIChldmVudC50eXBlID09IFwiY3V0XCIgJiYgIXZpZXcuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgY2hhbmdlczogcmFuZ2VzLFxuICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgICAgICB1c2VyRXZlbnQ6IFwiZGVsZXRlLmN1dFwiXG4gICAgICAgIH0pO1xuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9wbGFpblwiLCB0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYXB0dXJlQ29weSh2aWV3LCB0ZXh0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5jb25zdCBpc0ZvY3VzQ2hhbmdlID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG5mdW5jdGlvbiBmb2N1c0NoYW5nZVRyYW5zYWN0aW9uKHN0YXRlLCBmb2N1cykge1xuICAgIGxldCBlZmZlY3RzID0gW107XG4gICAgZm9yIChsZXQgZ2V0RWZmZWN0IG9mIHN0YXRlLmZhY2V0KGZvY3VzQ2hhbmdlRWZmZWN0KSkge1xuICAgICAgICBsZXQgZWZmZWN0ID0gZ2V0RWZmZWN0KHN0YXRlLCBmb2N1cyk7XG4gICAgICAgIGlmIChlZmZlY3QpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGVmZmVjdHMgPyBzdGF0ZS51cGRhdGUoeyBlZmZlY3RzLCBhbm5vdGF0aW9uczogaXNGb2N1c0NoYW5nZS5vZih0cnVlKSB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiB1cGRhdGVGb3JGb2N1c0NoYW5nZSh2aWV3KSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxldCBmb2N1cyA9IHZpZXcuaGFzRm9jdXM7XG4gICAgICAgIGlmIChmb2N1cyAhPSB2aWV3LmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkKSB7XG4gICAgICAgICAgICBsZXQgdHIgPSBmb2N1c0NoYW5nZVRyYW5zYWN0aW9uKHZpZXcuc3RhdGUsIGZvY3VzKTtcbiAgICAgICAgICAgIGlmICh0cilcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgIH1cbiAgICB9LCAxMCk7XG59XG5vYnNlcnZlcnMuZm9jdXMgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IERhdGUubm93KCk7XG4gICAgLy8gV2hlbiBmb2N1c2luZyByZXNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uLCBtb3ZlIGl0IGJhY2sgdG8gd2hlcmUgaXQgd2FzXG4gICAgaWYgKCF2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgJiYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsVG9wIHx8IHZpZXcuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdCkpIHtcbiAgICAgICAgdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wID0gdmlldy5pbnB1dFN0YXRlLmxhc3RTY3JvbGxUb3A7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQ7XG4gICAgfVxuICAgIHVwZGF0ZUZvckZvY3VzQ2hhbmdlKHZpZXcpO1xufTtcbm9ic2VydmVycy5ibHVyID0gdmlldyA9PiB7XG4gICAgdmlldy5vYnNlcnZlci5jbGVhclNlbGVjdGlvblJhbmdlKCk7XG4gICAgdXBkYXRlRm9yRm9jdXNDaGFuZ2Uodmlldyk7XG59O1xub2JzZXJ2ZXJzLmNvbXBvc2l0aW9uc3RhcnQgPSBvYnNlcnZlcnMuY29tcG9zaXRpb251cGRhdGUgPSB2aWV3ID0+IHtcbiAgICBpZiAodmlldy5vYnNlcnZlci5lZGl0Q29udGV4dClcbiAgICAgICAgcmV0dXJuOyAvLyBDb21wb3NpdGlvbiBoYW5kbGVkIGJ5IGVkaXQgY29udGV4dFxuICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9PSBudWxsKVxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IHRydWU7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKSB7XG4gICAgICAgIC8vIEZJWE1FIHBvc3NpYmx5IHNldCBhIHRpbWVvdXQgdG8gY2xlYXIgaXQgYWdhaW4gb24gQW5kcm9pZFxuICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gMDtcbiAgICB9XG59O1xub2JzZXJ2ZXJzLmNvbXBvc2l0aW9uZW5kID0gdmlldyA9PiB7XG4gICAgaWYgKHZpZXcub2JzZXJ2ZXIuZWRpdENvbnRleHQpXG4gICAgICAgIHJldHVybjsgLy8gQ29tcG9zaXRpb24gaGFuZGxlZCBieSBlZGl0IGNvbnRleHRcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gLTE7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRW5kZWRBdCA9IERhdGUubm93KCk7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0tleSA9IHRydWU7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZSA9IHZpZXcub2JzZXJ2ZXIucGVuZGluZ1JlY29yZHMoKS5sZW5ndGggPiAwO1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcbiAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5hbmRyb2lkKSB7XG4gICAgICAgIC8vIERlbGF5IGZsdXNoaW5nIGZvciBhIGJpdCBvbiBBbmRyb2lkIGJlY2F1c2UgaXQnbGwgb2Z0ZW4gZmlyZSBhXG4gICAgICAgIC8vIGJ1bmNoIG9mIGNvbnRyYWRpY3RvcnkgY2hhbmdlcyBpbiBhIHJvdyBhdCBlbmQgb2YgY29tcG9zaXRvblxuICAgICAgICB2aWV3Lm9ic2VydmVyLmZsdXNoU29vbigpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlKSB7XG4gICAgICAgIC8vIElmIHdlIGZvdW5kIHBlbmRpbmcgcmVjb3Jkcywgc2NoZWR1bGUgYSBmbHVzaC5cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB2aWV3Lm9ic2VydmVyLmZsdXNoKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBtYWtlIHN1cmUgdGhhdCwgaWYgbm8gY2hhbmdlcyBjb21lIGluIHNvb24sIHRoZVxuICAgICAgICAvLyBjb21wb3NpdGlvbiB2aWV3IGlzIGNsZWFyZWQuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwICYmIHZpZXcuZG9jVmlldy5oYXNDb21wb3NpdGlvbilcbiAgICAgICAgICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG59O1xub2JzZXJ2ZXJzLmNvbnRleHRtZW51ID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLmxhc3RDb250ZXh0TWVudSA9IERhdGUubm93KCk7XG59O1xuaGFuZGxlcnMuYmVmb3JlaW5wdXQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIC8vIEluIEVkaXRDb250ZXh0IG1vZGUsIHdlIG11c3QgaGFuZGxlIGluc2VydFJlcGxhY2VtZW50VGV4dCBldmVudHNcbiAgICAvLyBkaXJlY3RseSwgdG8gbWFrZSBzcGVsbCBjaGVja2luZyBjb3JyZWN0aW9ucyB3b3JrXG4gICAgaWYgKGV2ZW50LmlucHV0VHlwZSA9PSBcImluc2VydFJlcGxhY2VtZW50VGV4dFwiICYmIHZpZXcub2JzZXJ2ZXIuZWRpdENvbnRleHQpIHtcbiAgICAgICAgbGV0IHRleHQgPSAoX2EgPSBldmVudC5kYXRhVHJhbnNmZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXREYXRhKFwidGV4dC9wbGFpblwiKSwgcmFuZ2VzID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKCk7XG4gICAgICAgIGlmICh0ZXh0ICYmIHJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByID0gcmFuZ2VzWzBdO1xuICAgICAgICAgICAgbGV0IGZyb20gPSB2aWV3LnBvc0F0RE9NKHIuc3RhcnRDb250YWluZXIsIHIuc3RhcnRPZmZzZXQpLCB0byA9IHZpZXcucG9zQXRET00oci5lbmRDb250YWluZXIsIHIuZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgIGFwcGx5RE9NQ2hhbmdlSW5uZXIodmlldywgeyBmcm9tLCB0bywgaW5zZXJ0OiB2aWV3LnN0YXRlLnRvVGV4dCh0ZXh0KSB9LCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJlY2F1c2UgQ2hyb21lIEFuZHJvaWQgZG9lc24ndCBmaXJlIHVzZWZ1bCBrZXkgZXZlbnRzLCB1c2VcbiAgICAvLyBiZWZvcmVpbnB1dCB0byBkZXRlY3QgYmFja3NwYWNlIChhbmQgcG9zc2libHkgZW50ZXIgYW5kIGRlbGV0ZSxcbiAgICAvLyBidXQgdGhvc2UgdXN1YWxseSBkb24ndCBldmVuIHNlZW0gdG8gZmlyZSBiZWZvcmVpbnB1dCBldmVudHMgYXRcbiAgICAvLyB0aGUgbW9tZW50KSBhbmQgZmFrZSBhIGtleSBldmVudCBmb3IgaXQuXG4gICAgLy9cbiAgICAvLyAocHJldmVudERlZmF1bHQgb24gYmVmb3JlaW5wdXQsIHRob3VnaCBzdXBwb3J0ZWQgaW4gdGhlIHNwZWMsXG4gICAgLy8gc2VlbXMgdG8gZG8gbm90aGluZyBhdCBhbGwgb24gQ2hyb21lKS5cbiAgICBsZXQgcGVuZGluZztcbiAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5hbmRyb2lkICYmIChwZW5kaW5nID0gUGVuZGluZ0tleXMuZmluZChrZXkgPT4ga2V5LmlucHV0VHlwZSA9PSBldmVudC5pbnB1dFR5cGUpKSkge1xuICAgICAgICB2aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShwZW5kaW5nLmtleSwgcGVuZGluZy5rZXlDb2RlKTtcbiAgICAgICAgaWYgKHBlbmRpbmcua2V5ID09IFwiQmFja3NwYWNlXCIgfHwgcGVuZGluZy5rZXkgPT0gXCJEZWxldGVcIikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0Vmlld0hlaWdodCA9ICgoX2IgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHQpIHx8IDA7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gQmFja3NwYWNpbmcgbmVhciB1bmVkaXRhYmxlIG5vZGVzIG9uIENocm9tZSBBbmRyb2lkIHNvbWV0aW1lc1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlcyB0aGUgdmlydHVhbCBrZXlib2FyZC4gVGhpcyB0cmllcyB0byBjcnVkZWx5IGRldGVjdFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgYW5kIHJlZm9jdXMgdG8gZ2V0IGl0IGJhY2suXG4gICAgICAgICAgICAgICAgaWYgKCgoKF9hID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVpZ2h0KSB8fCAwKSA+IHN0YXJ0Vmlld0hlaWdodCArIDEwICYmIHZpZXcuaGFzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJyb3dzZXIuaW9zICYmIGV2ZW50LmlucHV0VHlwZSA9PSBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCIpIHtcbiAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCBET00gY2hhbmdlcyAoYW5kIGJlZm9yZWlucHV0KSBoYXBwZW4gX2JlZm9yZV9cbiAgICAgICAgLy8gdGhlIGtleSBldmVudCBmb3IgY3RybC1kIG9uIGlPUyB3aGVuIHVzaW5nIGFuIGV4dGVybmFsXG4gICAgICAgIC8vIGtleWJvYXJkLlxuICAgICAgICB2aWV3Lm9ic2VydmVyLmZsdXNoU29vbigpO1xuICAgIH1cbiAgICAvLyBTYWZhcmkgd2lsbCBvY2Nhc2lvbmFsbHkgZm9yZ2V0IHRvIGZpcmUgY29tcG9zaXRpb25lbmQgYXQgdGhlIGVuZCBvZiBhIGRlYWQta2V5IGNvbXBvc2l0aW9uXG4gICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmIGV2ZW50LmlucHV0VHlwZSA9PSBcImluc2VydFRleHRcIiAmJiB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDApIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBvYnNlcnZlcnMuY29tcG9zaXRpb25lbmQodmlldywgZXZlbnQpLCAyMCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBhcHBsaWVkRmlyZWZveEhhY2sgPSAvKkBfX1BVUkVfXyovbmV3IFNldDtcbi8vIEluIEZpcmVmb3gsIHdoZW4gY3V0L2NvcHkgaGFuZGxlcnMgYXJlIGFkZGVkIHRvIHRoZSBkb2N1bWVudCwgdGhhdFxuLy8gc29tZWhvdyBhdm9pZHMgYSBidWcgd2hlcmUgdGhvc2UgZXZlbnRzIGFyZW4ndCBmaXJlZCB3aGVuIHRoZVxuLy8gc2VsZWN0aW9uIGlzIGVtcHR5LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvZGV2L2lzc3Vlcy8xMDgyXG4vLyBhbmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTk1OTYxXG5mdW5jdGlvbiBmaXJlZm94Q29weUN1dEhhY2soZG9jKSB7XG4gICAgaWYgKCFhcHBsaWVkRmlyZWZveEhhY2suaGFzKGRvYykpIHtcbiAgICAgICAgYXBwbGllZEZpcmVmb3hIYWNrLmFkZChkb2MpO1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgKCkgPT4geyB9KTtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJjdXRcIiwgKCkgPT4geyB9KTtcbiAgICB9XG59XG5cbmNvbnN0IHdyYXBwaW5nV2hpdGVTcGFjZSA9IFtcInByZS13cmFwXCIsIFwibm9ybWFsXCIsIFwicHJlLWxpbmVcIiwgXCJicmVhay1zcGFjZXNcIl07XG4vLyBVc2VkIHRvIHRyYWNrLCBkdXJpbmcgdXBkYXRlSGVpZ2h0LCBpZiBhbnkgYWN0dWFsIGhlaWdodHMgY2hhbmdlZFxubGV0IGhlaWdodENoYW5nZUZsYWcgPSBmYWxzZTtcbmZ1bmN0aW9uIGNsZWFySGVpZ2h0Q2hhbmdlRmxhZygpIHsgaGVpZ2h0Q2hhbmdlRmxhZyA9IGZhbHNlOyB9XG5jbGFzcyBIZWlnaHRPcmFjbGUge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVXcmFwcGluZykge1xuICAgICAgICB0aGlzLmxpbmVXcmFwcGluZyA9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5kb2MgPSBUZXh0LmVtcHR5O1xuICAgICAgICB0aGlzLmhlaWdodFNhbXBsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gMTQ7IC8vIFRoZSBoZWlnaHQgb2YgYW4gZW50aXJlIGxpbmUgKGxpbmUtaGVpZ2h0KVxuICAgICAgICB0aGlzLmNoYXJXaWR0aCA9IDc7XG4gICAgICAgIHRoaXMudGV4dEhlaWdodCA9IDE0OyAvLyBUaGUgaGVpZ2h0IG9mIHRoZSBhY3R1YWwgZm9udCAoZm9udC1zaXplKVxuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSAzMDtcbiAgICB9XG4gICAgaGVpZ2h0Rm9yR2FwKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IHRoaXMuZG9jLmxpbmVBdCh0bykubnVtYmVyIC0gdGhpcy5kb2MubGluZUF0KGZyb20pLm51bWJlciArIDE7XG4gICAgICAgIGlmICh0aGlzLmxpbmVXcmFwcGluZylcbiAgICAgICAgICAgIGxpbmVzICs9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoKHRvIC0gZnJvbSkgLSAobGluZXMgKiB0aGlzLmxpbmVMZW5ndGggKiAwLjUpKSAvIHRoaXMubGluZUxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0ICogbGluZXM7XG4gICAgfVxuICAgIGhlaWdodEZvckxpbmUobGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICBsZXQgbGluZXMgPSAxICsgTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChsZW5ndGggLSB0aGlzLmxpbmVMZW5ndGgpIC8gKHRoaXMubGluZUxlbmd0aCAtIDUpKSk7XG4gICAgICAgIHJldHVybiBsaW5lcyAqIHRoaXMubGluZUhlaWdodDtcbiAgICB9XG4gICAgc2V0RG9jKGRvYykgeyB0aGlzLmRvYyA9IGRvYzsgcmV0dXJuIHRoaXM7IH1cbiAgICBtdXN0UmVmcmVzaEZvcldyYXBwaW5nKHdoaXRlU3BhY2UpIHtcbiAgICAgICAgcmV0dXJuICh3cmFwcGluZ1doaXRlU3BhY2UuaW5kZXhPZih3aGl0ZVNwYWNlKSA+IC0xKSAhPSB0aGlzLmxpbmVXcmFwcGluZztcbiAgICB9XG4gICAgbXVzdFJlZnJlc2hGb3JIZWlnaHRzKGxpbmVIZWlnaHRzKSB7XG4gICAgICAgIGxldCBuZXdIZWlnaHQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGggPSBsaW5lSGVpZ2h0c1tpXTtcbiAgICAgICAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSkgeyAvLyBSb3VuZCB0byAuMSBwaXhlbHNcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SGVpZ2h0O1xuICAgIH1cbiAgICByZWZyZXNoKHdoaXRlU3BhY2UsIGxpbmVIZWlnaHQsIGNoYXJXaWR0aCwgdGV4dEhlaWdodCwgbGluZUxlbmd0aCwga25vd25IZWlnaHRzKSB7XG4gICAgICAgIGxldCBsaW5lV3JhcHBpbmcgPSB3cmFwcGluZ1doaXRlU3BhY2UuaW5kZXhPZih3aGl0ZVNwYWNlKSA+IC0xO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IE1hdGgucm91bmQobGluZUhlaWdodCkgIT0gTWF0aC5yb3VuZCh0aGlzLmxpbmVIZWlnaHQpIHx8IHRoaXMubGluZVdyYXBwaW5nICE9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5saW5lV3JhcHBpbmcgPSBsaW5lV3JhcHBpbmc7XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gY2hhcldpZHRoO1xuICAgICAgICB0aGlzLnRleHRIZWlnaHQgPSB0ZXh0SGVpZ2h0O1xuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSBsaW5lTGVuZ3RoO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtub3duSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBoID0ga25vd25IZWlnaHRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChoIDwgMClcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbn1cbi8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYnkgYHVwZGF0ZUhlaWdodGAgdG8gbWFrZSBET00gbWVhc3VyZW1lbnRzXG4vLyBhcnJpdmUgYXQgdGhlIHJpZ2h0IG5pZGVzLiBUaGUgYGhlaWdodHNgIGFycmF5IGlzIGEgc2VxdWVuY2Ugb2Zcbi8vIGJsb2NrIGhlaWdodHMsIHN0YXJ0aW5nIGZyb20gcG9zaXRpb24gYGZyb21gLlxuY2xhc3MgTWVhc3VyZWRIZWlnaHRzIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCBoZWlnaHRzKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaGVpZ2h0cyA9IGhlaWdodHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBnZXQgbW9yZSgpIHsgcmV0dXJuIHRoaXMuaW5kZXggPCB0aGlzLmhlaWdodHMubGVuZ3RoOyB9XG59XG4vKipcblJlY29yZCB1c2VkIHRvIHJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIGJsb2NrLWxldmVsIGVsZW1lbnRcbmluIHRoZSBlZGl0b3Igdmlldy5cbiovXG5jbGFzcyBCbG9ja0luZm8ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBlbGVtZW50IGluIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSB0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnQpLlxuICAgICovXG4gICAgdG9wLCBcbiAgICAvKipcbiAgICBJdHMgaGVpZ2h0LlxuICAgICovXG4gICAgaGVpZ2h0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWwgV2VpcmQgcGFja2VkIGZpZWxkIHRoYXQgaG9sZHMgYW4gYXJyYXkgb2YgY2hpbGRyZW5cbiAgICBmb3IgY29tcG9zaXRlIGJsb2NrcywgYSBkZWNvcmF0aW9uIGZvciBibG9jayB3aWRnZXRzLCBhbmQgYVxuICAgIG51bWJlciBpbmRpY2F0aW5nIHRoZSBhbW91bnQgb2Ygd2lkZ2V0LWNyZWF0ZSBsaW5lIGJyZWFrcyBmb3JcbiAgICB0ZXh0IGJsb2Nrcy5cbiAgICAqL1xuICAgIF9jb250ZW50KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBfY29udGVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgZWxlbWVudCB0aGlzIGlzLiBXaGVuIHF1ZXJ5aW5nIGxpbmVzLCB0aGlzIG1heSBiZVxuICAgIGFuIGFycmF5IG9mIGFsbCB0aGUgYmxvY2tzIHRoYXQgbWFrZSB1cCB0aGUgbGluZS5cbiAgICAqL1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuX2NvbnRlbnQgPT0gXCJudW1iZXJcIiA/IEJsb2NrVHlwZS5UZXh0IDpcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodGhpcy5fY29udGVudCkgPyB0aGlzLl9jb250ZW50IDogdGhpcy5fY29udGVudC50eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBlbGVtZW50IGFzIGEgZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIFRoZSBib3R0b20gcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBnZXQgYm90dG9tKCkgeyByZXR1cm4gdGhpcy50b3AgKyB0aGlzLmhlaWdodDsgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSB3aWRnZXQgYmxvY2ssIHRoaXMgd2lsbCByZXR1cm4gdGhlIHdpZGdldFxuICAgIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAqL1xuICAgIGdldCB3aWRnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50IGluc3RhbmNlb2YgUG9pbnREZWNvcmF0aW9uID8gdGhpcy5fY29udGVudC53aWRnZXQgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBJZiB0aGlzIGlzIGEgdGV4dGJsb2NrLCB0aGlzIGhvbGRzIHRoZSBudW1iZXIgb2YgbGluZSBicmVha3NcbiAgICB0aGF0IGFwcGVhciBpbiB3aWRnZXRzIGluc2lkZSB0aGUgYmxvY2suXG4gICAgKi9cbiAgICBnZXQgd2lkZ2V0TGluZUJyZWFrcygpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9jb250ZW50ID09IFwibnVtYmVyXCIgPyB0aGlzLl9jb250ZW50IDogMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBqb2luKG90aGVyKSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gKEFycmF5LmlzQXJyYXkodGhpcy5fY29udGVudCkgPyB0aGlzLl9jb250ZW50IDogW3RoaXNdKVxuICAgICAgICAgICAgLmNvbmNhdChBcnJheS5pc0FycmF5KG90aGVyLl9jb250ZW50KSA/IG90aGVyLl9jb250ZW50IDogW290aGVyXSk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKHRoaXMuZnJvbSwgdGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGgsIHRoaXMudG9wLCB0aGlzLmhlaWdodCArIG90aGVyLmhlaWdodCwgY29udGVudCk7XG4gICAgfVxufVxudmFyIFF1ZXJ5VHlwZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFF1ZXJ5VHlwZSkge1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeVBvc1wiXSA9IDBdID0gXCJCeVBvc1wiO1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeUhlaWdodFwiXSA9IDFdID0gXCJCeUhlaWdodFwiO1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeVBvc05vSGVpZ2h0XCJdID0gMl0gPSBcIkJ5UG9zTm9IZWlnaHRcIjtcbnJldHVybiBRdWVyeVR5cGV9KShRdWVyeVR5cGUgfHwgKFF1ZXJ5VHlwZSA9IHt9KSk7XG5jb25zdCBFcHNpbG9uID0gMWUtMztcbmNsYXNzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCAvLyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY292ZXJlZFxuICAgIGhlaWdodCwgLy8gSGVpZ2h0IG9mIHRoaXMgcGFydCBvZiB0aGUgZG9jdW1lbnRcbiAgICBmbGFncyA9IDIgLyogRmxhZy5PdXRkYXRlZCAqLykge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgZ2V0IG91dGRhdGVkKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pID4gMDsgfVxuICAgIHNldCBvdXRkYXRlZCh2YWx1ZSkgeyB0aGlzLmZsYWdzID0gKHZhbHVlID8gMiAvKiBGbGFnLk91dGRhdGVkICovIDogMCkgfCAodGhpcy5mbGFncyAmIH4yIC8qIEZsYWcuT3V0ZGF0ZWQgKi8pOyB9XG4gICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5oZWlnaHQgLSBoZWlnaHQpID4gRXBzaWxvbilcbiAgICAgICAgICAgICAgICBoZWlnaHRDaGFuZ2VGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJhc2UgY2FzZSBpcyB0byByZXBsYWNlIGEgbGVhZiBub2RlLCB3aGljaCBzaW1wbHkgYnVpbGRzIGEgdHJlZVxuICAgIC8vIGZyb20gdGhlIG5ldyBub2RlcyBhbmQgcmV0dXJucyB0aGF0IChIZWlnaHRNYXBCcmFuY2ggYW5kXG4gICAgLy8gSGVpZ2h0TWFwR2FwIG92ZXJyaWRlIHRoaXMgdG8gYWN0dWFsbHkgdXNlIGZyb20vdG8pXG4gICAgcmVwbGFjZShfZnJvbSwgX3RvLCBub2Rlcykge1xuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICB9XG4gICAgLy8gQWdhaW4sIHRoZXNlIGFyZSBiYXNlIGNhc2VzLCBhbmQgYXJlIG92ZXJyaWRkZW4gZm9yIGJyYW5jaCBhbmQgZ2FwIG5vZGVzLlxuICAgIGRlY29tcG9zZUxlZnQoX3RvLCByZXN1bHQpIHsgcmVzdWx0LnB1c2godGhpcyk7IH1cbiAgICBkZWNvbXBvc2VSaWdodChfZnJvbSwgcmVzdWx0KSB7IHJlc3VsdC5wdXNoKHRoaXMpOyB9XG4gICAgYXBwbHlDaGFuZ2VzKGRlY29yYXRpb25zLCBvbGREb2MsIG9yYWNsZSwgY2hhbmdlcykge1xuICAgICAgICBsZXQgbWUgPSB0aGlzLCBkb2MgPSBvcmFjbGUuZG9jO1xuICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHsgZnJvbUEsIHRvQSwgZnJvbUIsIHRvQiB9ID0gY2hhbmdlc1tpXTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IG1lLmxpbmVBdChmcm9tQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9yYWNsZS5zZXREb2Mob2xkRG9jKSwgMCwgMCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQudG8gPj0gdG9BID8gc3RhcnQgOiBtZS5saW5lQXQodG9BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLCAwLCAwKTtcbiAgICAgICAgICAgIHRvQiArPSBlbmQudG8gLSB0b0E7XG4gICAgICAgICAgICB0b0EgPSBlbmQudG87XG4gICAgICAgICAgICB3aGlsZSAoaSA+IDAgJiYgc3RhcnQuZnJvbSA8PSBjaGFuZ2VzW2kgLSAxXS50b0EpIHtcbiAgICAgICAgICAgICAgICBmcm9tQSA9IGNoYW5nZXNbaSAtIDFdLmZyb21BO1xuICAgICAgICAgICAgICAgIGZyb21CID0gY2hhbmdlc1tpIC0gMV0uZnJvbUI7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQSA8IHN0YXJ0LmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWUubGluZUF0KGZyb21BLCBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCwgb3JhY2xlLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb21CICs9IHN0YXJ0LmZyb20gLSBmcm9tQTtcbiAgICAgICAgICAgIGZyb21BID0gc3RhcnQuZnJvbTtcbiAgICAgICAgICAgIGxldCBub2RlcyA9IE5vZGVCdWlsZGVyLmJ1aWxkKG9yYWNsZS5zZXREb2MoZG9jKSwgZGVjb3JhdGlvbnMsIGZyb21CLCB0b0IpO1xuICAgICAgICAgICAgbWUgPSByZXBsYWNlKG1lLCBtZS5yZXBsYWNlKGZyb21BLCB0b0EsIG5vZGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lLnVwZGF0ZUhlaWdodChvcmFjbGUsIDApO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7IHJldHVybiBuZXcgSGVpZ2h0TWFwVGV4dCgwLCAwKTsgfVxuICAgIC8vIG5vZGVzIHVzZXMgbnVsbCB2YWx1ZXMgdG8gaW5kaWNhdGUgdGhlIHBvc2l0aW9uIG9mIGxpbmUgYnJlYWtzLlxuICAgIC8vIFRoZXJlIGFyZSBuZXZlciBsaW5lIGJyZWFrcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBhcnJheSwgb3JcbiAgICAvLyB0d28gbGluZSBicmVha3MgbmV4dCB0byBlYWNoIG90aGVyLCBhbmQgdGhlIGFycmF5IGlzbid0IGFsbG93ZWRcbiAgICAvLyB0byBiZSBlbXB0eSAoc2FtZSByZXN0cmljdGlvbnMgYXMgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGJ1aWxkZXIpLlxuICAgIHN0YXRpYyBvZihub2Rlcykge1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDEpXG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbMF07XG4gICAgICAgIGxldCBpID0gMCwgaiA9IG5vZGVzLmxlbmd0aCwgYmVmb3JlID0gMCwgYWZ0ZXIgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSA+IGFmdGVyICogMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BsaXQgPSBub2Rlc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5icmVhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZSgtLWksIDEsIHNwbGl0LmxlZnQsIG51bGwsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKC0taSwgMSwgc3BsaXQubGVmdCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBqICs9IDEgKyBzcGxpdC5icmVhaztcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlIC09IHNwbGl0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFmdGVyID4gYmVmb3JlICogMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BsaXQgPSBub2Rlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0LmJyZWFrKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEsIHNwbGl0LmxlZnQsIG51bGwsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEsIHNwbGl0LmxlZnQsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaiArPSAyICsgc3BsaXQuYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyIC09IHNwbGl0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZWZvcmUgPCBhZnRlcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZXNbaSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZXNbLS1qXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBicmsgPSAwO1xuICAgICAgICBpZiAobm9kZXNbaSAtIDFdID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyayA9IDE7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZXNbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJrID0gMTtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhlaWdodE1hcEJyYW5jaChIZWlnaHRNYXAub2Yobm9kZXMuc2xpY2UoMCwgaSkpLCBicmssIEhlaWdodE1hcC5vZihub2Rlcy5zbGljZShqKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2Uob2xkLCB2YWwpIHtcbiAgICBpZiAob2xkID09IHZhbClcbiAgICAgICAgcmV0dXJuIG9sZDtcbiAgICBpZiAob2xkLmNvbnN0cnVjdG9yICE9IHZhbC5jb25zdHJ1Y3RvcilcbiAgICAgICAgaGVpZ2h0Q2hhbmdlRmxhZyA9IHRydWU7XG4gICAgcmV0dXJuIHZhbDtcbn1cbkhlaWdodE1hcC5wcm90b3R5cGUuc2l6ZSA9IDE7XG5jbGFzcyBIZWlnaHRNYXBCbG9jayBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBoZWlnaHQsIGRlY28pIHtcbiAgICAgICAgc3VwZXIobGVuZ3RoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmRlY28gPSBkZWNvO1xuICAgIH1cbiAgICBibG9ja0F0KF9oZWlnaHQsIF9vcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKG9mZnNldCwgdGhpcy5sZW5ndGgsIHRvcCwgdGhpcy5oZWlnaHQsIHRoaXMuZGVjbyB8fCAwKTtcbiAgICB9XG4gICAgbGluZUF0KF92YWx1ZSwgX3R5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tBdCgwLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpIHtcbiAgICAgICAgaWYgKGZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgdG8gPj0gb2Zmc2V0KVxuICAgICAgICAgICAgZih0aGlzLmJsb2NrQXQoMCwgb3JhY2xlLCB0b3AsIG9mZnNldCkpO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBfZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiBgYmxvY2soJHt0aGlzLmxlbmd0aH0pYDsgfVxufVxuY2xhc3MgSGVpZ2h0TWFwVGV4dCBleHRlbmRzIEhlaWdodE1hcEJsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihsZW5ndGgsIGhlaWdodCwgbnVsbCk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gMDsgLy8gQW1vdW50IG9mIGNvbGxhcHNlZCBjb250ZW50IGluIHRoZSBsaW5lXG4gICAgICAgIHRoaXMud2lkZ2V0SGVpZ2h0ID0gMDsgLy8gTWF4aW11bSBpbmxpbmUgd2lkZ2V0IGhlaWdodFxuICAgICAgICB0aGlzLmJyZWFrcyA9IDA7IC8vIE51bWJlciBvZiB3aWRnZXQtaW50cm9kdWNlZCBsaW5lIGJyZWFrcyBvbiB0aGUgbGluZVxuICAgIH1cbiAgICBibG9ja0F0KF9oZWlnaHQsIF9vcmFjbGUsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKG9mZnNldCwgdGhpcy5sZW5ndGgsIHRvcCwgdGhpcy5oZWlnaHQsIHRoaXMuYnJlYWtzKTtcbiAgICB9XG4gICAgcmVwbGFjZShfZnJvbSwgX3RvLCBub2Rlcykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzWzBdO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDEgJiYgKG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0IHx8IG5vZGUgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXAgJiYgKG5vZGUuZmxhZ3MgJiA0IC8qIEZsYWcuU2luZ2xlTGluZSAqLykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmxlbmd0aCAtIG5vZGUubGVuZ3RoKSA8IDEwKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IEhlaWdodE1hcFRleHQobm9kZS5sZW5ndGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2RlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgICAgIG5vZGUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdKTtcbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZClcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KE1hdGgubWF4KHRoaXMud2lkZ2V0SGVpZ2h0LCBvcmFjbGUuaGVpZ2h0Rm9yTGluZSh0aGlzLmxlbmd0aCAtIHRoaXMuY29sbGFwc2VkKSkgK1xuICAgICAgICAgICAgICAgIHRoaXMuYnJlYWtzICogb3JhY2xlLmxpbmVIZWlnaHQpO1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBsaW5lKCR7dGhpcy5sZW5ndGh9JHt0aGlzLmNvbGxhcHNlZCA/IC10aGlzLmNvbGxhcHNlZCA6IFwiXCJ9JHt0aGlzLndpZGdldEhlaWdodCA/IFwiOlwiICsgdGhpcy53aWRnZXRIZWlnaHQgOiBcIlwifSlgO1xuICAgIH1cbn1cbmNsYXNzIEhlaWdodE1hcEdhcCBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7IHN1cGVyKGxlbmd0aCwgMCk7IH1cbiAgICBoZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBmaXJzdExpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChvZmZzZXQpLm51bWJlciwgbGFzdExpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChvZmZzZXQgKyB0aGlzLmxlbmd0aCkubnVtYmVyO1xuICAgICAgICBsZXQgbGluZXMgPSBsYXN0TGluZSAtIGZpcnN0TGluZSArIDE7XG4gICAgICAgIGxldCBwZXJMaW5lLCBwZXJDaGFyID0gMDtcbiAgICAgICAgaWYgKG9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIGxldCB0b3RhbFBlckxpbmUgPSBNYXRoLm1pbih0aGlzLmhlaWdodCwgb3JhY2xlLmxpbmVIZWlnaHQgKiBsaW5lcyk7XG4gICAgICAgICAgICBwZXJMaW5lID0gdG90YWxQZXJMaW5lIC8gbGluZXM7XG4gICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPiBsaW5lcyArIDEpXG4gICAgICAgICAgICAgICAgcGVyQ2hhciA9ICh0aGlzLmhlaWdodCAtIHRvdGFsUGVyTGluZSkgLyAodGhpcy5sZW5ndGggLSBsaW5lcyAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGVyTGluZSA9IHRoaXMuaGVpZ2h0IC8gbGluZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZmlyc3RMaW5lLCBsYXN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9O1xuICAgIH1cbiAgICBibG9ja0F0KGhlaWdodCwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIGxhc3RMaW5lLCBwZXJMaW5lLCBwZXJDaGFyIH0gPSB0aGlzLmhlaWdodE1ldHJpY3Mob3JhY2xlLCBvZmZzZXQpO1xuICAgICAgICBpZiAob3JhY2xlLmxpbmVXcmFwcGluZykge1xuICAgICAgICAgICAgbGV0IGd1ZXNzID0gb2Zmc2V0ICsgKGhlaWdodCA8IG9yYWNsZS5saW5lSGVpZ2h0ID8gMFxuICAgICAgICAgICAgICAgIDogTWF0aC5yb3VuZChNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoaGVpZ2h0IC0gdG9wKSAvIHRoaXMuaGVpZ2h0KSkgKiB0aGlzLmxlbmd0aCkpO1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChndWVzcyksIGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgbGluZS5sZW5ndGggKiBwZXJDaGFyO1xuICAgICAgICAgICAgbGV0IGxpbmVUb3AgPSBNYXRoLm1heCh0b3AsIGhlaWdodCAtIGxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGxpbmUuZnJvbSwgbGluZS5sZW5ndGgsIGxpbmVUb3AsIGxpbmVIZWlnaHQsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsYXN0TGluZSAtIGZpcnN0TGluZSwgTWF0aC5mbG9vcigoaGVpZ2h0IC0gdG9wKSAvIHBlckxpbmUpKSk7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCBsZW5ndGggfSA9IG9yYWNsZS5kb2MubGluZShmaXJzdExpbmUgKyBsaW5lKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGZyb20sIGxlbmd0aCwgdG9wICsgcGVyTGluZSAqIGxpbmUsIHBlckxpbmUsIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBpZiAodHlwZSA9PSBRdWVyeVR5cGUuQnlIZWlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ibG9ja0F0KHZhbHVlLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBvcmFjbGUuZG9jLmxpbmVBdCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCB0byAtIGZyb20sIDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdCh2YWx1ZSksIGxpbmVIZWlnaHQgPSBwZXJMaW5lICsgbGluZS5sZW5ndGggKiBwZXJDaGFyO1xuICAgICAgICBsZXQgbGluZXNBYm92ZSA9IGxpbmUubnVtYmVyIC0gZmlyc3RMaW5lO1xuICAgICAgICBsZXQgbGluZVRvcCA9IHRvcCArIHBlckxpbmUgKiBsaW5lc0Fib3ZlICsgcGVyQ2hhciAqIChsaW5lLmZyb20gLSBvZmZzZXQgLSBsaW5lc0Fib3ZlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgTWF0aC5tYXgodG9wLCBNYXRoLm1pbihsaW5lVG9wLCB0b3AgKyB0aGlzLmhlaWdodCAtIGxpbmVIZWlnaHQpKSwgbGluZUhlaWdodCwgMCk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBvcmFjbGUsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGZyb20gPSBNYXRoLm1heChmcm9tLCBvZmZzZXQpO1xuICAgICAgICB0byA9IE1hdGgubWluKHRvLCBvZmZzZXQgKyB0aGlzLmxlbmd0aCk7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgcGVyTGluZSwgcGVyQ2hhciB9ID0gdGhpcy5oZWlnaHRNZXRyaWNzKG9yYWNsZSwgb2Zmc2V0KTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZnJvbSwgbGluZVRvcCA9IHRvcDsgcG9zIDw9IHRvOykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVzQWJvdmUgPSBsaW5lLm51bWJlciAtIGZpcnN0TGluZTtcbiAgICAgICAgICAgICAgICBsaW5lVG9wICs9IHBlckxpbmUgKiBsaW5lc0Fib3ZlICsgcGVyQ2hhciAqIChmcm9tIC0gb2Zmc2V0IC0gbGluZXNBYm92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGluZUhlaWdodCA9IHBlckxpbmUgKyBwZXJDaGFyICogbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBmKG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgbGluZVRvcCwgbGluZUhlaWdodCwgMCkpO1xuICAgICAgICAgICAgbGluZVRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgbm9kZXMpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gdGhpcy5sZW5ndGggLSB0bztcbiAgICAgICAgaWYgKGFmdGVyID4gMCkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdID0gbmV3IEhlaWdodE1hcEdhcChsYXN0Lmxlbmd0aCArIGFmdGVyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwsIG5ldyBIZWlnaHRNYXBHYXAoYWZ0ZXIgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb20gPiAwKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBub2Rlc1swXTtcbiAgICAgICAgICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2Rlc1swXSA9IG5ldyBIZWlnaHRNYXBHYXAoZnJvbSArIGZpcnN0Lmxlbmd0aCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZXMudW5zaGlmdChuZXcgSGVpZ2h0TWFwR2FwKGZyb20gLSAxKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gMSksIG51bGwpO1xuICAgIH1cbiAgICBkZWNvbXBvc2VSaWdodChmcm9tLCByZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcCh0aGlzLmxlbmd0aCAtIGZyb20gLSAxKSk7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCBlbmQgPSBvZmZzZXQgKyB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICsgdGhpcy5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgLy8gRmlsbCBpbiBwYXJ0IG9mIHRoaXMgZ2FwIHdpdGggbWVhc3VyZWQgbGluZXMuIFdlIGtub3cgdGhlcmVcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIHdpZGdldHMgb3IgY29sbGFwc2VkIHJhbmdlcyBpbiB0aG9zZSBsaW5lcywgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGhleSB3b3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgaGVpZ2h0bWFwIChnYXBzXG4gICAgICAgICAgICAvLyBvbmx5IGNvbnRhaW4gcGxhaW4gdGV4dCkuXG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBbXSwgcG9zID0gTWF0aC5tYXgob2Zmc2V0LCBtZWFzdXJlZC5mcm9tKSwgc2luZ2xlSGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICBpZiAobWVhc3VyZWQuZnJvbSA+IG9mZnNldClcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBHYXAobWVhc3VyZWQuZnJvbSAtIG9mZnNldCAtIDEpLnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCkpO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8PSBlbmQgJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhoZWlnaHQgLSBzaW5nbGVIZWlnaHQpID49IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IC0yO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQobGVuLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxpbmUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW4gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKGVuZCAtIHBvcykudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcG9zKSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPCAwIHx8IE1hdGguYWJzKHJlc3VsdC5oZWlnaHQgLSB0aGlzLmhlaWdodCkgPj0gRXBzaWxvbiB8fFxuICAgICAgICAgICAgICAgIE1hdGguYWJzKHNpbmdsZUhlaWdodCAtIHRoaXMuaGVpZ2h0TWV0cmljcyhvcmFjbGUsIG9mZnNldCkucGVyTGluZSkgPj0gRXBzaWxvbilcbiAgICAgICAgICAgICAgICBoZWlnaHRDaGFuZ2VGbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9yY2UgfHwgdGhpcy5vdXRkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLmhlaWdodEZvckdhcChvZmZzZXQsIG9mZnNldCArIHRoaXMubGVuZ3RoKSk7XG4gICAgICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gYGdhcCgke3RoaXMubGVuZ3RofSlgOyB9XG59XG5jbGFzcyBIZWlnaHRNYXBCcmFuY2ggZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIGJyaywgcmlnaHQpIHtcbiAgICAgICAgc3VwZXIobGVmdC5sZW5ndGggKyBicmsgKyByaWdodC5sZW5ndGgsIGxlZnQuaGVpZ2h0ICsgcmlnaHQuaGVpZ2h0LCBicmsgfCAobGVmdC5vdXRkYXRlZCB8fCByaWdodC5vdXRkYXRlZCA/IDIgLyogRmxhZy5PdXRkYXRlZCAqLyA6IDApKTtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgIH1cbiAgICBnZXQgYnJlYWsoKSB7IHJldHVybiB0aGlzLmZsYWdzICYgMSAvKiBGbGFnLkJyZWFrICovOyB9XG4gICAgYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG1pZCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBoZWlnaHQgPCBtaWQgPyB0aGlzLmxlZnQuYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQuYmxvY2tBdChoZWlnaHQsIG9yYWNsZSwgbWlkLCBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhayk7XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgb3JhY2xlLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBsZXQgbGVmdCA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5SGVpZ2h0ID8gdmFsdWUgPCByaWdodFRvcCA6IHZhbHVlIDwgcmlnaHRPZmZzZXQ7XG4gICAgICAgIGxldCBiYXNlID0gbGVmdCA/IHRoaXMubGVmdC5saW5lQXQodmFsdWUsIHR5cGUsIG9yYWNsZSwgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQubGluZUF0KHZhbHVlLCB0eXBlLCBvcmFjbGUsIHJpZ2h0VG9wLCByaWdodE9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrIHx8IChsZWZ0ID8gYmFzZS50byA8IHJpZ2h0T2Zmc2V0IDogYmFzZS5mcm9tID4gcmlnaHRPZmZzZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBzdWJRdWVyeSA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQgPyBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA6IFF1ZXJ5VHlwZS5CeVBvcztcbiAgICAgICAgaWYgKGxlZnQpXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5qb2luKHRoaXMucmlnaHQubGluZUF0KHJpZ2h0T2Zmc2V0LCBzdWJRdWVyeSwgb3JhY2xlLCByaWdodFRvcCwgcmlnaHRPZmZzZXQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5saW5lQXQocmlnaHRPZmZzZXQsIHN1YlF1ZXJ5LCBvcmFjbGUsIHRvcCwgb2Zmc2V0KS5qb2luKGJhc2UpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgb3JhY2xlLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgaWYgKGZyb20gPCByaWdodE9mZnNldClcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgdG9wLCBvZmZzZXQsIGYpO1xuICAgICAgICAgICAgaWYgKHRvID49IHJpZ2h0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSB0aGlzLmxpbmVBdChyaWdodE9mZnNldCwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgbWlkLmZyb20pXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hMaW5lKGZyb20sIG1pZC5mcm9tIC0gMSwgb3JhY2xlLCB0b3AsIG9mZnNldCwgZik7XG4gICAgICAgICAgICBpZiAobWlkLnRvID49IGZyb20gJiYgbWlkLmZyb20gPD0gdG8pXG4gICAgICAgICAgICAgICAgZihtaWQpO1xuICAgICAgICAgICAgaWYgKHRvID4gbWlkLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUobWlkLnRvICsgMSwgdG8sIG9yYWNsZSwgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCBub2Rlcykge1xuICAgICAgICBsZXQgcmlnaHRTdGFydCA9IHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodG8gPCByaWdodFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LnJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSwgdGhpcy5yaWdodCk7XG4gICAgICAgIGlmIChmcm9tID4gdGhpcy5sZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKHRoaXMubGVmdCwgdGhpcy5yaWdodC5yZXBsYWNlKGZyb20gLSByaWdodFN0YXJ0LCB0byAtIHJpZ2h0U3RhcnQsIG5vZGVzKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VMZWZ0KGZyb20sIHJlc3VsdCk7XG4gICAgICAgIGxldCBsZWZ0ID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2RlcylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBtZXJnZUdhcHMocmVzdWx0LCBsZWZ0IC0gMSk7XG4gICAgICAgIGlmICh0byA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VSaWdodCh0bywgcmVzdWx0KTtcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgICAgIGlmICh0byA8PSBsZWZ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5kZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmxlZnQpO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICAgICAgaWYgKHRvID49IGxlZnQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvID4gbGVmdClcbiAgICAgICAgICAgIHRoaXMucmlnaHQuZGVjb21wb3NlTGVmdCh0byAtIGxlZnQsIHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGgsIHJpZ2h0ID0gbGVmdCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmIChmcm9tID49IHJpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuZGVjb21wb3NlUmlnaHQoZnJvbSAtIHJpZ2h0LCByZXN1bHQpO1xuICAgICAgICBpZiAoZnJvbSA8IGxlZnQpXG4gICAgICAgICAgICB0aGlzLmxlZnQuZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWsgJiYgZnJvbSA8IHJpZ2h0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucmlnaHQpO1xuICAgIH1cbiAgICBiYWxhbmNlZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC5zaXplID4gMiAqIHJpZ2h0LnNpemUgfHwgcmlnaHQuc2l6ZSA+IDIgKiBsZWZ0LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHRoaXMuYnJlYWsgPyBbbGVmdCwgbnVsbCwgcmlnaHRdIDogW2xlZnQsIHJpZ2h0XSk7XG4gICAgICAgIHRoaXMubGVmdCA9IHJlcGxhY2UodGhpcy5sZWZ0LCBsZWZ0KTtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJlcGxhY2UodGhpcy5yaWdodCwgcmlnaHQpO1xuICAgICAgICB0aGlzLnNldEhlaWdodChsZWZ0LmhlaWdodCArIHJpZ2h0LmhlaWdodCk7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBsZWZ0Lm91dGRhdGVkIHx8IHJpZ2h0Lm91dGRhdGVkO1xuICAgICAgICB0aGlzLnNpemUgPSBsZWZ0LnNpemUgKyByaWdodC5zaXplO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlZnQubGVuZ3RoICsgdGhpcy5icmVhayArIHJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCA9IDAsIGZvcmNlID0gZmFsc2UsIG1lYXN1cmVkKSB7XG4gICAgICAgIGxldCB7IGxlZnQsIHJpZ2h0IH0gPSB0aGlzLCByaWdodFN0YXJ0ID0gb2Zmc2V0ICsgbGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrLCByZWJhbGFuY2UgPSBudWxsO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgKyBsZWZ0Lmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKVxuICAgICAgICAgICAgcmViYWxhbmNlID0gbGVmdCA9IGxlZnQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0LCBmb3JjZSwgbWVhc3VyZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZWZ0LnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCwgZm9yY2UpO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSByaWdodFN0YXJ0ICsgcmlnaHQubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICByZWJhbGFuY2UgPSByaWdodCA9IHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlLCBtZWFzdXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJpZ2h0LnVwZGF0ZUhlaWdodChvcmFjbGUsIHJpZ2h0U3RhcnQsIGZvcmNlKTtcbiAgICAgICAgaWYgKHJlYmFsYW5jZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmxlZnQuaGVpZ2h0ICsgdGhpcy5yaWdodC5oZWlnaHQ7XG4gICAgICAgIHRoaXMub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5sZWZ0ICsgKHRoaXMuYnJlYWsgPyBcIiBcIiA6IFwiLVwiKSArIHRoaXMucmlnaHQ7IH1cbn1cbmZ1bmN0aW9uIG1lcmdlR2Fwcyhub2RlcywgYXJvdW5kKSB7XG4gICAgbGV0IGJlZm9yZSwgYWZ0ZXI7XG4gICAgaWYgKG5vZGVzW2Fyb3VuZF0gPT0gbnVsbCAmJlxuICAgICAgICAoYmVmb3JlID0gbm9kZXNbYXJvdW5kIC0gMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwICYmXG4gICAgICAgIChhZnRlciA9IG5vZGVzW2Fyb3VuZCArIDFdKSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgbm9kZXMuc3BsaWNlKGFyb3VuZCAtIDEsIDMsIG5ldyBIZWlnaHRNYXBHYXAoYmVmb3JlLmxlbmd0aCArIDEgKyBhZnRlci5sZW5ndGgpKTtcbn1cbmNvbnN0IHJlbGV2YW50V2lkZ2V0SGVpZ2h0ID0gNTtcbmNsYXNzIE5vZGVCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIG9yYWNsZSkge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5vcmFjbGUgPSBvcmFjbGU7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5saW5lRW5kID0gLTE7XG4gICAgICAgIHRoaXMuY292ZXJpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHBvcztcbiAgICB9XG4gICAgZ2V0IGlzQ292ZXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY292ZXJpbmcgJiYgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IHRoaXMuY292ZXJpbmc7XG4gICAgfVxuICAgIHNwYW4oX2Zyb20sIHRvKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKSB7XG4gICAgICAgICAgICBsZXQgZW5kID0gTWF0aC5taW4odG8sIHRoaXMubGluZUVuZCksIGxhc3QgPSB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdCBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbGFzdC5sZW5ndGggKz0gZW5kIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPiB0aGlzLnBvcyB8fCAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KGVuZCAtIHRoaXMucG9zLCAtMSkpO1xuICAgICAgICAgICAgdGhpcy53cml0dGVuVG8gPSBlbmQ7XG4gICAgICAgICAgICBpZiAodG8gPiBlbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0dGVuVG8rKztcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gdG87XG4gICAgfVxuICAgIHBvaW50KGZyb20sIHRvLCBkZWNvKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgZGVjby5oZWlnaHRSZWxldmFudCkge1xuICAgICAgICAgICAgbGV0IGhlaWdodCA9IGRlY28ud2lkZ2V0ID8gZGVjby53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0IDogMDtcbiAgICAgICAgICAgIGxldCBicmVha3MgPSBkZWNvLndpZGdldCA/IGRlY28ud2lkZ2V0LmxpbmVCcmVha3MgOiAwO1xuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDApXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcmFjbGUubGluZUhlaWdodDtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0byAtIGZyb207XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmxvY2sobmV3IEhlaWdodE1hcEJsb2NrKGxlbiwgaGVpZ2h0LCBkZWNvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gfHwgYnJlYWtzIHx8IGhlaWdodCA+PSByZWxldmFudFdpZGdldEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGluZURlY28oaGVpZ2h0LCBicmVha3MsIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG8gPiBmcm9tKSB7XG4gICAgICAgICAgICB0aGlzLnNwYW4oZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpbmVFbmQgPiAtMSAmJiB0aGlzLmxpbmVFbmQgPCB0aGlzLnBvcylcbiAgICAgICAgICAgIHRoaXMubGluZUVuZCA9IHRoaXMub3JhY2xlLmRvYy5saW5lQXQodGhpcy5wb3MpLnRvO1xuICAgIH1cbiAgICBlbnRlckxpbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5vcmFjbGUuZG9jLmxpbmVBdCh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0ID0gZnJvbTtcbiAgICAgICAgdGhpcy5saW5lRW5kID0gdG87XG4gICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXR0ZW5UbyA8IGZyb20gLSAxIHx8IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaCh0aGlzLmJsYW5rQ29udGVudCh0aGlzLndyaXR0ZW5UbywgZnJvbSAtIDEpKTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wb3MgPiBmcm9tKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KHRoaXMucG9zIC0gZnJvbSwgLTEpKTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcztcbiAgICB9XG4gICAgYmxhbmtDb250ZW50KGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBnYXAgPSBuZXcgSGVpZ2h0TWFwR2FwKHRvIC0gZnJvbSk7XG4gICAgICAgIGlmICh0aGlzLm9yYWNsZS5kb2MubGluZUF0KGZyb20pLnRvID09IHRvKVxuICAgICAgICAgICAgZ2FwLmZsYWdzIHw9IDQgLyogRmxhZy5TaW5nbGVMaW5lICovO1xuICAgICAgICByZXR1cm4gZ2FwO1xuICAgIH1cbiAgICBlbnN1cmVMaW5lKCkge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoID8gdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQoMCwgLTEpO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobGluZSk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBhZGRCbG9jayhibG9jaykge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBsZXQgZGVjbyA9IGJsb2NrLmRlY287XG4gICAgICAgIGlmIChkZWNvICYmIGRlY28uc3RhcnRTaWRlID4gMCAmJiAhdGhpcy5pc0NvdmVyZWQpXG4gICAgICAgICAgICB0aGlzLmVuc3VyZUxpbmUoKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKGJsb2NrKTtcbiAgICAgICAgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgYmxvY2subGVuZ3RoO1xuICAgICAgICBpZiAoZGVjbyAmJiBkZWNvLmVuZFNpZGUgPiAwKVxuICAgICAgICAgICAgdGhpcy5jb3ZlcmluZyA9IGJsb2NrO1xuICAgIH1cbiAgICBhZGRMaW5lRGVjbyhoZWlnaHQsIGJyZWFrcywgbGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5lbnN1cmVMaW5lKCk7XG4gICAgICAgIGxpbmUubGVuZ3RoICs9IGxlbmd0aDtcbiAgICAgICAgbGluZS5jb2xsYXBzZWQgKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLndpZGdldEhlaWdodCA9IE1hdGgubWF4KGxpbmUud2lkZ2V0SGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgICBsaW5lLmJyZWFrcyArPSBicmVha3M7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3MgPSB0aGlzLnBvcyArIGxlbmd0aDtcbiAgICB9XG4gICAgZmluaXNoKGZyb20pIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCA9PSAwID8gbnVsbCA6IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEgJiYgIShsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCkgJiYgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KDAsIC0xKSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud3JpdHRlblRvIDwgdGhpcy5wb3MgfHwgbGFzdCA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCB0aGlzLnBvcykpO1xuICAgICAgICBsZXQgcG9zID0gZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVIZWlnaHQodGhpcy5vcmFjbGUsIHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gbm9kZSA/IG5vZGUubGVuZ3RoIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG4gICAgLy8gQWx3YXlzIGNhbGxlZCB3aXRoIGEgcmVnaW9uIHRoYXQgb24gYm90aCBzaWRlcyBlaXRoZXIgc3RyZXRjaGVzXG4gICAgLy8gdG8gYSBsaW5lIGJyZWFrIG9yIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgIC8vIFRoZSByZXR1cm5lZCBhcnJheSB1c2VzIG51bGwgdG8gaW5kaWNhdGUgbGluZSBicmVha3MsIGJ1dCBuZXZlclxuICAgIC8vIHN0YXJ0cyBvciBlbmRzIGluIGEgbGluZSBicmVhaywgb3IgaGFzIG11bHRpcGxlIGxpbmUgYnJlYWtzIG5leHRcbiAgICAvLyB0byBlYWNoIG90aGVyLlxuICAgIHN0YXRpYyBidWlsZChvcmFjbGUsIGRlY29yYXRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBOb2RlQnVpbGRlcihmcm9tLCBvcmFjbGUpO1xuICAgICAgICBSYW5nZVNldC5zcGFucyhkZWNvcmF0aW9ucywgZnJvbSwgdG8sIGJ1aWxkZXIsIDApO1xuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goZnJvbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3I7XG4gICAgUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wLCAwKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29tcGFyZVJhbmdlKCkgeyB9XG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvLCBhLCBiKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgYSAmJiBhLmhlaWdodFJlbGV2YW50IHx8IGIgJiYgYi5oZWlnaHRSZWxldmFudClcbiAgICAgICAgICAgIGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMsIDUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdmlzaWJsZVBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIGxldCBsZWZ0ID0gTWF0aC5tYXgoMCwgcmVjdC5sZWZ0KSwgcmlnaHQgPSBNYXRoLm1pbih3aW4uaW5uZXJXaWR0aCwgcmVjdC5yaWdodCk7XG4gICAgbGV0IHRvcCA9IE1hdGgubWF4KDAsIHJlY3QudG9wKSwgYm90dG9tID0gTWF0aC5taW4od2luLmlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7XG4gICAgZm9yIChsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7IHBhcmVudCAmJiBwYXJlbnQgIT0gZG9jLmJvZHk7KSB7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsdCk7XG4gICAgICAgICAgICBpZiAoKGVsdC5zY3JvbGxIZWlnaHQgPiBlbHQuY2xpZW50SGVpZ2h0IHx8IGVsdC5zY3JvbGxXaWR0aCA+IGVsdC5jbGllbnRXaWR0aCkgJiZcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyAhPSBcInZpc2libGVcIikge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRSZWN0ID0gZWx0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBwYXJlbnRSZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIHBhcmVudFJlY3QucmlnaHQpO1xuICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgcGFyZW50UmVjdC50b3ApO1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWluKHBhcmVudCA9PSBkb20ucGFyZW50Tm9kZSA/IHdpbi5pbm5lckhlaWdodCA6IGJvdHRvbSwgcGFyZW50UmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gc3R5bGUucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiIHx8IHN0eWxlLnBvc2l0aW9uID09IFwiZml4ZWRcIiA/IGVsdC5vZmZzZXRQYXJlbnQgOiBlbHQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHJlY3QubGVmdCwgcmlnaHQ6IE1hdGgubWF4KGxlZnQsIHJpZ2h0KSAtIHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiB0b3AgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSwgYm90dG9tOiBNYXRoLm1heCh0b3AsIGJvdHRvbSkgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSB9O1xufVxuZnVuY3Rpb24gaW5XaW5kb3coZWx0KSB7XG4gICAgbGV0IHJlY3QgPSBlbHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpbiA9IGVsdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICByZXR1cm4gcmVjdC5sZWZ0IDwgd2luLmlubmVyV2lkdGggJiYgcmVjdC5yaWdodCA+IDAgJiZcbiAgICAgICAgcmVjdC50b3AgPCB3aW4uaW5uZXJIZWlnaHQgJiYgcmVjdC5ib3R0b20gPiAwO1xufVxuZnVuY3Rpb24gZnVsbFBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHsgbGVmdDogMCwgcmlnaHQ6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgICAgIHRvcDogcGFkZGluZ1RvcCwgYm90dG9tOiByZWN0LmJvdHRvbSAtIChyZWN0LnRvcCArIHBhZGRpbmdUb3ApIH07XG59XG4vLyBMaW5lIGdhcHMgYXJlIHBsYWNlaG9sZGVyIHdpZGdldHMgdXNlZCB0byBoaWRlIHBpZWNlcyBvZiBvdmVybG9uZ1xuLy8gbGluZXMgd2l0aGluIHRoZSB2aWV3cG9ydCwgYXMgYSBrbHVkZ2UgdG8ga2VlcCB0aGUgZWRpdG9yXG4vLyByZXNwb25zaXZlIHdoZW4gYSByaWRpY3Vsb3VzbHkgbG9uZyBsaW5lIGlzIGxvYWRlZCBpbnRvIGl0LlxuY2xhc3MgTGluZUdhcCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8sIHNpemUsIGRpc3BsYXlTaXplKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5kaXNwbGF5U2l6ZSA9IGRpc3BsYXlTaXplO1xuICAgIH1cbiAgICBzdGF0aWMgc2FtZShhLCBiKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZ0EgPSBhW2ldLCBnQiA9IGJbaV07XG4gICAgICAgICAgICBpZiAoZ0EuZnJvbSAhPSBnQi5mcm9tIHx8IGdBLnRvICE9IGdCLnRvIHx8IGdBLnNpemUgIT0gZ0Iuc2l6ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRyYXcodmlld1N0YXRlLCB3cmFwcGluZykge1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgIHdpZGdldDogbmV3IExpbmVHYXBXaWRnZXQodGhpcy5kaXNwbGF5U2l6ZSAqICh3cmFwcGluZyA/IHZpZXdTdGF0ZS5zY2FsZVkgOiB2aWV3U3RhdGUuc2NhbGVYKSwgd3JhcHBpbmcpXG4gICAgICAgIH0pLnJhbmdlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgfVxufVxuY2xhc3MgTGluZUdhcFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHZlcnRpY2FsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMudmVydGljYWwgPSB2ZXJ0aWNhbDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLnNpemUgPT0gdGhpcy5zaXplICYmIG90aGVyLnZlcnRpY2FsID09IHRoaXMudmVydGljYWw7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWx0LnN0eWxlLndpZHRoID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IFwiMnB4XCI7XG4gICAgICAgICAgICBlbHQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIHRoaXMudmVydGljYWwgPyB0aGlzLnNpemUgOiAtMTsgfVxufVxuY2xhc3MgVmlld1N0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIC8vIFRoZXNlIGFyZSBjb250ZW50RE9NLWxvY2FsIGNvb3JkaW5hdGVzXG4gICAgICAgIHRoaXMucGl4ZWxWaWV3cG9ydCA9IHsgbGVmdDogMCwgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoLCB0b3A6IDAsIGJvdHRvbTogMCB9O1xuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IDA7IC8vIFBhZGRpbmcgYWJvdmUgdGhlIGRvY3VtZW50LCBzY2FsZWRcbiAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDsgLy8gUGFkZGluZyBiZWxvdyB0aGUgZG9jdW1lbnQsIHNjYWxlZFxuICAgICAgICB0aGlzLmNvbnRlbnRET01XaWR0aCA9IDA7IC8vIGNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbiAgICAgICAgdGhpcy5jb250ZW50RE9NSGVpZ2h0ID0gMDsgLy8gY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgICAgdGhpcy5lZGl0b3JIZWlnaHQgPSAwOyAvLyBzY3JvbGxET00uY2xpZW50SGVpZ2h0LCB1bnNjYWxlZFxuICAgICAgICB0aGlzLmVkaXRvcldpZHRoID0gMDsgLy8gc2Nyb2xsRE9NLmNsaWVudFdpZHRoLCB1bnNjYWxlZFxuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IDA7IC8vIExhc3Qgc2VlbiBzY3JvbGxET00uc2Nyb2xsVG9wLCBzY2FsZWRcbiAgICAgICAgdGhpcy5zY3JvbGxlZFRvQm90dG9tID0gZmFsc2U7XG4gICAgICAgIC8vIFRoZSBDU1MtdHJhbnNmb3JtYXRpb24gc2NhbGUgb2YgdGhlIGVkaXRvciAodHJhbnNmb3JtZWQgc2l6ZSAvXG4gICAgICAgIC8vIGNvbmNyZXRlIHNpemUpXG4gICAgICAgIHRoaXMuc2NhbGVYID0gMTtcbiAgICAgICAgdGhpcy5zY2FsZVkgPSAxO1xuICAgICAgICAvLyBUaGUgdmVydGljYWwgcG9zaXRpb24gKGRvY3VtZW50LXJlbGF0aXZlKSB0byB3aGljaCB0byBhbmNob3IgdGhlXG4gICAgICAgIC8vIHNjcm9sbCBwb3NpdGlvbi4gLTEgbWVhbnMgYW5jaG9yIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICB0aGlzLnNjcm9sbEFuY2hvclBvcyA9IDA7XG4gICAgICAgIC8vIFRoZSBoZWlnaHQgYXQgdGhlIGFuY2hvciBwb3NpdGlvbi4gU2V0IGJ5IHRoZSBET00gdXBkYXRlIHBoYXNlLlxuICAgICAgICAvLyAtMSBtZWFucyBubyBoZWlnaHQgYXZhaWxhYmxlLlxuICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IC0xO1xuICAgICAgICAvLyBTZWUgVlAuTWF4RE9NSGVpZ2h0XG4gICAgICAgIHRoaXMuc2NhbGVyID0gSWRTY2FsZXI7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gQnJpZWZseSBzZXQgdG8gdHJ1ZSB3aGVuIHByaW50aW5nLCB0byBkaXNhYmxlIHZpZXdwb3J0IGxpbWl0aW5nXG4gICAgICAgIHRoaXMucHJpbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gRmxhZyBzZXQgd2hlbiBlZGl0b3IgY29udGVudCB3YXMgcmVkcmF3biwgc28gdGhhdCB0aGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHN0YWdlIGtub3dzIGl0IG11c3QgcmVhZCBET00gbGF5b3V0XG4gICAgICAgIHRoaXMubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0VGV4dERpcmVjdGlvbiA9IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IFtdO1xuICAgICAgICAvLyBDdXJzb3IgJ2Fzc29jJyBpcyBvbmx5IHNpZ25pZmljYW50IHdoZW4gdGhlIGN1cnNvciBpcyBvbiBhIGxpbmVcbiAgICAgICAgLy8gd3JhcCBwb2ludCwgd2hlcmUgaXQgbXVzdCBzdGljayB0byB0aGUgY2hhcmFjdGVyIHRoYXQgaXQgaXNcbiAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoLiBTaW5jZSBicm93c2VycyBkb24ndCBwcm92aWRlIGEgcmVhc29uYWJsZVxuICAgICAgICAvLyBpbnRlcmZhY2UgdG8gc2V0IG9yIHF1ZXJ5IHRoaXMsIHdoZW4gYSBzZWxlY3Rpb24gaXMgc2V0IHRoYXRcbiAgICAgICAgLy8gbWlnaHQgY2F1c2UgdGhpcyB0byBiZSBzaWduaWZpY2FudCwgdGhpcyBmbGFnIGlzIHNldC4gVGhlIG5leHRcbiAgICAgICAgLy8gbWVhc3VyZSBwaGFzZSB3aWxsIGNoZWNrIHdoZXRoZXIgdGhlIGN1cnNvciBpcyBvbiBhIGxpbmUtd3JhcHBpbmdcbiAgICAgICAgLy8gYm91bmRhcnkgYW5kLCBpZiBzbywgcmVzZXQgaXQgdG8gbWFrZSBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgaW5cbiAgICAgICAgLy8gdGhlIHJpZ2h0IHBsYWNlLlxuICAgICAgICB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSBmYWxzZTtcbiAgICAgICAgbGV0IGd1ZXNzV3JhcHBpbmcgPSBzdGF0ZS5mYWNldChjb250ZW50QXR0cmlidXRlcykuc29tZSh2ID0+IHR5cGVvZiB2ICE9IFwiZnVuY3Rpb25cIiAmJiB2LmNsYXNzID09IFwiY20tbGluZVdyYXBwaW5nXCIpO1xuICAgICAgICB0aGlzLmhlaWdodE9yYWNsZSA9IG5ldyBIZWlnaHRPcmFjbGUoZ3Vlc3NXcmFwcGluZyk7XG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLmZpbHRlcihkID0+IHR5cGVvZiBkICE9IFwiZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gSGVpZ2h0TWFwLmVtcHR5KCkuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCBUZXh0LmVtcHR5LCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2Moc3RhdGUuZG9jKSwgW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgc3RhdGUuZG9jLmxlbmd0aCldKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KDAsIG51bGwpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIHRoaXMubGluZUdhcHMgPSB0aGlzLmVuc3VyZUxpbmVHYXBzKFtdKTtcbiAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KHRoaXMubGluZUdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyh0aGlzLCBmYWxzZSkpKTtcbiAgICAgICAgdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgIH1cbiAgICB1cGRhdGVGb3JWaWV3cG9ydCgpIHtcbiAgICAgICAgbGV0IHZpZXdwb3J0cyA9IFt0aGlzLnZpZXdwb3J0XSwgeyBtYWluIH0gPSB0aGlzLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcG9zID0gaSA/IG1haW4uaGVhZCA6IG1haW4uYW5jaG9yO1xuICAgICAgICAgICAgaWYgKCF2aWV3cG9ydHMuc29tZSgoeyBmcm9tLCB0byB9KSA9PiBwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG8pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHRoaXMubGluZUJsb2NrQXQocG9zKTtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydHMucHVzaChuZXcgVmlld3BvcnQoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVTY2FsZXIoKTtcbiAgICB9XG4gICAgdXBkYXRlU2NhbGVyKCkge1xuICAgICAgICBsZXQgc2NhbGVyID0gdGhpcy5zY2FsZXI7XG4gICAgICAgIHRoaXMuc2NhbGVyID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0IDw9IDcwMDAwMDAgLyogVlAuTWF4RE9NSGVpZ2h0ICovID8gSWRTY2FsZXIgOlxuICAgICAgICAgICAgbmV3IEJpZ1NjYWxlcih0aGlzLmhlaWdodE9yYWNsZSwgdGhpcy5oZWlnaHRNYXAsIHRoaXMudmlld3BvcnRzKTtcbiAgICAgICAgcmV0dXJuIHNjYWxlci5lcSh0aGlzLnNjYWxlcikgPyAwIDogMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLztcbiAgICB9XG4gICAgdXBkYXRlVmlld3BvcnRMaW5lcygpIHtcbiAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzID0gW107XG4gICAgICAgIHRoaXMuaGVpZ2h0TWFwLmZvckVhY2hMaW5lKHRoaXMudmlld3BvcnQuZnJvbSwgdGhpcy52aWV3cG9ydC50bywgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHRoaXMuc3RhdGUuZG9jKSwgMCwgMCwgYmxvY2sgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzLnB1c2goc2NhbGVCbG9jayhibG9jaywgdGhpcy5zY2FsZXIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUsIHNjcm9sbFRhcmdldCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHVwZGF0ZS5zdGF0ZTtcbiAgICAgICAgbGV0IHByZXZEZWNvID0gdGhpcy5zdGF0ZURlY287XG4gICAgICAgIHRoaXMuc3RhdGVEZWNvID0gdGhpcy5zdGF0ZS5mYWNldChkZWNvcmF0aW9ucykuZmlsdGVyKGQgPT4gdHlwZW9mIGQgIT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgbGV0IGNvbnRlbnRDaGFuZ2VzID0gdXBkYXRlLmNoYW5nZWRSYW5nZXM7XG4gICAgICAgIGxldCBoZWlnaHRDaGFuZ2VzID0gQ2hhbmdlZFJhbmdlLmV4dGVuZFdpdGhSYW5nZXMoY29udGVudENoYW5nZXMsIGhlaWdodFJlbGV2YW50RGVjb0NoYW5nZXMocHJldkRlY28sIHRoaXMuc3RhdGVEZWNvLCB1cGRhdGUgPyB1cGRhdGUuY2hhbmdlcyA6IENoYW5nZVNldC5lbXB0eSh0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKSk7XG4gICAgICAgIGxldCBwcmV2SGVpZ2h0ID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0O1xuICAgICAgICBsZXQgc2Nyb2xsQW5jaG9yID0gdGhpcy5zY3JvbGxlZFRvQm90dG9tID8gbnVsbCA6IHRoaXMuc2Nyb2xsQW5jaG9yQXQodGhpcy5zY3JvbGxUb3ApO1xuICAgICAgICBjbGVhckhlaWdodENoYW5nZUZsYWcoKTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSB0aGlzLmhlaWdodE1hcC5hcHBseUNoYW5nZXModGhpcy5zdGF0ZURlY28sIHVwZGF0ZS5zdGFydFN0YXRlLmRvYywgdGhpcy5oZWlnaHRPcmFjbGUuc2V0RG9jKHRoaXMuc3RhdGUuZG9jKSwgaGVpZ2h0Q2hhbmdlcyk7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodE1hcC5oZWlnaHQgIT0gcHJldkhlaWdodCB8fCBoZWlnaHRDaGFuZ2VGbGFnKVxuICAgICAgICAgICAgdXBkYXRlLmZsYWdzIHw9IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIGlmIChzY3JvbGxBbmNob3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9yUG9zID0gdXBkYXRlLmNoYW5nZXMubWFwUG9zKHNjcm9sbEFuY2hvci5mcm9tLCAtMSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IHNjcm9sbEFuY2hvci50b3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFuY2hvclBvcyA9IC0xO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxBbmNob3JIZWlnaHQgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gaGVpZ2h0Q2hhbmdlcy5sZW5ndGggPyB0aGlzLm1hcFZpZXdwb3J0KHRoaXMudmlld3BvcnQsIHVwZGF0ZS5jaGFuZ2VzKSA6IHRoaXMudmlld3BvcnQ7XG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQgJiYgKHNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDwgdmlld3BvcnQuZnJvbSB8fCBzY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA+IHZpZXdwb3J0LnRvKSB8fFxuICAgICAgICAgICAgIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHZpZXdwb3J0KSlcbiAgICAgICAgICAgIHZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydCgwLCBzY3JvbGxUYXJnZXQpO1xuICAgICAgICBsZXQgdmlld3BvcnRDaGFuZ2UgPSB2aWV3cG9ydC5mcm9tICE9IHRoaXMudmlld3BvcnQuZnJvbSB8fCB2aWV3cG9ydC50byAhPSB0aGlzLnZpZXdwb3J0LnRvO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHVwZGF0ZS5mbGFncyB8PSB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIGlmICh2aWV3cG9ydENoYW5nZSB8fCAhdXBkYXRlLmNoYW5nZXMuZW1wdHkgfHwgKHVwZGF0ZS5mbGFncyAmIDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi8pKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gKDIwMDAgLyogTEcuTWFyZ2luICovIDw8IDEpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVMaW5lR2Fwcyh0aGlzLmVuc3VyZUxpbmVHYXBzKHRoaXMubWFwTGluZUdhcHModGhpcy5saW5lR2FwcywgdXBkYXRlLmNoYW5nZXMpKSk7XG4gICAgICAgIHVwZGF0ZS5mbGFncyB8PSB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgaWYgKHNjcm9sbFRhcmdldClcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gc2Nyb2xsVGFyZ2V0O1xuICAgICAgICBpZiAoIXRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyAmJiB1cGRhdGUuc2VsZWN0aW9uU2V0ICYmIHVwZGF0ZS52aWV3LmxpbmVXcmFwcGluZyAmJlxuICAgICAgICAgICAgdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmVtcHR5ICYmIHVwZGF0ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hc3NvYyAmJlxuICAgICAgICAgICAgIXVwZGF0ZS5zdGF0ZS5mYWNldChuYXRpdmVTZWxlY3Rpb25IaWRkZW4pKVxuICAgICAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gdHJ1ZTtcbiAgICB9XG4gICAgbWVhc3VyZSh2aWV3KSB7XG4gICAgICAgIGxldCBkb20gPSB2aWV3LmNvbnRlbnRET00sIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tKTtcbiAgICAgICAgbGV0IG9yYWNsZSA9IHRoaXMuaGVpZ2h0T3JhY2xlO1xuICAgICAgICBsZXQgd2hpdGVTcGFjZSA9IHN0eWxlLndoaXRlU3BhY2U7XG4gICAgICAgIHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gPSBzdHlsZS5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IERpcmVjdGlvbi5SVEwgOiBEaXJlY3Rpb24uTFRSO1xuICAgICAgICBsZXQgcmVmcmVzaCA9IHRoaXMuaGVpZ2h0T3JhY2xlLm11c3RSZWZyZXNoRm9yV3JhcHBpbmcod2hpdGVTcGFjZSk7XG4gICAgICAgIGxldCBkb21SZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgbWVhc3VyZUNvbnRlbnQgPSByZWZyZXNoIHx8IHRoaXMubXVzdE1lYXN1cmVDb250ZW50IHx8IHRoaXMuY29udGVudERPTUhlaWdodCAhPSBkb21SZWN0LmhlaWdodDtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NSGVpZ2h0ID0gZG9tUmVjdC5oZWlnaHQ7XG4gICAgICAgIHRoaXMubXVzdE1lYXN1cmVDb250ZW50ID0gZmFsc2U7XG4gICAgICAgIGxldCByZXN1bHQgPSAwLCBiaWFzID0gMDtcbiAgICAgICAgaWYgKGRvbVJlY3Qud2lkdGggJiYgZG9tUmVjdC5oZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCB7IHNjYWxlWCwgc2NhbGVZIH0gPSBnZXRTY2FsZShkb20sIGRvbVJlY3QpO1xuICAgICAgICAgICAgaWYgKHNjYWxlWCA+IC4wMDUgJiYgTWF0aC5hYnModGhpcy5zY2FsZVggLSBzY2FsZVgpID4gLjAwNSB8fFxuICAgICAgICAgICAgICAgIHNjYWxlWSA+IC4wMDUgJiYgTWF0aC5hYnModGhpcy5zY2FsZVkgLSBzY2FsZVkpID4gLjAwNSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVYID0gc2NhbGVYO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGVZID0gc2NhbGVZO1xuICAgICAgICAgICAgICAgIHJlc3VsdCB8PSAxNiAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSBtZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmVydGljYWwgcGFkZGluZ1xuICAgICAgICBsZXQgcGFkZGluZ1RvcCA9IChwYXJzZUludChzdHlsZS5wYWRkaW5nVG9wKSB8fCAwKSAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9IChwYXJzZUludChzdHlsZS5wYWRkaW5nQm90dG9tKSB8fCAwKSAqIHRoaXMuc2NhbGVZO1xuICAgICAgICBpZiAodGhpcy5wYWRkaW5nVG9wICE9IHBhZGRpbmdUb3AgfHwgdGhpcy5wYWRkaW5nQm90dG9tICE9IHBhZGRpbmdCb3R0b20pIHtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3A7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tO1xuICAgICAgICAgICAgcmVzdWx0IHw9IDE2IC8qIFVwZGF0ZUZsYWcuR2VvbWV0cnkgKi8gfCAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVkaXRvcldpZHRoICE9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICBpZiAob3JhY2xlLmxpbmVXcmFwcGluZylcbiAgICAgICAgICAgICAgICBtZWFzdXJlQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVkaXRvcldpZHRoID0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgfD0gMTYgLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gdmlldy5zY3JvbGxET00uc2Nyb2xsVG9wICogdGhpcy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbFRvcCAhPSBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcm9sbGVkVG9Cb3R0b20gPSBpc1Njcm9sbGVkVG9Cb3R0b20odmlldy5zY3JvbGxET00pO1xuICAgICAgICAvLyBQaXhlbCB2aWV3cG9ydFxuICAgICAgICBsZXQgcGl4ZWxWaWV3cG9ydCA9ICh0aGlzLnByaW50aW5nID8gZnVsbFBpeGVsUmFuZ2UgOiB2aXNpYmxlUGl4ZWxSYW5nZSkoZG9tLCB0aGlzLnBhZGRpbmdUb3ApO1xuICAgICAgICBsZXQgZFRvcCA9IHBpeGVsVmlld3BvcnQudG9wIC0gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCwgZEJvdHRvbSA9IHBpeGVsVmlld3BvcnQuYm90dG9tIC0gdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbTtcbiAgICAgICAgdGhpcy5waXhlbFZpZXdwb3J0ID0gcGl4ZWxWaWV3cG9ydDtcbiAgICAgICAgbGV0IGluVmlldyA9IHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20gPiB0aGlzLnBpeGVsVmlld3BvcnQudG9wICYmIHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCA+IHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0O1xuICAgICAgICBpZiAoaW5WaWV3ICE9IHRoaXMuaW5WaWV3KSB7XG4gICAgICAgICAgICB0aGlzLmluVmlldyA9IGluVmlldztcbiAgICAgICAgICAgIGlmIChpblZpZXcpXG4gICAgICAgICAgICAgICAgbWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pblZpZXcgJiYgIXRoaXMuc2Nyb2xsVGFyZ2V0ICYmICFpbldpbmRvdyh2aWV3LmRvbSkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGNvbnRlbnRXaWR0aCA9IGRvbVJlY3Qud2lkdGg7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET01XaWR0aCAhPSBjb250ZW50V2lkdGggfHwgdGhpcy5lZGl0b3JIZWlnaHQgIT0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01XaWR0aCA9IGRvbVJlY3Qud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmVkaXRvckhlaWdodCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIHJlc3VsdCB8PSAxNiAvKiBVcGRhdGVGbGFnLkdlb21ldHJ5ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZWFzdXJlQ29udGVudCkge1xuICAgICAgICAgICAgbGV0IGxpbmVIZWlnaHRzID0gdmlldy5kb2NWaWV3Lm1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHModGhpcy52aWV3cG9ydCk7XG4gICAgICAgICAgICBpZiAob3JhY2xlLm11c3RSZWZyZXNoRm9ySGVpZ2h0cyhsaW5lSGVpZ2h0cykpXG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IHRydWU7XG4gICAgICAgICAgICBpZiAocmVmcmVzaCB8fCBvcmFjbGUubGluZVdyYXBwaW5nICYmIE1hdGguYWJzKGNvbnRlbnRXaWR0aCAtIHRoaXMuY29udGVudERPTVdpZHRoKSA+IG9yYWNsZS5jaGFyV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBsaW5lSGVpZ2h0LCBjaGFyV2lkdGgsIHRleHRIZWlnaHQgfSA9IHZpZXcuZG9jVmlldy5tZWFzdXJlVGV4dFNpemUoKTtcbiAgICAgICAgICAgICAgICByZWZyZXNoID0gbGluZUhlaWdodCA+IDAgJiYgb3JhY2xlLnJlZnJlc2god2hpdGVTcGFjZSwgbGluZUhlaWdodCwgY2hhcldpZHRoLCB0ZXh0SGVpZ2h0LCBjb250ZW50V2lkdGggLyBjaGFyV2lkdGgsIGxpbmVIZWlnaHRzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmRvY1ZpZXcubWluV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgfD0gMTYgLyogVXBkYXRlRmxhZy5HZW9tZXRyeSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZFRvcCA+IDAgJiYgZEJvdHRvbSA+IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWF4KGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZFRvcCA8IDAgJiYgZEJvdHRvbSA8IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWluKGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgY2xlYXJIZWlnaHRDaGFuZ2VGbGFnKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB2cCBvZiB0aGlzLnZpZXdwb3J0cykge1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHRzID0gdnAuZnJvbSA9PSB0aGlzLnZpZXdwb3J0LmZyb20gPyBsaW5lSGVpZ2h0cyA6IHZpZXcuZG9jVmlldy5tZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKHZwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodE1hcCA9IChyZWZyZXNoID8gSGVpZ2h0TWFwLmVtcHR5KCkuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCBUZXh0LmVtcHR5LCB0aGlzLmhlaWdodE9yYWNsZSwgW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKV0pIDogdGhpcy5oZWlnaHRNYXApLnVwZGF0ZUhlaWdodChvcmFjbGUsIDAsIHJlZnJlc2gsIG5ldyBNZWFzdXJlZEhlaWdodHModnAuZnJvbSwgaGVpZ2h0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlaWdodENoYW5nZUZsYWcpXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IDIgLyogVXBkYXRlRmxhZy5IZWlnaHQgKi87XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZpZXdwb3J0Q2hhbmdlID0gIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHRoaXMudmlld3BvcnQsIGJpYXMpIHx8XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRhcmdldCAmJiAodGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHRoaXMudmlld3BvcnQuZnJvbSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB0aGlzLnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKHZpZXdwb3J0Q2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICYgMiAvKiBVcGRhdGVGbGFnLkhlaWdodCAqLylcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gdGhpcy51cGRhdGVTY2FsZXIoKTtcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLmdldFZpZXdwb3J0KGJpYXMsIHRoaXMuc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgICAgIHJlc3VsdCB8PSB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChyZXN1bHQgJiAyIC8qIFVwZGF0ZUZsYWcuSGVpZ2h0ICovKSB8fCB2aWV3cG9ydENoYW5nZSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlld3BvcnRMaW5lcygpO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGggfHwgdGhpcy52aWV3cG9ydC50byAtIHRoaXMudmlld3BvcnQuZnJvbSA+ICgyMDAwIC8qIExHLk1hcmdpbiAqLyA8PCAxKSlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2FwcyhyZWZyZXNoID8gW10gOiB0aGlzLmxpbmVHYXBzLCB2aWV3KSk7XG4gICAgICAgIHJlc3VsdCB8PSB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MpIHtcbiAgICAgICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBkb25lIGluIHRoZSByZWFkIHN0YWdlLCBiZWNhdXNlIG1vdmluZyB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAvLyB0byBhIGxpbmUgZW5kIGlzIGdvaW5nIHRvIHRyaWdnZXIgYSBsYXlvdXQgYW55d2F5LCBzbyBpdFxuICAgICAgICAgICAgLy8gY2FuJ3QgYmUgYSBwdXJlIHdyaXRlLiBJdCBzaG91bGQgYmUgcmFyZSB0aGF0IGl0IGRvZXMgYW55XG4gICAgICAgICAgICAvLyB3cml0aW5nLlxuICAgICAgICAgICAgdmlldy5kb2NWaWV3LmVuZm9yY2VDdXJzb3JBc3NvYygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldCB2aXNpYmxlVG9wKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQudG9wKTsgfVxuICAgIGdldCB2aXNpYmxlQm90dG9tKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tKTsgfVxuICAgIGdldFZpZXdwb3J0KGJpYXMsIHNjcm9sbFRhcmdldCkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgZGl2aWRlIFZQLk1hcmdpbiBiZXR3ZWVuIHRoZSB0b3AgYW5kIHRoZVxuICAgICAgICAvLyBib3R0b20sIGRlcGVuZGluZyBvbiB0aGUgYmlhcyAodGhlIGNoYW5nZSBpbiB2aWV3cG9ydCBwb3NpdGlvblxuICAgICAgICAvLyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUpLiBJdCdsbCBob2xkIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAgICBsZXQgbWFyZ2luVG9wID0gMC41IC0gTWF0aC5tYXgoLTAuNSwgTWF0aC5taW4oMC41LCBiaWFzIC8gMTAwMCAvKiBWUC5NYXJnaW4gKi8gLyAyKSk7XG4gICAgICAgIGxldCBtYXAgPSB0aGlzLmhlaWdodE1hcCwgb3JhY2xlID0gdGhpcy5oZWlnaHRPcmFjbGU7XG4gICAgICAgIGxldCB7IHZpc2libGVUb3AsIHZpc2libGVCb3R0b20gfSA9IHRoaXM7XG4gICAgICAgIGxldCB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KHZpc2libGVUb3AgLSBtYXJnaW5Ub3AgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLywgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLmZyb20sIG1hcC5saW5lQXQodmlzaWJsZUJvdHRvbSArICgxIC0gbWFyZ2luVG9wKSAqIDEwMDAgLyogVlAuTWFyZ2luICovLCBRdWVyeVR5cGUuQnlIZWlnaHQsIG9yYWNsZSwgMCwgMCkudG8pO1xuICAgICAgICAvLyBJZiBzY3JvbGxUYXJnZXQgaXMgZ2l2ZW4sIG1ha2Ugc3VyZSB0aGUgdmlld3BvcnQgaW5jbHVkZXMgdGhhdCBwb3NpdGlvblxuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgICAgICBsZXQgeyBoZWFkIH0gPSBzY3JvbGxUYXJnZXQucmFuZ2U7XG4gICAgICAgICAgICBpZiAoaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgaGVhZCA+IHZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXdIZWlnaHQgPSBNYXRoLm1pbih0aGlzLmVkaXRvckhlaWdodCwgdGhpcy5waXhlbFZpZXdwb3J0LmJvdHRvbSAtIHRoaXMucGl4ZWxWaWV3cG9ydC50b3ApO1xuICAgICAgICAgICAgICAgIGxldCBibG9jayA9IG1hcC5saW5lQXQoaGVhZCwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIDAsIDApLCB0b3BQb3M7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRhcmdldC55ID09IFwiY2VudGVyXCIpXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IChibG9jay50b3AgKyBibG9jay5ib3R0b20pIC8gMiAtIHZpZXdIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbFRhcmdldC55ID09IFwic3RhcnRcIiB8fCBzY3JvbGxUYXJnZXQueSA9PSBcIm5lYXJlc3RcIiAmJiBoZWFkIDwgdmlld3BvcnQuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2sudG9wO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2suYm90dG9tIC0gdmlld0hlaWdodDtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KHRvcFBvcyAtIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLmZyb20sIG1hcC5saW5lQXQodG9wUG9zICsgdmlld0hlaWdodCArIDEwMDAgLyogVlAuTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBvcmFjbGUsIDAsIDApLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgfVxuICAgIG1hcFZpZXdwb3J0KHZpZXdwb3J0LCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3Modmlld3BvcnQuZnJvbSwgLTEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3cG9ydCh0aGlzLmhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCkuZnJvbSwgdGhpcy5oZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKS50byk7XG4gICAgfVxuICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIHZpZXdwb3J0IGNvdmVycyB0aGUgdmlzaWJsZSBwYXJ0IG9mIHRoZVxuICAgIC8vIGRvY3VtZW50IGFuZCBub3QgdG9vIG11Y2ggYmV5b25kIHRoYXQuXG4gICAgdmlld3BvcnRJc0FwcHJvcHJpYXRlKHsgZnJvbSwgdG8gfSwgYmlhcyA9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgeyB0b3AgfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKTtcbiAgICAgICAgbGV0IHsgYm90dG9tIH0gPSB0aGlzLmhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApO1xuICAgICAgICBsZXQgeyB2aXNpYmxlVG9wLCB2aXNpYmxlQm90dG9tIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGZyb20gPT0gMCB8fCB0b3AgPD0gdmlzaWJsZVRvcCAtIE1hdGgubWF4KDEwIC8qIFZQLk1pbkNvdmVyTWFyZ2luICovLCBNYXRoLm1pbigtYmlhcywgMjUwIC8qIFZQLk1heENvdmVyTWFyZ2luICovKSkpICYmXG4gICAgICAgICAgICAodG8gPT0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgYm90dG9tID49IHZpc2libGVCb3R0b20gKyBNYXRoLm1heCgxMCAvKiBWUC5NaW5Db3Zlck1hcmdpbiAqLywgTWF0aC5taW4oYmlhcywgMjUwIC8qIFZQLk1heENvdmVyTWFyZ2luICovKSkpICYmXG4gICAgICAgICAgICAodG9wID4gdmlzaWJsZVRvcCAtIDIgKiAxMDAwIC8qIFZQLk1hcmdpbiAqLyAmJiBib3R0b20gPCB2aXNpYmxlQm90dG9tICsgMiAqIDEwMDAgLyogVlAuTWFyZ2luICovKTtcbiAgICB9XG4gICAgbWFwTGluZUdhcHMoZ2FwcywgY2hhbmdlcykge1xuICAgICAgICBpZiAoIWdhcHMubGVuZ3RoIHx8IGNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gZ2FwcztcbiAgICAgICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBnYXAgb2YgZ2FwcylcbiAgICAgICAgICAgIGlmICghY2hhbmdlcy50b3VjaGVzUmFuZ2UoZ2FwLmZyb20sIGdhcC50bykpXG4gICAgICAgICAgICAgICAgbWFwcGVkLnB1c2gobmV3IExpbmVHYXAoY2hhbmdlcy5tYXBQb3MoZ2FwLmZyb20pLCBjaGFuZ2VzLm1hcFBvcyhnYXAudG8pLCBnYXAuc2l6ZSwgZ2FwLmRpc3BsYXlTaXplKSk7XG4gICAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfVxuICAgIC8vIENvbXB1dGVzIHBvc2l0aW9ucyBpbiB0aGUgdmlld3BvcnQgd2hlcmUgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhXG4gICAgLy8gbGluZSBzaG91bGQgYmUgaGlkZGVuLCB0cnlpbmcgdG8gcmV1c2UgZXhpc3RpbmcgbGluZSBnYXBzIHdoZW5cbiAgICAvLyBhcHByb3ByaWF0ZSB0byBhdm9pZCB1bm5lY2Nlc2FyeSByZWRyYXdzLlxuICAgIC8vIFVzZXMgY3J1ZGUgY2hhcmFjdGVyLWNvdW50aW5nIGZvciB0aGUgcG9zaXRpb25pbmcgYW5kIHNpemluZyxcbiAgICAvLyBzaW5jZSBhY3R1YWwgRE9NIGNvb3JkaW5hdGVzIGFyZW4ndCBhbHdheXMgYXZhaWxhYmxlIGFuZFxuICAgIC8vIHByZWRpY3RhYmxlLiBSZWxpZXMgb24gZ2VuZXJvdXMgbWFyZ2lucyAoc2VlIExHLk1hcmdpbikgdG8gaGlkZVxuICAgIC8vIHRoZSBhcnRpZmFjdHMgdGhpcyBtaWdodCBwcm9kdWNlIGZyb20gdGhlIHVzZXIuXG4gICAgZW5zdXJlTGluZUdhcHMoY3VycmVudCwgbWF5TWVhc3VyZSkge1xuICAgICAgICBsZXQgd3JhcHBpbmcgPSB0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7XG4gICAgICAgIGxldCBtYXJnaW4gPSB3cmFwcGluZyA/IDEwMDAwIC8qIExHLk1hcmdpbldyYXAgKi8gOiAyMDAwIC8qIExHLk1hcmdpbiAqLywgaGFsZk1hcmdpbiA9IG1hcmdpbiA+PiAxLCBkb3VibGVNYXJnaW4gPSBtYXJnaW4gPDwgMTtcbiAgICAgICAgLy8gVGhlIG5vbi13cmFwcGluZyBsb2dpYyB3b24ndCB3b3JrIGF0IGFsbCBpbiBwcmVkb21pbmFudGx5IHJpZ2h0LXRvLWxlZnQgdGV4dC5cbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gIT0gRGlyZWN0aW9uLkxUUiAmJiAhd3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGxldCBnYXBzID0gW107XG4gICAgICAgIGxldCBhZGRHYXAgPSAoZnJvbSwgdG8sIGxpbmUsIHN0cnVjdHVyZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRvIC0gZnJvbSA8IGhhbGZNYXJnaW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHNlbCA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uLm1haW4sIGF2b2lkID0gW3NlbC5mcm9tXTtcbiAgICAgICAgICAgIGlmICghc2VsLmVtcHR5KVxuICAgICAgICAgICAgICAgIGF2b2lkLnB1c2goc2VsLnRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyBvZiBhdm9pZCkge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIHBvcyA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdhcChmcm9tLCBwb3MgLSAxMCAvKiBMRy5TZWxlY3Rpb25NYXJnaW4gKi8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEdhcChwb3MgKyAxMCAvKiBMRy5TZWxlY3Rpb25NYXJnaW4gKi8sIHRvLCBsaW5lLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGdhcCA9IGZpbmQoY3VycmVudCwgZ2FwID0+IGdhcC5mcm9tID49IGxpbmUuZnJvbSAmJiBnYXAudG8gPD0gbGluZS50byAmJlxuICAgICAgICAgICAgICAgIE1hdGguYWJzKGdhcC5mcm9tIC0gZnJvbSkgPCBoYWxmTWFyZ2luICYmIE1hdGguYWJzKGdhcC50byAtIHRvKSA8IGhhbGZNYXJnaW4gJiZcbiAgICAgICAgICAgICAgICAhYXZvaWQuc29tZShwb3MgPT4gZ2FwLmZyb20gPCBwb3MgJiYgZ2FwLnRvID4gcG9zKSk7XG4gICAgICAgICAgICBpZiAoIWdhcCkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gc2Nyb2xsaW5nIGRvd24sIHNuYXAgZ2FwIGVuZHMgdG8gbGluZSBzdGFydHMgdG8gYXZvaWQgc2hpZnRzIGluIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgaWYgKHRvIDwgbGluZS50byAmJiBtYXlNZWFzdXJlICYmIHdyYXBwaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIG1heU1lYXN1cmUudmlzaWJsZVJhbmdlcy5zb21lKHIgPT4gci5mcm9tIDw9IHRvICYmIHIudG8gPj0gdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaW5lU3RhcnQgPSBtYXlNZWFzdXJlLm1vdmVUb0xpbmVCb3VuZGFyeShFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHRvKSwgZmFsc2UsIHRydWUpLmhlYWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU3RhcnQgPiBmcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG8gPSBsaW5lU3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBzaXplID0gdGhpcy5nYXBTaXplKGxpbmUsIGZyb20sIHRvLCBzdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgICAgIGxldCBkaXNwbGF5U2l6ZSA9IHdyYXBwaW5nIHx8IHNpemUgPCAyMDAwMDAwIC8qIFZQLk1heEhvcml6R2FwICovID8gc2l6ZSA6IDIwMDAwMDAgLyogVlAuTWF4SG9yaXpHYXAgKi87XG4gICAgICAgICAgICAgICAgZ2FwID0gbmV3IExpbmVHYXAoZnJvbSwgdG8sIHNpemUsIGRpc3BsYXlTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdhcHMucHVzaChnYXApO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgY2hlY2tMaW5lID0gKGxpbmUpID0+IHtcbiAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA8IGRvdWJsZU1hcmdpbiB8fCBsaW5lLnR5cGUgIT0gQmxvY2tUeXBlLlRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHN0cnVjdHVyZSA9IGxpbmVTdHJ1Y3R1cmUobGluZS5mcm9tLCBsaW5lLnRvLCB0aGlzLnN0YXRlRGVjbyk7XG4gICAgICAgICAgICBpZiAoc3RydWN0dXJlLnRvdGFsIDwgZG91YmxlTWFyZ2luKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnNjcm9sbFRhcmdldCA/IHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgOiBudWxsO1xuICAgICAgICAgICAgbGV0IHZpZXdGcm9tLCB2aWV3VG87XG4gICAgICAgICAgICBpZiAod3JhcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luSGVpZ2h0ID0gKG1hcmdpbiAvIHRoaXMuaGVpZ2h0T3JhY2xlLmxpbmVMZW5ndGgpICogdGhpcy5oZWlnaHRPcmFjbGUubGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICBsZXQgdG9wLCBib3Q7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRGcmFjID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRnJhYyA9ICgodGhpcy52aXNpYmxlQm90dG9tIC0gdGhpcy52aXNpYmxlVG9wKSAvIDIgKyBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IHRhcmdldEZyYWMgLSBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgICAgIGJvdCA9IHRhcmdldEZyYWMgKyBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSAodGhpcy52aXNpYmxlVG9wIC0gbGluZS50b3AgLSBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGJvdCA9ICh0aGlzLnZpc2libGVCb3R0b20gLSBsaW5lLnRvcCArIG1hcmdpbkhlaWdodCkgLyBsaW5lLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCB0b3ApO1xuICAgICAgICAgICAgICAgIHZpZXdUbyA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIGJvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxXaWR0aCA9IHN0cnVjdHVyZS50b3RhbCAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDtcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luV2lkdGggPSBtYXJnaW4gKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IGhvcml6T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodG90YWxXaWR0aCA+IDIwMDAwMDAgLyogVlAuTWF4SG9yaXpHYXAgKi8pXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG9sZCBvZiBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkLmZyb20gPj0gbGluZS5mcm9tICYmIG9sZC5mcm9tIDwgbGluZS50byAmJiBvbGQuc2l6ZSAhPSBvbGQuZGlzcGxheVNpemUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQuZnJvbSAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aCArIGhvcml6T2Zmc2V0IDwgdGhpcy5waXhlbFZpZXdwb3J0LmxlZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9yaXpPZmZzZXQgPSBvbGQuc2l6ZSAtIG9sZC5kaXNwbGF5U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBweExlZnQgPSB0aGlzLnBpeGVsVmlld3BvcnQubGVmdCArIGhvcml6T2Zmc2V0LCBweFJpZ2h0ID0gdGhpcy5waXhlbFZpZXdwb3J0LnJpZ2h0ICsgaG9yaXpPZmZzZXQ7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQsIHJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RnJhYyA9IGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzcGFjZUZyYWMgPSAoKHB4UmlnaHQgLSBweExlZnQpIC8gMiArIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSB0YXJnZXRGcmFjIC0gc3BhY2VGcmFjO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHRhcmdldEZyYWMgKyBzcGFjZUZyYWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKHB4TGVmdCAtIG1hcmdpbldpZHRoKSAvIHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gKHB4UmlnaHQgKyBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aWV3RnJvbSA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIGxlZnQpO1xuICAgICAgICAgICAgICAgIHZpZXdUbyA9IGZpbmRQb3NpdGlvbihzdHJ1Y3R1cmUsIHJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3RnJvbSA+IGxpbmUuZnJvbSlcbiAgICAgICAgICAgICAgICBhZGRHYXAobGluZS5mcm9tLCB2aWV3RnJvbSwgbGluZSwgc3RydWN0dXJlKTtcbiAgICAgICAgICAgIGlmICh2aWV3VG8gPCBsaW5lLnRvKVxuICAgICAgICAgICAgICAgIGFkZEdhcCh2aWV3VG8sIGxpbmUudG8sIGxpbmUsIHN0cnVjdHVyZSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy52aWV3cG9ydExpbmVzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShsaW5lLnR5cGUpKVxuICAgICAgICAgICAgICAgIGxpbmUudHlwZS5mb3JFYWNoKGNoZWNrTGluZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2hlY2tMaW5lKGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnYXBzO1xuICAgIH1cbiAgICBnYXBTaXplKGxpbmUsIGZyb20sIHRvLCBzdHJ1Y3R1cmUpIHtcbiAgICAgICAgbGV0IGZyYWN0aW9uID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdG8pIC0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgZnJvbSk7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lLmhlaWdodCAqIGZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdHVyZS50b3RhbCAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aCAqIGZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUxpbmVHYXBzKGdhcHMpIHtcbiAgICAgICAgaWYgKCFMaW5lR2FwLnNhbWUoZ2FwcywgdGhpcy5saW5lR2FwcykpIHtcbiAgICAgICAgICAgIHRoaXMubGluZUdhcHMgPSBnYXBzO1xuICAgICAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KGdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyh0aGlzLCB0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZVZpc2libGVSYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBsZXQgZGVjbyA9IHRoaXMuc3RhdGVEZWNvO1xuICAgICAgICBpZiAodGhpcy5saW5lR2Fwcy5sZW5ndGgpXG4gICAgICAgICAgICBkZWNvID0gZGVjby5jb25jYXQodGhpcy5saW5lR2FwRGVjbyk7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgUmFuZ2VTZXQuc3BhbnMoZGVjbywgdGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB7XG4gICAgICAgICAgICBzcGFuKGZyb20sIHRvKSB7IHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7IH0sXG4gICAgICAgICAgICBwb2ludCgpIHsgfVxuICAgICAgICB9LCAyMCk7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gMDtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggIT0gdGhpcy52aXNpYmxlUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IDggLyogVXBkYXRlRmxhZy5WaWV3cG9ydE1vdmVkICovIHwgNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoICYmICEoY2hhbmdlZCAmIDggLyogVXBkYXRlRmxhZy5WaWV3cG9ydE1vdmVkICovKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9sZCA9IHRoaXMudmlzaWJsZVJhbmdlc1tpXSwgbncgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG9sZC5mcm9tICE9IG53LmZyb20gfHwgb2xkLnRvICE9IG53LnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgfD0gNCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0ICovO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFuZ2VzICYmIGNoYW5nZXMubWFwUG9zKG9sZC5mcm9tLCAtMSkgPT0gbncuZnJvbSAmJiBjaGFuZ2VzLm1hcFBvcyhvbGQudG8sIDEpID09IG53LnRvKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgfD0gOCAvKiBVcGRhdGVGbGFnLlZpZXdwb3J0TW92ZWQgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIGxpbmVCbG9ja0F0KHBvcykge1xuICAgICAgICByZXR1cm4gKHBvcyA+PSB0aGlzLnZpZXdwb3J0LmZyb20gJiYgcG9zIDw9IHRoaXMudmlld3BvcnQudG8gJiZcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRMaW5lcy5maW5kKGIgPT4gYi5mcm9tIDw9IHBvcyAmJiBiLnRvID49IHBvcykpIHx8XG4gICAgICAgICAgICBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChwb3MsIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIGxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICByZXR1cm4gKGhlaWdodCA+PSB0aGlzLnZpZXdwb3J0TGluZXNbMF0udG9wICYmIGhlaWdodCA8PSB0aGlzLnZpZXdwb3J0TGluZXNbdGhpcy52aWV3cG9ydExpbmVzLmxlbmd0aCAtIDFdLmJvdHRvbSAmJlxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydExpbmVzLmZpbmQobCA9PiBsLnRvcCA8PSBoZWlnaHQgJiYgbC5ib3R0b20gPj0gaGVpZ2h0KSkgfHxcbiAgICAgICAgICAgIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHRoaXMuc2NhbGVyLmZyb21ET00oaGVpZ2h0KSwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgc2Nyb2xsQW5jaG9yQXQoc2Nyb2xsVG9wKSB7XG4gICAgICAgIGxldCBibG9jayA9IHRoaXMubGluZUJsb2NrQXRIZWlnaHQoc2Nyb2xsVG9wICsgOCk7XG4gICAgICAgIHJldHVybiBibG9jay5mcm9tID49IHRoaXMudmlld3BvcnQuZnJvbSB8fCB0aGlzLnZpZXdwb3J0TGluZXNbMF0udG9wIC0gc2Nyb2xsVG9wID4gMjAwID8gYmxvY2sgOiB0aGlzLnZpZXdwb3J0TGluZXNbMF07XG4gICAgfVxuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAuYmxvY2tBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGhlaWdodCksIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBnZXQgZG9jSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZXIudG9ET00odGhpcy5oZWlnaHRNYXAuaGVpZ2h0KTtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY0hlaWdodCArIHRoaXMucGFkZGluZ1RvcCArIHRoaXMucGFkZGluZ0JvdHRvbTtcbiAgICB9XG59XG5jbGFzcyBWaWV3cG9ydCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpbmVTdHJ1Y3R1cmUoZnJvbSwgdG8sIHN0YXRlRGVjbykge1xuICAgIGxldCByYW5nZXMgPSBbXSwgcG9zID0gZnJvbSwgdG90YWwgPSAwO1xuICAgIFJhbmdlU2V0LnNwYW5zKHN0YXRlRGVjbywgZnJvbSwgdG8sIHtcbiAgICAgICAgc3BhbigpIHsgfSxcbiAgICAgICAgcG9pbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGlmIChmcm9tID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBwb3MsIHRvOiBmcm9tIH0pO1xuICAgICAgICAgICAgICAgIHRvdGFsICs9IGZyb20gLSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSB0bztcbiAgICAgICAgfVxuICAgIH0sIDIwKTsgLy8gV2UncmUgb25seSBpbnRlcmVzdGVkIGluIGNvbGxhcHNlZCByYW5nZXMgb2YgYSBzaWduaWZpY2FudCBzaXplXG4gICAgaWYgKHBvcyA8IHRvKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0byB9KTtcbiAgICAgICAgdG90YWwgKz0gdG8gLSBwb3M7XG4gICAgfVxuICAgIHJldHVybiB7IHRvdGFsLCByYW5nZXMgfTtcbn1cbmZ1bmN0aW9uIGZpbmRQb3NpdGlvbih7IHRvdGFsLCByYW5nZXMgfSwgcmF0aW8pIHtcbiAgICBpZiAocmF0aW8gPD0gMClcbiAgICAgICAgcmV0dXJuIHJhbmdlc1swXS5mcm9tO1xuICAgIGlmIChyYXRpbyA+PSAxKVxuICAgICAgICByZXR1cm4gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICBsZXQgZGlzdCA9IE1hdGguZmxvb3IodG90YWwgKiByYXRpbyk7XG4gICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHJhbmdlc1tpXSwgc2l6ZSA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKGRpc3QgPD0gc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBmcm9tICsgZGlzdDtcbiAgICAgICAgZGlzdCAtPSBzaXplO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRGcmFjdGlvbihzdHJ1Y3R1cmUsIHBvcykge1xuICAgIGxldCBjb3VudGVkID0gMDtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygc3RydWN0dXJlLnJhbmdlcykge1xuICAgICAgICBpZiAocG9zIDw9IHRvKSB7XG4gICAgICAgICAgICBjb3VudGVkICs9IHBvcyAtIGZyb207XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb3VudGVkICs9IHRvIC0gZnJvbTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZWQgLyBzdHJ1Y3R1cmUudG90YWw7XG59XG5mdW5jdGlvbiBmaW5kKGFycmF5LCBmKSB7XG4gICAgZm9yIChsZXQgdmFsIG9mIGFycmF5KVxuICAgICAgICBpZiAoZih2YWwpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8gRG9uJ3Qgc2NhbGUgd2hlbiB0aGUgZG9jdW1lbnQgaGVpZ2h0IGlzIHdpdGhpbiB0aGUgcmFuZ2Ugb2Ygd2hhdFxuLy8gdGhlIERPTSBjYW4gaGFuZGxlLlxuY29uc3QgSWRTY2FsZXIgPSB7XG4gICAgdG9ET00obikgeyByZXR1cm4gbjsgfSxcbiAgICBmcm9tRE9NKG4pIHsgcmV0dXJuIG47IH0sXG4gICAgc2NhbGU6IDEsXG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyID09IHRoaXM7IH1cbn07XG4vLyBXaGVuIHRoZSBoZWlnaHQgaXMgdG9vIGJpZyAoPiBWUC5NYXhET01IZWlnaHQpLCBzY2FsZSBkb3duIHRoZVxuLy8gcmVnaW9ucyBvdXRzaWRlIHRoZSB2aWV3cG9ydHMgc28gdGhhdCB0aGUgdG90YWwgaGVpZ2h0IGlzXG4vLyBWUC5NYXhET01IZWlnaHQuXG5jbGFzcyBCaWdTY2FsZXIge1xuICAgIGNvbnN0cnVjdG9yKG9yYWNsZSwgaGVpZ2h0TWFwLCB2aWV3cG9ydHMpIHtcbiAgICAgICAgbGV0IHZwSGVpZ2h0ID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwO1xuICAgICAgICB0aGlzLnZpZXdwb3J0cyA9IHZpZXdwb3J0cy5tYXAoKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgbGV0IHRvcCA9IGhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCBvcmFjbGUsIDAsIDApLnRvcDtcbiAgICAgICAgICAgIGxldCBib3R0b20gPSBoZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIG9yYWNsZSwgMCwgMCkuYm90dG9tO1xuICAgICAgICAgICAgdnBIZWlnaHQgKz0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIHRvcCwgYm90dG9tLCBkb21Ub3A6IDAsIGRvbUJvdHRvbTogMCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zY2FsZSA9ICg3MDAwMDAwIC8qIFZQLk1heERPTUhlaWdodCAqLyAtIHZwSGVpZ2h0KSAvIChoZWlnaHRNYXAuaGVpZ2h0IC0gdnBIZWlnaHQpO1xuICAgICAgICBmb3IgKGxldCBvYmogb2YgdGhpcy52aWV3cG9ydHMpIHtcbiAgICAgICAgICAgIG9iai5kb21Ub3AgPSBkb21CYXNlICsgKG9iai50b3AgLSBiYXNlKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBkb21CYXNlID0gb2JqLmRvbUJvdHRvbSA9IG9iai5kb21Ub3AgKyAob2JqLmJvdHRvbSAtIG9iai50b3ApO1xuICAgICAgICAgICAgYmFzZSA9IG9iai5ib3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9ET00obikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdnAgPSBpIDwgdGhpcy52aWV3cG9ydHMubGVuZ3RoID8gdGhpcy52aWV3cG9ydHNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAudG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBkb21CYXNlICsgKG4gLSBiYXNlKSAqIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBpZiAobiA8PSB2cC5ib3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLmRvbVRvcCArIChuIC0gdnAudG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XG4gICAgICAgICAgICBkb21CYXNlID0gdnAuZG9tQm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21ET00obikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYmFzZSA9IDAsIGRvbUJhc2UgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdnAgPSBpIDwgdGhpcy52aWV3cG9ydHMubGVuZ3RoID8gdGhpcy52aWV3cG9ydHNbaV0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCF2cCB8fCBuIDwgdnAuZG9tVG9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlICsgKG4gLSBkb21CYXNlKSAvIHRoaXMuc2NhbGU7XG4gICAgICAgICAgICBpZiAobiA8PSB2cC5kb21Cb3R0b20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZwLnRvcCArIChuIC0gdnAuZG9tVG9wKTtcbiAgICAgICAgICAgIGJhc2UgPSB2cC5ib3R0b207XG4gICAgICAgICAgICBkb21CYXNlID0gdnAuZG9tQm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgQmlnU2NhbGVyKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUgPT0gb3RoZXIuc2NhbGUgJiYgdGhpcy52aWV3cG9ydHMubGVuZ3RoID09IG90aGVyLnZpZXdwb3J0cy5sZW5ndGggJiZcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRzLmV2ZXJ5KCh2cCwgaSkgPT4gdnAuZnJvbSA9PSBvdGhlci52aWV3cG9ydHNbaV0uZnJvbSAmJiB2cC50byA9PSBvdGhlci52aWV3cG9ydHNbaV0udG8pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjYWxlQmxvY2soYmxvY2ssIHNjYWxlcikge1xuICAgIGlmIChzY2FsZXIuc2NhbGUgPT0gMSlcbiAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIGxldCBiVG9wID0gc2NhbGVyLnRvRE9NKGJsb2NrLnRvcCksIGJCb3R0b20gPSBzY2FsZXIudG9ET00oYmxvY2suYm90dG9tKTtcbiAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhibG9jay5mcm9tLCBibG9jay5sZW5ndGgsIGJUb3AsIGJCb3R0b20gLSBiVG9wLCBBcnJheS5pc0FycmF5KGJsb2NrLl9jb250ZW50KSA/IGJsb2NrLl9jb250ZW50Lm1hcChiID0+IHNjYWxlQmxvY2soYiwgc2NhbGVyKSkgOiBibG9jay5fY29udGVudCk7XG59XG5cbmNvbnN0IHRoZW1lID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHN0cnMgPT4gc3Rycy5qb2luKFwiIFwiKSB9KTtcbmNvbnN0IGRhcmtUaGVtZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLmluZGV4T2YodHJ1ZSkgPiAtMSB9KTtcbmNvbnN0IGJhc2VUaGVtZUlEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKSwgYmFzZUxpZ2h0SUQgPSAvKkBfX1BVUkVfXyovU3R5bGVNb2R1bGUubmV3TmFtZSgpLCBiYXNlRGFya0lEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKTtcbmNvbnN0IGxpZ2h0RGFya0lEcyA9IHsgXCImbGlnaHRcIjogXCIuXCIgKyBiYXNlTGlnaHRJRCwgXCImZGFya1wiOiBcIi5cIiArIGJhc2VEYXJrSUQgfTtcbmZ1bmN0aW9uIGJ1aWxkVGhlbWUobWFpbiwgc3BlYywgc2NvcGVzKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZU1vZHVsZShzcGVjLCB7XG4gICAgICAgIGZpbmlzaChzZWwpIHtcbiAgICAgICAgICAgIHJldHVybiAvJi8udGVzdChzZWwpID8gc2VsLnJlcGxhY2UoLyZcXHcqLywgbSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG0gPT0gXCImXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWluO1xuICAgICAgICAgICAgICAgIGlmICghc2NvcGVzIHx8ICFzY29wZXNbbV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnN1cHBvcnRlZCBzZWxlY3RvcjogJHttfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZXNbbV07XG4gICAgICAgICAgICB9KSA6IG1haW4gKyBcIiBcIiArIHNlbDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgYmFzZVRoZW1lJDEgPSAvKkBfX1BVUkVfXyovYnVpbGRUaGVtZShcIi5cIiArIGJhc2VUaGVtZUlELCB7XG4gICAgXCImXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmUgIWltcG9ydGFudFwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBcIiYuY20tZm9jdXNlZFwiOiB7XG4gICAgICAgICAgICAvLyBQcm92aWRlIGEgc2ltcGxlIGRlZmF1bHQgb3V0bGluZSB0byBtYWtlIHN1cmUgYSBmb2N1c2VkXG4gICAgICAgICAgICAvLyBlZGl0b3IgaXMgdmlzdWFsbHkgZGlzdGluY3QuIENhbid0IGxlYXZlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd2lsbCBhcHBseSB0byB0aGUgY29udGVudCBlbGVtZW50LCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gaW5zaWRlIHRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lciBhbmQgZG9lc24ndCBpbmNsdWRlIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVycy4gV2UgYWxzbyBjYW4ndCB1c2UgYW4gJ2F1dG8nIG91dGxpbmUsIHNpbmNlIHRob3NlXG4gICAgICAgICAgICAvLyBhcmUsIGZvciBzb21lIHJlYXNvbiwgZHJhd24gYmVoaW5kIHRoZSBlbGVtZW50IGNvbnRlbnQsIHdoaWNoXG4gICAgICAgICAgICAvLyB3aWxsIGNhdXNlIHRoaW5ncyBsaWtlIHRoZSBhY3RpdmUgbGluZSBiYWNrZ3JvdW5kIHRvIGNvdmVyXG4gICAgICAgICAgICAvLyB0aGUgb3V0bGluZSAoIzI5NykuXG4gICAgICAgICAgICBvdXRsaW5lOiBcIjFweCBkb3R0ZWQgIzIxMjEyMVwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCJcbiAgICB9LFxuICAgIFwiLmNtLXNjcm9sbGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJmbGV4LXN0YXJ0ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgbGluZUhlaWdodDogMS40LFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvd1g6IFwiYXV0b1wiLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICB6SW5kZXg6IDAsXG4gICAgICAgIG92ZXJmbG93QW5jaG9yOiBcIm5vbmVcIixcbiAgICB9LFxuICAgIFwiLmNtLWNvbnRlbnRcIjoge1xuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIGZsZXhHcm93OiAyLFxuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCIsXG4gICAgICAgIHdvcmRXcmFwOiBcIm5vcm1hbFwiLCAvLyBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQ1NlxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBwYWRkaW5nOiBcIjRweCAwXCIsXG4gICAgICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgICAgICBcIiZbY29udGVudGVkaXRhYmxlPXRydWVdXCI6IHtcbiAgICAgICAgICAgIFdlYmtpdFVzZXJNb2RpZnk6IFwicmVhZC13cml0ZS1wbGFpbnRleHQtb25seVwiLFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS1saW5lV3JhcHBpbmdcIjoge1xuICAgICAgICB3aGl0ZVNwYWNlX2ZhbGxiYWNrOiBcInByZS13cmFwXCIsIC8vIEZvciBJRVxuICAgICAgICB3aGl0ZVNwYWNlOiBcImJyZWFrLXNwYWNlc1wiLFxuICAgICAgICB3b3JkQnJlYWs6IFwiYnJlYWstd29yZFwiLCAvLyBGb3IgU2FmYXJpLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgb3ZlcmZsb3ctd3JhcDogYW55d2hlcmVcbiAgICAgICAgb3ZlcmZsb3dXcmFwOiBcImFueXdoZXJlXCIsXG4gICAgICAgIGZsZXhTaHJpbms6IDFcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1jb250ZW50XCI6IHsgY2FyZXRDb2xvcjogXCJibGFja1wiIH0sXG4gICAgXCImZGFyayAuY20tY29udGVudFwiOiB7IGNhcmV0Q29sb3I6IFwid2hpdGVcIiB9LFxuICAgIFwiLmNtLWxpbmVcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMCAycHggMCA2cHhcIlxuICAgIH0sXG4gICAgXCIuY20tbGF5ZXJcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGNvbnRhaW46IFwic2l6ZSBzdHlsZVwiLFxuICAgICAgICBcIiYgPiAqXCI6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkOWQ5ZDlcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzIyMlwiXG4gICAgfSxcbiAgICBcIiZsaWdodC5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLXNlbGVjdGlvbkxheWVyIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZDdkNGYwXCJcbiAgICB9LFxuICAgIFwiJmRhcmsuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1zZWxlY3Rpb25MYXllciAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzIzM1wiXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3JMYXllclwiOiB7XG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgfSxcbiAgICBcIiYuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1jdXJzb3JMYXllclwiOiB7XG4gICAgICAgIGFuaW1hdGlvbjogXCJzdGVwcygxKSBjbS1ibGluayAxLjJzIGluZmluaXRlXCJcbiAgICB9LFxuICAgIC8vIFR3byBhbmltYXRpb25zIGRlZmluZWQgc28gdGhhdCB3ZSBjYW4gc3dpdGNoIGJldHdlZW4gdGhlbSB0b1xuICAgIC8vIHJlc3RhcnQgdGhlIGFuaW1hdGlvbiB3aXRob3V0IGZvcmNpbmcgYW5vdGhlciBzdHlsZVxuICAgIC8vIHJlY29tcHV0YXRpb24uXG4gICAgXCJAa2V5ZnJhbWVzIGNtLWJsaW5rXCI6IHsgXCIwJVwiOiB7fSwgXCI1MCVcIjogeyBvcGFjaXR5OiAwIH0sIFwiMTAwJVwiOiB7fSB9LFxuICAgIFwiQGtleWZyYW1lcyBjbS1ibGluazJcIjogeyBcIjAlXCI6IHt9LCBcIjUwJVwiOiB7IG9wYWNpdHk6IDAgfSwgXCIxMDAlXCI6IHt9IH0sXG4gICAgXCIuY20tY3Vyc29yLCAuY20tZHJvcEN1cnNvclwiOiB7XG4gICAgICAgIGJvcmRlckxlZnQ6IFwiMS4ycHggc29saWQgYmxhY2tcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCItMC42cHhcIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3JcIjoge1xuICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgYm9yZGVyTGVmdENvbG9yOiBcIiNkZGRcIlxuICAgIH0sXG4gICAgXCIuY20tZHJvcEN1cnNvclwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICB9LFxuICAgIFwiJi5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLWN1cnNvckxheWVyIC5jbS1jdXJzb3JcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCJcbiAgICB9LFxuICAgIFwiLmNtLWlzb1wiOiB7XG4gICAgICAgIHVuaWNvZGVCaWRpOiBcImlzb2xhdGVcIlxuICAgIH0sXG4gICAgXCIuY20tYW5ub3VuY2VkXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwiZml4ZWRcIixcbiAgICAgICAgdG9wOiBcIi0xMDAwMHB4XCJcbiAgICB9LFxuICAgIFwiQG1lZGlhIHByaW50XCI6IHtcbiAgICAgICAgXCIuY20tYW5ub3VuY2VkXCI6IHsgZGlzcGxheTogXCJub25lXCIgfVxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2NjZWVmZjQ0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1hY3RpdmVMaW5lXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWVlZmYzM1wiIH0sXG4gICAgXCImbGlnaHQgLmNtLXNwZWNpYWxDaGFyXCI6IHsgY29sb3I6IFwicmVkXCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zcGVjaWFsQ2hhclwiOiB7IGNvbG9yOiBcIiNmNzhcIiB9LFxuICAgIFwiLmNtLWd1dHRlcnNcIjoge1xuICAgICAgICBmbGV4U2hyaW5rOiAwLFxuICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgaW5zZXRJbmxpbmVTdGFydDogMCxcbiAgICAgICAgekluZGV4OiAyMDBcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiNmNWY1ZjVcIixcbiAgICAgICAgY29sb3I6IFwiIzZjNmM2Y1wiLFxuICAgICAgICBib3JkZXJSaWdodDogXCIxcHggc29saWQgI2RkZFwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1ndXR0ZXJzXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgICAgY29sb3I6IFwiI2NjY1wiXG4gICAgfSxcbiAgICBcIi5jbS1ndXR0ZXJcIjoge1xuICAgICAgICBkaXNwbGF5OiBcImZsZXggIWltcG9ydGFudFwiLCAvLyBOZWNlc3NhcnkgLS0gcHJldmVudHMgbWFyZ2luIGNvbGxhcHNpbmdcbiAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIixcbiAgICAgICAgZmxleFNocmluazogMCxcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgbWluSGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbiAgICB9LFxuICAgIFwiLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiXG4gICAgfSxcbiAgICBcIi5jbS1saW5lTnVtYmVycyAuY20tZ3V0dGVyRWxlbWVudFwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMCAzcHggMCA1cHhcIixcbiAgICAgICAgbWluV2lkdGg6IFwiMjBweFwiLFxuICAgICAgICB0ZXh0QWxpZ246IFwicmlnaHRcIixcbiAgICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWFjdGl2ZUxpbmVHdXR0ZXJcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2UyZjJmZlwiXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiMyMjIyMjdcIlxuICAgIH0sXG4gICAgXCIuY20tcGFuZWxzXCI6IHtcbiAgICAgICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAgICAgcG9zaXRpb246IFwic3RpY2t5XCIsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICB6SW5kZXg6IDMwMFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCIsXG4gICAgICAgIGNvbG9yOiBcImJsYWNrXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHMtdG9wXCI6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1wYW5lbHMtYm90dG9tXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wOiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXBhbmVsc1wiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiLmNtLXRhYlwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcImJvdHRvbVwiXG4gICAgfSxcbiAgICBcIi5jbS13aWRnZXRCdWZmZXJcIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRleHQtdG9wXCIsXG4gICAgICAgIGhlaWdodDogXCIxZW1cIixcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lXCJcbiAgICB9LFxuICAgIFwiLmNtLXBsYWNlaG9sZGVyXCI6IHtcbiAgICAgICAgY29sb3I6IFwiIzg4OFwiLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRvcFwiLFxuICAgIH0sXG4gICAgXCIuY20taGlnaGxpZ2h0U3BhY2VcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwicmFkaWFsLWdyYWRpZW50KGNpcmNsZSBhdCA1MCUgNTUlLCAjYWFhIDIwJSwgdHJhbnNwYXJlbnQgNSUpXCIsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogXCJjZW50ZXJcIixcbiAgICB9LFxuICAgIFwiLmNtLWhpZ2hsaWdodFRhYlwiOiB7XG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgnZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjBcIj48cGF0aCBzdHJva2U9XCIlMjM4ODhcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIm5vbmVcIiBkPVwiTTEgMTBIMTk2TDE5MCA1TTE5MCAxNUwxOTYgMTBNMTk3IDRMMTk3IDE2XCIvPjwvc3ZnPicpYCxcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IFwiYXV0byAxMDAlXCIsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvbjogXCJyaWdodCA5MCVcIixcbiAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogXCJuby1yZXBlYXRcIlxuICAgIH0sXG4gICAgXCIuY20tdHJhaWxpbmdTcGFjZVwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZmYzMzIyNTVcIlxuICAgIH0sXG4gICAgXCIuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIDFlbVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiMXB4XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNlZmYxZjUsICNkOWQ5ZGYpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoI2I0YjRiNCwgI2QwZDNkNilcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMzOTM5MzksICMxMTEpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoIzExMSwgIzMzMylcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICAgICAgICBjb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHNpbHZlclwiLFxuICAgICAgICBwYWRkaW5nOiBcIi4yZW0gLjVlbVwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzU1NVwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiXG4gICAgfVxufSwgbGlnaHREYXJrSURzKTtcblxuY29uc3Qgb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZVxufTtcbi8vIElFMTEgaGFzIHZlcnkgYnJva2VuIG11dGF0aW9uIG9ic2VydmVycywgc28gd2UgYWxzbyBsaXN0ZW4gdG9cbi8vIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZCB0aGVyZVxuY29uc3QgdXNlQ2hhckRhdGEgPSBicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMTtcbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZWRpdENvbnRleHQgPSBudWxsO1xuICAgICAgICAvLyBUaGUga25vd24gc2VsZWN0aW9uLiBLZXB0IGluIG91ciBvd24gb2JqZWN0LCBhcyBvcHBvc2VkIHRvIGp1c3RcbiAgICAgICAgLy8gZGlyZWN0bHkgYWNjZXNzaW5nIHRoZSBzZWxlY3Rpb24gYmVjYXVzZTpcbiAgICAgICAgLy8gIC0gU2FmYXJpIGRvZXNuJ3QgcmVwb3J0IHRoZSByaWdodCBzZWxlY3Rpb24gaW4gc2hhZG93IERPTVxuICAgICAgICAvLyAgLSBSZWFkaW5nIGZyb20gdGhlIHNlbGVjdGlvbiBmb3JjZXMgYSBET00gbGF5b3V0XG4gICAgICAgIC8vICAtIFRoaXMgd2F5LCB3ZSBjYW4gaWdub3JlIHNlbGVjdGlvbmNoYW5nZSBldmVudHMgaWYgd2UgaGF2ZVxuICAgICAgICAvLyAgICBhbHJlYWR5IHNlZW4gdGhlICduZXcnIHNlbGVjdGlvblxuICAgICAgICB0aGlzLnNlbGVjdGlvblJhbmdlID0gbmV3IERPTVNlbGVjdGlvblN0YXRlO1xuICAgICAgICAvLyBTZXQgd2hlbiBhIHNlbGVjdGlvbiBjaGFuZ2UgaXMgZGV0ZWN0ZWQsIGNsZWFyZWQgb24gZmx1c2hcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gLTE7XG4gICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RDaGFuZ2UgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbFRhcmdldHMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2l6ZVNjcm9sbCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5nYXBzID0gW107XG4gICAgICAgIHRoaXMucHJpbnRRdWVyeSA9IG51bGw7XG4gICAgICAgIC8vIFRpbWVvdXQgZm9yIHNjaGVkdWxpbmcgY2hlY2sgb2YgdGhlIHBhcmVudHMgdGhhdCBuZWVkIHNjcm9sbCBoYW5kbGVyc1xuICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gLTE7XG4gICAgICAgIHRoaXMuZG9tID0gdmlldy5jb250ZW50RE9NO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IG11dCBvZiBtdXRhdGlvbnMpXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG11dCk7XG4gICAgICAgICAgICAvLyBJRTExIHdpbGwgc29tZXRpbWVzIChvbiB0eXBpbmcgb3ZlciBhIHNlbGVjdGlvbiBvclxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgb3V0IGEgc2luZ2xlIGNoYXJhY3RlciB0ZXh0IG5vZGUpIGNhbGwgdGhlXG4gICAgICAgICAgICAvLyBvYnNlcnZlciBjYWxsYmFjayBiZWZvcmUgYWN0dWFsbHkgdXBkYXRpbmcgdGhlIERPTS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBVbnJlbGF0ZWRseSwgaU9TIFNhZmFyaSB3aWxsLCB3aGVuIGVuZGluZyBhIGNvbXBvc2l0aW9uLFxuICAgICAgICAgICAgLy8gc29tZXRpbWVzIGZpcnN0IGNsZWFyIGl0LCBkZWxpdmVyIHRoZSBtdXRhdGlvbnMsIGFuZCB0aGVuXG4gICAgICAgICAgICAvLyByZWluc2VydCB0aGUgZmluaXNoZWQgdGV4dC4gQ29kZU1pcnJvcidzIGhhbmRsaW5nIG9mIHRoZVxuICAgICAgICAgICAgLy8gZGVsZXRpb24gd2lsbCBwcmV2ZW50IHRoZSByZWluc2VydGlvbiBmcm9tIGhhcHBlbmluZyxcbiAgICAgICAgICAgIC8vIGJyZWFraW5nIGNvbXBvc2l0aW9uLlxuICAgICAgICAgICAgaWYgKChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMSB8fCBicm93c2VyLmlvcyAmJiB2aWV3LmNvbXBvc2luZykgJiZcbiAgICAgICAgICAgICAgICBtdXRhdGlvbnMuc29tZShtID0+IG0udHlwZSA9PSBcImNoaWxkTGlzdFwiICYmIG0ucmVtb3ZlZE5vZGVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgICAgICBtLnR5cGUgPT0gXCJjaGFyYWN0ZXJEYXRhXCIgJiYgbS5vbGRWYWx1ZS5sZW5ndGggPiBtLnRhcmdldC5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoU29vbigpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh3aW5kb3cuRWRpdENvbnRleHQgJiYgdmlldy5jb25zdHJ1Y3Rvci5FRElUX0NPTlRFWFQgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAvLyBDaHJvbWUgPDEyNiBkb2Vzbid0IHN1cHBvcnQgaW52ZXJ0ZWQgc2VsZWN0aW9ucyBpbiBlZGl0IGNvbnRleHQgKCMxMzkyKVxuICAgICAgICAgICAgIShicm93c2VyLmNocm9tZSAmJiBicm93c2VyLmNocm9tZV92ZXJzaW9uIDwgMTI2KSkge1xuICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dCA9IG5ldyBFZGl0Q29udGV4dE1hbmFnZXIodmlldyk7XG4gICAgICAgICAgICBpZiAodmlldy5zdGF0ZS5mYWNldChlZGl0YWJsZSkpXG4gICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmVkaXRDb250ZXh0ID0gdGhpcy5lZGl0Q29udGV4dC5lZGl0Q29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLm9uQ2hhckRhdGEgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goeyB0YXJnZXQ6IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjaGFyYWN0ZXJEYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBldmVudC5wcmV2VmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZXNpemUgPSB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25QcmludCA9IHRoaXMub25QcmludC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uU2Nyb2xsID0gdGhpcy5vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEpXG4gICAgICAgICAgICB0aGlzLnByaW50UXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYShcInByaW50XCIpO1xuICAgICAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMudmlldy5kb2NWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdFVwZGF0ZSkgPCBEYXRlLm5vdygpIC0gNzUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25SZXNpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVTY3JvbGwub2JzZXJ2ZSh2aWV3LnNjcm9sbERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4gPSB2aWV3Lndpbik7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudENoZWNrIDwgMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IHNldFRpbWVvdXQodGhpcy5saXN0ZW5Gb3JTY3JvbGwuYmluZCh0aGlzKSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCAmJiAoZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvID4gMCkgIT0gdGhpcy5pbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSAhdGhpcy5pbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZyAhPSB0aGlzLnZpZXcuaW5WaWV3KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgeyB0aHJlc2hvbGQ6IFswLCAuMDAxXSB9KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uLm9ic2VydmUodGhpcy5kb20pO1xuICAgICAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCAmJiBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPiAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbkZvclNjcm9sbCgpO1xuICAgICAgICB0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICAgIH1cbiAgICBvblNjcm9sbENoYW5nZWQoZSkge1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5ydW5IYW5kbGVycyhcInNjcm9sbFwiLCBlKTtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgdGhpcy52aWV3Lm1lYXN1cmUoKTtcbiAgICB9XG4gICAgb25TY3JvbGwoZSkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3RpbmcpXG4gICAgICAgICAgICB0aGlzLmZsdXNoKGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdENvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5lZGl0Q29udGV4dC5tZWFzdXJlUmVxKTtcbiAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZSk7XG4gICAgfVxuICAgIG9uUmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVUaW1lb3V0IDwgMClcbiAgICAgICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgIH1cbiAgICBvblByaW50KGV2ZW50KSB7XG4gICAgICAgIGlmICgoZXZlbnQudHlwZSA9PSBcImNoYW5nZVwiIHx8ICFldmVudC50eXBlKSAmJiAhZXZlbnQubWF0Y2hlcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudmlldy5tZWFzdXJlKCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuICAgIHVwZGF0ZUdhcHMoZ2Fwcykge1xuICAgICAgICBpZiAodGhpcy5nYXBJbnRlcnNlY3Rpb24gJiYgKGdhcHMubGVuZ3RoICE9IHRoaXMuZ2Fwcy5sZW5ndGggfHwgdGhpcy5nYXBzLnNvbWUoKGcsIGkpID0+IGcgIT0gZ2Fwc1tpXSkpKSB7XG4gICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBnYXAgb2YgZ2FwcylcbiAgICAgICAgICAgICAgICB0aGlzLmdhcEludGVyc2VjdGlvbi5vYnNlcnZlKGdhcCk7XG4gICAgICAgICAgICB0aGlzLmdhcHMgPSBnYXBzO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGxldCB3YXNDaGFuZ2VkID0gdGhpcy5zZWxlY3Rpb25DaGFuZ2VkO1xuICAgICAgICBpZiAoIXRoaXMucmVhZFNlbGVjdGlvblJhbmdlKCkgfHwgdGhpcy5kZWxheWVkQW5kcm9pZEtleSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcywgc2VsID0gdGhpcy5zZWxlY3Rpb25SYW5nZTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdGhpcy5kb20gOiAhaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCBzZWwpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgY29udGV4dCA9IHNlbC5hbmNob3JOb2RlICYmIHZpZXcuZG9jVmlldy5uZWFyZXN0KHNlbC5hbmNob3JOb2RlKTtcbiAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5pZ25vcmVFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgIGlmICghd2FzQ2hhbmdlZClcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGlvbnMgb24gSUUxMSBmaXJlIHRoZWlyIGV2ZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIsIGdpdmluZ1xuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcbiAgICAgICAgLy8gcmVwb3J0ZWQuXG4gICAgICAgIC8vIENocm9tZSBBbmRyb2lkIGhhcyBhIHNpbWlsYXIgaXNzdWUgd2hlbiBiYWNrc3BhY2luZyBvdXQgYVxuICAgICAgICAvLyBzZWxlY3Rpb24gKCM2NDUpLlxuICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSkgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiZcbiAgICAgICAgICAgIC8vIChTZWxlY3Rpb24uaXNDb2xsYXBzZWQgaXNuJ3QgcmVsaWFibGUgb24gSUUpXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5mbHVzaChmYWxzZSk7XG4gICAgfVxuICAgIHJlYWRTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdGhpcztcbiAgICAgICAgLy8gVGhlIFNlbGVjdGlvbiBvYmplY3QgaXMgYnJva2VuIGluIHNoYWRvdyByb290cyBpbiBTYWZhcmkuIFNlZVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQxNFxuICAgICAgICBsZXQgc2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgICAgIGlmICghc2VsZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcmFuZ2UgPSBicm93c2VyLnNhZmFyaSAmJiB2aWV3LnJvb3Qubm9kZVR5cGUgPT0gMTEgJiZcbiAgICAgICAgICAgIHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZG9tICYmXG4gICAgICAgICAgICBzYWZhcmlTZWxlY3Rpb25SYW5nZUhhY2sodGhpcy52aWV3LCBzZWxlY3Rpb24pIHx8IHNlbGVjdGlvbjtcbiAgICAgICAgaWYgKCFyYW5nZSB8fCB0aGlzLnNlbGVjdGlvblJhbmdlLmVxKHJhbmdlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGxvY2FsID0gaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCByYW5nZSk7XG4gICAgICAgIC8vIERldGVjdCB0aGUgc2l0dWF0aW9uIHdoZXJlIHRoZSBicm93c2VyIGhhcywgb24gZm9jdXMsIG1vdmVkIHRoZVxuICAgICAgICAvLyBzZWxlY3Rpb24gdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb250ZW50IGVsZW1lbnQuIFJlc2V0IGl0IHRvIHRoZVxuICAgICAgICAvLyBwb3NpdGlvbiBmcm9tIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAgICAgIGlmIChsb2NhbCAmJiAhdGhpcy5zZWxlY3Rpb25DaGFuZ2VkICYmXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lIDwgRGF0ZS5ub3coKSAtIDMwMCAmJlxuICAgICAgICAgICAgYXRFbGVtZW50U3RhcnQodGhpcy5kb20sIHJhbmdlKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgICAgICB2aWV3LmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXRSYW5nZShyYW5nZSk7XG4gICAgICAgIGlmIChsb2NhbClcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb25SYW5nZShhbmNob3IsIGhlYWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQsIGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgY2xlYXJTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQobnVsbCwgMCwgbnVsbCwgMCk7XG4gICAgfVxuICAgIGxpc3RlbkZvclNjcm9sbCgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRDaGVjayA9IC0xO1xuICAgICAgICBsZXQgaSA9IDAsIGNoYW5nZWQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBkb20gPSB0aGlzLmRvbTsgZG9tOykge1xuICAgICAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkICYmIGkgPCB0aGlzLnNjcm9sbFRhcmdldHMubGVuZ3RoICYmIHRoaXMuc2Nyb2xsVGFyZ2V0c1tpXSA9PSBkb20pXG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuc2Nyb2xsVGFyZ2V0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZC5wdXNoKGRvbSk7XG4gICAgICAgICAgICAgICAgZG9tID0gZG9tLmFzc2lnbmVkU2xvdCB8fCBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5ob3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCB0aGlzLnNjcm9sbFRhcmdldHMubGVuZ3RoICYmICFjaGFuZ2VkKVxuICAgICAgICAgICAgY2hhbmdlZCA9IHRoaXMuc2Nyb2xsVGFyZ2V0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMpXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzID0gY2hhbmdlZClcbiAgICAgICAgICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmUoZikge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUodGhpcy5kb20sIG9ic2VydmVPcHRpb25zKTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgfVxuICAgIC8vIFRocm93IGF3YXkgYW55IHBlbmRpbmcgY2hhbmdlc1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnByb2Nlc3NSZWNvcmRzKCk7XG4gICAgICAgIHRoaXMucXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIENocm9tZSBBbmRyb2lkLCBlc3BlY2lhbGx5IGluIGNvbWJpbmF0aW9uIHdpdGggR0JvYXJkLCBub3Qgb25seVxuICAgIC8vIGRvZXNuJ3QgcmVsaWFibHkgZmlyZSByZWd1bGFyIGtleSBldmVudHMsIGJ1dCBhbHNvIG9mdGVuXG4gICAgLy8gc3Vycm91bmRzIHRoZSBlZmZlY3Qgb2YgZW50ZXIgb3IgYmFja3NwYWNlIHdpdGggYSBidW5jaCBvZlxuICAgIC8vIGNvbXBvc2l0aW9uIGV2ZW50cyB0aGF0LCB3aGVuIGludGVycnVwdGVkLCBjYXVzZSB0ZXh0IGR1cGxpY2F0aW9uXG4gICAgLy8gb3Igb3RoZXIga2luZHMgb2YgY29ycnVwdGlvbi4gVGhpcyBoYWNrIG1ha2VzIHRoZSBlZGl0b3IgYmFjayBvZmZcbiAgICAvLyBmcm9tIGhhbmRsaW5nIERPTSBjaGFuZ2VzIGZvciBhIG1vbWVudCB3aGVuIHN1Y2ggYSBrZXkgaXNcbiAgICAvLyBkZXRlY3RlZCAodmlhIGJlZm9yZWlucHV0IG9yIGtleWRvd24pLCBhbmQgdGhlbiB0cmllcyB0byBmbHVzaFxuICAgIC8vIHRoZW0gb3IsIGlmIHRoYXQgaGFzIG5vIGVmZmVjdCwgZGlzcGF0Y2hlcyB0aGUgZ2l2ZW4ga2V5LlxuICAgIGRlbGF5QW5kcm9pZEtleShrZXksIGtleUNvZGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkpIHtcbiAgICAgICAgICAgIGxldCBmbHVzaCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA9IGtleS5rZXlDb2RlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmbHVzaGVkID0gdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZsdXNoZWQgJiYga2V5LmZvcmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodGhpcy5kb20sIGtleS5rZXksIGtleS5rZXlDb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSB0aGlzLnZpZXcud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZShmbHVzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgYmFja3NwYWNlIGJlZm9yZWlucHV0IGlzIHNvbWV0aW1lcyBzaWduYWxsZWQgc3B1cmlvdXNseSxcbiAgICAgICAgLy8gRW50ZXIgYWx3YXlzIHRha2VzIHByZWNlZGVuY2UuXG4gICAgICAgIGlmICghdGhpcy5kZWxheWVkQW5kcm9pZEtleSB8fCBrZXkgPT0gXCJFbnRlclwiKVxuICAgICAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IHtcbiAgICAgICAgICAgICAgICBrZXksIGtleUNvZGUsXG4gICAgICAgICAgICAgICAgLy8gT25seSBydW4gdGhlIGtleSBoYW5kbGVyIHdoZW4gbm8gY2hhbmdlcyBhcmUgZGV0ZWN0ZWQgaWZcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzbid0IGNvbWluZyByaWdodCBhZnRlciBhbm90aGVyIGNoYW5nZSwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAgICAgICAgIC8vIGl0IGlzIHByb2JhYmx5IHBhcnQgb2YgYSB3ZWlyZCBjaGFpbiBvZiB1cGRhdGVzLCBhbmQgc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gYmUgaWdub3JlZCBpZiBpdCByZXR1cm5zIHRoZSBET00gdG8gaXRzIHByZXZpb3VzIHN0YXRlLlxuICAgICAgICAgICAgICAgIGZvcmNlOiB0aGlzLmxhc3RDaGFuZ2UgPCBEYXRlLm5vdygpIC0gNTAgfHwgISEoKF9hID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcmNlKVxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpIHtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkpO1xuICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSAtMTtcbiAgICB9XG4gICAgZmx1c2hTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPCAwKVxuICAgICAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSB0aGlzLnZpZXcud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7IHRoaXMuZGVsYXllZEZsdXNoID0gLTE7IHRoaXMuZmx1c2goKTsgfSk7XG4gICAgfVxuICAgIGZvcmNlRmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVsYXllZEZsdXNoKTtcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICBwZW5kaW5nUmVjb3JkcygpIHtcbiAgICAgICAgZm9yIChsZXQgbXV0IG9mIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSlcbiAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZTtcbiAgICB9XG4gICAgcHJvY2Vzc1JlY29yZHMoKSB7XG4gICAgICAgIGxldCByZWNvcmRzID0gdGhpcy5wZW5kaW5nUmVjb3JkcygpO1xuICAgICAgICBpZiAocmVjb3Jkcy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIGxldCBmcm9tID0gLTEsIHRvID0gLTEsIHR5cGVPdmVyID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlYWRNdXRhdGlvbihyZWNvcmQpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50eXBlT3ZlcilcbiAgICAgICAgICAgICAgICB0eXBlT3ZlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICh7IGZyb20sIHRvIH0gPSByYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcm9tID0gTWF0aC5taW4ocmFuZ2UuZnJvbSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heChyYW5nZS50bywgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvLCB0eXBlT3ZlciB9O1xuICAgIH1cbiAgICByZWFkQ2hhbmdlKCkge1xuICAgICAgICBsZXQgeyBmcm9tLCB0bywgdHlwZU92ZXIgfSA9IHRoaXMucHJvY2Vzc1JlY29yZHMoKTtcbiAgICAgICAgbGV0IG5ld1NlbCA9IHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCAmJiBoYXNTZWxlY3Rpb24odGhpcy5kb20sIHRoaXMuc2VsZWN0aW9uUmFuZ2UpO1xuICAgICAgICBpZiAoZnJvbSA8IDAgJiYgIW5ld1NlbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoZnJvbSA+IC0xKVxuICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubGFzdEZvY3VzVGltZSA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY2hhbmdlID0gbmV3IERPTUNoYW5nZSh0aGlzLnZpZXcsIGZyb20sIHRvLCB0eXBlT3Zlcik7XG4gICAgICAgIHRoaXMudmlldy5kb2NWaWV3LmRvbUNoYW5nZWQgPSB7IG5ld1NlbDogY2hhbmdlLm5ld1NlbCA/IGNoYW5nZS5uZXdTZWwubWFpbiA6IG51bGwgfTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgLy8gQXBwbHkgcGVuZGluZyBjaGFuZ2VzLCBpZiBhbnlcbiAgICBmbHVzaChyZWFkU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgICAgICAvLyBDb21wbGV0ZWx5IGhvbGQgb2ZmIGZsdXNoaW5nIHdoZW4gcGVuZGluZyBrZXlzIGFyZSBzZXTigJR0aGUgY29kZVxuICAgICAgICAvLyBtYW5hZ2luZyB0aG9zZSB3aWxsIG1ha2Ugc3VyZSBwcm9jZXNzUmVjb3JkcyBpcyBjYWxsZWQgYW5kIHRoZVxuICAgICAgICAvLyB2aWV3IGlzIHJlc3luY2hyb25pemVkIGFmdGVyXG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA+PSAwIHx8IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChyZWFkU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IGRvbUNoYW5nZSA9IHRoaXMucmVhZENoYW5nZSgpO1xuICAgICAgICBpZiAoIWRvbUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0U3RhdGUgPSB0aGlzLnZpZXcuc3RhdGU7XG4gICAgICAgIGxldCBoYW5kbGVkID0gYXBwbHlET01DaGFuZ2UodGhpcy52aWV3LCBkb21DaGFuZ2UpO1xuICAgICAgICAvLyBUaGUgdmlldyB3YXNuJ3QgdXBkYXRlZCBidXQgRE9NL3NlbGVjdGlvbiBjaGFuZ2VzIHdlcmUgc2Vlbi4gUmVzZXQgdGhlIHZpZXcuXG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUgPT0gc3RhcnRTdGF0ZSAmJlxuICAgICAgICAgICAgKGRvbUNoYW5nZS5kb21DaGFuZ2VkIHx8IGRvbUNoYW5nZS5uZXdTZWwgJiYgIWRvbUNoYW5nZS5uZXdTZWwubWFpbi5lcSh0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4pKSlcbiAgICAgICAgICAgIHRoaXMudmlldy51cGRhdGUoW10pO1xuICAgICAgICByZXR1cm4gaGFuZGxlZDtcbiAgICB9XG4gICAgcmVhZE11dGF0aW9uKHJlYykge1xuICAgICAgICBsZXQgY1ZpZXcgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0KHJlYy50YXJnZXQpO1xuICAgICAgICBpZiAoIWNWaWV3IHx8IGNWaWV3Lmlnbm9yZU11dGF0aW9uKHJlYykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY1ZpZXcubWFya0RpcnR5KHJlYy50eXBlID09IFwiYXR0cmlidXRlc1wiKTtcbiAgICAgICAgaWYgKHJlYy50eXBlID09IFwiYXR0cmlidXRlc1wiKVxuICAgICAgICAgICAgY1ZpZXcuZmxhZ3MgfD0gNCAvKiBWaWV3RmxhZy5BdHRyc0RpcnR5ICovO1xuICAgICAgICBpZiAocmVjLnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgbGV0IGNoaWxkQmVmb3JlID0gZmluZENoaWxkKGNWaWV3LCByZWMucHJldmlvdXNTaWJsaW5nIHx8IHJlYy50YXJnZXQucHJldmlvdXNTaWJsaW5nLCAtMSk7XG4gICAgICAgICAgICBsZXQgY2hpbGRBZnRlciA9IGZpbmRDaGlsZChjVmlldywgcmVjLm5leHRTaWJsaW5nIHx8IHJlYy50YXJnZXQubmV4dFNpYmxpbmcsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogY2hpbGRCZWZvcmUgPyBjVmlldy5wb3NBZnRlcihjaGlsZEJlZm9yZSkgOiBjVmlldy5wb3NBdFN0YXJ0LFxuICAgICAgICAgICAgICAgIHRvOiBjaGlsZEFmdGVyID8gY1ZpZXcucG9zQmVmb3JlKGNoaWxkQWZ0ZXIpIDogY1ZpZXcucG9zQXRFbmQsIHR5cGVPdmVyOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlYy50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tOiBjVmlldy5wb3NBdFN0YXJ0LCB0bzogY1ZpZXcucG9zQXRFbmQsIHR5cGVPdmVyOiByZWMudGFyZ2V0Lm5vZGVWYWx1ZSA9PSByZWMub2xkVmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFdpbmRvdyh3aW4pIHtcbiAgICAgICAgaWYgKHdpbiAhPSB0aGlzLndpbikge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pO1xuICAgICAgICAgICAgdGhpcy53aW4gPSB3aW47XG4gICAgICAgICAgICB0aGlzLmFkZFdpbmRvd0xpc3RlbmVycyh0aGlzLndpbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkV2luZG93TGlzdGVuZXJzKHdpbikge1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKTtcbiAgICAgICAgaWYgKHRoaXMucHJpbnRRdWVyeSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJpbnRRdWVyeS5hZGRFdmVudExpc3RlbmVyKVxuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRRdWVyeS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMub25QcmludCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5wcmludFF1ZXJ5LmFkZExpc3RlbmVyKHRoaXMub25QcmludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVwcmludFwiLCB0aGlzLm9uUHJpbnQpO1xuICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgd2luLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIHJlbW92ZVdpbmRvd0xpc3RlbmVycyh3aW4pIHtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMub25SZXNpemUpO1xuICAgICAgICBpZiAodGhpcy5wcmludFF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmludFF1ZXJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIpXG4gICAgICAgICAgICAgICAgdGhpcy5wcmludFF1ZXJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgdGhpcy5vblByaW50KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnByaW50UXVlcnkucmVtb3ZlTGlzdGVuZXIodGhpcy5vblByaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXByaW50XCIsIHRoaXMub25QcmludCk7XG4gICAgICAgIHdpbi5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGVkaXRhYmxlKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQoZWRpdGFibGUpKVxuICAgICAgICAgICAgICAgIHVwZGF0ZS52aWV3LmNvbnRlbnRET00uZWRpdENvbnRleHQgPSB1cGRhdGUuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gdGhpcy5lZGl0Q29udGV4dC5lZGl0Q29udGV4dCA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAoX2EgPSB0aGlzLmludGVyc2VjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKF9iID0gdGhpcy5nYXBJbnRlcnNlY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XG4gICAgICAgIChfYyA9IHRoaXMucmVzaXplU2Nyb2xsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGlzY29ubmVjdCgpO1xuICAgICAgICBmb3IgKGxldCBkb20gb2YgdGhpcy5zY3JvbGxUYXJnZXRzKVxuICAgICAgICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHRoaXMucmVtb3ZlV2luZG93TGlzdGVuZXJzKHRoaXMud2luKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGFyZW50Q2hlY2spO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kZWxheWVkRmx1c2gpO1xuICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSk7XG4gICAgICAgIGlmICh0aGlzLmVkaXRDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuY29udGVudERPTS5lZGl0Q29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRDaGlsZChjVmlldywgZG9tLCBkaXIpIHtcbiAgICB3aGlsZSAoZG9tKSB7XG4gICAgICAgIGxldCBjdXJWaWV3ID0gQ29udGVudFZpZXcuZ2V0KGRvbSk7XG4gICAgICAgIGlmIChjdXJWaWV3ICYmIGN1clZpZXcucGFyZW50ID09IGNWaWV3KVxuICAgICAgICAgICAgcmV0dXJuIGN1clZpZXc7XG4gICAgICAgIGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgICAgICAgZG9tID0gcGFyZW50ICE9IGNWaWV3LmRvbSA/IHBhcmVudCA6IGRpciA+IDAgPyBkb20ubmV4dFNpYmxpbmcgOiBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2VsZWN0aW9uUmFuZ2VGcm9tUmFuZ2UodmlldywgcmFuZ2UpIHtcbiAgICBsZXQgYW5jaG9yTm9kZSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBhbmNob3JPZmZzZXQgPSByYW5nZS5zdGFydE9mZnNldDtcbiAgICBsZXQgZm9jdXNOb2RlID0gcmFuZ2UuZW5kQ29udGFpbmVyLCBmb2N1c09mZnNldCA9IHJhbmdlLmVuZE9mZnNldDtcbiAgICBsZXQgY3VyQW5jaG9yID0gdmlldy5kb2NWaWV3LmRvbUF0UG9zKHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yKTtcbiAgICAvLyBTaW5jZSBzdWNoIGEgcmFuZ2UgZG9lc24ndCBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuY2hvciBhbmQgaGVhZCxcbiAgICAvLyB1c2UgYSBoZXVyaXN0aWMgdGhhdCBmbGlwcyBpdCBhcm91bmQgaWYgaXRzIGVuZCBtYXRjaGVzIHRoZVxuICAgIC8vIGN1cnJlbnQgYW5jaG9yLlxuICAgIGlmIChpc0VxdWl2YWxlbnRQb3NpdGlvbihjdXJBbmNob3Iubm9kZSwgY3VyQW5jaG9yLm9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpXG4gICAgICAgIFthbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXRdID0gW2ZvY3VzTm9kZSwgZm9jdXNPZmZzZXQsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldF07XG4gICAgcmV0dXJuIHsgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH07XG59XG4vLyBVc2VkIHRvIHdvcmsgYXJvdW5kIGEgU2FmYXJpIFNlbGVjdGlvbi9zaGFkb3cgRE9NIGJ1ZyAoIzQxNClcbmZ1bmN0aW9uIHNhZmFyaVNlbGVjdGlvblJhbmdlSGFjayh2aWV3LCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsZWN0aW9uLmdldENvbXBvc2VkUmFuZ2VzKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHNlbGVjdGlvbi5nZXRDb21wb3NlZFJhbmdlcyh2aWV3LnJvb3QpWzBdO1xuICAgICAgICBpZiAocmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRTZWxlY3Rpb25SYW5nZUZyb21SYW5nZSh2aWV3LCByYW5nZSk7XG4gICAgfVxuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgLy8gQmVjYXVzZSBTYWZhcmkgKGF0IGxlYXN0IGluIDIwMTgtMjAyMSkgZG9lc24ndCBwcm92aWRlIHJlZ3VsYXJcbiAgICAvLyBhY2Nlc3MgdG8gdGhlIHNlbGVjdGlvbiBpbnNpZGUgYSBzaGFkb3dyb290LCB3ZSBoYXZlIHRvIHBlcmZvcm0gYVxuICAgIC8vIHJpZGljdWxvdXMgaGFjayB0byBnZXQgYXQgaXTigJR1c2luZyBgZXhlY0NvbW1hbmRgIHRvIHRyaWdnZXIgYVxuICAgIC8vIGBiZWZvcmVJbnB1dGAgZXZlbnQgc28gdGhhdCB3ZSBjYW4gcmVhZCB0aGUgdGFyZ2V0IHJhbmdlIGZyb20gdGhlXG4gICAgLy8gZXZlbnQuXG4gICAgZnVuY3Rpb24gcmVhZChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZm91bmQgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKVswXTtcbiAgICB9XG4gICAgdmlldy5jb250ZW50RE9NLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCByZWFkLCB0cnVlKTtcbiAgICB2aWV3LmRvbS5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5kZW50XCIpO1xuICAgIHZpZXcuY29udGVudERPTS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGZvdW5kID8gYnVpbGRTZWxlY3Rpb25SYW5nZUZyb21SYW5nZSh2aWV3LCBmb3VuZCkgOiBudWxsO1xufVxuY2xhc3MgRWRpdENvbnRleHRNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIC8vIFRoZSBkb2N1bWVudCB3aW5kb3cgZm9yIHdoaWNoIHRoZSB0ZXh0IGluIHRoZSBjb250ZXh0IGlzXG4gICAgICAgIC8vIG1haW50YWluZWQuIEZvciBsYXJnZSBkb2N1bWVudHMsIHRoaXMgbWF5IGJlIHNtYWxsZXIgdGhhbiB0aGVcbiAgICAgICAgLy8gZWRpdG9yIGRvY3VtZW50LiBUaGlzIHdpbmRvdyBhbHdheXMgaW5jbHVkZXMgdGhlIHNlbGVjdGlvbiBoZWFkLlxuICAgICAgICB0aGlzLmZyb20gPSAwO1xuICAgICAgICB0aGlzLnRvID0gMDtcbiAgICAgICAgLy8gV2hlbiBhcHBseWluZyBhIHRyYW5zYWN0aW9uLCB0aGlzIGlzIHVzZWQgdG8gY29tcGFyZSB0aGUgY2hhbmdlXG4gICAgICAgIC8vIG1hZGUgdG8gdGhlIGNvbnRleHQgY29udGVudCB0byB0aGUgY2hhbmdlIGluIHRoZSB0cmFuc2FjdGlvbiBpblxuICAgICAgICAvLyBvcmRlciB0byBtYWtlIHRoZSBtaW5pbWFsIGNoYW5nZXMgdG8gdGhlIGNvbnRleHQgKHNpbmNlIHRvdWNoaW5nXG4gICAgICAgIC8vIHRoYXQgc29tZXRpbWVzIGJyZWFrcyBzZXJpZXMgb2YgbXVsdGlwbGUgZWRpdHMgbWFkZSBmb3IgYSBzaW5nbGVcbiAgICAgICAgLy8gdXNlciBhY3Rpb24gb24gc29tZSBBbmRyb2lkIGtleWJvYXJkcylcbiAgICAgICAgdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgdGhlIGZhY3QgdGhhdCBFZGl0Q29udGV4dCBkb2VzIG5vdCByZXNwb25kXG4gICAgICAgIC8vIHdlbGwgdG8gaGF2aW5nIGl0cyBjb250ZW50IHVwZGF0ZWQgZHVyaW5nIGEgY29tcG9zaXRpb24gKHNlZSAjMTQ3MilcbiAgICAgICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2V0UmFuZ2Uodmlldy5zdGF0ZSk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5lZGl0Q29udGV4dCA9IG5ldyB3aW5kb3cuRWRpdENvbnRleHQoe1xuICAgICAgICAgICAgdGV4dDogdmlldy5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcodGhpcy5mcm9tLCB0aGlzLnRvKSxcbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0OiB0aGlzLnRvQ29udGV4dFBvcyhNYXRoLm1heCh0aGlzLmZyb20sIE1hdGgubWluKHRoaXMudG8sIHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yKSkpLFxuICAgICAgICAgICAgc2VsZWN0aW9uRW5kOiB0aGlzLnRvQ29udGV4dFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnRleHR1cGRhdGUgPSBlID0+IHtcbiAgICAgICAgICAgIGxldCBtYWluID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbiwgeyBhbmNob3IsIGhlYWQgfSA9IG1haW47XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMudG9FZGl0b3JQb3MoZS51cGRhdGVSYW5nZVN0YXJ0KSwgdG8gPSB0aGlzLnRvRWRpdG9yUG9zKGUudXBkYXRlUmFuZ2VFbmQpO1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCAmJiAhdGhpcy5jb21wb3NpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wb3NpbmcgPSB7IGNvbnRleHRCYXNlOiBlLnVwZGF0ZVJhbmdlU3RhcnQsIGVkaXRvckJhc2U6IGZyb20sIGRyaWZ0ZWQ6IGZhbHNlIH07XG4gICAgICAgICAgICBsZXQgY2hhbmdlID0geyBmcm9tLCB0bywgaW5zZXJ0OiBUZXh0Lm9mKGUudGV4dC5zcGxpdChcIlxcblwiKSkgfTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB3aW5kb3cgZG9lc24ndCBpbmNsdWRlIHRoZSBhbmNob3IsIGFzc3VtZSBjaGFuZ2VzXG4gICAgICAgICAgICAvLyBhZGphY2VudCB0byBhIHNpZGUgZ28gdXAgdG8gdGhlIGFuY2hvci5cbiAgICAgICAgICAgIGlmIChjaGFuZ2UuZnJvbSA9PSB0aGlzLmZyb20gJiYgYW5jaG9yIDwgdGhpcy5mcm9tKVxuICAgICAgICAgICAgICAgIGNoYW5nZS5mcm9tID0gYW5jaG9yO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnRvID09IHRoaXMudG8gJiYgYW5jaG9yID4gdGhpcy50bylcbiAgICAgICAgICAgICAgICBjaGFuZ2UudG8gPSBhbmNob3I7XG4gICAgICAgICAgICAvLyBFZGl0IGNvbnRleHRzIHNvbWV0aW1lcyBmaXJlIGVtcHR5IGNoYW5nZXNcbiAgICAgICAgICAgIGlmIChjaGFuZ2UuZnJvbSA9PSBjaGFuZ2UudG8gJiYgIWNoYW5nZS5pbnNlcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUodGhpcy50b0VkaXRvclBvcyhlLnNlbGVjdGlvblN0YXJ0KSwgdGhpcy50b0VkaXRvclBvcyhlLnNlbGVjdGlvbkVuZCkpO1xuICAgICAgICAgICAgICAgIGlmICghbmV3U2VsLm1haW4uZXEobWFpbikpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBzZWxlY3Rpb246IG5ld1NlbCwgdXNlckV2ZW50OiBcInNlbGVjdFwiIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoYnJvd3Nlci5tYWMgfHwgYnJvd3Nlci5hbmRyb2lkKSAmJiBjaGFuZ2UuZnJvbSA9PSBoZWFkIC0gMSAmJlxuICAgICAgICAgICAgICAgIC9eXFwuID8kLy50ZXN0KGUudGV4dCkgJiYgdmlldy5jb250ZW50RE9NLmdldEF0dHJpYnV0ZShcImF1dG9jb3JyZWN0XCIpID09IFwib2ZmXCIpXG4gICAgICAgICAgICAgICAgY2hhbmdlID0geyBmcm9tLCB0bywgaW5zZXJ0OiBUZXh0Lm9mKFtlLnRleHQucmVwbGFjZShcIi5cIiwgXCIgXCIpXSkgfTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UgPSBjaGFuZ2U7XG4gICAgICAgICAgICBpZiAoIXZpZXcuc3RhdGUucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3TGVuID0gdGhpcy50byAtIHRoaXMuZnJvbSArIChjaGFuZ2UudG8gLSBjaGFuZ2UuZnJvbSArIGNoYW5nZS5pbnNlcnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBhcHBseURPTUNoYW5nZUlubmVyKHZpZXcsIGNoYW5nZSwgRWRpdG9yU2VsZWN0aW9uLnNpbmdsZSh0aGlzLnRvRWRpdG9yUG9zKGUuc2VsZWN0aW9uU3RhcnQsIG5ld0xlbiksIHRoaXMudG9FZGl0b3JQb3MoZS5zZWxlY3Rpb25FbmQsIG5ld0xlbikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSB0cmFuc2FjdGlvbiBkaWRuJ3QgZmx1c2ggb3VyIGNoYW5nZSwgcmV2ZXJ0IGl0IHNvXG4gICAgICAgICAgICAvLyB0aGF0IHRoZSBjb250ZXh0IGlzIGluIHN5bmMgd2l0aCB0aGUgZWRpdG9yIHN0YXRlIGFnYWluLlxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NvbnRleHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldmVydFBlbmRpbmcodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24odmlldy5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuY2hhcmFjdGVyYm91bmRzdXBkYXRlID0gZSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVjdHMgPSBbXSwgcHJldiA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy50b0VkaXRvclBvcyhlLnJhbmdlU3RhcnQpLCBlbmQgPSB0aGlzLnRvRWRpdG9yUG9zKGUucmFuZ2VFbmQpOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHZpZXcuY29vcmRzRm9yQ2hhcihpKTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gKHJlY3QgJiYgbmV3IERPTVJlY3QocmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC5yaWdodCAtIHJlY3QubGVmdCwgcmVjdC5ib3R0b20gLSByZWN0LnRvcCkpXG4gICAgICAgICAgICAgICAgICAgIHx8IHByZXYgfHwgbmV3IERPTVJlY3Q7XG4gICAgICAgICAgICAgICAgcmVjdHMucHVzaChwcmV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQudXBkYXRlQ2hhcmFjdGVyQm91bmRzKGUucmFuZ2VTdGFydCwgcmVjdHMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnRleHRmb3JtYXR1cGRhdGUgPSBlID0+IHtcbiAgICAgICAgICAgIGxldCBkZWNvID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBmb3JtYXQgb2YgZS5nZXRUZXh0Rm9ybWF0cygpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVTdHlsZSA9IGZvcm1hdC51bmRlcmxpbmVTdHlsZSwgdGhpY2tuZXNzID0gZm9ybWF0LnVuZGVybGluZVRoaWNrbmVzcztcbiAgICAgICAgICAgICAgICBpZiAobGluZVN0eWxlICE9IFwiTm9uZVwiICYmIHRoaWNrbmVzcyAhPSBcIk5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHRoaXMudG9FZGl0b3JQb3MoZm9ybWF0LnJhbmdlU3RhcnQpLCB0byA9IHRoaXMudG9FZGl0b3JQb3MoZm9ybWF0LnJhbmdlRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gYHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lICR7bGluZVN0eWxlID09IFwiRGFzaGVkXCIgPyBcImRhc2hlZCBcIiA6IGxpbmVTdHlsZSA9PSBcIlNxdWlnZ2xlXCIgPyBcIndhdnkgXCIgOiBcIlwifSR7dGhpY2tuZXNzID09IFwiVGhpblwiID8gMSA6IDJ9cHhgO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjby5wdXNoKERlY29yYXRpb24ubWFyayh7IGF0dHJpYnV0ZXM6IHsgc3R5bGUgfSB9KS5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldEVkaXRDb250ZXh0Rm9ybWF0dGluZy5vZihEZWNvcmF0aW9uLnNldChkZWNvKSkgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuY29tcG9zaXRpb25zdGFydCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPSAwO1xuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVycy5jb21wb3NpdGlvbmVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPSAtMTtcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvc2luZykge1xuICAgICAgICAgICAgICAgIGxldCB7IGRyaWZ0ZWQgfSA9IHRoaXMuY29tcG9zaW5nO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZHJpZnRlZClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCh2aWV3LnN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gdGhpcy5oYW5kbGVycylcbiAgICAgICAgICAgIGNvbnRleHQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5oYW5kbGVyc1tldmVudF0pO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHZpZXcgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdENvbnRleHQudXBkYXRlQ29udHJvbEJvdW5kcyh2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSBnZXRTZWxlY3Rpb24odmlldy5yb290KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsICYmIHNlbC5yYW5nZUNvdW50KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnVwZGF0ZVNlbGVjdGlvbkJvdW5kcyhzZWwuZ2V0UmFuZ2VBdCgwKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgICAgICB9IH07XG4gICAgfVxuICAgIGFwcGx5RWRpdHModXBkYXRlKSB7XG4gICAgICAgIGxldCBvZmYgPSAwLCBhYm9ydCA9IGZhbHNlLCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZTtcbiAgICAgICAgdXBkYXRlLmNoYW5nZXMuaXRlckNoYW5nZXMoKGZyb21BLCB0b0EsIF9mcm9tQiwgX3RvQiwgaW5zZXJ0KSA9PiB7XG4gICAgICAgICAgICBpZiAoYWJvcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGRMZW4gPSBpbnNlcnQubGVuZ3RoIC0gKHRvQSAtIGZyb21BKTtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nICYmIHRvQSA+PSBwZW5kaW5nLnRvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmcuZnJvbSA9PSBmcm9tQSAmJiBwZW5kaW5nLnRvID09IHRvQSAmJiBwZW5kaW5nLmluc2VydC5lcShpbnNlcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlID0gbnVsbDsgLy8gTWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgb2ZmICs9IGRMZW47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gKz0gZExlbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gTWlzbWF0Y2gsIHJldmVydFxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXZlcnRQZW5kaW5nKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUEgKz0gb2ZmO1xuICAgICAgICAgICAgdG9BICs9IG9mZjtcbiAgICAgICAgICAgIGlmICh0b0EgPD0gdGhpcy5mcm9tKSB7IC8vIEJlZm9yZSB0aGUgd2luZG93XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tICs9IGRMZW47XG4gICAgICAgICAgICAgICAgdGhpcy50byArPSBkTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbUEgPCB0aGlzLnRvKSB7IC8vIE92ZXJsYXBzIHdpdGggd2luZG93XG4gICAgICAgICAgICAgICAgaWYgKGZyb21BIDwgdGhpcy5mcm9tIHx8IHRvQSA+IHRoaXMudG8gfHwgKHRoaXMudG8gLSB0aGlzLmZyb20pICsgaW5zZXJ0Lmxlbmd0aCA+IDMwMDAwIC8qIEN4VnAuTWF4U2l6ZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0Q29udGV4dC51cGRhdGVUZXh0KHRoaXMudG9Db250ZXh0UG9zKGZyb21BKSwgdGhpcy50b0NvbnRleHRQb3ModG9BKSwgaW5zZXJ0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMudG8gKz0gZExlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZiArPSBkTGVuO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBlbmRpbmcgJiYgIWFib3J0KVxuICAgICAgICAgICAgdGhpcy5yZXZlcnRQZW5kaW5nKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIHJldHVybiAhYWJvcnQ7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHJldmVydGVkID0gdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZSwgc3RhcnRTZWwgPSB1cGRhdGUuc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaW5nICYmXG4gICAgICAgICAgICAodGhpcy5jb21wb3NpbmcuZHJpZnRlZCB8fFxuICAgICAgICAgICAgICAgICghdXBkYXRlLmNoYW5nZXMudG91Y2hlc1JhbmdlKHN0YXJ0U2VsLmZyb20sIHN0YXJ0U2VsLnRvKSAmJlxuICAgICAgICAgICAgICAgICAgICB1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gIXRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSAmJiB0ci5jaGFuZ2VzLnRvdWNoZXNSYW5nZSh0aGlzLmZyb20sIHRoaXMudG8pKSkpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2luZy5kcmlmdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaW5nLmVkaXRvckJhc2UgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5jb21wb3NpbmcuZWRpdG9yQmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuYXBwbHlFZGl0cyh1cGRhdGUpIHx8ICF0aGlzLnJhbmdlSXNWYWxpZCh1cGRhdGUuc3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDb250ZXh0Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVzZXQodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHJldmVydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbih1cGRhdGUuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQpXG4gICAgICAgICAgICB1cGRhdGUudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgIH1cbiAgICByZXNldFJhbmdlKHN0YXRlKSB7XG4gICAgICAgIGxldCB7IGhlYWQgfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICB0aGlzLmZyb20gPSBNYXRoLm1heCgwLCBoZWFkIC0gMTAwMDAgLyogQ3hWcC5NYXJnaW4gKi8pO1xuICAgICAgICB0aGlzLnRvID0gTWF0aC5taW4oc3RhdGUuZG9jLmxlbmd0aCwgaGVhZCArIDEwMDAwIC8qIEN4VnAuTWFyZ2luICovKTtcbiAgICB9XG4gICAgcmVzZXQoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5yZXNldFJhbmdlKHN0YXRlKTtcbiAgICAgICAgdGhpcy5lZGl0Q29udGV4dC51cGRhdGVUZXh0KDAsIHRoaXMuZWRpdENvbnRleHQudGV4dC5sZW5ndGgsIHN0YXRlLmRvYy5zbGljZVN0cmluZyh0aGlzLmZyb20sIHRoaXMudG8pKTtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc3RhdGUpO1xuICAgIH1cbiAgICByZXZlcnRQZW5kaW5nKHN0YXRlKSB7XG4gICAgICAgIGxldCBwZW5kaW5nID0gdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ29udGV4dENoYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZWRpdENvbnRleHQudXBkYXRlVGV4dCh0aGlzLnRvQ29udGV4dFBvcyhwZW5kaW5nLmZyb20pLCB0aGlzLnRvQ29udGV4dFBvcyhwZW5kaW5nLmZyb20gKyBwZW5kaW5nLmluc2VydC5sZW5ndGgpLCBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcocGVuZGluZy5mcm9tLCBwZW5kaW5nLnRvKSk7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvbihzdGF0ZSkge1xuICAgICAgICBsZXQgeyBtYWluIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMudG9Db250ZXh0UG9zKE1hdGgubWF4KHRoaXMuZnJvbSwgTWF0aC5taW4odGhpcy50bywgbWFpbi5hbmNob3IpKSk7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLnRvQ29udGV4dFBvcyhtYWluLmhlYWQpO1xuICAgICAgICBpZiAodGhpcy5lZGl0Q29udGV4dC5zZWxlY3Rpb25TdGFydCAhPSBzdGFydCB8fCB0aGlzLmVkaXRDb250ZXh0LnNlbGVjdGlvbkVuZCAhPSBlbmQpXG4gICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnVwZGF0ZVNlbGVjdGlvbihzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgcmFuZ2VJc1ZhbGlkKHN0YXRlKSB7XG4gICAgICAgIGxldCB7IGhlYWQgfSA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICByZXR1cm4gISh0aGlzLmZyb20gPiAwICYmIGhlYWQgLSB0aGlzLmZyb20gPCA1MDAgLyogQ3hWcC5NaW5NYXJnaW4gKi8gfHxcbiAgICAgICAgICAgIHRoaXMudG8gPCBzdGF0ZS5kb2MubGVuZ3RoICYmIHRoaXMudG8gLSBoZWFkIDwgNTAwIC8qIEN4VnAuTWluTWFyZ2luICovIHx8XG4gICAgICAgICAgICB0aGlzLnRvIC0gdGhpcy5mcm9tID4gMTAwMDAgLyogQ3hWcC5NYXJnaW4gKi8gKiAzKTtcbiAgICB9XG4gICAgdG9FZGl0b3JQb3MoY29udGV4dFBvcywgY2xpcExlbiA9IHRoaXMudG8gLSB0aGlzLmZyb20pIHtcbiAgICAgICAgY29udGV4dFBvcyA9IE1hdGgubWluKGNvbnRleHRQb3MsIGNsaXBMZW4pO1xuICAgICAgICBsZXQgYyA9IHRoaXMuY29tcG9zaW5nO1xuICAgICAgICByZXR1cm4gYyAmJiBjLmRyaWZ0ZWQgPyBjLmVkaXRvckJhc2UgKyAoY29udGV4dFBvcyAtIGMuY29udGV4dEJhc2UpIDogY29udGV4dFBvcyArIHRoaXMuZnJvbTtcbiAgICB9XG4gICAgdG9Db250ZXh0UG9zKGVkaXRvclBvcykge1xuICAgICAgICBsZXQgYyA9IHRoaXMuY29tcG9zaW5nO1xuICAgICAgICByZXR1cm4gYyAmJiBjLmRyaWZ0ZWQgPyBjLmNvbnRleHRCYXNlICsgKGVkaXRvclBvcyAtIGMuZWRpdG9yQmFzZSkgOiBlZGl0b3JQb3MgLSB0aGlzLmZyb207XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IGV2ZW50IGluIHRoaXMuaGFuZGxlcnMpXG4gICAgICAgICAgICB0aGlzLmVkaXRDb250ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlcnNbZXZlbnRdKTtcbiAgICB9XG59XG5cbi8vIFRoZSBlZGl0b3IncyB1cGRhdGUgc3RhdGUgbWFjaGluZSBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuLy9cbi8vICAgICBJZGxlIOKGkiBVcGRhdGluZyDih4YgSWRsZSAodW5jaGVja2VkKSDihpIgTWVhc3VyaW5nIOKGkiBJZGxlXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRICAgICAg4oaTXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXBkYXRpbmcgKG1lYXN1cmUpXG4vL1xuLy8gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiAnSWRsZScgYW5kICdJZGxlICh1bmNoZWNrZWQpJyBsaWVzIGluXG4vLyB3aGV0aGVyIGEgbGF5b3V0IGNoZWNrIGhhcyBiZWVuIHNjaGVkdWxlZC4gQSByZWd1bGFyIHVwZGF0ZSB0aHJvdWdoXG4vLyB0aGUgYHVwZGF0ZWAgbWV0aG9kIHVwZGF0ZXMgdGhlIERPTSBpbiBhIHdyaXRlLW9ubHkgZmFzaGlvbiwgYW5kXG4vLyByZWxpZXMgb24gYSBjaGVjayAoc2NoZWR1bGVkIHdpdGggYHJlcXVlc3RBbmltYXRpb25GcmFtZWApIHRvIG1ha2Vcbi8vIHN1cmUgZXZlcnl0aGluZyBpcyB3aGVyZSBpdCBzaG91bGQgYmUgYW5kIHRoZSB2aWV3cG9ydCBjb3ZlcnMgdGhlXG4vLyB2aXNpYmxlIGNvZGUuIFRoYXQgY2hlY2sgY29udGludWVzIHRvIG1lYXN1cmUgYW5kIHRoZW4gb3B0aW9uYWxseVxuLy8gdXBkYXRlIHVudGlsIGl0IHJlYWNoZXMgYSBjb2hlcmVudCBzdGF0ZS5cbi8qKlxuQW4gZWRpdG9yIHZpZXcgcmVwcmVzZW50cyB0aGUgZWRpdG9yJ3MgdXNlciBpbnRlcmZhY2UuIEl0IGhvbGRzXG50aGUgZWRpdGFibGUgRE9NIHN1cmZhY2UsIGFuZCBwb3NzaWJseSBvdGhlciBlbGVtZW50cyBzdWNoIGFzIHRoZVxubGluZSBudW1iZXIgZ3V0dGVyLiBJdCBoYW5kbGVzIGV2ZW50cyBhbmQgZGlzcGF0Y2hlcyBzdGF0ZVxudHJhbnNhY3Rpb25zIGZvciBlZGl0aW5nIGFjdGlvbnMuXG4qL1xuY2xhc3MgRWRpdG9yVmlldyB7XG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IHN0YXRlKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuc3RhdGU7IH1cbiAgICAvKipcbiAgICBUbyBiZSBhYmxlIHRvIGRpc3BsYXkgbGFyZ2UgZG9jdW1lbnRzIHdpdGhvdXQgY29uc3VtaW5nIHRvbyBtdWNoXG4gICAgbWVtb3J5IG9yIG92ZXJsb2FkaW5nIHRoZSBicm93c2VyLCBDb2RlTWlycm9yIG9ubHkgZHJhd3MgdGhlXG4gICAgY29kZSB0aGF0IGlzIHZpc2libGUgKHBsdXMgYSBtYXJnaW4gYXJvdW5kIGl0KSB0byB0aGUgRE9NLiBUaGlzXG4gICAgcHJvcGVydHkgdGVsbHMgeW91IHRoZSBleHRlbnQgb2YgdGhlIGN1cnJlbnQgZHJhd24gdmlld3BvcnQsIGluXG4gICAgZG9jdW1lbnQgcG9zaXRpb25zLlxuICAgICovXG4gICAgZ2V0IHZpZXdwb3J0KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlld3BvcnQ7IH1cbiAgICAvKipcbiAgICBXaGVuIHRoZXJlIGFyZSwgZm9yIGV4YW1wbGUsIGxhcmdlIGNvbGxhcHNlZCByYW5nZXMgaW4gdGhlXG4gICAgdmlld3BvcnQsIGl0cyBzaXplIGNhbiBiZSBhIGxvdCBiaWdnZXIgdGhhbiB0aGUgYWN0dWFsIHZpc2libGVcbiAgICBjb250ZW50LiBUaHVzLCBpZiB5b3UgYXJlIGRvaW5nIHNvbWV0aGluZyBsaWtlIHN0eWxpbmcgdGhlXG4gICAgY29udGVudCBpbiB0aGUgdmlld3BvcnQsIGl0IGlzIHByZWZlcmFibGUgdG8gb25seSBkbyBzbyBmb3JcbiAgICB0aGVzZSByYW5nZXMsIHdoaWNoIGFyZSB0aGUgc3Vic2V0IG9mIHRoZSB2aWV3cG9ydCB0aGF0IGlzXG4gICAgYWN0dWFsbHkgZHJhd24uXG4gICAgKi9cbiAgICBnZXQgdmlzaWJsZVJhbmdlcygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpc2libGVSYW5nZXM7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGZhbHNlIHdoZW4gdGhlIGVkaXRvciBpcyBlbnRpcmVseSBzY3JvbGxlZCBvdXQgb2Ygdmlld1xuICAgIG9yIG90aGVyd2lzZSBoaWRkZW4uXG4gICAgKi9cbiAgICBnZXQgaW5WaWV3KCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaW5WaWV3OyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaXMgY3VycmVudGx5IGNvbXBvc2luZyB0ZXh0IHZpYVxuICAgIFtJTUVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lucHV0X21ldGhvZCksIGFuZCBhdCBsZWFzdFxuICAgIG9uZSBjaGFuZ2UgaGFzIGJlZW4gbWFkZSBpbiB0aGUgY3VycmVudCBjb21wb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBjb21wb3NpbmcoKSB7IHJldHVybiB0aGlzLmlucHV0U3RhdGUuY29tcG9zaW5nID4gMDsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBpbiBjb21wb3Npbmcgc3RhdGUuIE5vdGVcbiAgICB0aGF0IG9uIHNvbWUgcGxhdGZvcm1zLCBsaWtlIEFuZHJvaWQsIHRoaXMgd2lsbCBiZSB0aGUgY2FzZSBhXG4gICAgbG90LCBzaW5jZSBqdXN0IHB1dHRpbmcgdGhlIGN1cnNvciBvbiBhIHdvcmQgc3RhcnRzIGFcbiAgICBjb21wb3NpdGlvbiB0aGVyZS5cbiAgICAqL1xuICAgIGdldCBjb21wb3NpdGlvblN0YXJ0ZWQoKSB7IHJldHVybiB0aGlzLmlucHV0U3RhdGUuY29tcG9zaW5nID49IDA7IH1cbiAgICAvKipcbiAgICBUaGUgZG9jdW1lbnQgb3Igc2hhZG93IHJvb3QgdGhhdCB0aGUgdmlldyBsaXZlcyBpbi5cbiAgICAqL1xuICAgIGdldCByb290KCkgeyByZXR1cm4gdGhpcy5fcm9vdDsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHdpbigpIHsgcmV0dXJuIHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93OyB9XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgbmV3IHZpZXcuIFlvdSdsbCB3YW50IHRvIGVpdGhlciBwcm92aWRlIGEgYHBhcmVudGBcbiAgICBvcHRpb24sIG9yIHB1dCBgdmlldy5kb21gIGludG8geW91ciBkb2N1bWVudCBhZnRlciBjcmVhdGluZyBhXG4gICAgdmlldywgc28gdGhhdCB0aGUgdXNlciBjYW4gc2VlIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpbk1hcCA9IG5ldyBNYXA7XG4gICAgICAgIHRoaXMuZWRpdG9yQXR0cnMgPSB7fTtcbiAgICAgICAgdGhpcy5jb250ZW50QXR0cnMgPSB7fTtcbiAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnNjcm9sbERPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLnRhYkluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLmNsYXNzTmFtZSA9IFwiY20tc2Nyb2xsZXJcIjtcbiAgICAgICAgdGhpcy5zY3JvbGxET00uYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00uY2xhc3NOYW1lID0gXCJjbS1hbm5vdW5jZWRcIjtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxpdmVcIiwgXCJwb2xpdGVcIik7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5hbm5vdW5jZURPTSk7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc2Nyb2xsRE9NKTtcbiAgICAgICAgaWYgKGNvbmZpZy5wYXJlbnQpXG4gICAgICAgICAgICBjb25maWcucGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZG9tKTtcbiAgICAgICAgbGV0IHsgZGlzcGF0Y2ggfSA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5kaXNwYXRjaFRyYW5zYWN0aW9ucyA9IGNvbmZpZy5kaXNwYXRjaFRyYW5zYWN0aW9ucyB8fFxuICAgICAgICAgICAgKGRpc3BhdGNoICYmICgodHJzKSA9PiB0cnMuZm9yRWFjaCh0ciA9PiBkaXNwYXRjaCh0ciwgdGhpcykpKSkgfHxcbiAgICAgICAgICAgICgodHJzKSA9PiB0aGlzLnVwZGF0ZSh0cnMpKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IChjb25maWcucm9vdCB8fCBnZXRSb290KGNvbmZpZy5wYXJlbnQpIHx8IGRvY3VtZW50KTtcbiAgICAgICAgdGhpcy52aWV3U3RhdGUgPSBuZXcgVmlld1N0YXRlKGNvbmZpZy5zdGF0ZSB8fCBFZGl0b3JTdGF0ZS5jcmVhdGUoY29uZmlnKSk7XG4gICAgICAgIGlmIChjb25maWcuc2Nyb2xsVG8gJiYgY29uZmlnLnNjcm9sbFRvLmlzKHNjcm9sbEludG9WaWV3KSlcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCA9IGNvbmZpZy5zY3JvbGxUby52YWx1ZS5jbGlwKHRoaXMudmlld1N0YXRlLnN0YXRlKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKS5tYXAoc3BlYyA9PiBuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgcGx1Z2luLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBET01PYnNlcnZlcih0aGlzKTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlID0gbmV3IElucHV0U3RhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzLnBsdWdpbnMpO1xuICAgICAgICB0aGlzLmRvY1ZpZXcgPSBuZXcgRG9jVmlldyh0aGlzKTtcbiAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgaWYgKChfYSA9IGRvY3VtZW50LmZvbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhZHkpXG4gICAgICAgICAgICBkb2N1bWVudC5mb250cy5yZWFkeS50aGVuKCgpID0+IHRoaXMucmVxdWVzdE1lYXN1cmUoKSk7XG4gICAgfVxuICAgIGRpc3BhdGNoKC4uLmlucHV0KSB7XG4gICAgICAgIGxldCB0cnMgPSBpbnB1dC5sZW5ndGggPT0gMSAmJiBpbnB1dFswXSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uID8gaW5wdXRcbiAgICAgICAgICAgIDogaW5wdXQubGVuZ3RoID09IDEgJiYgQXJyYXkuaXNBcnJheShpbnB1dFswXSkgPyBpbnB1dFswXVxuICAgICAgICAgICAgICAgIDogW3RoaXMuc3RhdGUudXBkYXRlKC4uLmlucHV0KV07XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUcmFuc2FjdGlvbnModHJzLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3IGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgdHJhbnNhY3Rpb25zLiBUaGlzIHdpbGxcbiAgICB1cGRhdGUgdGhlIHZpc2libGUgZG9jdW1lbnQgYW5kIHNlbGVjdGlvbiB0byBtYXRjaCB0aGUgc3RhdGVcbiAgICBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb25zLCBhbmQgbm90aWZ5IHZpZXcgcGx1Z2lucyBvZiB0aGVcbiAgICBjaGFuZ2UuIFlvdSBzaG91bGQgdXN1YWxseSBjYWxsXG4gICAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLCB3aGljaCB1c2VzIHRoaXNcbiAgICBhcyBhIHByaW1pdGl2ZS5cbiAgICAqL1xuICAgIHVwZGF0ZSh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgIT0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbHMgdG8gRWRpdG9yVmlldy51cGRhdGUgYXJlIG5vdCBhbGxvd2VkIHdoaWxlIGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgbGV0IHJlZHJhd24gPSBmYWxzZSwgYXR0cnNDaGFuZ2VkID0gZmFsc2UsIHVwZGF0ZTtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAodHIuc3RhcnRTdGF0ZSAhPSBzdGF0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byB1cGRhdGUgc3RhdGUgd2l0aCBhIHRyYW5zYWN0aW9uIHRoYXQgZG9lc24ndCBzdGFydCBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZS5cIik7XG4gICAgICAgICAgICBzdGF0ZSA9IHRyLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm9jdXMgPSB0aGlzLmhhc0ZvY3VzLCBmb2N1c0ZsYWcgPSAwLCBkaXNwYXRjaEZvY3VzID0gbnVsbDtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9ucy5zb21lKHRyID0+IHRyLmFubm90YXRpb24oaXNGb2N1c0NoYW5nZSkpKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkID0gZm9jdXM7XG4gICAgICAgICAgICAvLyBJZiBhIGZvY3VzLWNoYW5nZSB0cmFuc2FjdGlvbiBpcyBiZWluZyBkaXNwYXRjaGVkLCBzZXQgdGhpcyB1cGRhdGUgZmxhZy5cbiAgICAgICAgICAgIGZvY3VzRmxhZyA9IDEgLyogVXBkYXRlRmxhZy5Gb2N1cyAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb2N1cyAhPSB0aGlzLmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUubm90aWZpZWRGb2N1c2VkID0gZm9jdXM7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIHNlcGFyYXRlIGZvY3VzIHRyYW5zYWN0aW9uIGlmIG5lY2Vzc2FyeSwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBhZGQgYSBmbGFnIHRvIHRoaXMgdXBkYXRlXG4gICAgICAgICAgICBkaXNwYXRjaEZvY3VzID0gZm9jdXNDaGFuZ2VUcmFuc2FjdGlvbihzdGF0ZSwgZm9jdXMpO1xuICAgICAgICAgICAgaWYgKCFkaXNwYXRjaEZvY3VzKVxuICAgICAgICAgICAgICAgIGZvY3VzRmxhZyA9IDEgLyogVXBkYXRlRmxhZy5Gb2N1cyAqLztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwZW5kaW5nIERPTSBjaGFuZ2UsIGVhZ2VybHkgcmVhZCBpdCBhbmQgdHJ5IHRvXG4gICAgICAgIC8vIGFwcGx5IGl0IGFmdGVyIHRoZSBnaXZlbiB0cmFuc2FjdGlvbnMuXG4gICAgICAgIGxldCBwZW5kaW5nS2V5ID0gdGhpcy5vYnNlcnZlci5kZWxheWVkQW5kcm9pZEtleSwgZG9tQ2hhbmdlID0gbnVsbDtcbiAgICAgICAgaWYgKHBlbmRpbmdLZXkpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuY2xlYXJEZWxheWVkQW5kcm9pZEtleSgpO1xuICAgICAgICAgICAgZG9tQ2hhbmdlID0gdGhpcy5vYnNlcnZlci5yZWFkQ2hhbmdlKCk7XG4gICAgICAgICAgICAvLyBPbmx5IHRyeSB0byBhcHBseSBET00gY2hhbmdlcyBpZiB0aGUgdHJhbnNhY3Rpb25zIGRpZG4ndFxuICAgICAgICAgICAgLy8gY2hhbmdlIHRoZSBkb2Mgb3Igc2VsZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGRvbUNoYW5nZSAmJiAhdGhpcy5zdGF0ZS5kb2MuZXEoc3RhdGUuZG9jKSB8fCAhdGhpcy5zdGF0ZS5zZWxlY3Rpb24uZXEoc3RhdGUuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgICAgICBkb21DaGFuZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlIHBocmFzZXMgY2hhbmdlLCByZWRyYXcgdGhlIGVkaXRvclxuICAgICAgICBpZiAoc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykgIT0gdGhpcy5zdGF0ZS5mYWNldChFZGl0b3JTdGF0ZS5waHJhc2VzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgdXBkYXRlID0gVmlld1VwZGF0ZS5jcmVhdGUodGhpcywgc3RhdGUsIHRyYW5zYWN0aW9ucyk7XG4gICAgICAgIHVwZGF0ZS5mbGFncyB8PSBmb2N1c0ZsYWc7XG4gICAgICAgIGxldCBzY3JvbGxUYXJnZXQgPSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgICAgIGZvciAobGV0IHRyIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IHNjcm9sbFRhcmdldC5tYXAodHIuY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRyLnNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IG1haW4gfSA9IHRyLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gbmV3IFNjcm9sbFRhcmdldChtYWluLmVtcHR5ID8gbWFpbiA6IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobWFpbi5oZWFkLCBtYWluLmhlYWQgPiBtYWluLmFuY2hvciA/IC0xIDogMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmlzKHNjcm9sbEludG9WaWV3KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IGUudmFsdWUuY2xpcCh0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnVwZGF0ZSh1cGRhdGUsIHNjcm9sbFRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IENhY2hlZE9yZGVyLnVwZGF0ZSh0aGlzLmJpZGlDYWNoZSwgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpbnModXBkYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWRyYXduID0gdGhpcy5kb2NWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZmFjZXQoc3R5bGVNb2R1bGUpICE9IHRoaXMuc3R5bGVNb2R1bGVzKVxuICAgICAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgICAgIGF0dHJzQ2hhbmdlZCA9IHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd0Fubm91bmNlbWVudHModHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24ocmVkcmF3biwgdHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuaXNVc2VyRXZlbnQoXCJzZWxlY3QucG9pbnRlclwiKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQodGhlbWUpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0aGVtZSkpXG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICBpZiAocmVkcmF3biB8fCBhdHRyc0NoYW5nZWQgfHwgc2Nyb2xsVGFyZ2V0IHx8IHRoaXMudmlld1N0YXRlLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgfHwgdGhpcy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50KVxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgICAgICBpZiAocmVkcmF3bilcbiAgICAgICAgICAgIHRoaXMuZG9jVmlld1VwZGF0ZSgpO1xuICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSlcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGUuZmFjZXQodXBkYXRlTGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIodXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUsIFwidXBkYXRlIGxpc3RlbmVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BhdGNoRm9jdXMgfHwgZG9tQ2hhbmdlKVxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoRm9jdXMgJiYgdGhpcy5zdGF0ZSA9PSBkaXNwYXRjaEZvY3VzLnN0YXJ0U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goZGlzcGF0Y2hGb2N1cyk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFwcGx5RE9NQ2hhbmdlKHRoaXMsIGRvbUNoYW5nZSkgJiYgcGVuZGluZ0tleS5mb3JjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHRoaXMuY29udGVudERPTSwgcGVuZGluZ0tleS5rZXksIHBlbmRpbmdLZXkua2V5Q29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc2V0IHRoZSB2aWV3IHRvIHRoZSBnaXZlbiBzdGF0ZS4gKFRoaXMgd2lsbCBjYXVzZSB0aGUgZW50aXJlXG4gICAgZG9jdW1lbnQgdG8gYmUgcmVkcmF3biBhbmQgYWxsIHZpZXcgcGx1Z2lucyB0byBiZSByZWluaXRpYWxpemVkLFxuICAgIHNvIHlvdSBzaG91bGQgcHJvYmFibHkgb25seSB1c2UgaXQgd2hlbiB0aGUgbmV3IHN0YXRlIGlzbid0XG4gICAgZGVyaXZlZCBmcm9tIHRoZSBvbGQgc3RhdGUuIE90aGVyd2lzZSwgdXNlXG4gICAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLilcbiAgICAqL1xuICAgIHNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogVXBkYXRlU3RhdGUuSWRsZSAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcuc2V0U3RhdGUgYXJlIG5vdCBhbGxvd2VkIHdoaWxlIGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyIC8qIFVwZGF0ZVN0YXRlLlVwZGF0aW5nICovO1xuICAgICAgICBsZXQgaGFkRm9jdXMgPSB0aGlzLmhhc0ZvY3VzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlID0gbmV3IFZpZXdTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMgPSBuZXdTdGF0ZS5mYWNldCh2aWV3UGx1Z2luKS5tYXAoc3BlYyA9PiBuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcGx1Z2luLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcgPSBuZXcgRG9jVmlldyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzLnBsdWdpbnMpO1xuICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhZEZvY3VzKVxuICAgICAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgfVxuICAgIHVwZGF0ZVBsdWdpbnModXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2U3BlY3MgPSB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldCh2aWV3UGx1Z2luKSwgc3BlY3MgPSB1cGRhdGUuc3RhdGUuZmFjZXQodmlld1BsdWdpbik7XG4gICAgICAgIGlmIChwcmV2U3BlY3MgIT0gc3BlY3MpIHtcbiAgICAgICAgICAgIGxldCBuZXdQbHVnaW5zID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBzcGVjIG9mIHNwZWNzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gcHJldlNwZWNzLmluZGV4T2Yoc3BlYyk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdQbHVnaW5zLnB1c2gobmV3IFBsdWdpbkluc3RhbmNlKHNwZWMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLnBsdWdpbnNbZm91bmRdO1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4ubXVzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLm11c3RVcGRhdGUgIT0gdXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4uZGVzdHJveSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucyA9IG5ld1BsdWdpbnM7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbk1hcC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgcCBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcC5tdXN0VXBkYXRlID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgdGhpcy5wbHVnaW5zW2ldLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKHByZXZTcGVjcyAhPSBzcGVjcylcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzLnBsdWdpbnMpO1xuICAgIH1cbiAgICBkb2NWaWV3VXBkYXRlKCkge1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gcGx1Z2luLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWwuZG9jVmlld1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5kb2NWaWV3VXBkYXRlKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSwgXCJkb2MgdmlldyB1cGRhdGUgbGlzdGVuZXJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWVhc3VyZShmbHVzaCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlci5kZWxheWVkQW5kcm9pZEtleSkge1xuICAgICAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gMDsgLy8gUHJldmVudCByZXF1ZXN0TWVhc3VyZSBjYWxscyBmcm9tIHNjaGVkdWxpbmcgYW5vdGhlciBhbmltYXRpb24gZnJhbWVcbiAgICAgICAgaWYgKGZsdXNoKVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlci5mb3JjZUZsdXNoKCk7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbnVsbDtcbiAgICAgICAgbGV0IHNET00gPSB0aGlzLnNjcm9sbERPTSwgc2Nyb2xsVG9wID0gc0RPTS5zY3JvbGxUb3AgKiB0aGlzLnNjYWxlWTtcbiAgICAgICAgbGV0IHsgc2Nyb2xsQW5jaG9yUG9zLCBzY3JvbGxBbmNob3JIZWlnaHQgfSA9IHRoaXMudmlld1N0YXRlO1xuICAgICAgICBpZiAoTWF0aC5hYnMoc2Nyb2xsVG9wIC0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsVG9wKSA+IDEpXG4gICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxBbmNob3JIZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Njcm9sbGVkVG9Cb3R0b20oc0RPTSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFuY2hvclBvcyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gdGhpcy52aWV3U3RhdGUuaGVpZ2h0TWFwLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBibG9jayA9IHRoaXMudmlld1N0YXRlLnNjcm9sbEFuY2hvckF0KHNjcm9sbFRvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JQb3MgPSBibG9jay5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gYmxvY2sudG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAxIC8qIFVwZGF0ZVN0YXRlLk1lYXN1cmluZyAqLztcbiAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMudmlld1N0YXRlLm1lYXN1cmUodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFuZ2VkICYmICF0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGggJiYgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpID4gNSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4odGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiTWVhc3VyZSBsb29wIHJlc3RhcnRlZCBtb3JlIHRoYW4gNSB0aW1lc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiVmlld3BvcnQgZmFpbGVkIHRvIHN0YWJpbGl6ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJ1biBtZWFzdXJlIHJlcXVlc3RzIGluIHRoaXMgY3ljbGUgd2hlbiB0aGUgdmlld3BvcnQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIGlmICghKGNoYW5nZWQgJiA0IC8qIFVwZGF0ZUZsYWcuVmlld3BvcnQgKi8pKVxuICAgICAgICAgICAgICAgICAgICBbdGhpcy5tZWFzdXJlUmVxdWVzdHMsIG1lYXN1cmluZ10gPSBbbWVhc3VyaW5nLCB0aGlzLm1lYXN1cmVSZXF1ZXN0c107XG4gICAgICAgICAgICAgICAgbGV0IG1lYXN1cmVkID0gbWVhc3VyaW5nLm1hcChtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtLnJlYWQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCYWRNZWFzdXJlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGV0IHVwZGF0ZSA9IFZpZXdVcGRhdGUuY3JlYXRlKHRoaXMsIHRoaXMuc3RhdGUsIFtdKSwgcmVkcmF3biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZS5mbGFncyB8PSBjaGFuZ2VkO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlZClcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZCA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQuZmxhZ3MgfD0gY2hhbmdlZDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLztcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZS5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpbnModXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUF0dHJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhd24gPSB0aGlzLmRvY1ZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWRyYXduKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3VXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVhc3VyaW5nLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAobWVhc3VyZWRbaV0gIT0gQmFkTWVhc3VyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IG1lYXN1cmluZ1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobS53cml0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS53cml0ZShtZWFzdXJlZFtpXSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih0aGlzLnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWRyYXduKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCAmJiB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3U3RhdGUuZWRpdG9ySGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnNjcm9sbEludG9WaWV3KHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBbmNob3JIZWlnaHQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdBbmNob3JIZWlnaHQgPSBzY3JvbGxBbmNob3JQb3MgPCAwID8gdGhpcy52aWV3U3RhdGUuaGVpZ2h0TWFwLmhlaWdodCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0KHNjcm9sbEFuY2hvclBvcykudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaWZmID0gbmV3QW5jaG9ySGVpZ2h0IC0gc2Nyb2xsQW5jaG9ySGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmID4gMSB8fCBkaWZmIDwgLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gc2Nyb2xsVG9wICsgZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc0RPTS5zY3JvbGxUb3AgPSBzY3JvbGxUb3AgLyB0aGlzLnNjYWxlWTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBVcGRhdGVTdGF0ZS5JZGxlICovO1xuICAgICAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQgJiYgIXVwZGF0ZWQuZW1wdHkpXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlLmZhY2V0KHVwZGF0ZUxpc3RlbmVyKSlcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcih1cGRhdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBDU1MgY2xhc3NlcyBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgZWRpdG9yIHRoZW1lcy5cbiAgICAqL1xuICAgIGdldCB0aGVtZUNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBiYXNlVGhlbWVJRCArIFwiIFwiICtcbiAgICAgICAgICAgICh0aGlzLnN0YXRlLmZhY2V0KGRhcmtUaGVtZSkgPyBiYXNlRGFya0lEIDogYmFzZUxpZ2h0SUQpICsgXCIgXCIgK1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5mYWNldCh0aGVtZSk7XG4gICAgfVxuICAgIHVwZGF0ZUF0dHJzKCkge1xuICAgICAgICBsZXQgZWRpdG9yQXR0cnMgPSBhdHRyc0Zyb21GYWNldCh0aGlzLCBlZGl0b3JBdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICBjbGFzczogXCJjbS1lZGl0b3JcIiArICh0aGlzLmhhc0ZvY3VzID8gXCIgY20tZm9jdXNlZCBcIiA6IFwiIFwiKSArIHRoaXMudGhlbWVDbGFzc2VzXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgY29udGVudEF0dHJzID0ge1xuICAgICAgICAgICAgc3BlbGxjaGVjazogXCJmYWxzZVwiLFxuICAgICAgICAgICAgYXV0b2NvcnJlY3Q6IFwib2ZmXCIsXG4gICAgICAgICAgICBhdXRvY2FwaXRhbGl6ZTogXCJvZmZcIixcbiAgICAgICAgICAgIHdyaXRpbmdzdWdnZXN0aW9uczogXCJmYWxzZVwiLFxuICAgICAgICAgICAgdHJhbnNsYXRlOiBcIm5vXCIsXG4gICAgICAgICAgICBjb250ZW50ZWRpdGFibGU6ICF0aGlzLnN0YXRlLmZhY2V0KGVkaXRhYmxlKSA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tY29udGVudFwiLFxuICAgICAgICAgICAgc3R5bGU6IGAke2Jyb3dzZXIudGFiU2l6ZX06ICR7dGhpcy5zdGF0ZS50YWJTaXplfWAsXG4gICAgICAgICAgICByb2xlOiBcInRleHRib3hcIixcbiAgICAgICAgICAgIFwiYXJpYS1tdWx0aWxpbmVcIjogXCJ0cnVlXCJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICBjb250ZW50QXR0cnNbXCJhcmlhLXJlYWRvbmx5XCJdID0gXCJ0cnVlXCI7XG4gICAgICAgIGF0dHJzRnJvbUZhY2V0KHRoaXMsIGNvbnRlbnRBdHRyaWJ1dGVzLCBjb250ZW50QXR0cnMpO1xuICAgICAgICBsZXQgY2hhbmdlZCA9IHRoaXMub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VkQ29udGVudCA9IHVwZGF0ZUF0dHJzKHRoaXMuY29udGVudERPTSwgdGhpcy5jb250ZW50QXR0cnMsIGNvbnRlbnRBdHRycyk7XG4gICAgICAgICAgICBsZXQgY2hhbmdlZEVkaXRvciA9IHVwZGF0ZUF0dHJzKHRoaXMuZG9tLCB0aGlzLmVkaXRvckF0dHJzLCBlZGl0b3JBdHRycyk7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlZENvbnRlbnQgfHwgY2hhbmdlZEVkaXRvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWRpdG9yQXR0cnMgPSBlZGl0b3JBdHRycztcbiAgICAgICAgdGhpcy5jb250ZW50QXR0cnMgPSBjb250ZW50QXR0cnM7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbiAgICBzaG93QW5ub3VuY2VtZW50cyh0cnMpIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJzKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhFZGl0b3JWaWV3LmFubm91bmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFubm91bmNlRE9NLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpdiA9IHRoaXMuYW5ub3VuY2VET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi50ZXh0Q29udGVudCA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgfVxuICAgIG1vdW50U3R5bGVzKCkge1xuICAgICAgICB0aGlzLnN0eWxlTW9kdWxlcyA9IHRoaXMuc3RhdGUuZmFjZXQoc3R5bGVNb2R1bGUpO1xuICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLnN0YXRlLmZhY2V0KEVkaXRvclZpZXcuY3NwTm9uY2UpO1xuICAgICAgICBTdHlsZU1vZHVsZS5tb3VudCh0aGlzLnJvb3QsIHRoaXMuc3R5bGVNb2R1bGVzLmNvbmNhdChiYXNlVGhlbWUkMSkucmV2ZXJzZSgpLCBub25jZSA/IHsgbm9uY2UgfSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJlYWRNZWFzdXJlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgPT0gMiAvKiBVcGRhdGVTdGF0ZS5VcGRhdGluZyAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWRpbmcgdGhlIGVkaXRvciBsYXlvdXQgaXNuJ3QgYWxsb3dlZCBkdXJpbmcgYW4gdXBkYXRlXCIpO1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSA9PSAwIC8qIFVwZGF0ZVN0YXRlLklkbGUgKi8gJiYgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmUoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBTY2hlZHVsZSBhIGxheW91dCBtZWFzdXJlbWVudCwgb3B0aW9uYWxseSBwcm92aWRpbmcgY2FsbGJhY2tzIHRvXG4gICAgZG8gY3VzdG9tIERPTSBtZWFzdXJpbmcgZm9sbG93ZWQgYnkgYSBET00gd3JpdGUgcGhhc2UuIFVzaW5nXG4gICAgdGhpcyBpcyBwcmVmZXJhYmxlIHJlYWRpbmcgRE9NIGxheW91dCBkaXJlY3RseSBmcm9tLCBmb3JcbiAgICBleGFtcGxlLCBhbiBldmVudCBoYW5kbGVyLCBiZWNhdXNlIGl0J2xsIG1ha2Ugc3VyZSBtZWFzdXJpbmcgYW5kXG4gICAgZHJhd2luZyBkb25lIGJ5IG90aGVyIGNvbXBvbmVudHMgaXMgc3luY2hyb25pemVkLCBhdm9pZGluZ1xuICAgIHVubmVjZXNzYXJ5IERPTSBsYXlvdXQgY29tcHV0YXRpb25zLlxuICAgICovXG4gICAgcmVxdWVzdE1lYXN1cmUocmVxdWVzdCkge1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkIDwgMClcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IHRoaXMud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLm1lYXN1cmUoKSk7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZWFzdXJlUmVxdWVzdHMuaW5kZXhPZihyZXF1ZXN0KSA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LmtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWVhc3VyZVJlcXVlc3RzW2ldLmtleSA9PT0gcmVxdWVzdC5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzW2ldID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVJlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSB2YWx1ZSBvZiBhIHNwZWNpZmljIHBsdWdpbiwgaWYgcHJlc2VudC4gTm90ZSB0aGF0XG4gICAgcGx1Z2lucyB0aGF0IGNyYXNoIGNhbiBiZSBkcm9wcGVkIGZyb20gYSB2aWV3LCBzbyBldmVuIHdoZW4geW91XG4gICAga25vdyB5b3UgcmVnaXN0ZXJlZCBhIGdpdmVuIHBsdWdpbiwgaXQgaXMgcmVjb21tZW5kZWQgdG8gY2hlY2tcbiAgICB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgbWV0aG9kLlxuICAgICovXG4gICAgcGx1Z2luKHBsdWdpbikge1xuICAgICAgICBsZXQga25vd24gPSB0aGlzLnBsdWdpbk1hcC5nZXQocGx1Z2luKTtcbiAgICAgICAgaWYgKGtub3duID09PSB1bmRlZmluZWQgfHwga25vd24gJiYga25vd24uc3BlYyAhPSBwbHVnaW4pXG4gICAgICAgICAgICB0aGlzLnBsdWdpbk1hcC5zZXQocGx1Z2luLCBrbm93biA9IHRoaXMucGx1Z2lucy5maW5kKHAgPT4gcC5zcGVjID09IHBsdWdpbikgfHwgbnVsbCk7XG4gICAgICAgIHJldHVybiBrbm93biAmJiBrbm93bi51cGRhdGUodGhpcykudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGRvY3VtZW50LCBpbiBzY3JlZW4gY29vcmRpbmF0ZXMuIFRoaXNcbiAgICBtYXkgYmUgbmVnYXRpdmUgd2hlbiB0aGUgZWRpdG9yIGlzIHNjcm9sbGVkIGRvd24uIFBvaW50c1xuICAgIGRpcmVjdGx5IHRvIHRoZSB0b3Agb2YgdGhlIGZpcnN0IGxpbmUsIG5vdCBhYm92ZSB0aGUgcGFkZGluZy5cbiAgICAqL1xuICAgIGdldCBkb2N1bWVudFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBvcnRzIHRoZSBwYWRkaW5nIGFib3ZlIGFuZCBiZWxvdyB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZG9jdW1lbnRQYWRkaW5nKCkge1xuICAgICAgICByZXR1cm4geyB0b3A6IHRoaXMudmlld1N0YXRlLnBhZGRpbmdUb3AsIGJvdHRvbTogdGhpcy52aWV3U3RhdGUucGFkZGluZ0JvdHRvbSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBJZiB0aGUgZWRpdG9yIGlzIHRyYW5zZm9ybWVkIHdpdGggQ1NTLCB0aGlzIHByb3ZpZGVzIHRoZSBzY2FsZVxuICAgIGFsb25nIHRoZSBYIGF4aXMuIE90aGVyd2lzZSwgaXQgd2lsbCBqdXN0IGJlIDEuIE5vdGUgdGhhdFxuICAgIHRyYW5zZm9ybXMgb3RoZXIgdGhhbiB0cmFuc2xhdGlvbiBhbmQgc2NhbGluZyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICAqL1xuICAgIGdldCBzY2FsZVgoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zY2FsZVg7IH1cbiAgICAvKipcbiAgICBQcm92aWRlIHRoZSBDU1MgdHJhbnNmb3JtZWQgc2NhbGUgYWxvbmcgdGhlIFkgYXhpcy5cbiAgICAqL1xuICAgIGdldCBzY2FsZVkoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5zY2FsZVk7IH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB0ZXh0IGxpbmUgb3IgYmxvY2sgd2lkZ2V0IGF0IHRoZSBnaXZlbiB2ZXJ0aWNhbFxuICAgIHBvc2l0aW9uICh3aGljaCBpcyBpbnRlcnByZXRlZCBhcyByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApKS5cbiAgICAqL1xuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmVsZW1lbnRBdEhlaWdodChoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBsaW5lIGJsb2NrIChzZWVcbiAgICBbYGxpbmVCbG9ja0F0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZUJsb2NrQXQpIGF0IHRoZSBnaXZlblxuICAgIGhlaWdodCwgYWdhaW4gaW50ZXJwcmV0ZWQgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKS5cbiAgICAqL1xuICAgIGxpbmVCbG9ja0F0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBleHRlbnQgYW5kIHZlcnRpY2FsIHBvc2l0aW9uIG9mIGFsbCBbbGluZVxuICAgIGJsb2Nrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZUJsb2NrQXQpIGluIHRoZSB2aWV3cG9ydC4gUG9zaXRpb25zXG4gICAgYXJlIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCk7XG4gICAgKi9cbiAgICBnZXQgdmlld3BvcnRMaW5lQmxvY2tzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlld3BvcnRMaW5lcztcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgbGluZSBibG9jayBhcm91bmQgdGhlIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLiBBIGxpbmVcbiAgICBibG9jayBpcyBhIHJhbmdlIGRlbGltaXRlZCBvbiBib3RoIHNpZGVzIGJ5IGVpdGhlciBhXG4gICAgbm9uLVtoaWRkZW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uXnJlcGxhY2UpIGxpbmUgYnJlYWssIG9yIHRoZVxuICAgIHN0YXJ0L2VuZCBvZiB0aGUgZG9jdW1lbnQuIEl0IHdpbGwgdXN1YWxseSBqdXN0IGhvbGQgYSBsaW5lIG9mXG4gICAgdGV4dCwgYnV0IG1heSBiZSBicm9rZW4gaW50byBtdWx0aXBsZSB0ZXh0YmxvY2tzIGJ5IGJsb2NrXG4gICAgd2lkZ2V0cy5cbiAgICAqL1xuICAgIGxpbmVCbG9ja0F0KHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUubGluZUJsb2NrQXQocG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVkaXRvcidzIHRvdGFsIGNvbnRlbnQgaGVpZ2h0LlxuICAgICovXG4gICAgZ2V0IGNvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5jb250ZW50SGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGEgY3Vyc29yIHBvc2l0aW9uIGJ5IFtncmFwaGVtZVxuICAgIGNsdXN0ZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuZmluZENsdXN0ZXJCcmVhaykuIGBmb3J3YXJkYCBkZXRlcm1pbmVzIHdoZXRoZXJcbiAgICB0aGUgbW90aW9uIGlzIGF3YXkgZnJvbSB0aGUgbGluZSBzdGFydCwgb3IgdG93YXJkcyBpdC4gSW5cbiAgICBiaWRpcmVjdGlvbmFsIHRleHQsIHRoZSBsaW5lIGlzIHRyYXZlcnNlZCBpbiB2aXN1YWwgb3JkZXIsIHVzaW5nXG4gICAgdGhlIGVkaXRvcidzIFt0ZXh0IGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuXG4gICAgV2hlbiB0aGUgc3RhcnQgcG9zaXRpb24gd2FzIHRoZSBsYXN0IG9uZSBvbiB0aGUgbGluZSwgdGhlXG4gICAgcmV0dXJuZWQgcG9zaXRpb24gd2lsbCBiZSBhY3Jvc3MgdGhlIGxpbmUgYnJlYWsuIElmIHRoZXJlIGlzIG5vXG4gICAgZnVydGhlciBsaW5lLCB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAgXG4gICAgQnkgZGVmYXVsdCwgdGhpcyBtZXRob2QgbW92ZXMgb3ZlciBhIHNpbmdsZSBjbHVzdGVyLiBUaGVcbiAgICBvcHRpb25hbCBgYnlgIGFyZ3VtZW50IGNhbiBiZSB1c2VkIHRvIG1vdmUgYWNyb3NzIG1vcmUuIEl0IHdpbGxcbiAgICBiZSBjYWxsZWQgd2l0aCB0aGUgZmlyc3QgY2x1c3RlciBhcyBhcmd1bWVudCwgYW5kIHNob3VsZCByZXR1cm5cbiAgICBhIHByZWRpY2F0ZSB0aGF0IGRldGVybWluZXMsIGZvciBlYWNoIHN1YnNlcXVlbnQgY2x1c3RlcixcbiAgICB3aGV0aGVyIGl0IHNob3VsZCBhbHNvIGJlIG1vdmVkIG92ZXIuXG4gICAgKi9cbiAgICBtb3ZlQnlDaGFyKHN0YXJ0LCBmb3J3YXJkLCBieSkge1xuICAgICAgICByZXR1cm4gc2tpcEF0b21zKHRoaXMsIHN0YXJ0LCBtb3ZlQnlDaGFyKHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBieSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIGEgY3Vyc29yIHBvc2l0aW9uIGFjcm9zcyB0aGUgbmV4dCBncm91cCBvZiBlaXRoZXJcbiAgICBbbGV0dGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpIG9yIG5vbi1sZXR0ZXJcbiAgICBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICovXG4gICAgbW92ZUJ5R3JvdXAoc3RhcnQsIGZvcndhcmQpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZUJ5Q2hhcih0aGlzLCBzdGFydCwgZm9yd2FyZCwgaW5pdGlhbCA9PiBieUdyb3VwKHRoaXMsIHN0YXJ0LmhlYWQsIGluaXRpYWwpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY3Vyc29yIHBvc2l0aW9uIHZpc3VhbGx5IGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBsaW5lLlxuICAgIE5vdGUgdGhhdCB0aGlzIG1heSBkaWZmZXIgZnJvbSB0aGUgX2xvZ2ljYWxfIHBvc2l0aW9uIGF0IGl0c1xuICAgIHN0YXJ0IG9yIGVuZCAod2hpY2ggaXMgc2ltcGx5IGF0IGBsaW5lLmZyb21gL2BsaW5lLnRvYCkgaWYgdGV4dFxuICAgIGF0IHRoZSBzdGFydCBvciBlbmQgZ29lcyBhZ2FpbnN0IHRoZSBsaW5lJ3MgYmFzZSB0ZXh0IGRpcmVjdGlvbi5cbiAgICAqL1xuICAgIHZpc3VhbExpbmVTaWRlKGxpbmUsIGVuZCkge1xuICAgICAgICBsZXQgb3JkZXIgPSB0aGlzLmJpZGlTcGFucyhsaW5lKSwgZGlyID0gdGhpcy50ZXh0RGlyZWN0aW9uQXQobGluZS5mcm9tKTtcbiAgICAgICAgbGV0IHNwYW4gPSBvcmRlcltlbmQgPyBvcmRlci5sZW5ndGggLSAxIDogMF07XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHNwYW4uc2lkZShlbmQsIGRpcikgKyBsaW5lLmZyb20sIHNwYW4uZm9yd2FyZCghZW5kLCBkaXIpID8gMSA6IC0xKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBsaW5lIGJvdW5kYXJ5IGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uIElmXG4gICAgYGluY2x1ZGVXcmFwYCBpcyB0cnVlLCBsaW5lIHdyYXBwaW5nIGlzIG9uLCBhbmQgdGhlcmUgaXMgYVxuICAgIGZ1cnRoZXIgd3JhcCBwb2ludCBvbiB0aGUgY3VycmVudCBsaW5lLCB0aGUgd3JhcCBwb2ludCB3aWxsIGJlXG4gICAgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzdGFydCBvciBlbmRcbiAgICBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIG1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCwgaW5jbHVkZVdyYXAgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBtb3ZlVG9MaW5lQm91bmRhcnkodGhpcywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiB2ZXJ0aWNhbGx5LiBXaGVuIGBkaXN0YW5jZWAgaXNuJ3QgZ2l2ZW4sXG4gICAgaXQgZGVmYXVsdHMgdG8gbW92aW5nIHRvIHRoZSBuZXh0IGxpbmUgKGluY2x1ZGluZyB3cmFwcGVkXG4gICAgbGluZXMpLiBPdGhlcndpc2UsIGBkaXN0YW5jZWAgc2hvdWxkIHByb3ZpZGUgYSBwb3NpdGl2ZSBkaXN0YW5jZVxuICAgIGluIHBpeGVscy5cbiAgICBcbiAgICBXaGVuIGBzdGFydGAgaGFzIGFcbiAgICBbYGdvYWxDb2x1bW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmdvYWxDb2x1bW4pLCB0aGUgdmVydGljYWxcbiAgICBtb3Rpb24gd2lsbCB1c2UgdGhhdCBhcyBhIHRhcmdldCBob3Jpem9udGFsIHBvc2l0aW9uLiBPdGhlcndpc2UsXG4gICAgdGhlIGN1cnNvcidzIG93biBob3Jpem9udGFsIHBvc2l0aW9uIGlzIHVzZWQuIFRoZSByZXR1cm5lZFxuICAgIGN1cnNvciB3aWxsIGhhdmUgaXRzIGdvYWwgY29sdW1uIHNldCB0byB3aGljaGV2ZXIgY29sdW1uIHdhc1xuICAgIHVzZWQuXG4gICAgKi9cbiAgICBtb3ZlVmVydGljYWxseShzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZVZlcnRpY2FsbHkodGhpcywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBwYXJlbnQgbm9kZSBhbmQgb2Zmc2V0IChjaGlsZCBvZmZzZXQgaWYgYG5vZGVgIGlzXG4gICAgYW4gZWxlbWVudCwgY2hhcmFjdGVyIG9mZnNldCB3aGVuIGl0IGlzIGEgdGV4dCBub2RlKSBhdCB0aGVcbiAgICBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICBcbiAgICBOb3RlIHRoYXQgZm9yIHBvc2l0aW9ucyB0aGF0IGFyZW4ndCBjdXJyZW50bHkgaW5cbiAgICBgdmlzaWJsZVJhbmdlc2AsIHRoZSByZXN1bHRpbmcgRE9NIHBvc2l0aW9uIGlzbid0IG5lY2Vzc2FyaWx5XG4gICAgbWVhbmluZ2Z1bCAoaXQgbWF5IGp1c3QgcG9pbnQgYmVmb3JlIG9yIGFmdGVyIGEgcGxhY2Vob2xkZXJcbiAgICBlbGVtZW50KS5cbiAgICAqL1xuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUF0UG9zKHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBET00gbm9kZS4gQ2FuIGJlIHVzZWZ1bFxuICAgIGZvciBhc3NvY2lhdGluZyBwb3NpdGlvbnMgd2l0aCBET00gZXZlbnRzLiBXaWxsIHJhaXNlIGFuIGVycm9yXG4gICAgd2hlbiBgbm9kZWAgaXNuJ3QgcGFydCBvZiB0aGUgZWRpdG9yIGNvbnRlbnQuXG4gICAgKi9cbiAgICBwb3NBdERPTShub2RlLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgICBwb3NBdENvb3Jkcyhjb29yZHMsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiBwb3NBdENvb3Jkcyh0aGlzLCBjb29yZHMsIHByZWNpc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHNjcmVlbiBjb29yZGluYXRlcyBhdCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgYHNpZGVgIGRldGVybWluZXMgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGJhc2VkIG9uIHRoZVxuICAgIGVsZW1lbnQgYmVmb3JlICgtMSkgb3IgYWZ0ZXIgKDEpIHRoZSBwb3NpdGlvbiAoaWYgbm8gZWxlbWVudCBpc1xuICAgIGF2YWlsYWJsZSBvbiB0aGUgZ2l2ZW4gc2lkZSwgdGhlIG1ldGhvZCB3aWxsIHRyYW5zcGFyZW50bHkgdXNlXG4gICAgYW5vdGhlciBzdHJhdGVneSB0byBnZXQgcmVhc29uYWJsZSBjb29yZGluYXRlcykuXG4gICAgKi9cbiAgICBjb29yZHNBdFBvcyhwb3MsIHNpZGUgPSAxKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5kb2NWaWV3LmNvb3Jkc0F0KHBvcywgc2lkZSk7XG4gICAgICAgIGlmICghcmVjdCB8fCByZWN0LmxlZnQgPT0gcmVjdC5yaWdodClcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBvcmRlciA9IHRoaXMuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW0JpZGlTcGFuLmZpbmQob3JkZXIsIHBvcyAtIGxpbmUuZnJvbSwgLTEsIHNpZGUpXTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHJlY3QsIChzcGFuLmRpciA9PSBEaXJlY3Rpb24uTFRSKSA9PSAoc2lkZSA+IDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSByZWN0YW5nbGUgYXJvdW5kIGEgZ2l2ZW4gY2hhcmFjdGVyLiBJZiBgcG9zYCBkb2VzIG5vdFxuICAgIHBvaW50IGluIGZyb250IG9mIGEgY2hhcmFjdGVyIHRoYXQgaXMgaW4gdGhlIHZpZXdwb3J0IGFuZFxuICAgIHJlbmRlcmVkIChpLmUuIG5vdCByZXBsYWNlZCwgbm90IGEgbGluZSBicmVhayksIHRoaXMgd2lsbCByZXR1cm5cbiAgICBudWxsLiBGb3Igc3BhY2UgY2hhcmFjdGVycyB0aGF0IGFyZSBhIGxpbmUgd3JhcCBwb2ludCwgdGhpcyB3aWxsXG4gICAgcmV0dXJuIHRoZSBwb3NpdGlvbiBiZWZvcmUgdGhlIGxpbmUgYnJlYWsuXG4gICAgKi9cbiAgICBjb29yZHNGb3JDaGFyKHBvcykge1xuICAgICAgICB0aGlzLnJlYWRNZWFzdXJlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmNvb3Jkc0ZvckNoYXIocG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgd2lkdGggb2YgYSBjaGFyYWN0ZXIgaW4gdGhlIGVkaXRvci4gTWF5IG5vdFxuICAgIGFjY3VyYXRlbHkgcmVmbGVjdCB0aGUgd2lkdGggb2YgYWxsIGNoYXJhY3RlcnMgKGdpdmVuIHZhcmlhYmxlXG4gICAgd2lkdGggZm9udHMgb3Igc3R5bGluZyBvZiBpbnZpZGlkdWFsIHJhbmdlcykuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdENoYXJhY3RlcldpZHRoKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDsgfVxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IGhlaWdodCBvZiBhIGxpbmUgaW4gdGhlIGVkaXRvci4gTWF5IG5vdCBiZSBhY2N1cmF0ZVxuICAgIGZvciBhbGwgbGluZXMuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdExpbmVIZWlnaHQoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUhlaWdodDsgfVxuICAgIC8qKlxuICAgIFRoZSB0ZXh0IGRpcmVjdGlvblxuICAgIChbYGRpcmVjdGlvbmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9kaXJlY3Rpb24pXG4gICAgQ1NTIHByb3BlcnR5KSBvZiB0aGUgZWRpdG9yJ3MgY29udGVudCBlbGVtZW50LlxuICAgICovXG4gICAgZ2V0IHRleHREaXJlY3Rpb24oKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5kZWZhdWx0VGV4dERpcmVjdGlvbjsgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBibG9jayBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGFzXG4gICAgYXNzaWduZWQgYnkgQ1NTLiBJZlxuICAgIFtgcGVyTGluZVRleHREaXJlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15wZXJMaW5lVGV4dERpcmVjdGlvbilcbiAgICBpc24ndCBlbmFibGVkLCBvciB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQsXG4gICAgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgYXNcbiAgICBbYHRleHREaXJlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS4gTm90ZSB0aGF0XG4gICAgdGhpcyBtYXkgdHJpZ2dlciBhIERPTSBsYXlvdXQuXG4gICAgKi9cbiAgICB0ZXh0RGlyZWN0aW9uQXQocG9zKSB7XG4gICAgICAgIGxldCBwZXJMaW5lID0gdGhpcy5zdGF0ZS5mYWNldChwZXJMaW5lVGV4dERpcmVjdGlvbik7XG4gICAgICAgIGlmICghcGVyTGluZSB8fCBwb3MgPCB0aGlzLnZpZXdwb3J0LmZyb20gfHwgcG9zID4gdGhpcy52aWV3cG9ydC50bylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHREaXJlY3Rpb247XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcudGV4dERpcmVjdGlvbkF0KHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhpcyBlZGl0b3IgW3dyYXBzIGxpbmVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcpXG4gICAgKGFzIGRldGVybWluZWQgYnkgdGhlXG4gICAgW2B3aGl0ZS1zcGFjZWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy93aGl0ZS1zcGFjZSlcbiAgICBDU1MgcHJvcGVydHkgb2YgaXRzIGNvbnRlbnQgZWxlbWVudCkuXG4gICAgKi9cbiAgICBnZXQgbGluZVdyYXBwaW5nKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVXcmFwcGluZzsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhlIGJpZGlyZWN0aW9uYWwgdGV4dCBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuIGxpbmVcbiAgICAod2hpY2ggc2hvdWxkIGJlIGluIHRoZSBjdXJyZW50IGRvY3VtZW50KSBhcyBhbiBhcnJheSBvZiBzcGFuXG4gICAgb2JqZWN0cy4gVGhlIG9yZGVyIG9mIHRoZXNlIHNwYW5zIG1hdGNoZXMgdGhlIFt0ZXh0XG4gICAgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKeKAlGlmIHRoYXQgaXNcbiAgICBsZWZ0LXRvLXJpZ2h0LCB0aGUgbGVmdG1vc3Qgc3BhbnMgY29tZSBmaXJzdCwgb3RoZXJ3aXNlIHRoZVxuICAgIHJpZ2h0bW9zdCBzcGFucyBjb21lIGZpcnN0LlxuICAgICovXG4gICAgYmlkaVNwYW5zKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gTWF4QmlkaUxpbmUpXG4gICAgICAgICAgICByZXR1cm4gdHJpdmlhbE9yZGVyKGxpbmUubGVuZ3RoKTtcbiAgICAgICAgbGV0IGRpciA9IHRoaXMudGV4dERpcmVjdGlvbkF0KGxpbmUuZnJvbSksIGlzb2xhdGVzO1xuICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiB0aGlzLmJpZGlDYWNoZSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5LmZyb20gPT0gbGluZS5mcm9tICYmIGVudHJ5LmRpciA9PSBkaXIgJiZcbiAgICAgICAgICAgICAgICAoZW50cnkuZnJlc2ggfHwgaXNvbGF0ZXNFcShlbnRyeS5pc29sYXRlcywgaXNvbGF0ZXMgPSBnZXRJc29sYXRlZFJhbmdlcyh0aGlzLCBsaW5lKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5vcmRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzb2xhdGVzKVxuICAgICAgICAgICAgaXNvbGF0ZXMgPSBnZXRJc29sYXRlZFJhbmdlcyh0aGlzLCBsaW5lKTtcbiAgICAgICAgbGV0IG9yZGVyID0gY29tcHV0ZU9yZGVyKGxpbmUudGV4dCwgZGlyLCBpc29sYXRlcyk7XG4gICAgICAgIHRoaXMuYmlkaUNhY2hlLnB1c2gobmV3IENhY2hlZE9yZGVyKGxpbmUuZnJvbSwgbGluZS50bywgZGlyLCBpc29sYXRlcywgdHJ1ZSwgb3JkZXIpKTtcbiAgICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZSBlZGl0b3IgaGFzIGZvY3VzLlxuICAgICovXG4gICAgZ2V0IGhhc0ZvY3VzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFNhZmFyaSByZXR1cm4gZmFsc2UgZm9yIGhhc0ZvY3VzIHdoZW4gdGhlIGNvbnRleHQgbWVudSBpcyBvcGVuXG4gICAgICAgIC8vIG9yIGNsb3NpbmcsIHdoaWNoIGxlYWRzIHVzIHRvIGlnbm9yZSBzZWxlY3Rpb24gY2hhbmdlcyBmcm9tIHRoZVxuICAgICAgICAvLyBjb250ZXh0IG1lbnUgYmVjYXVzZSBpdCBsb29rcyBsaWtlIHRoZSBlZGl0b3IgaXNuJ3QgZm9jdXNlZC5cbiAgICAgICAgLy8gVGhpcyBrbHVkZ2VzIGFyb3VuZCB0aGF0LlxuICAgICAgICByZXR1cm4gKHRoaXMuZG9tLm93bmVyRG9jdW1lbnQuaGFzRm9jdXMoKSB8fCBicm93c2VyLnNhZmFyaSAmJiAoKF9hID0gdGhpcy5pbnB1dFN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdENvbnRleHRNZW51KSA+IERhdGUubm93KCkgLSAzZTQpICYmXG4gICAgICAgICAgICB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudCA9PSB0aGlzLmNvbnRlbnRET007XG4gICAgfVxuICAgIC8qKlxuICAgIFB1dCBmb2N1cyBvbiB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgICAgICAgIGZvY3VzUHJldmVudFNjcm9sbCh0aGlzLmNvbnRlbnRET00pO1xuICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSBbcm9vdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyMjdmlldy5FZGl0b3JWaWV3Q29uZmlnLnJvb3QpIGluIHdoaWNoIHRoZSBlZGl0b3IgbGl2ZXMuIFRoaXMgaXMgb25seVxuICAgIG5lY2Vzc2FyeSB3aGVuIG1vdmluZyB0aGUgZWRpdG9yJ3MgZXhpc3RpbmcgRE9NIHRvIGEgbmV3IHdpbmRvdyBvciBzaGFkb3cgcm9vdC5cbiAgICAqL1xuICAgIHNldFJvb3Qocm9vdCkge1xuICAgICAgICBpZiAodGhpcy5fcm9vdCAhPSByb290KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuc2V0V2luZG93KChyb290Lm5vZGVUeXBlID09IDkgPyByb290IDogcm9vdC5vd25lckRvY3VtZW50KS5kZWZhdWx0VmlldyB8fCB3aW5kb3cpO1xuICAgICAgICAgICAgdGhpcy5tb3VudFN0eWxlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENsZWFuIHVwIHRoaXMgZWRpdG9yIHZpZXcsIHJlbW92aW5nIGl0cyBlbGVtZW50IGZyb20gdGhlXG4gICAgZG9jdW1lbnQsIHVucmVnaXN0ZXJpbmcgZXZlbnQgaGFuZGxlcnMsIGFuZCBub3RpZnlpbmdcbiAgICBwbHVnaW5zLiBUaGUgdmlldyBpbnN0YW5jZSBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgYWZ0ZXJcbiAgICBjYWxsaW5nIHRoaXMuXG4gICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgdGhpcy5jb250ZW50RE9NLmJsdXIoKTtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZWZmZWN0IHRoYXQgY2FuIGJlXG4gICAgW2FkZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSB0byBhIHRyYW5zYWN0aW9uIHRvXG4gICAgY2F1c2UgaXQgdG8gc2Nyb2xsIHRoZSBnaXZlbiBwb3NpdGlvbiBvciByYW5nZSBpbnRvIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgc2Nyb2xsSW50b1ZpZXcocG9zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHNjcm9sbEludG9WaWV3Lm9mKG5ldyBTY3JvbGxUYXJnZXQodHlwZW9mIHBvcyA9PSBcIm51bWJlclwiID8gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpIDogcG9zLCBvcHRpb25zLnksIG9wdGlvbnMueCwgb3B0aW9ucy55TWFyZ2luLCBvcHRpb25zLnhNYXJnaW4pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGFuIGVmZmVjdCB0aGF0IHJlc2V0cyB0aGUgZWRpdG9yIHRvIGl0cyBjdXJyZW50IChhdCB0aGVcbiAgICB0aW1lIHRoaXMgbWV0aG9kIHdhcyBjYWxsZWQpIHNjcm9sbCBwb3NpdGlvbi4gTm90ZSB0aGF0IHRoaXNcbiAgICBvbmx5IGFmZmVjdHMgdGhlIGVkaXRvcidzIG93biBzY3JvbGxhYmxlIGVsZW1lbnQsIG5vdCBwYXJlbnRzLlxuICAgIFNlZSBhbHNvXG4gICAgW2BFZGl0b3JWaWV3Q29uZmlnLnNjcm9sbFRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdDb25maWcuc2Nyb2xsVG8pLlxuICAgIFxuICAgIFRoZSBlZmZlY3Qgc2hvdWxkIGJlIHVzZWQgd2l0aCBhIGRvY3VtZW50IGlkZW50aWNhbCB0byB0aGUgb25lXG4gICAgaXQgd2FzIGNyZWF0ZWQgZm9yLiBGYWlsaW5nIHRvIGRvIHNvIGlzIG5vdCBhbiBlcnJvciwgYnV0IG1heVxuICAgIG5vdCBzY3JvbGwgdG8gdGhlIGV4cGVjdGVkIHBvc2l0aW9uLiBZb3UgY2FuXG4gICAgW21hcF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdC5tYXApIHRoZSBlZmZlY3QgdG8gYWNjb3VudCBmb3IgY2hhbmdlcy5cbiAgICAqL1xuICAgIHNjcm9sbFNuYXBzaG90KCkge1xuICAgICAgICBsZXQgeyBzY3JvbGxUb3AsIHNjcm9sbExlZnQgfSA9IHRoaXMuc2Nyb2xsRE9NO1xuICAgICAgICBsZXQgcmVmID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9yQXQoc2Nyb2xsVG9wKTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbEludG9WaWV3Lm9mKG5ldyBTY3JvbGxUYXJnZXQoRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyZWYuZnJvbSksIFwic3RhcnRcIiwgXCJzdGFydFwiLCByZWYudG9wIC0gc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0LCB0cnVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEVuYWJsZSBvciBkaXNhYmxlIHRhYi1mb2N1cyBtb2RlLCB3aGljaCBkaXNhYmxlcyBrZXkgYmluZGluZ3NcbiAgICBmb3IgVGFiIGFuZCBTaGlmdC1UYWIsIGxldHRpbmcgdGhlIGJyb3dzZXIncyBkZWZhdWx0XG4gICAgZm9jdXMtY2hhbmdpbmcgYmVoYXZpb3IgZ28gdGhyb3VnaCBpbnN0ZWFkLiBUaGlzIGlzIHVzZWZ1bCB0b1xuICAgIHByZXZlbnQgdHJhcHBpbmcga2V5Ym9hcmQgdXNlcnMgaW4geW91ciBlZGl0b3IuXG4gICAgXG4gICAgV2l0aG91dCBhcmd1bWVudCwgdGhpcyB0b2dnbGVzIHRoZSBtb2RlLiBXaXRoIGEgYm9vbGVhbiwgaXRcbiAgICBlbmFibGVzICh0cnVlKSBvciBkaXNhYmxlcyBpdCAoZmFsc2UpLiBHaXZlbiBhIG51bWJlciwgaXRcbiAgICB0ZW1wb3JhcmlseSBlbmFibGVzIHRoZSBtb2RlIHVudGlsIHRoYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICAgIGhhdmUgcGFzc2VkIG9yIGFub3RoZXIgbm9uLVRhYiBrZXkgaXMgcHJlc3NlZC5cbiAgICAqL1xuICAgIHNldFRhYkZvY3VzTW9kZSh0bykge1xuICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS50YWJGb2N1c01vZGUgPSB0aGlzLmlucHV0U3RhdGUudGFiRm9jdXNNb2RlIDwgMCA/IDAgOiAtMTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRvID09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgdGhpcy5pbnB1dFN0YXRlLnRhYkZvY3VzTW9kZSA9IHRvID8gMCA6IC0xO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmlucHV0U3RhdGUudGFiRm9jdXNNb2RlICE9IDApXG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudGFiRm9jdXNNb2RlID0gRGF0ZS5ub3coKSArIHRvO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFkZCBET00gZXZlbnQgaGFuZGxlcnMuXG4gICAgVGhlIHZhbHVlIHNob3VsZCBiZSBhbiBvYmplY3QgbWFwcGluZyBldmVudCBuYW1lcyB0byBoYW5kbGVyXG4gICAgZnVuY3Rpb25zLiBGb3IgYW55IGdpdmVuIGV2ZW50LCBzdWNoIGZ1bmN0aW9ucyBhcmUgb3JkZXJlZCBieVxuICAgIGV4dGVuc2lvbiBwcmVjZWRlbmNlLCBhbmQgdGhlIGZpcnN0IGhhbmRsZXIgdG8gcmV0dXJuIHRydWUgd2lsbFxuICAgIGJlIGFzc3VtZWQgdG8gaGF2ZSBoYW5kbGVkIHRoYXQgZXZlbnQsIGFuZCBubyBvdGhlciBoYW5kbGVycyBvclxuICAgIGJ1aWx0LWluIGJlaGF2aW9yIHdpbGwgYmUgYWN0aXZhdGVkIGZvciBpdC4gVGhlc2UgYXJlIHJlZ2lzdGVyZWRcbiAgICBvbiB0aGUgW2NvbnRlbnQgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuY29udGVudERPTSksIGV4Y2VwdFxuICAgIGZvciBgc2Nyb2xsYCBoYW5kbGVycywgd2hpY2ggd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgdGhlXG4gICAgZWRpdG9yJ3MgW3Njcm9sbCBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5zY3JvbGxET00pIG9yIG9uZSBvZlxuICAgIGl0cyBwYXJlbnQgbm9kZXMgaXMgc2Nyb2xsZWQuXG4gICAgKi9cbiAgICBzdGF0aWMgZG9tRXZlbnRIYW5kbGVycyhoYW5kbGVycykge1xuICAgICAgICByZXR1cm4gVmlld1BsdWdpbi5kZWZpbmUoKCkgPT4gKHt9KSwgeyBldmVudEhhbmRsZXJzOiBoYW5kbGVycyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IHJlZ2lzdGVycyBET00gZXZlbnQgb2JzZXJ2ZXJzLiBDb250cmFyeVxuICAgIHRvIGV2ZW50IFtoYW5kbGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZG9tRXZlbnRIYW5kbGVycyksXG4gICAgb2JzZXJ2ZXJzIGNhbid0IGJlIHByZXZlbnRlZCBmcm9tIHJ1bm5pbmcgYnkgYSBoaWdoZXItcHJlY2VkZW5jZVxuICAgIGhhbmRsZXIgcmV0dXJuaW5nIHRydWUuIFRoZXkgYWxzbyBkb24ndCBwcmV2ZW50IG90aGVyIGhhbmRsZXJzXG4gICAgYW5kIG9ic2VydmVycyBmcm9tIHJ1bm5pbmcgd2hlbiB0aGV5IHJldHVybiB0cnVlLCBhbmQgc2hvdWxkIG5vdFxuICAgIGNhbGwgYHByZXZlbnREZWZhdWx0YC5cbiAgICAqL1xuICAgIHN0YXRpYyBkb21FdmVudE9ic2VydmVycyhvYnNlcnZlcnMpIHtcbiAgICAgICAgcmV0dXJuIFZpZXdQbHVnaW4uZGVmaW5lKCgpID0+ICh7fSksIHsgZXZlbnRPYnNlcnZlcnM6IG9ic2VydmVycyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgdGhlbWUgZXh0ZW5zaW9uLiBUaGUgZmlyc3QgYXJndW1lbnQgY2FuIGJlIGFcbiAgICBbYHN0eWxlLW1vZGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKVxuICAgIHN0eWxlIHNwZWMgcHJvdmlkaW5nIHRoZSBzdHlsZXMgZm9yIHRoZSB0aGVtZS4gVGhlc2Ugd2lsbCBiZVxuICAgIHByZWZpeGVkIHdpdGggYSBnZW5lcmF0ZWQgY2xhc3MgZm9yIHRoZSBzdHlsZS5cbiAgICBcbiAgICBCZWNhdXNlIHRoZSBzZWxlY3RvcnMgd2lsbCBiZSBwcmVmaXhlZCB3aXRoIGEgc2NvcGUgY2xhc3MsIHJ1bGVcbiAgICB0aGF0IGRpcmVjdGx5IG1hdGNoIHRoZSBlZGl0b3IncyBbd3JhcHBlclxuICAgIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvbSnigJR0byB3aGljaCB0aGUgc2NvcGUgY2xhc3Mgd2lsbCBiZVxuICAgIGFkZGVk4oCUbmVlZCB0byBiZSBleHBsaWNpdGx5IGRpZmZlcmVudGlhdGVkIGJ5IGFkZGluZyBhbiBgJmAgdG9cbiAgICB0aGUgc2VsZWN0b3IgZm9yIHRoYXQgZWxlbWVudOKAlGZvciBleGFtcGxlXG4gICAgYCYuY20tZm9jdXNlZGAuXG4gICAgXG4gICAgV2hlbiBgZGFya2AgaXMgc2V0IHRvIHRydWUsIHRoZSB0aGVtZSB3aWxsIGJlIG1hcmtlZCBhcyBkYXJrLFxuICAgIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGAmZGFya2AgcnVsZXMgZnJvbSBbYmFzZVxuICAgIHRoZW1lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeYmFzZVRoZW1lKSB0byBiZSB1c2VkIChhcyBvcHBvc2VkIHRvXG4gICAgYCZsaWdodGAgd2hlbiBhIGxpZ2h0IHRoZW1lIGlzIGFjdGl2ZSkuXG4gICAgKi9cbiAgICBzdGF0aWMgdGhlbWUoc3BlYywgb3B0aW9ucykge1xuICAgICAgICBsZXQgcHJlZml4ID0gU3R5bGVNb2R1bGUubmV3TmFtZSgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW3RoZW1lLm9mKHByZWZpeCksIHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoYC4ke3ByZWZpeH1gLCBzcGVjKSldO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRhcmspXG4gICAgICAgICAgICByZXN1bHQucHVzaChkYXJrVGhlbWUub2YodHJ1ZSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyBzdHlsZXMgdG8gdGhlIGJhc2UgdGhlbWUuIExpa2VcbiAgICB3aXRoIFtgdGhlbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld150aGVtZSksIHVzZSBgJmAgdG8gaW5kaWNhdGUgdGhlXG4gICAgcGxhY2Ugb2YgdGhlIGVkaXRvciB3cmFwcGVyIGVsZW1lbnQgd2hlbiBkaXJlY3RseSB0YXJnZXRpbmdcbiAgICB0aGF0LiBZb3UgY2FuIGFsc28gdXNlIGAmZGFya2Agb3IgYCZsaWdodGAgaW5zdGVhZCB0byBvbmx5XG4gICAgdGFyZ2V0IGVkaXRvcnMgd2l0aCBhIGRhcmsgb3IgbGlnaHQgdGhlbWUuXG4gICAgKi9cbiAgICBzdGF0aWMgYmFzZVRoZW1lKHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIFByZWMubG93ZXN0KHN0eWxlTW9kdWxlLm9mKGJ1aWxkVGhlbWUoXCIuXCIgKyBiYXNlVGhlbWVJRCwgc3BlYywgbGlnaHREYXJrSURzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSBhbiBlZGl0b3IgdmlldyBpbnN0YW5jZSBmcm9tIHRoZSB2aWV3J3MgRE9NXG4gICAgcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEZyb21ET00oZG9tKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBkb20ucXVlcnlTZWxlY3RvcihcIi5jbS1jb250ZW50XCIpO1xuICAgICAgICBsZXQgY1ZpZXcgPSBjb250ZW50ICYmIENvbnRlbnRWaWV3LmdldChjb250ZW50KSB8fCBDb250ZW50Vmlldy5nZXQoZG9tKTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBjVmlldyA9PT0gbnVsbCB8fCBjVmlldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY1ZpZXcucm9vdFZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52aWV3KSB8fCBudWxsO1xuICAgIH1cbn1cbi8qKlxuRmFjZXQgdG8gYWRkIGEgW3N0eWxlXG5tb2R1bGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKSB0b1xuYW4gZWRpdG9yIHZpZXcuIFRoZSB2aWV3IHdpbGwgZW5zdXJlIHRoYXQgdGhlIG1vZHVsZSBpc1xubW91bnRlZCBpbiBpdHMgW2RvY3VtZW50XG5yb290XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5jb25zdHJ1Y3Rvcl5jb25maWcucm9vdCkuXG4qL1xuRWRpdG9yVmlldy5zdHlsZU1vZHVsZSA9IHN0eWxlTW9kdWxlO1xuLyoqXG5BbiBpbnB1dCBoYW5kbGVyIGNhbiBvdmVycmlkZSB0aGUgd2F5IGNoYW5nZXMgdG8gdGhlIGVkaXRhYmxlXG5ET00gY29udGVudCBhcmUgaGFuZGxlZC4gSGFuZGxlcnMgYXJlIHBhc3NlZCB0aGUgZG9jdW1lbnRcbnBvc2l0aW9ucyBiZXR3ZWVuIHdoaWNoIHRoZSBjaGFuZ2Ugd2FzIGZvdW5kLCBhbmQgdGhlIG5ld1xuY29udGVudC4gV2hlbiBvbmUgcmV0dXJucyB0cnVlLCBubyBmdXJ0aGVyIGlucHV0IGhhbmRsZXJzIGFyZVxuY2FsbGVkIGFuZCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBwcmV2ZW50ZWQuXG5cblRoZSBgaW5zZXJ0YCBhcmd1bWVudCBjYW4gYmUgdXNlZCB0byBnZXQgdGhlIGRlZmF1bHQgdHJhbnNhY3Rpb25cbnRoYXQgd291bGQgYmUgYXBwbGllZCBmb3IgdGhpcyBpbnB1dC4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW5cbmRpc3BhdGNoaW5nIHRoZSBjdXN0b20gYmVoYXZpb3IgYXMgYSBzZXBhcmF0ZSB0cmFuc2FjdGlvbi5cbiovXG5FZGl0b3JWaWV3LmlucHV0SGFuZGxlciA9IGlucHV0SGFuZGxlcjtcbi8qKlxuRnVuY3Rpb25zIHByb3ZpZGVkIGluIHRoaXMgZmFjZXQgd2lsbCBiZSB1c2VkIHRvIHRyYW5zZm9ybSB0ZXh0XG5wYXN0ZWQgb3IgZHJvcHBlZCBpbnRvIHRoZSBlZGl0b3IuXG4qL1xuRWRpdG9yVmlldy5jbGlwYm9hcmRJbnB1dEZpbHRlciA9IGNsaXBib2FyZElucHV0RmlsdGVyO1xuLyoqXG5UcmFuc2Zvcm0gdGV4dCBjb3BpZWQgb3IgZHJhZ2dlZCBmcm9tIHRoZSBlZGl0b3IuXG4qL1xuRWRpdG9yVmlldy5jbGlwYm9hcmRPdXRwdXRGaWx0ZXIgPSBjbGlwYm9hcmRPdXRwdXRGaWx0ZXI7XG4vKipcblNjcm9sbCBoYW5kbGVycyBjYW4gb3ZlcnJpZGUgaG93IHRoaW5ncyBhcmUgc2Nyb2xsZWQgaW50byB2aWV3LlxuSWYgdGhleSByZXR1cm4gYHRydWVgLCBubyBmdXJ0aGVyIGhhbmRsaW5nIGhhcHBlbnMgZm9yIHRoZVxuc2Nyb2xsaW5nLiBJZiB0aGV5IHJldHVybiBmYWxzZSwgdGhlIGRlZmF1bHQgc2Nyb2xsIGJlaGF2aW9yIGlzXG5hcHBsaWVkLiBTY3JvbGwgaGFuZGxlcnMgc2hvdWxkIG5ldmVyIGluaXRpYXRlIGVkaXRvciB1cGRhdGVzLlxuKi9cbkVkaXRvclZpZXcuc2Nyb2xsSGFuZGxlciA9IHNjcm9sbEhhbmRsZXI7XG4vKipcblRoaXMgZmFjZXQgY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBmdW5jdGlvbnMgdGhhdCBjcmVhdGUgZWZmZWN0c1xudG8gYmUgZGlzcGF0Y2hlZCB3aGVuIHRoZSBlZGl0b3IncyBmb2N1cyBzdGF0ZSBjaGFuZ2VzLlxuKi9cbkVkaXRvclZpZXcuZm9jdXNDaGFuZ2VFZmZlY3QgPSBmb2N1c0NoYW5nZUVmZmVjdDtcbi8qKlxuQnkgZGVmYXVsdCwgdGhlIGVkaXRvciBhc3N1bWVzIGFsbCBpdHMgY29udGVudCBoYXMgdGhlIHNhbWVcblt0ZXh0IGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRpcmVjdGlvbikuIENvbmZpZ3VyZSB0aGlzIHdpdGggYSBgdHJ1ZWBcbnZhbHVlIHRvIG1ha2UgaXQgcmVhZCB0aGUgdGV4dCBkaXJlY3Rpb24gb2YgZXZlcnkgKHJlbmRlcmVkKVxubGluZSBzZXBhcmF0ZWx5LlxuKi9cbkVkaXRvclZpZXcucGVyTGluZVRleHREaXJlY3Rpb24gPSBwZXJMaW5lVGV4dERpcmVjdGlvbjtcbi8qKlxuQWxsb3dzIHlvdSB0byBwcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlXG5saWJyYXJ5IGNhdGNoZXMgYW4gZXhjZXB0aW9uIGZyb20gYW4gZXh0ZW5zaW9uIChtb3N0bHkgZnJvbSB2aWV3XG5wbHVnaW5zLCBidXQgbWF5IGJlIHVzZWQgYnkgb3RoZXIgZXh0ZW5zaW9ucyB0byByb3V0ZSBleGNlcHRpb25zXG5mcm9tIHVzZXItY29kZS1wcm92aWRlZCBjYWxsYmFja3MpLiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgZm9yXG5kZWJ1Z2dpbmcgYW5kIGxvZ2dpbmcuIFNlZSBbYGxvZ0V4Y2VwdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5sb2dFeGNlcHRpb24pLlxuKi9cbkVkaXRvclZpZXcuZXhjZXB0aW9uU2luayA9IGV4Y2VwdGlvblNpbms7XG4vKipcbkEgZmFjZXQgdGhhdCBjYW4gYmUgdXNlZCB0byByZWdpc3RlciBhIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuZXZlcnkgdGltZSB0aGUgdmlldyB1cGRhdGVzLlxuKi9cbkVkaXRvclZpZXcudXBkYXRlTGlzdGVuZXIgPSB1cGRhdGVMaXN0ZW5lcjtcbi8qKlxuRmFjZXQgdGhhdCBjb250cm9scyB3aGV0aGVyIHRoZSBlZGl0b3IgY29udGVudCBET00gaXMgZWRpdGFibGUuXG5XaGVuIGl0cyBoaWdoZXN0LXByZWNlZGVuY2UgdmFsdWUgaXMgYGZhbHNlYCwgdGhlIGVsZW1lbnQgd2lsbFxubm90IGhhdmUgaXRzIGBjb250ZW50ZWRpdGFibGVgIGF0dHJpYnV0ZSBzZXQuIChOb3RlIHRoYXQgdGhpc1xuZG9lc24ndCBhZmZlY3QgQVBJIGNhbGxzIHRoYXQgY2hhbmdlIHRoZSBlZGl0b3IgY29udGVudCwgZXZlblxud2hlbiB0aG9zZSBhcmUgYm91bmQgdG8ga2V5cyBvciBidXR0b25zLiBTZWUgdGhlXG5bYHJlYWRPbmx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5yZWFkT25seSkgZmFjZXQgZm9yIHRoYXQuKVxuKi9cbkVkaXRvclZpZXcuZWRpdGFibGUgPSBlZGl0YWJsZTtcbi8qKlxuQWxsb3dzIHlvdSB0byBpbmZsdWVuY2UgdGhlIHdheSBtb3VzZSBzZWxlY3Rpb24gaGFwcGVucy4gVGhlXG5mdW5jdGlvbnMgaW4gdGhpcyBmYWNldCB3aWxsIGJlIGNhbGxlZCBmb3IgYSBgbW91c2Vkb3duYCBldmVudFxub24gdGhlIGVkaXRvciwgYW5kIGNhbiByZXR1cm4gYW4gb2JqZWN0IHRoYXQgb3ZlcnJpZGVzIHRoZSB3YXkgYVxuc2VsZWN0aW9uIGlzIGNvbXB1dGVkIGZyb20gdGhhdCBtb3VzZSBjbGljayBvciBkcmFnLlxuKi9cbkVkaXRvclZpZXcubW91c2VTZWxlY3Rpb25TdHlsZSA9IG1vdXNlU2VsZWN0aW9uU3R5bGU7XG4vKipcbkZhY2V0IHVzZWQgdG8gY29uZmlndXJlIHdoZXRoZXIgYSBnaXZlbiBzZWxlY3Rpb24gZHJhZyBldmVudFxuc2hvdWxkIG1vdmUgb3IgY29weSB0aGUgc2VsZWN0aW9uLiBUaGUgZ2l2ZW4gcHJlZGljYXRlIHdpbGwgYmVcbmNhbGxlZCB3aXRoIHRoZSBgbW91c2Vkb3duYCBldmVudCwgYW5kIGNhbiByZXR1cm4gYHRydWVgIHdoZW5cbnRoZSBkcmFnIHNob3VsZCBtb3ZlIHRoZSBjb250ZW50LlxuKi9cbkVkaXRvclZpZXcuZHJhZ01vdmVzU2VsZWN0aW9uID0gZHJhZ01vdmVzU2VsZWN0aW9uJDE7XG4vKipcbkZhY2V0IHVzZWQgdG8gY29uZmlndXJlIHdoZXRoZXIgYSBnaXZlbiBzZWxlY3RpbmcgY2xpY2sgYWRkcyBhXG5uZXcgcmFuZ2UgdG8gdGhlIGV4aXN0aW5nIHNlbGVjdGlvbiBvciByZXBsYWNlcyBpdCBlbnRpcmVseS4gVGhlXG5kZWZhdWx0IGJlaGF2aW9yIGlzIHRvIGNoZWNrIGBldmVudC5tZXRhS2V5YCBvbiBtYWNPUywgYW5kXG5gZXZlbnQuY3RybEtleWAgZWxzZXdoZXJlLlxuKi9cbkVkaXRvclZpZXcuY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UgPSBjbGlja0FkZHNTZWxlY3Rpb25SYW5nZTtcbi8qKlxuQSBmYWNldCB0aGF0IGRldGVybWluZXMgd2hpY2ggW2RlY29yYXRpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbilcbmFyZSBzaG93biBpbiB0aGUgdmlldy4gRGVjb3JhdGlvbnMgY2FuIGJlIHByb3ZpZGVkIGluIHR3b1xud2F5c+KAlGRpcmVjdGx5LCBvciB2aWEgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIGVkaXRvciB2aWV3LlxuXG5Pbmx5IGRlY29yYXRpb24gc2V0cyBwcm92aWRlZCBkaXJlY3RseSBhcmUgYWxsb3dlZCB0byBpbmZsdWVuY2VcbnRoZSBlZGl0b3IncyB2ZXJ0aWNhbCBsYXlvdXQgc3RydWN0dXJlLiBUaGUgb25lcyBwcm92aWRlZCBhc1xuZnVuY3Rpb25zIGFyZSBjYWxsZWQgX2FmdGVyXyB0aGUgbmV3IHZpZXdwb3J0IGhhcyBiZWVuIGNvbXB1dGVkLFxuYW5kIHRodXMgKiptdXN0IG5vdCoqIGludHJvZHVjZSBibG9jayB3aWRnZXRzIG9yIHJlcGxhY2luZ1xuZGVjb3JhdGlvbnMgdGhhdCBjb3ZlciBsaW5lIGJyZWFrcy5cblxuSWYgeW91IHdhbnQgZGVjb3JhdGVkIHJhbmdlcyB0byBiZWhhdmUgbGlrZSBhdG9taWMgdW5pdHMgZm9yXG5jdXJzb3IgbW90aW9uIGFuZCBkZWxldGlvbiBwdXJwb3NlcywgYWxzbyBwcm92aWRlIHRoZSByYW5nZSBzZXRcbmNvbnRhaW5pbmcgdGhlIGRlY29yYXRpb25zIHRvXG5bYEVkaXRvclZpZXcuYXRvbWljUmFuZ2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeYXRvbWljUmFuZ2VzKS5cbiovXG5FZGl0b3JWaWV3LmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4vKipcbkZhY2V0IHRoYXQgd29ya3MgbXVjaCBsaWtlXG5bYGRlY29yYXRpb25zYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeZGVjb3JhdGlvbnMpLCBidXQgcHV0cyBpdHNcbmlucHV0cyBhdCB0aGUgdmVyeSBib3R0b20gb2YgdGhlIHByZWNlZGVuY2Ugc3RhY2ssIG1lYW5pbmcgbWFya1xuZGVjb3JhdGlvbnMgcHJvdmlkZWQgaGVyZSB3aWxsIG9ubHkgYmUgc3BsaXQgYnkgb3RoZXIsIHBhcnRpYWxseVxub3ZlcmxhcHBpbmcgXFxgb3V0ZXJEZWNvcmF0aW9uc1xcYCByYW5nZXMsIGFuZCB3cmFwIGFyb3VuZCBhbGxcbnJlZ3VsYXIgZGVjb3JhdGlvbnMuIFVzZSB0aGlzIGZvciBtYXJrIGVsZW1lbnRzIHRoYXQgc2hvdWxkLCBhc1xubXVjaCBhcyBwb3NzaWJsZSwgcmVtYWluIGluIG9uZSBwaWVjZS5cbiovXG5FZGl0b3JWaWV3Lm91dGVyRGVjb3JhdGlvbnMgPSBvdXRlckRlY29yYXRpb25zO1xuLyoqXG5Vc2VkIHRvIHByb3ZpZGUgcmFuZ2VzIHRoYXQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYXRvbXMgYXMgZmFyIGFzXG5jdXJzb3IgbW90aW9uIGlzIGNvbmNlcm5lZC4gVGhpcyBjYXVzZXMgbWV0aG9kcyBsaWtlXG5bYG1vdmVCeUNoYXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlQnlDaGFyKSBhbmRcbltgbW92ZVZlcnRpY2FsbHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlVmVydGljYWxseSkgKGFuZCB0aGVcbmNvbW1hbmRzIGJ1aWx0IG9uIHRvcCBvZiB0aGVtKSB0byBza2lwIGFjcm9zcyBzdWNoIHJlZ2lvbnMgd2hlblxuYSBzZWxlY3Rpb24gZW5kcG9pbnQgd291bGQgZW50ZXIgdGhlbS4gVGhpcyBkb2VzIF9ub3RfIHByZXZlbnRcbmRpcmVjdCBwcm9ncmFtbWF0aWMgW3NlbGVjdGlvblxudXBkYXRlc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSBmcm9tIG1vdmluZyBpbnRvIHN1Y2hcbnJlZ2lvbnMuXG4qL1xuRWRpdG9yVmlldy5hdG9taWNSYW5nZXMgPSBhdG9taWNSYW5nZXM7XG4vKipcbldoZW4gcmFuZ2UgZGVjb3JhdGlvbnMgYWRkIGEgYHVuaWNvZGUtYmlkaTogaXNvbGF0ZWAgc3R5bGUsIHRoZXlcbnNob3VsZCBhbHNvIGluY2x1ZGUgYVxuW2BiaWRpSXNvbGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5NYXJrRGVjb3JhdGlvblNwZWMuYmlkaUlzb2xhdGUpIHByb3BlcnR5XG5pbiB0aGVpciBkZWNvcmF0aW9uIHNwZWMsIGFuZCBiZSBleHBvc2VkIHRocm91Z2ggdGhpcyBmYWNldCwgc29cbnRoYXQgdGhlIGVkaXRvciBjYW4gY29tcHV0ZSB0aGUgcHJvcGVyIHRleHQgb3JkZXIuIChPdGhlciB2YWx1ZXNcbmZvciBgdW5pY29kZS1iaWRpYCwgZXhjZXB0IG9mIGNvdXJzZSBgbm9ybWFsYCwgYXJlIG5vdFxuc3VwcG9ydGVkLilcbiovXG5FZGl0b3JWaWV3LmJpZGlJc29sYXRlZFJhbmdlcyA9IGJpZGlJc29sYXRlZFJhbmdlcztcbi8qKlxuRmFjZXQgdGhhdCBhbGxvd3MgZXh0ZW5zaW9ucyB0byBwcm92aWRlIGFkZGl0aW9uYWwgc2Nyb2xsXG5tYXJnaW5zIChzcGFjZSBhcm91bmQgdGhlIHNpZGVzIG9mIHRoZSBzY3JvbGxpbmcgZWxlbWVudCB0aGF0XG5zaG91bGQgYmUgY29uc2lkZXJlZCBpbnZpc2libGUpLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB0aGVcbnBsdWdpbiBpbnRyb2R1Y2VzIGVsZW1lbnRzIHRoYXQgY292ZXIgcGFydCBvZiB0aGF0IGVsZW1lbnQgKGZvclxuZXhhbXBsZSBhIGhvcml6b250YWxseSBmaXhlZCBndXR0ZXIpLlxuKi9cbkVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucyA9IHNjcm9sbE1hcmdpbnM7XG4vKipcblRoaXMgZmFjZXQgcmVjb3JkcyB3aGV0aGVyIGEgZGFyayB0aGVtZSBpcyBhY3RpdmUuIFRoZSBleHRlbnNpb25cbnJldHVybmVkIGJ5IFtgdGhlbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld150aGVtZSkgYXV0b21hdGljYWxseVxuaW5jbHVkZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyB3aGVuIHRoZSBgZGFya2Agb3B0aW9uIGlzIHNldCB0b1xudHJ1ZS5cbiovXG5FZGl0b3JWaWV3LmRhcmtUaGVtZSA9IGRhcmtUaGVtZTtcbi8qKlxuUHJvdmlkZXMgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBub25jZSB0byB1c2Ugd2hlbiBjcmVhdGluZ1xudGhlIHN0eWxlIHNoZWV0cyBmb3IgdGhlIGVkaXRvci4gSG9sZHMgdGhlIGVtcHR5IHN0cmluZyB3aGVuIG5vXG5ub25jZSBoYXMgYmVlbiBwcm92aWRlZC5cbiovXG5FZGl0b3JWaWV3LmNzcE5vbmNlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogXCJcIiB9KTtcbi8qKlxuRmFjZXQgdGhhdCBwcm92aWRlcyBhZGRpdGlvbmFsIERPTSBhdHRyaWJ1dGVzIGZvciB0aGUgZWRpdG9yJ3NcbmVkaXRhYmxlIERPTSBlbGVtZW50LlxuKi9cbkVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMgPSBjb250ZW50QXR0cmlidXRlcztcbi8qKlxuRmFjZXQgdGhhdCBwcm92aWRlcyBET00gYXR0cmlidXRlcyBmb3IgdGhlIGVkaXRvcidzIG91dGVyXG5lbGVtZW50LlxuKi9cbkVkaXRvclZpZXcuZWRpdG9yQXR0cmlidXRlcyA9IGVkaXRvckF0dHJpYnV0ZXM7XG4vKipcbkFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgbGluZSB3cmFwcGluZyBpbiB0aGUgZWRpdG9yIChieVxuc2V0dGluZyBDU1MgYHdoaXRlLXNwYWNlYCB0byBgcHJlLXdyYXBgIGluIHRoZSBjb250ZW50KS5cbiovXG5FZGl0b3JWaWV3LmxpbmVXcmFwcGluZyA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLm9mKHsgXCJjbGFzc1wiOiBcImNtLWxpbmVXcmFwcGluZ1wiIH0pO1xuLyoqXG5TdGF0ZSBlZmZlY3QgdXNlZCB0byBpbmNsdWRlIHNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50cyBpbiBhXG50cmFuc2FjdGlvbi4gVGhlc2Ugd2lsbCBiZSBhZGRlZCB0byB0aGUgRE9NIGluIGEgdmlzdWFsbHkgaGlkZGVuXG5lbGVtZW50IHdpdGggYGFyaWEtbGl2ZT1cInBvbGl0ZVwiYCBzZXQsIGFuZCBzaG91bGQgYmUgdXNlZCB0b1xuZGVzY3JpYmUgZWZmZWN0cyB0aGF0IGFyZSB2aXN1YWxseSBvYnZpb3VzIGJ1dCBtYXkgbm90IGJlXG5ub3RpY2VkIGJ5IHNjcmVlbiByZWFkZXIgdXNlcnMgKHN1Y2ggYXMgbW92aW5nIHRvIHRoZSBuZXh0XG5zZWFyY2ggbWF0Y2gpLlxuKi9cbkVkaXRvclZpZXcuYW5ub3VuY2UgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vLyBNYXhpbXVtIGxpbmUgbGVuZ3RoIGZvciB3aGljaCB3ZSBjb21wdXRlIGFjY3VyYXRlIGJpZGkgaW5mb1xuY29uc3QgTWF4QmlkaUxpbmUgPSA0MDk2O1xuY29uc3QgQmFkTWVhc3VyZSA9IHt9O1xuY2xhc3MgQ2FjaGVkT3JkZXIge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBkaXIsIGlzb2xhdGVzLCBmcmVzaCwgb3JkZXIpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgdGhpcy5pc29sYXRlcyA9IGlzb2xhdGVzO1xuICAgICAgICB0aGlzLmZyZXNoID0gZnJlc2g7XG4gICAgICAgIHRoaXMub3JkZXIgPSBvcmRlcjtcbiAgICB9XG4gICAgc3RhdGljIHVwZGF0ZShjYWNoZSwgY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5lbXB0eSAmJiAhY2FjaGUuc29tZShjID0+IGMuZnJlc2gpKVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIGxhc3REaXIgPSBjYWNoZS5sZW5ndGggPyBjYWNoZVtjYWNoZS5sZW5ndGggLSAxXS5kaXIgOiBEaXJlY3Rpb24uTFRSO1xuICAgICAgICBmb3IgKGxldCBpID0gTWF0aC5tYXgoMCwgY2FjaGUubGVuZ3RoIC0gMTApOyBpIDwgY2FjaGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBlbnRyeSA9IGNhY2hlW2ldO1xuICAgICAgICAgICAgaWYgKGVudHJ5LmRpciA9PSBsYXN0RGlyICYmICFjaGFuZ2VzLnRvdWNoZXNSYW5nZShlbnRyeS5mcm9tLCBlbnRyeS50bykpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IENhY2hlZE9yZGVyKGNoYW5nZXMubWFwUG9zKGVudHJ5LmZyb20sIDEpLCBjaGFuZ2VzLm1hcFBvcyhlbnRyeS50bywgLTEpLCBlbnRyeS5kaXIsIGVudHJ5Lmlzb2xhdGVzLCBmYWxzZSwgZW50cnkub3JkZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGF0dHJzRnJvbUZhY2V0KHZpZXcsIGZhY2V0LCBiYXNlKSB7XG4gICAgZm9yIChsZXQgc291cmNlcyA9IHZpZXcuc3RhdGUuZmFjZXQoZmFjZXQpLCBpID0gc291cmNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgc291cmNlID0gc291cmNlc1tpXSwgdmFsdWUgPSB0eXBlb2Ygc291cmNlID09IFwiZnVuY3Rpb25cIiA/IHNvdXJjZSh2aWV3KSA6IHNvdXJjZTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgY29tYmluZUF0dHJzKHZhbHVlLCBiYXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG59XG5cbmNvbnN0IGN1cnJlbnRQbGF0Zm9ybSA9IGJyb3dzZXIubWFjID8gXCJtYWNcIiA6IGJyb3dzZXIud2luZG93cyA/IFwid2luXCIgOiBicm93c2VyLmxpbnV4ID8gXCJsaW51eFwiIDogXCJrZXlcIjtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSwgcGxhdGZvcm0pIHtcbiAgICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pO1xuICAgIGxldCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAocmVzdWx0ID09IFwiU3BhY2VcIilcbiAgICAgICAgcmVzdWx0ID0gXCIgXCI7XG4gICAgbGV0IGFsdCwgY3RybCwgc2hpZnQsIG1ldGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgY29uc3QgbW9kID0gcGFydHNbaV07XG4gICAgICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgYWx0ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIHNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15tb2QkL2kudGVzdChtb2QpKSB7XG4gICAgICAgICAgICBpZiAocGxhdGZvcm0gPT0gXCJtYWNcIilcbiAgICAgICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIgKyBtb2QpO1xuICAgIH1cbiAgICBpZiAoYWx0KVxuICAgICAgICByZXN1bHQgPSBcIkFsdC1cIiArIHJlc3VsdDtcbiAgICBpZiAoY3RybClcbiAgICAgICAgcmVzdWx0ID0gXCJDdHJsLVwiICsgcmVzdWx0O1xuICAgIGlmIChtZXRhKVxuICAgICAgICByZXN1bHQgPSBcIk1ldGEtXCIgKyByZXN1bHQ7XG4gICAgaWYgKHNoaWZ0KVxuICAgICAgICByZXN1bHQgPSBcIlNoaWZ0LVwiICsgcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2RpZmllcnMobmFtZSwgZXZlbnQsIHNoaWZ0KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSlcbiAgICAgICAgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7XG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkpXG4gICAgICAgIG5hbWUgPSBcIk1ldGEtXCIgKyBuYW1lO1xuICAgIGlmIChzaGlmdCAhPT0gZmFsc2UgJiYgZXZlbnQuc2hpZnRLZXkpXG4gICAgICAgIG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbn1cbmNvbnN0IGhhbmRsZUtleUV2ZW50cyA9IC8qQF9fUFVSRV9fKi9QcmVjLmRlZmF1bHQoLypAX19QVVJFX18qL0VkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAga2V5ZG93bihldmVudCwgdmlldykge1xuICAgICAgICByZXR1cm4gcnVuSGFuZGxlcnMoZ2V0S2V5bWFwKHZpZXcuc3RhdGUpLCBldmVudCwgdmlldywgXCJlZGl0b3JcIik7XG4gICAgfVxufSkpO1xuLyoqXG5GYWNldCB1c2VkIGZvciByZWdpc3RlcmluZyBrZXltYXBzLlxuXG5Zb3UgY2FuIGFkZCBtdWx0aXBsZSBrZXltYXBzIHRvIGFuIGVkaXRvci4gVGhlaXIgcHJpb3JpdGllc1xuZGV0ZXJtaW5lIHRoZWlyIHByZWNlZGVuY2UgKHRoZSBvbmVzIHNwZWNpZmllZCBlYXJseSBvciB3aXRoIGhpZ2hcbnByaW9yaXR5IGdldCBjaGVja2VkIGZpcnN0KS4gV2hlbiBhIGhhbmRsZXIgaGFzIHJldHVybmVkIGB0cnVlYFxuZm9yIGEgZ2l2ZW4ga2V5LCBubyBmdXJ0aGVyIGhhbmRsZXJzIGFyZSBjYWxsZWQuXG4qL1xuY29uc3Qga2V5bWFwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IGVuYWJsZXM6IGhhbmRsZUtleUV2ZW50cyB9KTtcbmNvbnN0IEtleW1hcHMgPSAvKkBfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbi8vIFRoaXMgaXMgaGlkZGVuIGJlaGluZCBhbiBpbmRpcmVjdGlvbiwgcmF0aGVyIHRoYW4gZGlyZWN0bHkgY29tcHV0ZWRcbi8vIGJ5IHRoZSBmYWNldCwgdG8ga2VlcCBpbnRlcm5hbCB0eXBlcyBvdXQgb2YgdGhlIGZhY2V0J3MgdHlwZS5cbmZ1bmN0aW9uIGdldEtleW1hcChzdGF0ZSkge1xuICAgIGxldCBiaW5kaW5ncyA9IHN0YXRlLmZhY2V0KGtleW1hcCk7XG4gICAgbGV0IG1hcCA9IEtleW1hcHMuZ2V0KGJpbmRpbmdzKTtcbiAgICBpZiAoIW1hcClcbiAgICAgICAgS2V5bWFwcy5zZXQoYmluZGluZ3MsIG1hcCA9IGJ1aWxkS2V5bWFwKGJpbmRpbmdzLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYiksIFtdKSkpO1xuICAgIHJldHVybiBtYXA7XG59XG4vKipcblJ1biB0aGUga2V5IGhhbmRsZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gc2NvcGUuIFRoZSBldmVudFxub2JqZWN0IHNob3VsZCBiZSBhIGBcImtleWRvd25cImAgZXZlbnQuIFJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlXG5oYW5kbGVycyBoYW5kbGVkIGl0LlxuKi9cbmZ1bmN0aW9uIHJ1blNjb3BlSGFuZGxlcnModmlldywgZXZlbnQsIHNjb3BlKSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJzKGdldEtleW1hcCh2aWV3LnN0YXRlKSwgZXZlbnQsIHZpZXcsIHNjb3BlKTtcbn1cbmxldCBzdG9yZWRQcmVmaXggPSBudWxsO1xuY29uc3QgUHJlZml4VGltZW91dCA9IDQwMDA7XG5mdW5jdGlvbiBidWlsZEtleW1hcChiaW5kaW5ncywgcGxhdGZvcm0gPSBjdXJyZW50UGxhdGZvcm0pIHtcbiAgICBsZXQgYm91bmQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBpc1ByZWZpeCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNoZWNrUHJlZml4ID0gKG5hbWUsIGlzKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gaXNQcmVmaXhbbmFtZV07XG4gICAgICAgIGlmIChjdXJyZW50ID09IG51bGwpXG4gICAgICAgICAgICBpc1ByZWZpeFtuYW1lXSA9IGlzO1xuICAgICAgICBlbHNlIGlmIChjdXJyZW50ICE9IGlzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGJpbmRpbmcgXCIgKyBuYW1lICsgXCIgaXMgdXNlZCBib3RoIGFzIGEgcmVndWxhciBiaW5kaW5nIGFuZCBhcyBhIG11bHRpLXN0cm9rZSBwcmVmaXhcIik7XG4gICAgfTtcbiAgICBsZXQgYWRkID0gKHNjb3BlLCBrZXksIGNvbW1hbmQsIHByZXZlbnREZWZhdWx0LCBzdG9wUHJvcGFnYXRpb24pID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHNjb3BlT2JqID0gYm91bmRbc2NvcGVdIHx8IChib3VuZFtzY29wZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgbGV0IHBhcnRzID0ga2V5LnNwbGl0KC8gKD8hJCkvKS5tYXAoayA9PiBub3JtYWxpemVLZXlOYW1lKGssIHBsYXRmb3JtKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwcmVmaXggPSBwYXJ0cy5zbGljZSgwLCBpKS5qb2luKFwiIFwiKTtcbiAgICAgICAgICAgIGNoZWNrUHJlZml4KHByZWZpeCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXNjb3BlT2JqW3ByZWZpeF0pXG4gICAgICAgICAgICAgICAgc2NvcGVPYmpbcHJlZml4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJ1bjogWyh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG91ck9iaiA9IHN0b3JlZFByZWZpeCA9IHsgdmlldywgcHJlZml4LCBzY29wZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyBpZiAoc3RvcmVkUHJlZml4ID09IG91ck9iailcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUHJlZml4ID0gbnVsbDsgfSwgUHJlZml4VGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bGwgPSBwYXJ0cy5qb2luKFwiIFwiKTtcbiAgICAgICAgY2hlY2tQcmVmaXgoZnVsbCwgZmFsc2UpO1xuICAgICAgICBsZXQgYmluZGluZyA9IHNjb3BlT2JqW2Z1bGxdIHx8IChzY29wZU9ialtmdWxsXSA9IHtcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBydW46ICgoX2IgPSAoX2EgPSBzY29wZU9iai5fYW55KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucnVuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2xpY2UoKSkgfHwgW11cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb21tYW5kKVxuICAgICAgICAgICAgYmluZGluZy5ydW4ucHVzaChjb21tYW5kKTtcbiAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KVxuICAgICAgICAgICAgYmluZGluZy5wcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICAgIGlmIChzdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICBiaW5kaW5nLnN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgfTtcbiAgICBmb3IgKGxldCBiIG9mIGJpbmRpbmdzKSB7XG4gICAgICAgIGxldCBzY29wZXMgPSBiLnNjb3BlID8gYi5zY29wZS5zcGxpdChcIiBcIikgOiBbXCJlZGl0b3JcIl07XG4gICAgICAgIGlmIChiLmFueSlcbiAgICAgICAgICAgIGZvciAobGV0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgICAgICAgICAgICAgIGxldCBzY29wZU9iaiA9IGJvdW5kW3Njb3BlXSB8fCAoYm91bmRbc2NvcGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzY29wZU9iai5fYW55KVxuICAgICAgICAgICAgICAgICAgICBzY29wZU9iai5fYW55ID0geyBwcmV2ZW50RGVmYXVsdDogZmFsc2UsIHN0b3BQcm9wYWdhdGlvbjogZmFsc2UsIHJ1bjogW10gfTtcbiAgICAgICAgICAgICAgICBsZXQgeyBhbnkgfSA9IGI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHNjb3BlT2JqKVxuICAgICAgICAgICAgICAgICAgICBzY29wZU9ialtrZXldLnJ1bi5wdXNoKHZpZXcgPT4gYW55KHZpZXcsIGN1cnJlbnRLZXlFdmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgbmFtZSA9IGJbcGxhdGZvcm1dIHx8IGIua2V5O1xuICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgICAgICAgICBhZGQoc2NvcGUsIG5hbWUsIGIucnVuLCBiLnByZXZlbnREZWZhdWx0LCBiLnN0b3BQcm9wYWdhdGlvbik7XG4gICAgICAgICAgICBpZiAoYi5zaGlmdClcbiAgICAgICAgICAgICAgICBhZGQoc2NvcGUsIFwiU2hpZnQtXCIgKyBuYW1lLCBiLnNoaWZ0LCBiLnByZXZlbnREZWZhdWx0LCBiLnN0b3BQcm9wYWdhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kO1xufVxubGV0IGN1cnJlbnRLZXlFdmVudCA9IG51bGw7XG5mdW5jdGlvbiBydW5IYW5kbGVycyhtYXAsIGV2ZW50LCB2aWV3LCBzY29wZSkge1xuICAgIGN1cnJlbnRLZXlFdmVudCA9IGV2ZW50O1xuICAgIGxldCBuYW1lID0ga2V5TmFtZShldmVudCk7XG4gICAgbGV0IGNoYXJDb2RlID0gY29kZVBvaW50QXQobmFtZSwgMCksIGlzQ2hhciA9IGNvZGVQb2ludFNpemUoY2hhckNvZGUpID09IG5hbWUubGVuZ3RoICYmIG5hbWUgIT0gXCIgXCI7XG4gICAgbGV0IHByZWZpeCA9IFwiXCIsIGhhbmRsZWQgPSBmYWxzZSwgcHJldmVudGVkID0gZmFsc2UsIHN0b3BQcm9wYWdhdGlvbiA9IGZhbHNlO1xuICAgIGlmIChzdG9yZWRQcmVmaXggJiYgc3RvcmVkUHJlZml4LnZpZXcgPT0gdmlldyAmJiBzdG9yZWRQcmVmaXguc2NvcGUgPT0gc2NvcGUpIHtcbiAgICAgICAgcHJlZml4ID0gc3RvcmVkUHJlZml4LnByZWZpeCArIFwiIFwiO1xuICAgICAgICBpZiAobW9kaWZpZXJDb2Rlcy5pbmRleE9mKGV2ZW50LmtleUNvZGUpIDwgMCkge1xuICAgICAgICAgICAgcHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0b3JlZFByZWZpeCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHJhbiA9IG5ldyBTZXQ7XG4gICAgbGV0IHJ1bkZvciA9IChiaW5kaW5nKSA9PiB7XG4gICAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjbWQgb2YgYmluZGluZy5ydW4pXG4gICAgICAgICAgICAgICAgaWYgKCFyYW4uaGFzKGNtZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuLmFkZChjbWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY21kKHZpZXcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpbmRpbmcucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5zdG9wUHJvcGFnYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJldmVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBsZXQgc2NvcGVPYmogPSBtYXBbc2NvcGVdLCBiYXNlTmFtZSwgc2hpZnROYW1lO1xuICAgIGlmIChzY29wZU9iaikge1xuICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgIWlzQ2hhcildKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDaGFyICYmIChldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSAmJlxuICAgICAgICAgICAgLy8gQ3RybC1BbHQgbWF5IGJlIHVzZWQgZm9yIEFsdEdyIG9uIFdpbmRvd3NcbiAgICAgICAgICAgICEoYnJvd3Nlci53aW5kb3dzICYmIGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQuYWx0S2V5KSAmJlxuICAgICAgICAgICAgKGJhc2VOYW1lID0gYmFzZVtldmVudC5rZXlDb2RlXSkgJiYgYmFzZU5hbWUgIT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKHJ1bkZvcihzY29wZU9ialtwcmVmaXggKyBtb2RpZmllcnMoYmFzZU5hbWUsIGV2ZW50LCB0cnVlKV0pKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiAoc2hpZnROYW1lID0gc2hpZnRbZXZlbnQua2V5Q29kZV0pICE9IG5hbWUgJiYgc2hpZnROYW1lICE9IGJhc2VOYW1lICYmXG4gICAgICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhzaGlmdE5hbWUsIGV2ZW50LCBmYWxzZSldKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ2hhciAmJiBldmVudC5zaGlmdEtleSAmJlxuICAgICAgICAgICAgcnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgdHJ1ZSldKSkge1xuICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYW5kbGVkICYmIHJ1bkZvcihzY29wZU9iai5fYW55KSlcbiAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJldmVudGVkKVxuICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICBpZiAoaGFuZGxlZCAmJiBzdG9wUHJvcGFnYXRpb24pXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGN1cnJlbnRLZXlFdmVudCA9IG51bGw7XG4gICAgcmV0dXJuIGhhbmRsZWQ7XG59XG5cbi8qKlxuSW1wbGVtZW50YXRpb24gb2YgW2BMYXllck1hcmtlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5MYXllck1hcmtlcikgdGhhdCBjcmVhdGVzXG5hIHJlY3RhbmdsZSBhdCBhIGdpdmVuIHNldCBvZiBjb29yZGluYXRlcy5cbiovXG5jbGFzcyBSZWN0YW5nbGVNYXJrZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmtlciB3aXRoIHRoZSBnaXZlbiBjbGFzcyBhbmQgZGltZW5zaW9ucy4gSWYgYHdpZHRoYFxuICAgIGlzIG51bGwsIHRoZSBET00gZWxlbWVudCB3aWxsIGdldCBubyB3aWR0aCBzdHlsZS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsYXNzTmFtZSwgXG4gICAgLyoqXG4gICAgVGhlIGxlZnQgcG9zaXRpb24gb2YgdGhlIG1hcmtlciAoaW4gcGl4ZWxzLCBkb2N1bWVudC1yZWxhdGl2ZSkuXG4gICAgKi9cbiAgICBsZWZ0LCBcbiAgICAvKipcbiAgICBUaGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBtYXJrZXIuXG4gICAgKi9cbiAgICB0b3AsIFxuICAgIC8qKlxuICAgIFRoZSB3aWR0aCBvZiB0aGUgbWFya2VyLCBvciBudWxsIGlmIGl0IHNob3VsZG4ndCBnZXQgYSB3aWR0aCBhc3NpZ25lZC5cbiAgICAqL1xuICAgIHdpZHRoLCBcbiAgICAvKipcbiAgICBUaGUgaGVpZ2h0IG9mIHRoZSBtYXJrZXIuXG4gICAgKi9cbiAgICBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZWx0LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuICAgICAgICB0aGlzLmFkanVzdChlbHQpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICB1cGRhdGUoZWx0LCBwcmV2KSB7XG4gICAgICAgIGlmIChwcmV2LmNsYXNzTmFtZSAhPSB0aGlzLmNsYXNzTmFtZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5hZGp1c3QoZWx0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFkanVzdChlbHQpIHtcbiAgICAgICAgZWx0LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyBcInB4XCI7XG4gICAgICAgIGVsdC5zdHlsZS50b3AgPSB0aGlzLnRvcCArIFwicHhcIjtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggIT0gbnVsbClcbiAgICAgICAgICAgIGVsdC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICB9XG4gICAgZXEocCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0ID09IHAubGVmdCAmJiB0aGlzLnRvcCA9PSBwLnRvcCAmJiB0aGlzLndpZHRoID09IHAud2lkdGggJiYgdGhpcy5oZWlnaHQgPT0gcC5oZWlnaHQgJiZcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID09IHAuY2xhc3NOYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXQgb2YgcmVjdGFuZ2xlcyBmb3IgdGhlIGdpdmVuIHNlbGVjdGlvbiByYW5nZSxcbiAgICBhc3NpZ25pbmcgdGhlbSB0aGVjbGFzc2BjbGFzc05hbWVgLiBXaWxsIGNyZWF0ZSBhIHNpbmdsZVxuICAgIHJlY3RhbmdsZSBmb3IgZW1wdHkgcmFuZ2VzLCBhbmQgYSBzZXQgb2Ygc2VsZWN0aW9uLXN0eWxlXG4gICAgcmVjdGFuZ2xlcyBjb3ZlcmluZyB0aGUgcmFuZ2UncyBjb250ZW50IChpbiBhIGJpZGktYXdhcmVcbiAgICB3YXkpIGZvciBub24tZW1wdHkgb25lcy5cbiAgICAqL1xuICAgIHN0YXRpYyBmb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IHZpZXcuY29vcmRzQXRQb3MocmFuZ2UuaGVhZCwgcmFuZ2UuYXNzb2MgfHwgMSk7XG4gICAgICAgICAgICBpZiAoIXBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGdldEJhc2Uodmlldyk7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBSZWN0YW5nbGVNYXJrZXIoY2xhc3NOYW1lLCBwb3MubGVmdCAtIGJhc2UubGVmdCwgcG9zLnRvcCAtIGJhc2UudG9wLCBudWxsLCBwb3MuYm90dG9tIC0gcG9zLnRvcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RhbmdsZXNGb3JSYW5nZSh2aWV3LCBjbGFzc05hbWUsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEJhc2Uodmlldykge1xuICAgIGxldCByZWN0ID0gdmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGxlZnQgPSB2aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUiA/IHJlY3QubGVmdCA6IHJlY3QucmlnaHQgLSB2aWV3LnNjcm9sbERPTS5jbGllbnRXaWR0aCAqIHZpZXcuc2NhbGVYO1xuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0ICogdmlldy5zY2FsZVgsIHRvcDogcmVjdC50b3AgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgKiB2aWV3LnNjYWxlWSB9O1xufVxuZnVuY3Rpb24gd3JhcHBlZExpbmUodmlldywgcG9zLCBzaWRlLCBpbnNpZGUpIHtcbiAgICBsZXQgY29vcmRzID0gdmlldy5jb29yZHNBdFBvcyhwb3MsIHNpZGUgKiAyKTtcbiAgICBpZiAoIWNvb3JkcylcbiAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICBsZXQgZWRpdG9yUmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCB5ID0gKGNvb3Jkcy50b3AgKyBjb29yZHMuYm90dG9tKSAvIDI7XG4gICAgbGV0IGxlZnQgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZWRpdG9yUmVjdC5sZWZ0ICsgMSwgeSB9KTtcbiAgICBsZXQgcmlnaHQgPSB2aWV3LnBvc0F0Q29vcmRzKHsgeDogZWRpdG9yUmVjdC5yaWdodCAtIDEsIHkgfSk7XG4gICAgaWYgKGxlZnQgPT0gbnVsbCB8fCByaWdodCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgIHJldHVybiB7IGZyb206IE1hdGgubWF4KGluc2lkZS5mcm9tLCBNYXRoLm1pbihsZWZ0LCByaWdodCkpLCB0bzogTWF0aC5taW4oaW5zaWRlLnRvLCBNYXRoLm1heChsZWZ0LCByaWdodCkpIH07XG59XG5mdW5jdGlvbiByZWN0YW5nbGVzRm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCByYW5nZSkge1xuICAgIGlmIChyYW5nZS50byA8PSB2aWV3LnZpZXdwb3J0LmZyb20gfHwgcmFuZ2UuZnJvbSA+PSB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGZyb20gPSBNYXRoLm1heChyYW5nZS5mcm9tLCB2aWV3LnZpZXdwb3J0LmZyb20pLCB0byA9IE1hdGgubWluKHJhbmdlLnRvLCB2aWV3LnZpZXdwb3J0LnRvKTtcbiAgICBsZXQgbHRyID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00sIGNvbnRlbnRSZWN0ID0gY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYmFzZSA9IGdldEJhc2Uodmlldyk7XG4gICAgbGV0IGxpbmVFbHQgPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCIuY20tbGluZVwiKSwgbGluZVN0eWxlID0gbGluZUVsdCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShsaW5lRWx0KTtcbiAgICBsZXQgbGVmdFNpZGUgPSBjb250ZW50UmVjdC5sZWZ0ICtcbiAgICAgICAgKGxpbmVTdHlsZSA/IHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nTGVmdCkgKyBNYXRoLm1pbigwLCBwYXJzZUludChsaW5lU3R5bGUudGV4dEluZGVudCkpIDogMCk7XG4gICAgbGV0IHJpZ2h0U2lkZSA9IGNvbnRlbnRSZWN0LnJpZ2h0IC0gKGxpbmVTdHlsZSA/IHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nUmlnaHQpIDogMCk7XG4gICAgbGV0IHN0YXJ0QmxvY2sgPSBibG9ja0F0KHZpZXcsIGZyb20pLCBlbmRCbG9jayA9IGJsb2NrQXQodmlldywgdG8pO1xuICAgIGxldCB2aXN1YWxTdGFydCA9IHN0YXJ0QmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IHN0YXJ0QmxvY2sgOiBudWxsO1xuICAgIGxldCB2aXN1YWxFbmQgPSBlbmRCbG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0ID8gZW5kQmxvY2sgOiBudWxsO1xuICAgIGlmICh2aXN1YWxTdGFydCAmJiAodmlldy5saW5lV3JhcHBpbmcgfHwgc3RhcnRCbG9jay53aWRnZXRMaW5lQnJlYWtzKSlcbiAgICAgICAgdmlzdWFsU3RhcnQgPSB3cmFwcGVkTGluZSh2aWV3LCBmcm9tLCAxLCB2aXN1YWxTdGFydCk7XG4gICAgaWYgKHZpc3VhbEVuZCAmJiAodmlldy5saW5lV3JhcHBpbmcgfHwgZW5kQmxvY2sud2lkZ2V0TGluZUJyZWFrcykpXG4gICAgICAgIHZpc3VhbEVuZCA9IHdyYXBwZWRMaW5lKHZpZXcsIHRvLCAtMSwgdmlzdWFsRW5kKTtcbiAgICBpZiAodmlzdWFsU3RhcnQgJiYgdmlzdWFsRW5kICYmIHZpc3VhbFN0YXJ0LmZyb20gPT0gdmlzdWFsRW5kLmZyb20gJiYgdmlzdWFsU3RhcnQudG8gPT0gdmlzdWFsRW5kLnRvKSB7XG4gICAgICAgIHJldHVybiBwaWVjZXMoZHJhd0ZvckxpbmUocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHZpc3VhbFN0YXJ0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgdG9wID0gdmlzdWFsU3RhcnQgPyBkcmF3Rm9yTGluZShyYW5nZS5mcm9tLCBudWxsLCB2aXN1YWxTdGFydCkgOiBkcmF3Rm9yV2lkZ2V0KHN0YXJ0QmxvY2ssIGZhbHNlKTtcbiAgICAgICAgbGV0IGJvdHRvbSA9IHZpc3VhbEVuZCA/IGRyYXdGb3JMaW5lKG51bGwsIHJhbmdlLnRvLCB2aXN1YWxFbmQpIDogZHJhd0ZvcldpZGdldChlbmRCbG9jaywgdHJ1ZSk7XG4gICAgICAgIGxldCBiZXR3ZWVuID0gW107XG4gICAgICAgIGlmICgodmlzdWFsU3RhcnQgfHwgc3RhcnRCbG9jaykudG8gPCAodmlzdWFsRW5kIHx8IGVuZEJsb2NrKS5mcm9tIC0gKHZpc3VhbFN0YXJ0ICYmIHZpc3VhbEVuZCA/IDEgOiAwKSB8fFxuICAgICAgICAgICAgc3RhcnRCbG9jay53aWRnZXRMaW5lQnJlYWtzID4gMSAmJiB0b3AuYm90dG9tICsgdmlldy5kZWZhdWx0TGluZUhlaWdodCAvIDIgPCBib3R0b20udG9wKVxuICAgICAgICAgICAgYmV0d2Vlbi5wdXNoKHBpZWNlKGxlZnRTaWRlLCB0b3AuYm90dG9tLCByaWdodFNpZGUsIGJvdHRvbS50b3ApKTtcbiAgICAgICAgZWxzZSBpZiAodG9wLmJvdHRvbSA8IGJvdHRvbS50b3AgJiYgdmlldy5lbGVtZW50QXRIZWlnaHQoKHRvcC5ib3R0b20gKyBib3R0b20udG9wKSAvIDIpLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpXG4gICAgICAgICAgICB0b3AuYm90dG9tID0gYm90dG9tLnRvcCA9ICh0b3AuYm90dG9tICsgYm90dG9tLnRvcCkgLyAyO1xuICAgICAgICByZXR1cm4gcGllY2VzKHRvcCkuY29uY2F0KGJldHdlZW4pLmNvbmNhdChwaWVjZXMoYm90dG9tKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBpZWNlKGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZU1hcmtlcihjbGFzc05hbWUsIGxlZnQgLSBiYXNlLmxlZnQsIHRvcCAtIGJhc2UudG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBpZWNlcyh7IHRvcCwgYm90dG9tLCBob3Jpem9udGFsIH0pIHtcbiAgICAgICAgbGV0IHBpZWNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvcml6b250YWwubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICBwaWVjZXMucHVzaChwaWVjZShob3Jpem9udGFsW2ldLCB0b3AsIGhvcml6b250YWxbaSArIDFdLCBib3R0b20pKTtcbiAgICAgICAgcmV0dXJuIHBpZWNlcztcbiAgICB9XG4gICAgLy8gR2V0cyBwYXNzZWQgZnJvbS90byBpbiBsaW5lLWxvY2FsIHBvc2l0aW9uc1xuICAgIGZ1bmN0aW9uIGRyYXdGb3JMaW5lKGZyb20sIHRvLCBsaW5lKSB7XG4gICAgICAgIGxldCB0b3AgPSAxZTksIGJvdHRvbSA9IC0xZTksIGhvcml6b250YWwgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gYWRkU3Bhbihmcm9tLCBmcm9tT3BlbiwgdG8sIHRvT3BlbiwgZGlyKSB7XG4gICAgICAgICAgICAvLyBQYXNzaW5nIDIvLTIgaXMgYSBrbHVkZ2UgdG8gZm9yY2UgdGhlIHZpZXcgdG8gcmV0dXJuXG4gICAgICAgICAgICAvLyBjb29yZGluYXRlcyBvbiB0aGUgcHJvcGVyIHNpZGUgb2YgYmxvY2sgd2lkZ2V0cywgc2luY2VcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6aW5nIHRoZSBzaWRlIHRoZXJlLCB0aG91Z2ggYXBwcm9wcmlhdGUgZm9yIG1vc3RcbiAgICAgICAgICAgIC8vIGNvb3Jkc0F0UG9zIHF1ZXJpZXMsIHdvdWxkIGJyZWFrIHNlbGVjdGlvbiBkcmF3aW5nLlxuICAgICAgICAgICAgbGV0IGZyb21Db29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKGZyb20sIChmcm9tID09IGxpbmUudG8gPyAtMiA6IDIpKTtcbiAgICAgICAgICAgIGxldCB0b0Nvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3ModG8sICh0byA9PSBsaW5lLmZyb20gPyAyIDogLTIpKTtcbiAgICAgICAgICAgIGlmICghZnJvbUNvb3JkcyB8fCAhdG9Db29yZHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdG9wID0gTWF0aC5taW4oZnJvbUNvb3Jkcy50b3AsIHRvQ29vcmRzLnRvcCwgdG9wKTtcbiAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGZyb21Db29yZHMuYm90dG9tLCB0b0Nvb3Jkcy5ib3R0b20sIGJvdHRvbSk7XG4gICAgICAgICAgICBpZiAoZGlyID09IERpcmVjdGlvbi5MVFIpXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbC5wdXNoKGx0ciAmJiBmcm9tT3BlbiA/IGxlZnRTaWRlIDogZnJvbUNvb3Jkcy5sZWZ0LCBsdHIgJiYgdG9PcGVuID8gcmlnaHRTaWRlIDogdG9Db29yZHMucmlnaHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGhvcml6b250YWwucHVzaCghbHRyICYmIHRvT3BlbiA/IGxlZnRTaWRlIDogdG9Db29yZHMubGVmdCwgIWx0ciAmJiBmcm9tT3BlbiA/IHJpZ2h0U2lkZSA6IGZyb21Db29yZHMucmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IGZyb20gIT09IG51bGwgJiYgZnJvbSAhPT0gdm9pZCAwID8gZnJvbSA6IGxpbmUuZnJvbSwgZW5kID0gdG8gIT09IG51bGwgJiYgdG8gIT09IHZvaWQgMCA/IHRvIDogbGluZS50bztcbiAgICAgICAgLy8gU3BsaXQgdGhlIHJhbmdlIGJ5IHZpc2libGUgcmFuZ2UgYW5kIGRvY3VtZW50IGxpbmVcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnZpc2libGVSYW5nZXMpXG4gICAgICAgICAgICBpZiAoci50byA+IHN0YXJ0ICYmIHIuZnJvbSA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IE1hdGgubWF4KHIuZnJvbSwgc3RhcnQpLCBlbmRQb3MgPSBNYXRoLm1pbihyLnRvLCBlbmQpOzspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRvY0xpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3BhbiBvZiB2aWV3LmJpZGlTcGFucyhkb2NMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYW5Gcm9tID0gc3Bhbi5mcm9tICsgZG9jTGluZS5mcm9tLCBzcGFuVG8gPSBzcGFuLnRvICsgZG9jTGluZS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5Gcm9tID49IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFuVG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkU3BhbihNYXRoLm1heChzcGFuRnJvbSwgcG9zKSwgZnJvbSA9PSBudWxsICYmIHNwYW5Gcm9tIDw9IHN0YXJ0LCBNYXRoLm1pbihzcGFuVG8sIGVuZFBvcyksIHRvID09IG51bGwgJiYgc3BhblRvID49IGVuZCwgc3Bhbi5kaXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGRvY0xpbmUudG8gKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID49IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGhvcml6b250YWwubGVuZ3RoID09IDApXG4gICAgICAgICAgICBhZGRTcGFuKHN0YXJ0LCBmcm9tID09IG51bGwsIGVuZCwgdG8gPT0gbnVsbCwgdmlldy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZHJhd0ZvcldpZGdldChibG9jaywgdG9wKSB7XG4gICAgICAgIGxldCB5ID0gY29udGVudFJlY3QudG9wICsgKHRvcCA/IGJsb2NrLnRvcCA6IGJsb2NrLmJvdHRvbSk7XG4gICAgICAgIHJldHVybiB7IHRvcDogeSwgYm90dG9tOiB5LCBob3Jpem9udGFsOiBbXSB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVNYXJrZXIoYSwgYikge1xuICAgIHJldHVybiBhLmNvbnN0cnVjdG9yID09IGIuY29uc3RydWN0b3IgJiYgYS5lcShiKTtcbn1cbmNsYXNzIExheWVyVmlldyB7XG4gICAgY29uc3RydWN0b3IodmlldywgbGF5ZXIpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgICAgICB0aGlzLmRyYXduID0gW107XG4gICAgICAgIHRoaXMuc2NhbGVYID0gMTtcbiAgICAgICAgdGhpcy5zY2FsZVkgPSAxO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMubWVhc3VyZS5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy5kcmF3LmJpbmQodGhpcykgfTtcbiAgICAgICAgdGhpcy5kb20gPSB2aWV3LnNjcm9sbERPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NMaXN0LmFkZChcImNtLWxheWVyXCIpO1xuICAgICAgICBpZiAobGF5ZXIuYWJvdmUpXG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tbGF5ZXItYWJvdmVcIik7XG4gICAgICAgIGlmIChsYXllci5jbGFzcylcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQobGF5ZXIuY2xhc3MpO1xuICAgICAgICB0aGlzLnNjYWxlKCk7XG4gICAgICAgIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5zZXRPcmRlcih2aWV3LnN0YXRlKTtcbiAgICAgICAgdmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICBpZiAobGF5ZXIubW91bnQpXG4gICAgICAgICAgICBsYXllci5tb3VudCh0aGlzLmRvbSwgdmlldyk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxheWVyT3JkZXIpICE9IHVwZGF0ZS5zdGF0ZS5mYWNldChsYXllck9yZGVyKSlcbiAgICAgICAgICAgIHRoaXMuc2V0T3JkZXIodXBkYXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXIudXBkYXRlKHVwZGF0ZSwgdGhpcy5kb20pIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUoKTtcbiAgICAgICAgICAgIHVwZGF0ZS52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9jVmlld1VwZGF0ZSh2aWV3KSB7XG4gICAgICAgIGlmICh0aGlzLmxheWVyLnVwZGF0ZU9uRG9jVmlld1VwZGF0ZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICB2aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgfVxuICAgIHNldE9yZGVyKHN0YXRlKSB7XG4gICAgICAgIGxldCBwb3MgPSAwLCBvcmRlciA9IHN0YXRlLmZhY2V0KGxheWVyT3JkZXIpO1xuICAgICAgICB3aGlsZSAocG9zIDwgb3JkZXIubGVuZ3RoICYmIG9yZGVyW3Bvc10gIT0gdGhpcy5sYXllcilcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB0aGlzLmRvbS5zdHlsZS56SW5kZXggPSBTdHJpbmcoKHRoaXMubGF5ZXIuYWJvdmUgPyAxNTAgOiAtMSkgLSBwb3MpO1xuICAgIH1cbiAgICBtZWFzdXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXllci5tYXJrZXJzKHRoaXMudmlldyk7XG4gICAgfVxuICAgIHNjYWxlKCkge1xuICAgICAgICBsZXQgeyBzY2FsZVgsIHNjYWxlWSB9ID0gdGhpcy52aWV3O1xuICAgICAgICBpZiAoc2NhbGVYICE9IHRoaXMuc2NhbGVYIHx8IHNjYWxlWSAhPSB0aGlzLnNjYWxlWSkge1xuICAgICAgICAgICAgdGhpcy5zY2FsZVggPSBzY2FsZVg7XG4gICAgICAgICAgICB0aGlzLnNjYWxlWSA9IHNjYWxlWTtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgkezEgLyBzY2FsZVh9LCAkezEgLyBzY2FsZVl9KWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhdyhtYXJrZXJzKSB7XG4gICAgICAgIGlmIChtYXJrZXJzLmxlbmd0aCAhPSB0aGlzLmRyYXduLmxlbmd0aCB8fCBtYXJrZXJzLnNvbWUoKHAsIGkpID0+ICFzYW1lTWFya2VyKHAsIHRoaXMuZHJhd25baV0pKSkge1xuICAgICAgICAgICAgbGV0IG9sZCA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQsIG9sZEkgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgbWFya2VyIG9mIG1hcmtlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyLnVwZGF0ZSAmJiBvbGQgJiYgbWFya2VyLmNvbnN0cnVjdG9yICYmIHRoaXMuZHJhd25bb2xkSV0uY29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLnVwZGF0ZShvbGQsIHRoaXMuZHJhd25bb2xkSV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZCA9IG9sZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgb2xkSSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKG1hcmtlci5kcmF3KCksIG9sZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG9sZCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gb2xkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIG9sZC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBvbGQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmF3biA9IG1hcmtlcnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXIuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMubGF5ZXIuZGVzdHJveSh0aGlzLmRvbSwgdGhpcy52aWV3KTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgfVxufVxuY29uc3QgbGF5ZXJPcmRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuRGVmaW5lIGEgbGF5ZXIuXG4qL1xuZnVuY3Rpb24gbGF5ZXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgVmlld1BsdWdpbi5kZWZpbmUodiA9PiBuZXcgTGF5ZXJWaWV3KHYsIGNvbmZpZykpLFxuICAgICAgICBsYXllck9yZGVyLm9mKGNvbmZpZylcbiAgICBdO1xufVxuXG5jb25zdCBDYW5IaWRlUHJpbWFyeSA9ICEoYnJvd3Nlci5pb3MgJiYgYnJvd3Nlci53ZWJraXQgJiYgYnJvd3Nlci53ZWJraXRfdmVyc2lvbiA8IDUzNCk7XG5jb25zdCBzZWxlY3Rpb25Db25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgY3Vyc29yQmxpbmtSYXRlOiAxMjAwLFxuICAgICAgICAgICAgZHJhd1JhbmdlQ3Vyc29yOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGN1cnNvckJsaW5rUmF0ZTogKGEsIGIpID0+IE1hdGgubWluKGEsIGIpLFxuICAgICAgICAgICAgZHJhd1JhbmdlQ3Vyc29yOiAoYSwgYikgPT4gYSB8fCBiXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGhpZGVzIHRoZSBicm93c2VyJ3MgbmF0aXZlIHNlbGVjdGlvbiBhbmRcbmN1cnNvciwgcmVwbGFjaW5nIHRoZSBzZWxlY3Rpb24gd2l0aCBhIGJhY2tncm91bmQgYmVoaW5kIHRoZSB0ZXh0XG4od2l0aCB0aGUgYGNtLXNlbGVjdGlvbkJhY2tncm91bmRgIGNsYXNzKSwgYW5kIHRoZVxuY3Vyc29ycyB3aXRoIGVsZW1lbnRzIG92ZXJsYWlkIG92ZXIgdGhlIGNvZGUgKHVzaW5nXG5gY20tY3Vyc29yLXByaW1hcnlgIGFuZCBgY20tY3Vyc29yLXNlY29uZGFyeWApLlxuXG5UaGlzIGFsbG93cyB0aGUgZWRpdG9yIHRvIGRpc3BsYXkgc2Vjb25kYXJ5IHNlbGVjdGlvbiByYW5nZXMsIGFuZFxudGVuZHMgdG8gcHJvZHVjZSBhIHR5cGUgb2Ygc2VsZWN0aW9uIG1vcmUgaW4gbGluZSB3aXRoIHRoYXQgdXNlcnNcbmV4cGVjdCBpbiBhIHRleHQgZWRpdG9yICh0aGUgbmF0aXZlIHNlbGVjdGlvbiBzdHlsaW5nIHdpbGwgb2Z0ZW5cbmxlYXZlIGdhcHMgYmV0d2VlbiBsaW5lcyBhbmQgd29uJ3QgZmlsbCB0aGUgaG9yaXpvbnRhbCBzcGFjZSBhZnRlclxuYSBsaW5lIHdoZW4gdGhlIHNlbGVjdGlvbiBjb250aW51ZXMgcGFzdCBpdCkuXG5cbkl0IGRvZXMgaGF2ZSBhIHBlcmZvcm1hbmNlIGNvc3QsIGluIHRoYXQgaXQgcmVxdWlyZXMgYW4gZXh0cmEgRE9NXG5sYXlvdXQgY3ljbGUgZm9yIG1hbnkgdXBkYXRlcyAodGhlIHNlbGVjdGlvbiBpcyBkcmF3biBiYXNlZCBvbiBET01cbmxheW91dCBpbmZvcm1hdGlvbiB0aGF0J3Mgb25seSBhdmFpbGFibGUgYWZ0ZXIgbGF5aW5nIG91dCB0aGVcbmNvbnRlbnQpLlxuKi9cbmZ1bmN0aW9uIGRyYXdTZWxlY3Rpb24oY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBzZWxlY3Rpb25Db25maWcub2YoY29uZmlnKSxcbiAgICAgICAgY3Vyc29yTGF5ZXIsXG4gICAgICAgIHNlbGVjdGlvbkxheWVyLFxuICAgICAgICBoaWRlTmF0aXZlU2VsZWN0aW9uLFxuICAgICAgICBuYXRpdmVTZWxlY3Rpb25IaWRkZW4ub2YodHJ1ZSlcbiAgICBdO1xufVxuLyoqXG5SZXRyaWV2ZSB0aGUgW2BkcmF3U2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LmRyYXdTZWxlY3Rpb24pIGNvbmZpZ3VyYXRpb25cbmZvciB0aGlzIHN0YXRlLiAoTm90ZSB0aGF0IHRoaXMgd2lsbCByZXR1cm4gYSBzZXQgb2YgZGVmYXVsdHMgZXZlblxuaWYgYGRyYXdTZWxlY3Rpb25gIGlzbid0IGVuYWJsZWQuKVxuKi9cbmZ1bmN0aW9uIGdldERyYXdTZWxlY3Rpb25Db25maWcoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbn1cbmZ1bmN0aW9uIGNvbmZpZ0NoYW5nZWQodXBkYXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZykgIT0gdXBkYXRlLnN0YXRlLmZhY2V0KHNlbGVjdGlvbkNvbmZpZyk7XG59XG5jb25zdCBjdXJzb3JMYXllciA9IC8qQF9fUFVSRV9fKi9sYXllcih7XG4gICAgYWJvdmU6IHRydWUsXG4gICAgbWFya2Vycyh2aWV3KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCBjb25mID0gc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgbGV0IGN1cnNvcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgcHJpbSA9IHIgPT0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgICAgICBpZiAoci5lbXB0eSA/ICFwcmltIHx8IENhbkhpZGVQcmltYXJ5IDogY29uZi5kcmF3UmFuZ2VDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2xhc3NOYW1lID0gcHJpbSA/IFwiY20tY3Vyc29yIGNtLWN1cnNvci1wcmltYXJ5XCIgOiBcImNtLWN1cnNvciBjbS1jdXJzb3Itc2Vjb25kYXJ5XCI7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnNvciA9IHIuZW1wdHkgPyByIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyLmhlYWQsIHIuaGVhZCA+IHIuYW5jaG9yID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwaWVjZSBvZiBSZWN0YW5nbGVNYXJrZXIuZm9yUmFuZ2UodmlldywgY2xhc3NOYW1lLCBjdXJzb3IpKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3JzLnB1c2gocGllY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJzb3JzO1xuICAgIH0sXG4gICAgdXBkYXRlKHVwZGF0ZSwgZG9tKSB7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuc2VsZWN0aW9uKSlcbiAgICAgICAgICAgIGRvbS5zdHlsZS5hbmltYXRpb25OYW1lID0gZG9tLnN0eWxlLmFuaW1hdGlvbk5hbWUgPT0gXCJjbS1ibGlua1wiID8gXCJjbS1ibGluazJcIiA6IFwiY20tYmxpbmtcIjtcbiAgICAgICAgbGV0IGNvbmZDaGFuZ2UgPSBjb25maWdDaGFuZ2VkKHVwZGF0ZSk7XG4gICAgICAgIGlmIChjb25mQ2hhbmdlKVxuICAgICAgICAgICAgc2V0QmxpbmtSYXRlKHVwZGF0ZS5zdGF0ZSwgZG9tKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgY29uZkNoYW5nZTtcbiAgICB9LFxuICAgIG1vdW50KGRvbSwgdmlldykge1xuICAgICAgICBzZXRCbGlua1JhdGUodmlldy5zdGF0ZSwgZG9tKTtcbiAgICB9LFxuICAgIGNsYXNzOiBcImNtLWN1cnNvckxheWVyXCJcbn0pO1xuZnVuY3Rpb24gc2V0QmxpbmtSYXRlKHN0YXRlLCBkb20pIHtcbiAgICBkb20uc3R5bGUuYW5pbWF0aW9uRHVyYXRpb24gPSBzdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpLmN1cnNvckJsaW5rUmF0ZSArIFwibXNcIjtcbn1cbmNvbnN0IHNlbGVjdGlvbkxheWVyID0gLypAX19QVVJFX18qL2xheWVyKHtcbiAgICBhYm92ZTogZmFsc2UsXG4gICAgbWFya2Vycyh2aWV3KSB7XG4gICAgICAgIHJldHVybiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubWFwKHIgPT4gci5lbXB0eSA/IFtdIDogUmVjdGFuZ2xlTWFya2VyLmZvclJhbmdlKHZpZXcsIFwiY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiLCByKSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcbiAgICB9LFxuICAgIHVwZGF0ZSh1cGRhdGUsIGRvbSkge1xuICAgICAgICByZXR1cm4gdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8IGNvbmZpZ0NoYW5nZWQodXBkYXRlKTtcbiAgICB9LFxuICAgIGNsYXNzOiBcImNtLXNlbGVjdGlvbkxheWVyXCJcbn0pO1xuY29uc3QgdGhlbWVTcGVjID0ge1xuICAgIFwiLmNtLWxpbmVcIjoge1xuICAgICAgICBcIiYgOjpzZWxlY3Rpb24sICY6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCIgfSxcbiAgICB9LFxuICAgIFwiLmNtLWNvbnRlbnRcIjoge1xuICAgICAgICBcIiYgOmZvY3VzXCI6IHtcbiAgICAgICAgICAgIGNhcmV0Q29sb3I6IFwiaW5pdGlhbCAhaW1wb3J0YW50XCIsXG4gICAgICAgICAgICBcIiY6OnNlbGVjdGlvbiwgJiA6OnNlbGVjdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIkhpZ2hsaWdodCAhaW1wb3J0YW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5pZiAoQ2FuSGlkZVByaW1hcnkpXG4gICAgdGhlbWVTcGVjW1wiLmNtLWxpbmVcIl0uY2FyZXRDb2xvciA9IHRoZW1lU3BlY1tcIi5jbS1jb250ZW50XCJdLmNhcmV0Q29sb3IgPSBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIjtcbmNvbnN0IGhpZGVOYXRpdmVTZWxlY3Rpb24gPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoZXN0KC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LnRoZW1lKHRoZW1lU3BlYykpO1xuXG5jb25zdCBzZXREcm9wQ3Vyc29yUG9zID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7XG4gICAgbWFwKHBvcywgbWFwcGluZykgeyByZXR1cm4gcG9zID09IG51bGwgPyBudWxsIDogbWFwcGluZy5tYXBQb3MocG9zKTsgfVxufSk7XG5jb25zdCBkcm9wQ3Vyc29yUG9zID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBudWxsOyB9LFxuICAgIHVwZGF0ZShwb3MsIHRyKSB7XG4gICAgICAgIGlmIChwb3MgIT0gbnVsbClcbiAgICAgICAgICAgIHBvcyA9IHRyLmNoYW5nZXMubWFwUG9zKHBvcyk7XG4gICAgICAgIHJldHVybiB0ci5lZmZlY3RzLnJlZHVjZSgocG9zLCBlKSA9PiBlLmlzKHNldERyb3BDdXJzb3JQb3MpID8gZS52YWx1ZSA6IHBvcywgcG9zKTtcbiAgICB9XG59KTtcbmNvbnN0IGRyYXdEcm9wQ3Vyc29yID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLnJlYWRQb3MuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMuZHJhd0N1cnNvci5iaW5kKHRoaXMpIH07XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY3Vyc29yUG9zID0gdXBkYXRlLnN0YXRlLmZpZWxkKGRyb3BDdXJzb3JQb3MpO1xuICAgICAgICBpZiAoY3Vyc29yUG9zID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnNvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5jdXJzb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLnZpZXcuc2Nyb2xsRE9NLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLmNsYXNzTmFtZSA9IFwiY20tZHJvcEN1cnNvclwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZpZWxkKGRyb3BDdXJzb3JQb3MpICE9IGN1cnNvclBvcyB8fCB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWRQb3MoKSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwb3MgPSB2aWV3LnN0YXRlLmZpZWxkKGRyb3BDdXJzb3JQb3MpO1xuICAgICAgICBsZXQgcmVjdCA9IHBvcyAhPSBudWxsICYmIHZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgaWYgKCFyZWN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBvdXRlciA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gb3V0ZXIubGVmdCArIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgKiB2aWV3LnNjYWxlWCxcbiAgICAgICAgICAgIHRvcDogcmVjdC50b3AgLSBvdXRlci50b3AgKyB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgKiB2aWV3LnNjYWxlWSxcbiAgICAgICAgICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICAgICAgICB9O1xuICAgIH1cbiAgICBkcmF3Q3Vyc29yKHBvcykge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICAgIGxldCB7IHNjYWxlWCwgc2NhbGVZIH0gPSB0aGlzLnZpZXc7XG4gICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUubGVmdCA9IHBvcy5sZWZ0IC8gc2NhbGVYICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLnRvcCA9IHBvcy50b3AgLyBzY2FsZVkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gcG9zLmhlaWdodCAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmxlZnQgPSBcIi0xMDAwMDBweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvcilcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlbW92ZSgpO1xuICAgIH1cbiAgICBzZXREcm9wUG9zKHBvcykge1xuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmZpZWxkKGRyb3BDdXJzb3JQb3MpICE9IHBvcylcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldERyb3BDdXJzb3JQb3Mub2YocG9zKSB9KTtcbiAgICB9XG59LCB7XG4gICAgZXZlbnRPYnNlcnZlcnM6IHtcbiAgICAgICAgZHJhZ292ZXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyh0aGlzLnZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2xlYXZlKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09IHRoaXMudmlldy5jb250ZW50RE9NIHx8ICF0aGlzLnZpZXcuY29udGVudERPTS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdlbmQoKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyb3AoKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbi8qKlxuRHJhd3MgYSBjdXJzb3IgYXQgdGhlIGN1cnJlbnQgZHJvcCBwb3NpdGlvbiB3aGVuIHNvbWV0aGluZyBpc1xuZHJhZ2dlZCBvdmVyIHRoZSBlZGl0b3IuXG4qL1xuZnVuY3Rpb24gZHJvcEN1cnNvcigpIHtcbiAgICByZXR1cm4gW2Ryb3BDdXJzb3JQb3MsIGRyYXdEcm9wQ3Vyc29yXTtcbn1cblxuZnVuY3Rpb24gaXRlck1hdGNoZXMoZG9jLCByZSwgZnJvbSwgdG8sIGYpIHtcbiAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgIGZvciAobGV0IGN1cnNvciA9IGRvYy5pdGVyUmFuZ2UoZnJvbSwgdG8pLCBwb3MgPSBmcm9tLCBtOyAhY3Vyc29yLm5leHQoKS5kb25lOyBwb3MgKz0gY3Vyc29yLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICBpZiAoIWN1cnNvci5saW5lQnJlYWspXG4gICAgICAgICAgICB3aGlsZSAobSA9IHJlLmV4ZWMoY3Vyc29yLnZhbHVlKSlcbiAgICAgICAgICAgICAgICBmKHBvcyArIG0uaW5kZXgsIG0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoUmFuZ2VzKHZpZXcsIG1heExlbmd0aCkge1xuICAgIGxldCB2aXNpYmxlID0gdmlldy52aXNpYmxlUmFuZ2VzO1xuICAgIGlmICh2aXNpYmxlLmxlbmd0aCA9PSAxICYmIHZpc2libGVbMF0uZnJvbSA9PSB2aWV3LnZpZXdwb3J0LmZyb20gJiZcbiAgICAgICAgdmlzaWJsZVswXS50byA9PSB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHZpc2libGUpIHtcbiAgICAgICAgZnJvbSA9IE1hdGgubWF4KHZpZXcuc3RhdGUuZG9jLmxpbmVBdChmcm9tKS5mcm9tLCBmcm9tIC0gbWF4TGVuZ3RoKTtcbiAgICAgICAgdG8gPSBNYXRoLm1pbih2aWV3LnN0YXRlLmRvYy5saW5lQXQodG8pLnRvLCB0byArIG1heExlbmd0aCk7XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0udG8gPj0gZnJvbSlcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0udG8gPSB0bztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuSGVscGVyIGNsYXNzIHVzZWQgdG8gbWFrZSBpdCBlYXNpZXIgdG8gbWFpbnRhaW4gZGVjb3JhdGlvbnMgb25cbnZpc2libGUgY29kZSB0aGF0IG1hdGNoZXMgYSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24uIFRvIGJlIHVzZWRcbmluIGEgW3ZpZXcgcGx1Z2luXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuVmlld1BsdWdpbikuIEluc3RhbmNlcyBvZiB0aGlzIG9iamVjdFxucmVwcmVzZW50IGEgbWF0Y2hpbmcgY29uZmlndXJhdGlvbi5cbiovXG5jbGFzcyBNYXRjaERlY29yYXRvciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZGVjb3JhdG9yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHsgcmVnZXhwLCBkZWNvcmF0aW9uLCBkZWNvcmF0ZSwgYm91bmRhcnksIG1heExlbmd0aCA9IDEwMDAgfSA9IGNvbmZpZztcbiAgICAgICAgaWYgKCFyZWdleHAuZ2xvYmFsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgcmVndWxhciBleHByZXNzaW9uIGdpdmVuIHRvIE1hdGNoRGVjb3JhdG9yIHNob3VsZCBoYXZlIGl0cyAnZycgZmxhZyBzZXRcIik7XG4gICAgICAgIHRoaXMucmVnZXhwID0gcmVnZXhwO1xuICAgICAgICBpZiAoZGVjb3JhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIHZpZXcsIGZyb20sIGFkZCkgPT4gZGVjb3JhdGUoYWRkLCBmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBtYXRjaCwgdmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlY29yYXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE1hdGNoID0gKG1hdGNoLCB2aWV3LCBmcm9tLCBhZGQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZGVjbyA9IGRlY29yYXRpb24obWF0Y2gsIHZpZXcsIGZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChkZWNvKVxuICAgICAgICAgICAgICAgICAgICBhZGQoZnJvbSwgZnJvbSArIG1hdGNoWzBdLmxlbmd0aCwgZGVjbyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlY29yYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2ggPSAobWF0Y2gsIF92aWV3LCBmcm9tLCBhZGQpID0+IGFkZChmcm9tLCBmcm9tICsgbWF0Y2hbMF0ubGVuZ3RoLCBkZWNvcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRWl0aGVyICdkZWNvcmF0ZScgb3IgJ2RlY29yYXRpb24nIHNob3VsZCBiZSBwcm92aWRlZCB0byBNYXRjaERlY29yYXRvclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvdW5kYXJ5ID0gYm91bmRhcnk7XG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wdXRlIHRoZSBmdWxsIHNldCBvZiBkZWNvcmF0aW9ucyBmb3IgbWF0Y2hlcyBpbiB0aGUgZ2l2ZW5cbiAgICB2aWV3J3Mgdmlld3BvcnQuIFlvdSdsbCB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIGluaXRpYWxpemluZyB5b3VyXG4gICAgcGx1Z2luLlxuICAgICovXG4gICAgY3JlYXRlRGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBidWlsZCA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKSwgYWRkID0gYnVpbGQuYWRkLmJpbmQoYnVpbGQpO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgbWF0Y2hSYW5nZXModmlldywgdGhpcy5tYXhMZW5ndGgpKVxuICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBmcm9tLCB0bywgKGZyb20sIG0pID0+IHRoaXMuYWRkTWF0Y2gobSwgdmlldywgZnJvbSwgYWRkKSk7XG4gICAgICAgIHJldHVybiBidWlsZC5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIGEgc2V0IG9mIGRlY29yYXRpb25zIGZvciBhIHZpZXcgdXBkYXRlLiBgZGVjb2AgX211c3RfIGJlXG4gICAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBwcm9kdWNlZCBieSBfdGhpc18gYE1hdGNoRGVjb3JhdG9yYCBmb3JcbiAgICB0aGUgdmlldyBzdGF0ZSBiZWZvcmUgdGhlIHVwZGF0ZS5cbiAgICAqL1xuICAgIHVwZGF0ZURlY28odXBkYXRlLCBkZWNvKSB7XG4gICAgICAgIGxldCBjaGFuZ2VGcm9tID0gMWU5LCBjaGFuZ2VUbyA9IC0xO1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB1cGRhdGUuY2hhbmdlcy5pdGVyQ2hhbmdlcygoX2YsIF90LCBmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0byA+PSB1cGRhdGUudmlldy52aWV3cG9ydC5mcm9tICYmIGZyb20gPD0gdXBkYXRlLnZpZXcudmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRnJvbSA9IE1hdGgubWluKGZyb20sIGNoYW5nZUZyb20pO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUbyA9IE1hdGgubWF4KHRvLCBjaGFuZ2VUbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cGRhdGUudmlld3BvcnRNb3ZlZCB8fCBjaGFuZ2VUbyAtIGNoYW5nZUZyb20gPiAxMDAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGVjbyh1cGRhdGUudmlldyk7XG4gICAgICAgIGlmIChjaGFuZ2VUbyA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlUmFuZ2UodXBkYXRlLnZpZXcsIGRlY28ubWFwKHVwZGF0ZS5jaGFuZ2VzKSwgY2hhbmdlRnJvbSwgY2hhbmdlVG8pO1xuICAgICAgICByZXR1cm4gZGVjbztcbiAgICB9XG4gICAgdXBkYXRlUmFuZ2UodmlldywgZGVjbywgdXBkYXRlRnJvbSwgdXBkYXRlVG8pIHtcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoci5mcm9tLCB1cGRhdGVGcm9tKSwgdG8gPSBNYXRoLm1pbihyLnRvLCB1cGRhdGVUbyk7XG4gICAgICAgICAgICBpZiAodG8gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb21MaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLCB0b0xpbmUgPSBmcm9tTGluZS50byA8IHRvID8gdmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKSA6IGZyb21MaW5lO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHIuZnJvbSwgZnJvbUxpbmUuZnJvbSksIGVuZCA9IE1hdGgubWluKHIudG8sIHRvTGluZS50byk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGZyb20gPiBmcm9tTGluZS5mcm9tOyBmcm9tLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeS50ZXN0KGZyb21MaW5lLnRleHRbZnJvbSAtIDEgLSBmcm9tTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyB0byA8IHRvTGluZS50bzsgdG8rKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QodG9MaW5lLnRleHRbdG8gLSB0b0xpbmUuZnJvbV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBbXSwgbTtcbiAgICAgICAgICAgICAgICBsZXQgYWRkID0gKGZyb20sIHRvLCBkZWNvKSA9PiByYW5nZXMucHVzaChkZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21MaW5lID09IHRvTGluZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZ2V4cC5sYXN0SW5kZXggPSBzdGFydCAtIGZyb21MaW5lLmZyb207XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgobSA9IHRoaXMucmVnZXhwLmV4ZWMoZnJvbUxpbmUudGV4dCkpICYmIG0uaW5kZXggPCBlbmQgLSBmcm9tTGluZS5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNYXRjaChtLCB2aWV3LCBtLmluZGV4ICsgZnJvbUxpbmUuZnJvbSwgYWRkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJNYXRjaGVzKHZpZXcuc3RhdGUuZG9jLCB0aGlzLnJlZ2V4cCwgc3RhcnQsIGVuZCwgKGZyb20sIG0pID0+IHRoaXMuYWRkTWF0Y2gobSwgdmlldywgZnJvbSwgYWRkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY28gPSBkZWNvLnVwZGF0ZSh7IGZpbHRlckZyb206IHN0YXJ0LCBmaWx0ZXJUbzogZW5kLCBmaWx0ZXI6IChmcm9tLCB0bykgPT4gZnJvbSA8IHN0YXJ0IHx8IHRvID4gZW5kLCBhZGQ6IHJhbmdlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjbztcbiAgICB9XG59XG5cbmNvbnN0IFVuaWNvZGVSZWdleHBTdXBwb3J0ID0gL3gvLnVuaWNvZGUgIT0gbnVsbCA/IFwiZ3VcIiA6IFwiZ1wiO1xuY29uc3QgU3BlY2lhbHMgPSAvKkBfX1BVUkVfXyovbmV3IFJlZ0V4cChcIltcXHUwMDAwLVxcdTAwMDhcXHUwMDBhLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYxY1xcdTIwMGJcXHUyMDBlXFx1MjAwZlxcdTIwMjhcXHUyMDI5XFx1MjAyZFxcdTIwMmVcXHUyMDY2XFx1MjA2N1xcdTIwNjlcXHVmZWZmXFx1ZmZmOS1cXHVmZmZjXVwiLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG5jb25zdCBOYW1lcyA9IHtcbiAgICAwOiBcIm51bGxcIixcbiAgICA3OiBcImJlbGxcIixcbiAgICA4OiBcImJhY2tzcGFjZVwiLFxuICAgIDEwOiBcIm5ld2xpbmVcIixcbiAgICAxMTogXCJ2ZXJ0aWNhbCB0YWJcIixcbiAgICAxMzogXCJjYXJyaWFnZSByZXR1cm5cIixcbiAgICAyNzogXCJlc2NhcGVcIixcbiAgICA4MjAzOiBcInplcm8gd2lkdGggc3BhY2VcIixcbiAgICA4MjA0OiBcInplcm8gd2lkdGggbm9uLWpvaW5lclwiLFxuICAgIDgyMDU6IFwiemVybyB3aWR0aCBqb2luZXJcIixcbiAgICA4MjA2OiBcImxlZnQtdG8tcmlnaHQgbWFya1wiLFxuICAgIDgyMDc6IFwicmlnaHQtdG8tbGVmdCBtYXJrXCIsXG4gICAgODIzMjogXCJsaW5lIHNlcGFyYXRvclwiLFxuICAgIDgyMzc6IFwibGVmdC10by1yaWdodCBvdmVycmlkZVwiLFxuICAgIDgyMzg6IFwicmlnaHQtdG8tbGVmdCBvdmVycmlkZVwiLFxuICAgIDgyOTQ6IFwibGVmdC10by1yaWdodCBpc29sYXRlXCIsXG4gICAgODI5NTogXCJyaWdodC10by1sZWZ0IGlzb2xhdGVcIixcbiAgICA4Mjk3OiBcInBvcCBkaXJlY3Rpb25hbCBpc29sYXRlXCIsXG4gICAgODIzMzogXCJwYXJhZ3JhcGggc2VwYXJhdG9yXCIsXG4gICAgNjUyNzk6IFwiemVybyB3aWR0aCBuby1icmVhayBzcGFjZVwiLFxuICAgIDY1NTMyOiBcIm9iamVjdCByZXBsYWNlbWVudFwiXG59O1xubGV0IF9zdXBwb3J0c1RhYlNpemUgPSBudWxsO1xuZnVuY3Rpb24gc3VwcG9ydHNUYWJTaXplKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoX3N1cHBvcnRzVGFiU2l6ZSA9PSBudWxsICYmIHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgbGV0IHN0eWxlcyA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgICAgIF9zdXBwb3J0c1RhYlNpemUgPSAoKF9hID0gc3R5bGVzLnRhYlNpemUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHN0eWxlcy5Nb3pUYWJTaXplKSAhPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX3N1cHBvcnRzVGFiU2l6ZSB8fCBmYWxzZTtcbn1cbmNvbnN0IHNwZWNpYWxDaGFyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCBjb25maWcgPSBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgICAgIHNwZWNpYWxDaGFyczogU3BlY2lhbHMsXG4gICAgICAgICAgICBhZGRTcGVjaWFsQ2hhcnM6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcucmVwbGFjZVRhYnMgPSAhc3VwcG9ydHNUYWJTaXplKCkpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChcIlxcdHxcIiArIGNvbmZpZy5zcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIGlmIChjb25maWcuYWRkU3BlY2lhbENoYXJzKVxuICAgICAgICAgICAgY29uZmlnLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAoY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UgKyBcInxcIiArIGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaW5zdGFsbHMgaGlnaGxpZ2h0aW5nIG9mIHNwZWNpYWxcbmNoYXJhY3RlcnMuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U3BlY2lhbENoYXJzKFxuLyoqXG5Db25maWd1cmF0aW9uIG9wdGlvbnMuXG4qL1xuY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW3NwZWNpYWxDaGFyQ29uZmlnLm9mKGNvbmZpZyksIHNwZWNpYWxDaGFyUGx1Z2luKCldO1xufVxubGV0IF9wbHVnaW4gPSBudWxsO1xuZnVuY3Rpb24gc3BlY2lhbENoYXJQbHVnaW4oKSB7XG4gICAgcmV0dXJuIF9wbHVnaW4gfHwgKF9wbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9uQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3Iodmlldy5zdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgbWFrZURlY29yYXRvcihjb25mKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICAgICAgICAgICAgICByZWdleHA6IGNvbmYuc3BlY2lhbENoYXJzLFxuICAgICAgICAgICAgICAgIGRlY29yYXRpb246IChtLCB2aWV3LCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZG9jIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IGNvZGVQb2ludEF0KG1bMF0sIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gdmlldy5zdGF0ZS50YWJTaXplLCBjb2wgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIHNpemUsIHBvcyAtIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5yZXBsYWNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQ6IG5ldyBUYWJXaWRnZXQoKHNpemUgLSAoY29sICUgc2l6ZSkpICogdGhpcy52aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCAvIHRoaXMudmlldy5zY2FsZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9uQ2FjaGVbY29kZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSA9IERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IFNwZWNpYWxDaGFyV2lkZ2V0KGNvbmYsIGNvZGUpIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvdW5kYXJ5OiBjb25mLnJlcGxhY2VUYWJzID8gdW5kZWZpbmVkIDogL1teXS9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykgIT0gY29uZikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdG9yID0gdGhpcy5tYWtlRGVjb3JhdG9yKGNvbmYpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci5jcmVhdGVEZWNvKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRvci51cGRhdGVEZWNvKHVwZGF0ZSwgdGhpcy5kZWNvcmF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbiAgICB9KSk7XG59XG5jb25zdCBEZWZhdWx0UGxhY2Vob2xkZXIgPSBcIlxcdTIwMjJcIjtcbi8vIEFzc2lnbnMgcGxhY2Vob2xkZXIgY2hhcmFjdGVycyBmcm9tIHRoZSBDb250cm9sIFBpY3R1cmVzIGJsb2NrIHRvXG4vLyBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnNcbmZ1bmN0aW9uIHBsYWNlaG9sZGVyJDEoY29kZSkge1xuICAgIGlmIChjb2RlID49IDMyKVxuICAgICAgICByZXR1cm4gRGVmYXVsdFBsYWNlaG9sZGVyO1xuICAgIGlmIChjb2RlID09IDEwKVxuICAgICAgICByZXR1cm4gXCJcXHUyNDI0XCI7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoOTIxNiArIGNvZGUpO1xufVxuY2xhc3MgU3BlY2lhbENoYXJXaWRnZXQgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlci5jb2RlID09IHRoaXMuY29kZTsgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgbGV0IHBoID0gcGxhY2Vob2xkZXIkMSh0aGlzLmNvZGUpO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuc3RhdGUucGhyYXNlKFwiQ29udHJvbCBjaGFyYWN0ZXJcIikgKyBcIiBcIiArIChOYW1lc1t0aGlzLmNvZGVdIHx8IFwiMHhcIiArIHRoaXMuY29kZS50b1N0cmluZygxNikpO1xuICAgICAgICBsZXQgY3VzdG9tID0gdGhpcy5vcHRpb25zLnJlbmRlciAmJiB0aGlzLm9wdGlvbnMucmVuZGVyKHRoaXMuY29kZSwgZGVzYywgcGgpO1xuICAgICAgICBpZiAoY3VzdG9tKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbTtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHBoO1xuICAgICAgICBzcGFuLnRpdGxlID0gZGVzYztcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIGRlc2MpO1xuICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiY20tc3BlY2lhbENoYXJcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmNsYXNzIFRhYldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLndpZHRoID09IHRoaXMud2lkdGg7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IFwiXFx0XCI7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS10YWJcIjtcbiAgICAgICAgc3Bhbi5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5cbmNvbnN0IHBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMTAwMDtcbiAgICAgICAgdGhpcy5hdHRycyA9IHsgc3R5bGU6IFwicGFkZGluZy1ib3R0b206IDEwMDBweFwiIH07XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IHsgdmlldyB9ID0gdXBkYXRlO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdmlldy52aWV3U3RhdGUuZWRpdG9ySGVpZ2h0IC1cbiAgICAgICAgICAgIHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgLSB2aWV3LmRvY3VtZW50UGFkZGluZy50b3AgLSAwLjU7XG4gICAgICAgIGlmIChoZWlnaHQgPj0gMCAmJiBoZWlnaHQgIT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5hdHRycyA9IHsgc3R5bGU6IGBwYWRkaW5nLWJvdHRvbTogJHtoZWlnaHR9cHhgIH07XG4gICAgICAgIH1cbiAgICB9XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBtYWtlcyBzdXJlIHRoZSBjb250ZW50IGhhcyBhIGJvdHRvbVxubWFyZ2luIGVxdWl2YWxlbnQgdG8gdGhlIGhlaWdodCBvZiB0aGUgZWRpdG9yLCBtaW51cyBvbmUgbGluZVxuaGVpZ2h0LCBzbyB0aGF0IGV2ZXJ5IGxpbmUgaW4gdGhlIGRvY3VtZW50IGNhbiBiZSBzY3JvbGxlZCB0byB0aGVcbnRvcCBvZiB0aGUgZWRpdG9yLlxuXG5UaGlzIGlzIG9ubHkgbWVhbmluZ2Z1bCB3aGVuIHRoZSBlZGl0b3IgaXMgc2Nyb2xsYWJsZSwgYW5kIHNob3VsZFxubm90IGJlIGVuYWJsZWQgaW4gZWRpdG9ycyB0aGF0IHRha2UgdGhlIHNpemUgb2YgdGhlaXIgY29udGVudC5cbiovXG5mdW5jdGlvbiBzY3JvbGxQYXN0RW5kKCkge1xuICAgIHJldHVybiBbcGx1Z2luLCBjb250ZW50QXR0cmlidXRlcy5vZih2aWV3ID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKHBsdWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdHRycykgfHwgbnVsbDsgfSldO1xufVxuXG4vKipcbk1hcmsgbGluZXMgdGhhdCBoYXZlIGEgY3Vyc29yIG9uIHRoZW0gd2l0aCB0aGUgYFwiY20tYWN0aXZlTGluZVwiYFxuRE9NIGNsYXNzLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodEFjdGl2ZUxpbmUoKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUxpbmVIaWdobGlnaHRlcjtcbn1cbmNvbnN0IGxpbmVEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubGluZSh7IGNsYXNzOiBcImNtLWFjdGl2ZUxpbmVcIiB9KTtcbmNvbnN0IGFjdGl2ZUxpbmVIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuc2VsZWN0aW9uU2V0KVxuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh1cGRhdGUudmlldyk7XG4gICAgfVxuICAgIGdldERlY28odmlldykge1xuICAgICAgICBsZXQgbGFzdExpbmVTdGFydCA9IC0xLCBkZWNvID0gW107XG4gICAgICAgIGZvciAobGV0IHIgb2Ygdmlldy5zdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQoci5oZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPiBsYXN0TGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgZGVjby5wdXNoKGxpbmVEZWNvLnJhbmdlKGxpbmUuZnJvbSkpO1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lU3RhcnQgPSBsaW5lLmZyb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xuICAgIH1cbn0sIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KTtcblxuY2xhc3MgUGxhY2Vob2xkZXIgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgbGV0IHdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgd3JhcC5jbGFzc05hbWUgPSBcImNtLXBsYWNlaG9sZGVyXCI7XG4gICAgICAgIHdyYXAuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICB3cmFwLmFwcGVuZENoaWxkKHR5cGVvZiB0aGlzLmNvbnRlbnQgPT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY29udGVudCkgOlxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuY29udGVudCA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLmNvbnRlbnQodmlldykgOlxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29udGVudCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgd3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwicGxhY2Vob2xkZXIgXCIgKyB0aGlzLmNvbnRlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cmFwLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgcmV0dXJuIHdyYXA7XG4gICAgfVxuICAgIGNvb3Jkc0F0KGRvbSkge1xuICAgICAgICBsZXQgcmVjdHMgPSBkb20uZmlyc3RDaGlsZCA/IGNsaWVudFJlY3RzRm9yKGRvbS5maXJzdENoaWxkKSA6IFtdO1xuICAgICAgICBpZiAoIXJlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20ucGFyZW50Tm9kZSk7XG4gICAgICAgIGxldCByZWN0ID0gZmxhdHRlblJlY3QocmVjdHNbMF0sIHN0eWxlLmRpcmVjdGlvbiAhPSBcInJ0bFwiKTtcbiAgICAgICAgbGV0IGxpbmVIZWlnaHQgPSBwYXJzZUludChzdHlsZS5saW5lSGVpZ2h0KTtcbiAgICAgICAgaWYgKHJlY3QuYm90dG9tIC0gcmVjdC50b3AgPiBsaW5lSGVpZ2h0ICogMS41KVxuICAgICAgICAgICAgcmV0dXJuIHsgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCwgdG9wOiByZWN0LnRvcCwgYm90dG9tOiByZWN0LnRvcCArIGxpbmVIZWlnaHQgfTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8qKlxuRXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBhIHBsYWNlaG9sZGVy4oCUYSBwaWVjZSBvZiBleGFtcGxlIGNvbnRlbnRcbnRvIHNob3cgd2hlbiB0aGUgZWRpdG9yIGlzIGVtcHR5LlxuKi9cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IGNvbnRlbnRcbiAgICAgICAgICAgICAgICA/IERlY29yYXRpb24uc2V0KFtEZWNvcmF0aW9uLndpZGdldCh7IHdpZGdldDogbmV3IFBsYWNlaG9sZGVyKGNvbnRlbnQpLCBzaWRlOiAxIH0pLnJhbmdlKDApXSlcbiAgICAgICAgICAgICAgICA6IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGVjb3JhdGlvbnMoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aCA/IERlY29yYXRpb24ubm9uZSA6IHRoaXMucGxhY2Vob2xkZXI7IH1cbiAgICB9LCB7IGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnMgfSk7XG59XG5cbi8vIERvbid0IGNvbXB1dGUgcHJlY2lzZSBjb2x1bW4gcG9zaXRpb25zIGZvciBsaW5lIG9mZnNldHMgYWJvdmUgdGhpc1xuLy8gKHNpbmNlIGl0IGNvdWxkIGdldCBleHBlbnNpdmUpLiBBc3N1bWUgb2Zmc2V0PT1jb2x1bW4gZm9yIHRoZW0uXG5jb25zdCBNYXhPZmYgPSAyMDAwO1xuZnVuY3Rpb24gcmVjdGFuZ2xlRm9yKHN0YXRlLCBhLCBiKSB7XG4gICAgbGV0IHN0YXJ0TGluZSA9IE1hdGgubWluKGEubGluZSwgYi5saW5lKSwgZW5kTGluZSA9IE1hdGgubWF4KGEubGluZSwgYi5saW5lKTtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgaWYgKGEub2ZmID4gTWF4T2ZmIHx8IGIub2ZmID4gTWF4T2ZmIHx8IGEuY29sIDwgMCB8fCBiLmNvbCA8IDApIHtcbiAgICAgICAgbGV0IHN0YXJ0T2ZmID0gTWF0aC5taW4oYS5vZmYsIGIub2ZmKSwgZW5kT2ZmID0gTWF0aC5tYXgoYS5vZmYsIGIub2ZmKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8PSBlbmRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gc3RhdGUuZG9jLmxpbmUoaSk7XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPD0gZW5kT2ZmKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKEVkaXRvclNlbGVjdGlvbi5yYW5nZShsaW5lLmZyb20gKyBzdGFydE9mZiwgbGluZS50byArIGVuZE9mZikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgc3RhcnRDb2wgPSBNYXRoLm1pbihhLmNvbCwgYi5jb2wpLCBlbmRDb2wgPSBNYXRoLm1heChhLmNvbCwgYi5jb2wpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBzdGF0ZS5kb2MubGluZShpKTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IGZpbmRDb2x1bW4obGluZS50ZXh0LCBzdGFydENvbCwgc3RhdGUudGFiU2l6ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihsaW5lLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gZmluZENvbHVtbihsaW5lLnRleHQsIGVuZENvbCwgc3RhdGUudGFiU2l6ZSk7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGxpbmUuZnJvbSArIHN0YXJ0LCBsaW5lLmZyb20gKyBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuZnVuY3Rpb24gYWJzb2x1dGVDb2x1bW4odmlldywgeCkge1xuICAgIGxldCByZWYgPSB2aWV3LmNvb3Jkc0F0UG9zKHZpZXcudmlld3BvcnQuZnJvbSk7XG4gICAgcmV0dXJuIHJlZiA/IE1hdGgucm91bmQoTWF0aC5hYnMoKHJlZi5sZWZ0IC0geCkgLyB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCkpIDogLTE7XG59XG5mdW5jdGlvbiBnZXRQb3ModmlldywgZXZlbnQpIHtcbiAgICBsZXQgb2Zmc2V0ID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIGxldCBsaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KG9mZnNldCksIG9mZiA9IG9mZnNldCAtIGxpbmUuZnJvbTtcbiAgICBsZXQgY29sID0gb2ZmID4gTWF4T2ZmID8gLTFcbiAgICAgICAgOiBvZmYgPT0gbGluZS5sZW5ndGggPyBhYnNvbHV0ZUNvbHVtbih2aWV3LCBldmVudC5jbGllbnRYKVxuICAgICAgICAgICAgOiBjb3VudENvbHVtbihsaW5lLnRleHQsIHZpZXcuc3RhdGUudGFiU2l6ZSwgb2Zmc2V0IC0gbGluZS5mcm9tKTtcbiAgICByZXR1cm4geyBsaW5lOiBsaW5lLm51bWJlciwgY29sLCBvZmYgfTtcbn1cbmZ1bmN0aW9uIHJlY3RhbmdsZVNlbGVjdGlvblN0eWxlKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHN0YXJ0ID0gZ2V0UG9zKHZpZXcsIGV2ZW50KSwgc3RhcnRTZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoIXN0YXJ0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3U3RhcnQgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModXBkYXRlLnN0YXJ0U3RhdGUuZG9jLmxpbmUoc3RhcnQubGluZSkuZnJvbSk7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0xpbmUgPSB1cGRhdGUuc3RhdGUuZG9jLmxpbmVBdChuZXdTdGFydCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB7IGxpbmU6IG5ld0xpbmUubnVtYmVyLCBjb2w6IHN0YXJ0LmNvbCwgb2ZmOiBNYXRoLm1pbihzdGFydC5vZmYsIG5ld0xpbmUubGVuZ3RoKSB9O1xuICAgICAgICAgICAgICAgIHN0YXJ0U2VsID0gc3RhcnRTZWwubWFwKHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KGV2ZW50LCBfZXh0ZW5kLCBtdWx0aXBsZSkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IGdldFBvcyh2aWV3LCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIWN1cilcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWw7XG4gICAgICAgICAgICBsZXQgcmFuZ2VzID0gcmVjdGFuZ2xlRm9yKHZpZXcuc3RhdGUsIHN0YXJ0LCBjdXIpO1xuICAgICAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydFNlbDtcbiAgICAgICAgICAgIGlmIChtdWx0aXBsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZShyYW5nZXMuY29uY2F0KHN0YXJ0U2VsLnJhbmdlcykpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyByZWN0YW5ndWxhciBzZWxlY3Rpb25zLiBCeVxuZGVmYXVsdCwgaXQgd2lsbCByZWFjdCB0byBsZWZ0IG1vdXNlIGRyYWcgd2l0aCB0aGUgQWx0IGtleSBoZWxkXG5kb3duLiBXaGVuIHN1Y2ggYSBzZWxlY3Rpb24gb2NjdXJzLCB0aGUgdGV4dCB3aXRoaW4gdGhlIHJlY3RhbmdsZVxudGhhdCB3YXMgZHJhZ2dlZCBvdmVyIHdpbGwgYmUgc2VsZWN0ZWQsIGFzIG9uZSBzZWxlY3Rpb25cbltyYW5nZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZSkgcGVyIGxpbmUuXG4qL1xuZnVuY3Rpb24gcmVjdGFuZ3VsYXJTZWxlY3Rpb24ob3B0aW9ucykge1xuICAgIGxldCBmaWx0ZXIgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmV2ZW50RmlsdGVyKSB8fCAoZSA9PiBlLmFsdEtleSAmJiBlLmJ1dHRvbiA9PSAwKTtcbiAgICByZXR1cm4gRWRpdG9yVmlldy5tb3VzZVNlbGVjdGlvblN0eWxlLm9mKCh2aWV3LCBldmVudCkgPT4gZmlsdGVyKGV2ZW50KSA/IHJlY3RhbmdsZVNlbGVjdGlvblN0eWxlKHZpZXcsIGV2ZW50KSA6IG51bGwpO1xufVxuY29uc3Qga2V5cyA9IHtcbiAgICBBbHQ6IFsxOCwgZSA9PiAhIWUuYWx0S2V5XSxcbiAgICBDb250cm9sOiBbMTcsIGUgPT4gISFlLmN0cmxLZXldLFxuICAgIFNoaWZ0OiBbMTYsIGUgPT4gISFlLnNoaWZ0S2V5XSxcbiAgICBNZXRhOiBbOTEsIGUgPT4gISFlLm1ldGFLZXldXG59O1xuY29uc3Qgc2hvd0Nyb3NzaGFpciA9IHsgc3R5bGU6IFwiY3Vyc29yOiBjcm9zc2hhaXJcIiB9O1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IHR1cm5zIHRoZSBwb2ludGVyIGN1cnNvciBpbnRvIGFcbmNyb3NzaGFpciB3aGVuIGEgZ2l2ZW4gbW9kaWZpZXIga2V5LCBkZWZhdWx0aW5nIHRvIEFsdCwgaXMgaGVsZFxuZG93bi4gQ2FuIHNlcnZlIGFzIGEgdmlzdWFsIGhpbnQgdGhhdCByZWN0YW5ndWxhciBzZWxlY3Rpb24gaXNcbmdvaW5nIHRvIGhhcHBlbiB3aGVuIHBhaXJlZCB3aXRoXG5bYHJlY3Rhbmd1bGFyU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LnJlY3Rhbmd1bGFyU2VsZWN0aW9uKS5cbiovXG5mdW5jdGlvbiBjcm9zc2hhaXJDdXJzb3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IFtjb2RlLCBnZXR0ZXJdID0ga2V5c1tvcHRpb25zLmtleSB8fCBcIkFsdFwiXTtcbiAgICBsZXQgcGx1Z2luID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAgICAgdGhpcy5pc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZXQoaXNEb3duKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Rvd24gIT0gaXNEb3duKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0Rvd24gPSBpc0Rvd247XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnVwZGF0ZShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGV2ZW50T2JzZXJ2ZXJzOiB7XG4gICAgICAgICAgICBrZXlkb3duKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChlLmtleUNvZGUgPT0gY29kZSB8fCBnZXR0ZXIoZSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleXVwKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IGNvZGUgfHwgIWdldHRlcihlKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlbW92ZShlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoZ2V0dGVyKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHBsdWdpbixcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5vZih2aWV3ID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKHBsdWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0Rvd24pID8gc2hvd0Nyb3NzaGFpciA6IG51bGw7IH0pXG4gICAgXTtcbn1cblxuY29uc3QgT3V0c2lkZSA9IFwiLTEwMDAwcHhcIjtcbmNsYXNzIFRvb2x0aXBWaWV3TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IodmlldywgZmFjZXQsIGNyZWF0ZVRvb2x0aXBWaWV3LCByZW1vdmVUb29sdGlwVmlldykge1xuICAgICAgICB0aGlzLmZhY2V0ID0gZmFjZXQ7XG4gICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcFZpZXcgPSBjcmVhdGVUb29sdGlwVmlldztcbiAgICAgICAgdGhpcy5yZW1vdmVUb29sdGlwVmlldyA9IHJlbW92ZVRvb2x0aXBWaWV3O1xuICAgICAgICB0aGlzLmlucHV0ID0gdmlldy5zdGF0ZS5mYWNldChmYWNldCk7XG4gICAgICAgIHRoaXMudG9vbHRpcHMgPSB0aGlzLmlucHV0LmZpbHRlcih0ID0+IHQpO1xuICAgICAgICBsZXQgcHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMudG9vbHRpcFZpZXdzID0gdGhpcy50b29sdGlwcy5tYXAodCA9PiBwcmV2ID0gY3JlYXRlVG9vbHRpcFZpZXcodCwgcHJldikpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlLCBhYm92ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBpbnB1dCA9IHVwZGF0ZS5zdGF0ZS5mYWNldCh0aGlzLmZhY2V0KTtcbiAgICAgICAgbGV0IHRvb2x0aXBzID0gaW5wdXQuZmlsdGVyKHggPT4geCk7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICBpZiAodC51cGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIHQudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvb2x0aXBWaWV3cyA9IFtdLCBuZXdBYm92ZSA9IGFib3ZlID8gW10gOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvb2x0aXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdGlwID0gdG9vbHRpcHNbaV0sIGtub3duID0gLTE7XG4gICAgICAgICAgICBpZiAoIXRpcClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50b29sdGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBvdGhlciA9IHRoaXMudG9vbHRpcHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyICYmIG90aGVyLmNyZWF0ZSA9PSB0aXAuY3JlYXRlKVxuICAgICAgICAgICAgICAgICAgICBrbm93biA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa25vd24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcFZpZXdzW2ldID0gdGhpcy5jcmVhdGVUb29sdGlwVmlldyh0aXAsIGkgPyB0b29sdGlwVmlld3NbaSAtIDFdIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Fib3ZlKVxuICAgICAgICAgICAgICAgICAgICBuZXdBYm92ZVtpXSA9ICEhdGlwLmFib3ZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRvb2x0aXBWaWV3ID0gdG9vbHRpcFZpZXdzW2ldID0gdGhpcy50b29sdGlwVmlld3Nba25vd25dO1xuICAgICAgICAgICAgICAgIGlmIChuZXdBYm92ZSlcbiAgICAgICAgICAgICAgICAgICAgbmV3QWJvdmVbaV0gPSBhYm92ZVtrbm93bl07XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBWaWV3LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcFZpZXcudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgIGlmICh0b29sdGlwVmlld3MuaW5kZXhPZih0KSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRvb2x0aXBWaWV3KHQpO1xuICAgICAgICAgICAgICAgIChfYSA9IHQuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGlmIChhYm92ZSkge1xuICAgICAgICAgICAgbmV3QWJvdmUuZm9yRWFjaCgodmFsLCBpKSA9PiBhYm92ZVtpXSA9IHZhbCk7XG4gICAgICAgICAgICBhYm92ZS5sZW5ndGggPSBuZXdBYm92ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnRvb2x0aXBzID0gdG9vbHRpcHM7XG4gICAgICAgIHRoaXMudG9vbHRpcFZpZXdzID0gdG9vbHRpcFZpZXdzO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vKipcbkNyZWF0ZXMgYW4gZXh0ZW5zaW9uIHRoYXQgY29uZmlndXJlcyB0b29sdGlwIGJlaGF2aW9yLlxuKi9cbmZ1bmN0aW9uIHRvb2x0aXBzKGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIHRvb2x0aXBDb25maWcub2YoY29uZmlnKTtcbn1cbmZ1bmN0aW9uIHdpbmRvd1NwYWNlKHZpZXcpIHtcbiAgICBsZXQgZG9jRWx0ID0gdmlldy5kb20ub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IGRvY0VsdC5jbGllbnRIZWlnaHQsIHJpZ2h0OiBkb2NFbHQuY2xpZW50V2lkdGggfTtcbn1cbmNvbnN0IHRvb2x0aXBDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBwb3NpdGlvbjogYnJvd3Nlci5pb3MgPyBcImFic29sdXRlXCIgOiAoKF9hID0gdmFsdWVzLmZpbmQoY29uZiA9PiBjb25mLnBvc2l0aW9uKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvc2l0aW9uKSB8fCBcImZpeGVkXCIsXG4gICAgICAgICAgICBwYXJlbnQ6ICgoX2IgPSB2YWx1ZXMuZmluZChjb25mID0+IGNvbmYucGFyZW50KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcmVudCkgfHwgbnVsbCxcbiAgICAgICAgICAgIHRvb2x0aXBTcGFjZTogKChfYyA9IHZhbHVlcy5maW5kKGNvbmYgPT4gY29uZi50b29sdGlwU3BhY2UpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9vbHRpcFNwYWNlKSB8fCB3aW5kb3dTcGFjZSxcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jb25zdCBrbm93bkhlaWdodCA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuY29uc3QgdG9vbHRpcFBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmFib3ZlID0gW107XG4gICAgICAgIHRoaXMuaW5WaWV3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYWRlQWJzb2x1dGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYXN0VHJhbnNhY3Rpb24gPSAwO1xuICAgICAgICB0aGlzLm1lYXN1cmVUaW1lb3V0ID0gLTE7XG4gICAgICAgIGxldCBjb25maWcgPSB2aWV3LnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gY29uZmlnLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLnBhcmVudCA9IGNvbmZpZy5wYXJlbnQ7XG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IHZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZE1lYXN1cmUuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMud3JpdGVNZWFzdXJlLmJpbmQodGhpcyksIGtleTogdGhpcyB9O1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09IFwiZnVuY3Rpb25cIiA/IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB0aGlzLm1lYXN1cmVTb29uKCkpIDogbnVsbDtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbmV3IFRvb2x0aXBWaWV3TWFuYWdlcih2aWV3LCBzaG93VG9vbHRpcCwgKHQsIHApID0+IHRoaXMuY3JlYXRlVG9vbHRpcCh0LCBwKSwgdCA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcilcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZSh0LmRvbSk7XG4gICAgICAgICAgICB0LmRvbS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWJvdmUgPSB0aGlzLm1hbmFnZXIudG9vbHRpcHMubWFwKHQgPT4gISF0LmFib3ZlKTtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlciA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIgPyBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IHRoaXMubGFzdFRyYW5zYWN0aW9uIC0gNTAgJiZcbiAgICAgICAgICAgICAgICBlbnRyaWVzLmxlbmd0aCA+IDAgJiYgZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvIDwgMSlcbiAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVTb29uKCk7XG4gICAgICAgIH0sIHsgdGhyZXNob2xkOiBbMV0gfSkgOiBudWxsO1xuICAgICAgICB0aGlzLm9ic2VydmVJbnRlcnNlY3Rpb24oKTtcbiAgICAgICAgdmlldy53aW4uYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm1lYXN1cmVTb29uID0gdGhpcy5tZWFzdXJlU29vbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICB9XG4gICAgY3JlYXRlQ29udGFpbmVyKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy52aWV3LnRoZW1lQ2xhc3NlcztcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy52aWV3LmRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvYnNlcnZlSW50ZXJzZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0b29sdGlwIG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKHRvb2x0aXAuZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMubWVhc3VyZVRpbWVvdXQgPCAwKVxuICAgICAgICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZVRpbWVvdXQgPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSB0aGlzLm1hbmFnZXIudXBkYXRlKHVwZGF0ZSwgdGhpcy5hYm92ZSk7XG4gICAgICAgIGlmICh1cGRhdGVkKVxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlSW50ZXJzZWN0aW9uKCk7XG4gICAgICAgIGxldCBzaG91bGRNZWFzdXJlID0gdXBkYXRlZCB8fCB1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkO1xuICAgICAgICBsZXQgbmV3Q29uZmlnID0gdXBkYXRlLnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpO1xuICAgICAgICBpZiAobmV3Q29uZmlnLnBvc2l0aW9uICE9IHRoaXMucG9zaXRpb24gJiYgIXRoaXMubWFkZUFic29sdXRlKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gbmV3Q29uZmlnLnBvc2l0aW9uO1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHQuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgICAgIHNob3VsZE1lYXN1cmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDb25maWcucGFyZW50ICE9IHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG5ld0NvbmZpZy5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHQuZG9tKTtcbiAgICAgICAgICAgIHNob3VsZE1lYXN1cmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMudmlldy50aGVtZUNsYXNzZXMgIT0gdGhpcy5jbGFzc2VzKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzZXMgPSB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRNZWFzdXJlKVxuICAgICAgICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICB9XG4gICAgY3JlYXRlVG9vbHRpcCh0b29sdGlwLCBwcmV2KSB7XG4gICAgICAgIGxldCB0b29sdGlwVmlldyA9IHRvb2x0aXAuY3JlYXRlKHRoaXMudmlldyk7XG4gICAgICAgIGxldCBiZWZvcmUgPSBwcmV2ID8gcHJldi5kb20gOiBudWxsO1xuICAgICAgICB0b29sdGlwVmlldy5kb20uY2xhc3NMaXN0LmFkZChcImNtLXRvb2x0aXBcIik7XG4gICAgICAgIGlmICh0b29sdGlwLmFycm93ICYmICF0b29sdGlwVmlldy5kb20ucXVlcnlTZWxlY3RvcihcIi5jbS10b29sdGlwID4gLmNtLXRvb2x0aXAtYXJyb3dcIikpIHtcbiAgICAgICAgICAgIGxldCBhcnJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBhcnJvdy5jbGFzc05hbWUgPSBcImNtLXRvb2x0aXAtYXJyb3dcIjtcbiAgICAgICAgICAgIHRvb2x0aXBWaWV3LmRvbS5hcHBlbmRDaGlsZChhcnJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdG9vbHRpcFZpZXcuZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgIHRvb2x0aXBWaWV3LmRvbS5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICAgICAgdGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKHRvb2x0aXBWaWV3LmRvbSwgYmVmb3JlKTtcbiAgICAgICAgaWYgKHRvb2x0aXBWaWV3Lm1vdW50KVxuICAgICAgICAgICAgdG9vbHRpcFZpZXcubW91bnQodGhpcy52aWV3KTtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodG9vbHRpcFZpZXcuZG9tKTtcbiAgICAgICAgcmV0dXJuIHRvb2x0aXBWaWV3O1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy52aWV3Lndpbi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMubWVhc3VyZVNvb24pO1xuICAgICAgICBmb3IgKGxldCB0b29sdGlwVmlldyBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKSB7XG4gICAgICAgICAgICB0b29sdGlwVmlldy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAoX2EgPSB0b29sdGlwVmlldy5kZXN0cm95KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0b29sdGlwVmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlKCk7XG4gICAgICAgIChfYiA9IHRoaXMucmVzaXplT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XG4gICAgICAgIChfYyA9IHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kaXNjb25uZWN0KCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1lYXN1cmVUaW1lb3V0KTtcbiAgICB9XG4gICAgcmVhZE1lYXN1cmUoKSB7XG4gICAgICAgIGxldCBzY2FsZVggPSAxLCBzY2FsZVkgPSAxLCBtYWtlQWJzb2x1dGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gXCJmaXhlZFwiICYmIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyBkb20gfSA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbMF07XG4gICAgICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbykge1xuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggc2V0cyB0aGUgZWxlbWVudCdzIGBvZmZzZXRQYXJlbnRgIHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybWVkIGVsZW1lbnQgd2hlbiBhIHRyYW5zZm9ybSBpbnRlcmZlcmVzIHdpdGggZml4ZWRcbiAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbmluZy5cbiAgICAgICAgICAgICAgICBtYWtlQWJzb2x1dGUgPSBkb20ub2Zmc2V0UGFyZW50ICE9IHRoaXMuY29udGFpbmVyLm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5zdHlsZS50b3AgPT0gT3V0c2lkZSAmJiBkb20uc3R5bGUubGVmdCA9PSBcIjBweFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gT24gb3RoZXIgYnJvd3NlcnMsIHdlIGhhdmUgdG8gYXdrd2FyZGx5IHRyeSBhbmQgdXNlIG90aGVyXG4gICAgICAgICAgICAgICAgLy8gaW5mb3JtYXRpb24gdG8gZGV0ZWN0IGEgdHJhbnNmb3JtLlxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIG1ha2VBYnNvbHV0ZSA9IE1hdGguYWJzKHJlY3QudG9wICsgMTAwMDApID4gMSB8fCBNYXRoLmFicyhyZWN0LmxlZnQpID4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWFrZUFic29sdXRlIHx8IHRoaXMucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHRoaXMucGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlWCA9IHJlY3Qud2lkdGggLyB0aGlzLnBhcmVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVZID0gcmVjdC5oZWlnaHQgLyB0aGlzLnBhcmVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKHsgc2NhbGVYLCBzY2FsZVkgfSA9IHRoaXMudmlldy52aWV3U3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB2aXNpYmxlID0gdGhpcy52aWV3LnNjcm9sbERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbWFyZ2lucyA9IGdldFNjcm9sbE1hcmdpbnModGhpcy52aWV3KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB2aXNpYmxlLmxlZnQgKyBtYXJnaW5zLmxlZnQsIHRvcDogdmlzaWJsZS50b3AgKyBtYXJnaW5zLnRvcCxcbiAgICAgICAgICAgICAgICByaWdodDogdmlzaWJsZS5yaWdodCAtIG1hcmdpbnMucmlnaHQsIGJvdHRvbTogdmlzaWJsZS5ib3R0b20gLSBtYXJnaW5zLmJvdHRvbVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQgPyB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHRoaXMudmlldy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBwb3M6IHRoaXMubWFuYWdlci50b29sdGlwcy5tYXAoKHQsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdHYgPSB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiB0di5nZXRDb29yZHMgPyB0di5nZXRDb29yZHModC5wb3MpIDogdGhpcy52aWV3LmNvb3Jkc0F0UG9zKHQucG9zKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc2l6ZTogdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cy5tYXAoKHsgZG9tIH0pID0+IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSksXG4gICAgICAgICAgICBzcGFjZTogdGhpcy52aWV3LnN0YXRlLmZhY2V0KHRvb2x0aXBDb25maWcpLnRvb2x0aXBTcGFjZSh0aGlzLnZpZXcpLFxuICAgICAgICAgICAgc2NhbGVYLCBzY2FsZVksIG1ha2VBYnNvbHV0ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICB3cml0ZU1lYXN1cmUobWVhc3VyZWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAobWVhc3VyZWQubWFrZUFic29sdXRlKSB7XG4gICAgICAgICAgICB0aGlzLm1hZGVBYnNvbHV0ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICAgICAgICAgIHQuZG9tLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHZpc2libGUsIHNwYWNlLCBzY2FsZVgsIHNjYWxlWSB9ID0gbWVhc3VyZWQ7XG4gICAgICAgIGxldCBvdGhlcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0b29sdGlwID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBzW2ldLCB0VmlldyA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbaV0sIHsgZG9tIH0gPSB0VmlldztcbiAgICAgICAgICAgIGxldCBwb3MgPSBtZWFzdXJlZC5wb3NbaV0sIHNpemUgPSBtZWFzdXJlZC5zaXplW2ldO1xuICAgICAgICAgICAgLy8gSGlkZSB0b29sdGlwcyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBlZGl0b3IuXG4gICAgICAgICAgICBpZiAoIXBvcyB8fCB0b29sdGlwLmNsaXAgIT09IGZhbHNlICYmIChwb3MuYm90dG9tIDw9IE1hdGgubWF4KHZpc2libGUudG9wLCBzcGFjZS50b3ApIHx8XG4gICAgICAgICAgICAgICAgcG9zLnRvcCA+PSBNYXRoLm1pbih2aXNpYmxlLmJvdHRvbSwgc3BhY2UuYm90dG9tKSB8fFxuICAgICAgICAgICAgICAgIHBvcy5yaWdodCA8IE1hdGgubWF4KHZpc2libGUubGVmdCwgc3BhY2UubGVmdCkgLSAuMSB8fFxuICAgICAgICAgICAgICAgIHBvcy5sZWZ0ID4gTWF0aC5taW4odmlzaWJsZS5yaWdodCwgc3BhY2UucmlnaHQpICsgLjEpKSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9IE91dHNpZGU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYXJyb3cgPSB0b29sdGlwLmFycm93ID8gdFZpZXcuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcC1hcnJvd1wiKSA6IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJyb3dIZWlnaHQgPSBhcnJvdyA/IDcgLyogQXJyb3cuU2l6ZSAqLyA6IDA7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBzaXplLnJpZ2h0IC0gc2l6ZS5sZWZ0LCBoZWlnaHQgPSAoX2EgPSBrbm93bkhlaWdodC5nZXQodFZpZXcpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzaXplLmJvdHRvbSAtIHNpemUudG9wO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHRWaWV3Lm9mZnNldCB8fCBub09mZnNldCwgbHRyID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gc2l6ZS53aWR0aCA+IHNwYWNlLnJpZ2h0IC0gc3BhY2UubGVmdFxuICAgICAgICAgICAgICAgID8gKGx0ciA/IHNwYWNlLmxlZnQgOiBzcGFjZS5yaWdodCAtIHNpemUud2lkdGgpXG4gICAgICAgICAgICAgICAgOiBsdHIgPyBNYXRoLm1heChzcGFjZS5sZWZ0LCBNYXRoLm1pbihwb3MubGVmdCAtIChhcnJvdyA/IDE0IC8qIEFycm93Lk9mZnNldCAqLyA6IDApICsgb2Zmc2V0LngsIHNwYWNlLnJpZ2h0IC0gd2lkdGgpKVxuICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKE1hdGgubWF4KHNwYWNlLmxlZnQsIHBvcy5sZWZ0IC0gd2lkdGggKyAoYXJyb3cgPyAxNCAvKiBBcnJvdy5PZmZzZXQgKi8gOiAwKSAtIG9mZnNldC54KSwgc3BhY2UucmlnaHQgLSB3aWR0aCk7XG4gICAgICAgICAgICBsZXQgYWJvdmUgPSB0aGlzLmFib3ZlW2ldO1xuICAgICAgICAgICAgaWYgKCF0b29sdGlwLnN0cmljdFNpZGUgJiYgKGFib3ZlXG4gICAgICAgICAgICAgICAgPyBwb3MudG9wIC0gaGVpZ2h0IC0gYXJyb3dIZWlnaHQgLSBvZmZzZXQueSA8IHNwYWNlLnRvcFxuICAgICAgICAgICAgICAgIDogcG9zLmJvdHRvbSArIGhlaWdodCArIGFycm93SGVpZ2h0ICsgb2Zmc2V0LnkgPiBzcGFjZS5ib3R0b20pICYmXG4gICAgICAgICAgICAgICAgYWJvdmUgPT0gKHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20gPiBwb3MudG9wIC0gc3BhY2UudG9wKSlcbiAgICAgICAgICAgICAgICBhYm92ZSA9IHRoaXMuYWJvdmVbaV0gPSAhYWJvdmU7XG4gICAgICAgICAgICBsZXQgc3BhY2VWZXJ0ID0gKGFib3ZlID8gcG9zLnRvcCAtIHNwYWNlLnRvcCA6IHNwYWNlLmJvdHRvbSAtIHBvcy5ib3R0b20pIC0gYXJyb3dIZWlnaHQ7XG4gICAgICAgICAgICBpZiAoc3BhY2VWZXJ0IDwgaGVpZ2h0ICYmIHRWaWV3LnJlc2l6ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2VWZXJ0IDwgdGhpcy52aWV3LmRlZmF1bHRMaW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga25vd25IZWlnaHQuc2V0KHRWaWV3LCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGRvbS5zdHlsZS5oZWlnaHQgPSAoaGVpZ2h0ID0gc3BhY2VWZXJ0KSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRvbS5zdHlsZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3AgPSBhYm92ZSA/IHBvcy50b3AgLSBoZWlnaHQgLSBhcnJvd0hlaWdodCAtIG9mZnNldC55IDogcG9zLmJvdHRvbSArIGFycm93SGVpZ2h0ICsgb2Zmc2V0Lnk7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgICAgICAgICBpZiAodFZpZXcub3ZlcmxhcCAhPT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG90aGVycylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIubGVmdCA8IHJpZ2h0ICYmIHIucmlnaHQgPiBsZWZ0ICYmIHIudG9wIDwgdG9wICsgaGVpZ2h0ICYmIHIuYm90dG9tID4gdG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gYWJvdmUgPyByLnRvcCAtIGhlaWdodCAtIDIgLSBhcnJvd0hlaWdodCA6IHIuYm90dG9tICsgYXJyb3dIZWlnaHQgKyAyO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgZG9tLnN0eWxlLnRvcCA9ICh0b3AgLSBtZWFzdXJlZC5wYXJlbnQudG9wKSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBzZXRMZWZ0U3R5bGUoZG9tLCAobGVmdCAtIG1lYXN1cmVkLnBhcmVudC5sZWZ0KSAvIHNjYWxlWCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUudG9wID0gdG9wIC8gc2NhbGVZICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHNldExlZnRTdHlsZShkb20sIGxlZnQgLyBzY2FsZVgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFycm93KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFycm93TGVmdCA9IHBvcy5sZWZ0ICsgKGx0ciA/IG9mZnNldC54IDogLW9mZnNldC54KSAtIChsZWZ0ICsgMTQgLyogQXJyb3cuT2Zmc2V0ICovIC0gNyAvKiBBcnJvdy5TaXplICovKTtcbiAgICAgICAgICAgICAgICBhcnJvdy5zdHlsZS5sZWZ0ID0gYXJyb3dMZWZ0IC8gc2NhbGVYICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRWaWV3Lm92ZXJsYXAgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgb3RoZXJzLnB1c2goeyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b206IHRvcCArIGhlaWdodCB9KTtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QudG9nZ2xlKFwiY20tdG9vbHRpcC1hYm92ZVwiLCBhYm92ZSk7XG4gICAgICAgICAgICBkb20uY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYmVsb3dcIiwgIWFib3ZlKTtcbiAgICAgICAgICAgIGlmICh0Vmlldy5wb3NpdGlvbmVkKVxuICAgICAgICAgICAgICAgIHRWaWV3LnBvc2l0aW9uZWQobWVhc3VyZWQuc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heWJlTWVhc3VyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFuYWdlci50b29sdGlwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5WaWV3KVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5WaWV3ICE9IHRoaXMudmlldy5pblZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluVmlldyA9IHRoaXMudmlldy5pblZpZXc7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdHYgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgICAgICAgICAgICAgIHR2LmRvbS5zdHlsZS50b3AgPSBPdXRzaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwge1xuICAgIGV2ZW50T2JzZXJ2ZXJzOiB7XG4gICAgICAgIHNjcm9sbCgpIHsgdGhpcy5tYXliZU1lYXN1cmUoKTsgfVxuICAgIH1cbn0pO1xuZnVuY3Rpb24gc2V0TGVmdFN0eWxlKGVsdCwgdmFsdWUpIHtcbiAgICBsZXQgY3VycmVudCA9IHBhcnNlSW50KGVsdC5zdHlsZS5sZWZ0LCAxMCk7XG4gICAgaWYgKGlzTmFOKGN1cnJlbnQpIHx8IE1hdGguYWJzKHZhbHVlIC0gY3VycmVudCkgPiAxKVxuICAgICAgICBlbHQuc3R5bGUubGVmdCA9IHZhbHVlICsgXCJweFwiO1xufVxuY29uc3QgYmFzZVRoZW1lID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgekluZGV4OiA1MDAsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwXCI6IHtcbiAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjYmJiXCIsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS10b29sdGlwLXNlY3Rpb246bm90KDpmaXJzdC1jaGlsZClcIjoge1xuICAgICAgICBib3JkZXJUb3A6IFwiMXB4IHNvbGlkICNiYmJcIixcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRvb2x0aXBcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzMzMzMzOFwiLFxuICAgICAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gICAgfSxcbiAgICBcIi5jbS10b29sdGlwLWFycm93XCI6IHtcbiAgICAgICAgaGVpZ2h0OiBgJHs3IC8qIEFycm93LlNpemUgKi99cHhgLFxuICAgICAgICB3aWR0aDogYCR7NyAvKiBBcnJvdy5TaXplICovICogMn1weGAsXG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHpJbmRleDogLTEsXG4gICAgICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgICAgICBcIiY6YmVmb3JlLCAmOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiJydcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGJvcmRlckxlZnQ6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICAgICAgICBib3JkZXJSaWdodDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkIHRyYW5zcGFyZW50YCxcbiAgICAgICAgfSxcbiAgICAgICAgXCIuY20tdG9vbHRpcC1hYm92ZSAmXCI6IHtcbiAgICAgICAgICAgIGJvdHRvbTogYC0kezcgLyogQXJyb3cuU2l6ZSAqL31weGAsXG4gICAgICAgICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJUb3A6IGAkezcgLyogQXJyb3cuU2l6ZSAqL31weCBzb2xpZCAjYmJiYCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlclRvcDogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNmNWY1ZjVgLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogXCIxcHhcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIi5jbS10b29sdGlwLWJlbG93ICZcIjoge1xuICAgICAgICAgICAgdG9wOiBgLSR7NyAvKiBBcnJvdy5TaXplICovfXB4YCxcbiAgICAgICAgICAgIFwiJjpiZWZvcmVcIjoge1xuICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYCR7NyAvKiBBcnJvdy5TaXplICovfXB4IHNvbGlkICNiYmJgLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiJjphZnRlclwiOiB7XG4gICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBgJHs3IC8qIEFycm93LlNpemUgKi99cHggc29saWQgI2Y1ZjVmNWAsXG4gICAgICAgICAgICAgICAgdG9wOiBcIjFweFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93XCI6IHtcbiAgICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgICAgICBib3JkZXJUb3BDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCIjMzMzMzM4XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgICAgIGJvcmRlclRvcENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICAgICAgICBib3JkZXJCb3R0b21Db2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNvbnN0IG5vT2Zmc2V0ID0geyB4OiAwLCB5OiAwIH07XG4vKipcbkZhY2V0IHRvIHdoaWNoIGFuIGV4dGVuc2lvbiBjYW4gYWRkIGEgdmFsdWUgdG8gc2hvdyBhIHRvb2x0aXAuXG4qL1xuY29uc3Qgc2hvd1Rvb2x0aXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBlbmFibGVzOiBbdG9vbHRpcFBsdWdpbiwgYmFzZVRoZW1lXVxufSk7XG5jb25zdCBzaG93SG92ZXJUb29sdGlwID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogaW5wdXRzID0+IGlucHV0cy5yZWR1Y2UoKGEsIGkpID0+IGEuY29uY2F0KGkpLCBbXSlcbn0pO1xuY2xhc3MgSG92ZXJUb29sdGlwSG9zdCB7XG4gICAgLy8gTmVlZHMgdG8gYmUgc3RhdGljIHNvIHRoYXQgaG9zdCB0b29sdGlwIGluc3RhbmNlcyBhbHdheXMgbWF0Y2hcbiAgICBzdGF0aWMgY3JlYXRlKHZpZXcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIb3ZlclRvb2x0aXBIb3N0KHZpZXcpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS10b29sdGlwLWhvdmVyXCIpO1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBuZXcgVG9vbHRpcFZpZXdNYW5hZ2VyKHZpZXcsIHNob3dIb3ZlclRvb2x0aXAsICh0LCBwKSA9PiB0aGlzLmNyZWF0ZUhvc3RlZFZpZXcodCwgcCksIHQgPT4gdC5kb20ucmVtb3ZlKCkpO1xuICAgIH1cbiAgICBjcmVhdGVIb3N0ZWRWaWV3KHRvb2x0aXAsIHByZXYpIHtcbiAgICAgICAgbGV0IGhvc3RlZFZpZXcgPSB0b29sdGlwLmNyZWF0ZSh0aGlzLnZpZXcpO1xuICAgICAgICBob3N0ZWRWaWV3LmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tdG9vbHRpcC1zZWN0aW9uXCIpO1xuICAgICAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUoaG9zdGVkVmlldy5kb20sIHByZXYgPyBwcmV2LmRvbS5uZXh0U2libGluZyA6IHRoaXMuZG9tLmZpcnN0Q2hpbGQpO1xuICAgICAgICBpZiAodGhpcy5tb3VudGVkICYmIGhvc3RlZFZpZXcubW91bnQpXG4gICAgICAgICAgICBob3N0ZWRWaWV3Lm1vdW50KHRoaXMudmlldyk7XG4gICAgICAgIHJldHVybiBob3N0ZWRWaWV3O1xuICAgIH1cbiAgICBtb3VudCh2aWV3KSB7XG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcubW91bnQpXG4gICAgICAgICAgICAgICAgaG9zdGVkVmlldy5tb3VudCh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwb3NpdGlvbmVkKHNwYWNlKSB7XG4gICAgICAgIGZvciAobGV0IGhvc3RlZFZpZXcgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cykge1xuICAgICAgICAgICAgaWYgKGhvc3RlZFZpZXcucG9zaXRpb25lZClcbiAgICAgICAgICAgICAgICBob3N0ZWRWaWV3LnBvc2l0aW9uZWQoc3BhY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnVwZGF0ZSh1cGRhdGUpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGZvciAobGV0IHQgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgICAgIChfYSA9IHQuZGVzdHJveSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodCk7XG4gICAgfVxuICAgIHBhc3NQcm9wKG5hbWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGxldCB2aWV3IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpIHtcbiAgICAgICAgICAgIGxldCBnaXZlbiA9IHZpZXdbbmFtZV07XG4gICAgICAgICAgICBpZiAoZ2l2ZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdpdmVuO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSBnaXZlbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGdldCBvZmZzZXQoKSB7IHJldHVybiB0aGlzLnBhc3NQcm9wKFwib2Zmc2V0XCIpOyB9XG4gICAgZ2V0IGdldENvb3JkcygpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJnZXRDb29yZHNcIik7IH1cbiAgICBnZXQgb3ZlcmxhcCgpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJvdmVybGFwXCIpOyB9XG4gICAgZ2V0IHJlc2l6ZSgpIHsgcmV0dXJuIHRoaXMucGFzc1Byb3AoXCJyZXNpemVcIik7IH1cbn1cbmNvbnN0IHNob3dIb3ZlclRvb2x0aXBIb3N0ID0gLypAX19QVVJFX18qL3Nob3dUb29sdGlwLmNvbXB1dGUoW3Nob3dIb3ZlclRvb2x0aXBdLCBzdGF0ZSA9PiB7XG4gICAgbGV0IHRvb2x0aXBzID0gc3RhdGUuZmFjZXQoc2hvd0hvdmVyVG9vbHRpcCk7XG4gICAgaWYgKHRvb2x0aXBzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zOiBNYXRoLm1pbiguLi50b29sdGlwcy5tYXAodCA9PiB0LnBvcykpLFxuICAgICAgICBlbmQ6IE1hdGgubWF4KC4uLnRvb2x0aXBzLm1hcCh0ID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdC5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHQucG9zOyB9KSksXG4gICAgICAgIGNyZWF0ZTogSG92ZXJUb29sdGlwSG9zdC5jcmVhdGUsXG4gICAgICAgIGFib3ZlOiB0b29sdGlwc1swXS5hYm92ZSxcbiAgICAgICAgYXJyb3c6IHRvb2x0aXBzLnNvbWUodCA9PiB0LmFycm93KSxcbiAgICB9O1xufSk7XG5jbGFzcyBIb3ZlclBsdWdpbiB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc291cmNlLCBmaWVsZCwgc2V0SG92ZXIsIGhvdmVyVGltZSkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLnNldEhvdmVyID0gc2V0SG92ZXI7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lID0gaG92ZXJUaW1lO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE1vdmUgPSB7IHg6IDAsIHk6IDAsIHRhcmdldDogdmlldy5kb20sIHRpbWU6IDAgfTtcbiAgICAgICAgdGhpcy5jaGVja0hvdmVyID0gdGhpcy5jaGVja0hvdmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMubW91c2VsZWF2ZSA9IHRoaXMubW91c2VsZWF2ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLm1vdXNlbW92ZSA9IHRoaXMubW91c2Vtb3ZlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnJlc3RhcnRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXJ0SG92ZXIoKSwgMjApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5maWVsZCk7XG4gICAgfVxuICAgIGNoZWNrSG92ZXIoKSB7XG4gICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBob3ZlcmVkID0gRGF0ZS5ub3coKSAtIHRoaXMubGFzdE1vdmUudGltZTtcbiAgICAgICAgaWYgKGhvdmVyZWQgPCB0aGlzLmhvdmVyVGltZSlcbiAgICAgICAgICAgIHRoaXMuaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmNoZWNrSG92ZXIsIHRoaXMuaG92ZXJUaW1lIC0gaG92ZXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc3RhcnRIb3ZlcigpO1xuICAgIH1cbiAgICBzdGFydEhvdmVyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXN0YXJ0VGltZW91dCk7XG4gICAgICAgIGxldCB7IHZpZXcsIGxhc3RNb3ZlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0KGxhc3RNb3ZlLnRhcmdldCk7XG4gICAgICAgIGlmICghZGVzYylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHBvcywgc2lkZSA9IDE7XG4gICAgICAgIGlmIChkZXNjIGluc3RhbmNlb2YgV2lkZ2V0Vmlldykge1xuICAgICAgICAgICAgcG9zID0gZGVzYy5wb3NBdFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gdmlldy5wb3NBdENvb3JkcyhsYXN0TW92ZSk7XG4gICAgICAgICAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHBvc0Nvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgICAgIGlmICghcG9zQ29vcmRzIHx8XG4gICAgICAgICAgICAgICAgbGFzdE1vdmUueSA8IHBvc0Nvb3Jkcy50b3AgfHwgbGFzdE1vdmUueSA+IHBvc0Nvb3Jkcy5ib3R0b20gfHxcbiAgICAgICAgICAgICAgICBsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgLSB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCB8fFxuICAgICAgICAgICAgICAgIGxhc3RNb3ZlLnggPiBwb3NDb29yZHMucmlnaHQgKyB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgYmlkaSA9IHZpZXcuYmlkaVNwYW5zKHZpZXcuc3RhdGUuZG9jLmxpbmVBdChwb3MpKS5maW5kKHMgPT4gcy5mcm9tIDw9IHBvcyAmJiBzLnRvID49IHBvcyk7XG4gICAgICAgICAgICBsZXQgcnRsID0gYmlkaSAmJiBiaWRpLmRpciA9PSBEaXJlY3Rpb24uUlRMID8gLTEgOiAxO1xuICAgICAgICAgICAgc2lkZSA9IChsYXN0TW92ZS54IDwgcG9zQ29vcmRzLmxlZnQgPyAtcnRsIDogcnRsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuc291cmNlKHZpZXcsIHBvcywgc2lkZSk7XG4gICAgICAgIGlmIChvcGVuID09PSBudWxsIHx8IG9wZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZW4udGhlbikge1xuICAgICAgICAgICAgbGV0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmcgPSB7IHBvcyB9O1xuICAgICAgICAgICAgb3Blbi50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZyA9PSBwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgIShBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgIXJlc3VsdC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoQXJyYXkuaXNBcnJheShyZXN1bHQpID8gcmVzdWx0IDogW3Jlc3VsdF0pIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGUgPT4gbG9nRXhjZXB0aW9uKHZpZXcuc3RhdGUsIGUsIFwiaG92ZXIgdG9vbHRpcFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlbiAmJiAhKEFycmF5LmlzQXJyYXkob3BlbikgJiYgIW9wZW4ubGVuZ3RoKSkge1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoQXJyYXkuaXNBcnJheShvcGVuKSA/IG9wZW4gOiBbb3Blbl0pIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0b29sdGlwKCkge1xuICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy52aWV3LnBsdWdpbih0b29sdGlwUGx1Z2luKTtcbiAgICAgICAgbGV0IGluZGV4ID0gcGx1Z2luID8gcGx1Z2luLm1hbmFnZXIudG9vbHRpcHMuZmluZEluZGV4KHQgPT4gdC5jcmVhdGUgPT0gSG92ZXJUb29sdGlwSG9zdC5jcmVhdGUpIDogLTE7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gcGx1Z2luLm1hbmFnZXIudG9vbHRpcFZpZXdzW2luZGV4XSA6IG51bGw7XG4gICAgfVxuICAgIG1vdXNlbW92ZShldmVudCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmxhc3RNb3ZlID0geyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZLCB0YXJnZXQ6IGV2ZW50LnRhcmdldCwgdGltZTogRGF0ZS5ub3coKSB9O1xuICAgICAgICBpZiAodGhpcy5ob3ZlclRpbWVvdXQgPCAwKVxuICAgICAgICAgICAgdGhpcy5ob3ZlclRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuY2hlY2tIb3ZlciwgdGhpcy5ob3ZlclRpbWUpO1xuICAgICAgICBsZXQgeyBhY3RpdmUsIHRvb2x0aXAgfSA9IHRoaXM7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoICYmIHRvb2x0aXAgJiYgIWlzSW5Ub29sdGlwKHRvb2x0aXAuZG9tLCBldmVudCkgfHwgdGhpcy5wZW5kaW5nKSB7XG4gICAgICAgICAgICBsZXQgeyBwb3MgfSA9IGFjdGl2ZVswXSB8fCB0aGlzLnBlbmRpbmcsIGVuZCA9IChfYiA9IChfYSA9IGFjdGl2ZVswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcG9zO1xuICAgICAgICAgICAgaWYgKChwb3MgPT0gZW5kID8gdGhpcy52aWV3LnBvc0F0Q29vcmRzKHRoaXMubGFzdE1vdmUpICE9IHBvc1xuICAgICAgICAgICAgICAgIDogIWlzT3ZlclJhbmdlKHRoaXMudmlldywgcG9zLCBlbmQsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoW10pIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91c2VsZWF2ZShldmVudCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ob3ZlclRpbWVvdXQpO1xuICAgICAgICB0aGlzLmhvdmVyVGltZW91dCA9IC0xO1xuICAgICAgICBsZXQgeyBhY3RpdmUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgeyB0b29sdGlwIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IGluVG9vbHRpcCA9IHRvb2x0aXAgJiYgdG9vbHRpcC5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIWluVG9vbHRpcClcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB0aGlzLnNldEhvdmVyLm9mKFtdKSB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLndhdGNoVG9vbHRpcExlYXZlKHRvb2x0aXAuZG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3YXRjaFRvb2x0aXBMZWF2ZSh0b29sdGlwKSB7XG4gICAgICAgIGxldCB3YXRjaCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdG9vbHRpcC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB3YXRjaCk7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmUubGVuZ3RoICYmICF0aGlzLnZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHRoaXMuc2V0SG92ZXIub2YoW10pIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0b29sdGlwLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHdhdGNoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLm1vdXNlbGVhdmUpO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3VzZW1vdmUpO1xuICAgIH1cbn1cbmNvbnN0IHRvb2x0aXBNYXJnaW4gPSA0O1xuZnVuY3Rpb24gaXNJblRvb2x0aXAodG9vbHRpcCwgZXZlbnQpIHtcbiAgICBsZXQgeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSA9IHRvb2x0aXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGFycm93O1xuICAgIGlmIChhcnJvdyA9IHRvb2x0aXAucXVlcnlTZWxlY3RvcihcIi5jbS10b29sdGlwLWFycm93XCIpKSB7XG4gICAgICAgIGxldCBhcnJvd1JlY3QgPSBhcnJvdy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdG9wID0gTWF0aC5taW4oYXJyb3dSZWN0LnRvcCwgdG9wKTtcbiAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoYXJyb3dSZWN0LmJvdHRvbSwgYm90dG9tKTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50LmNsaWVudFggPj0gbGVmdCAtIHRvb2x0aXBNYXJnaW4gJiYgZXZlbnQuY2xpZW50WCA8PSByaWdodCArIHRvb2x0aXBNYXJnaW4gJiZcbiAgICAgICAgZXZlbnQuY2xpZW50WSA+PSB0b3AgLSB0b29sdGlwTWFyZ2luICYmIGV2ZW50LmNsaWVudFkgPD0gYm90dG9tICsgdG9vbHRpcE1hcmdpbjtcbn1cbmZ1bmN0aW9uIGlzT3ZlclJhbmdlKHZpZXcsIGZyb20sIHRvLCB4LCB5LCBtYXJnaW4pIHtcbiAgICBsZXQgcmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBkb2NCb3R0b20gPSB2aWV3LmRvY3VtZW50VG9wICsgdmlldy5kb2N1bWVudFBhZGRpbmcudG9wICsgdmlldy5jb250ZW50SGVpZ2h0O1xuICAgIGlmIChyZWN0LmxlZnQgPiB4IHx8IHJlY3QucmlnaHQgPCB4IHx8IHJlY3QudG9wID4geSB8fCBNYXRoLm1pbihyZWN0LmJvdHRvbSwgZG9jQm90dG9tKSA8IHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHgsIHkgfSwgZmFsc2UpO1xuICAgIHJldHVybiBwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG87XG59XG4vKipcblNldCB1cCBhIGhvdmVyIHRvb2x0aXAsIHdoaWNoIHNob3dzIHVwIHdoZW4gdGhlIHBvaW50ZXIgaG92ZXJzXG5vdmVyIHJhbmdlcyBvZiB0ZXh0LiBUaGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGhvdmVyc1xub3ZlciB0aGUgZG9jdW1lbnQgdGV4dC4gSXQgc2hvdWxkLCBpZiB0aGVyZSBpcyBhIHRvb2x0aXBcbmFzc29jaWF0ZWQgd2l0aCBwb3NpdGlvbiBgcG9zYCwgcmV0dXJuIHRoZSB0b29sdGlwIGRlc2NyaXB0aW9uXG4oZWl0aGVyIGRpcmVjdGx5IG9yIGluIGEgcHJvbWlzZSkuIFRoZSBgc2lkZWAgYXJndW1lbnQgaW5kaWNhdGVzXG5vbiB3aGljaCBzaWRlIG9mIHRoZSBwb3NpdGlvbiB0aGUgcG9pbnRlciBpc+KAlGl0IHdpbGwgYmUgLTEgaWYgdGhlXG5wb2ludGVyIGlzIGJlZm9yZSB0aGUgcG9zaXRpb24sIDEgaWYgYWZ0ZXIgdGhlIHBvc2l0aW9uLlxuXG5Ob3RlIHRoYXQgYWxsIGhvdmVyIHRvb2x0aXBzIGFyZSBob3N0ZWQgd2l0aGluIGEgc2luZ2xlIHRvb2x0aXBcbmNvbnRhaW5lciBlbGVtZW50LiBUaGlzIGFsbG93cyBtdWx0aXBsZSB0b29sdGlwcyBvdmVyIHRoZSBzYW1lXG5yYW5nZSB0byBiZSBcIm1lcmdlZFwiIHRvZ2V0aGVyIHdpdGhvdXQgb3ZlcmxhcHBpbmcuXG5cblRoZSByZXR1cm4gdmFsdWUgaXMgYSB2YWxpZCBbZWRpdG9yIGV4dGVuc2lvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FeHRlbnNpb24pXG5idXQgYWxzbyBwcm92aWRlcyBhbiBgYWN0aXZlYCBwcm9wZXJ0eSBob2xkaW5nIGEgc3RhdGUgZmllbGQgdGhhdFxuY2FuIGJlIHVzZWQgdG8gcmVhZCB0aGUgY3VycmVudGx5IGFjdGl2ZSB0b29sdGlwcyBwcm9kdWNlZCBieSB0aGlzXG5leHRlbnNpb24uXG4qL1xuZnVuY3Rpb24gaG92ZXJUb29sdGlwKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHNldEhvdmVyID0gU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4gICAgbGV0IGhvdmVyU3RhdGUgPSBTdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgICAgIGNyZWF0ZSgpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgICB1cGRhdGUodmFsdWUsIHRyKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGlkZU9uQ2hhbmdlICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oaWRlT24pXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZmlsdGVyKHYgPT4gIW9wdGlvbnMuaGlkZU9uKHRyLCB2KSk7XG4gICAgICAgICAgICAgICAgaWYgKHRyLmRvY0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0b29sdGlwIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UG9zID0gdHIuY2hhbmdlcy5tYXBQb3ModG9vbHRpcC5wb3MsIC0xLCBNYXBNb2RlLlRyYWNrRGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdQb3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB0b29sdGlwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5LnBvcyA9IG5ld1BvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29weS5lbmQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weS5lbmQgPSB0ci5jaGFuZ2VzLm1hcFBvcyhjb3B5LmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGVkLnB1c2goY29weSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtYXBwZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWZmZWN0LmlzKHNldEhvdmVyKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBlZmZlY3QudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhjbG9zZUhvdmVyVG9vbHRpcEVmZmVjdCkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGU6IGYgPT4gc2hvd0hvdmVyVG9vbHRpcC5mcm9tKGYpXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aXZlOiBob3ZlclN0YXRlLFxuICAgICAgICBleHRlbnNpb246IFtcbiAgICAgICAgICAgIGhvdmVyU3RhdGUsXG4gICAgICAgICAgICBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+IG5ldyBIb3ZlclBsdWdpbih2aWV3LCBzb3VyY2UsIGhvdmVyU3RhdGUsIHNldEhvdmVyLCBvcHRpb25zLmhvdmVyVGltZSB8fCAzMDAgLyogSG92ZXIuVGltZSAqLykpLFxuICAgICAgICAgICAgc2hvd0hvdmVyVG9vbHRpcEhvc3RcbiAgICAgICAgXVxuICAgIH07XG59XG4vKipcbkdldCB0aGUgYWN0aXZlIHRvb2x0aXAgdmlldyBmb3IgYSBnaXZlbiB0b29sdGlwLCBpZiBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gZ2V0VG9vbHRpcCh2aWV3LCB0b29sdGlwKSB7XG4gICAgbGV0IHBsdWdpbiA9IHZpZXcucGx1Z2luKHRvb2x0aXBQbHVnaW4pO1xuICAgIGlmICghcGx1Z2luKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgZm91bmQgPSBwbHVnaW4ubWFuYWdlci50b29sdGlwcy5pbmRleE9mKHRvb2x0aXApO1xuICAgIHJldHVybiBmb3VuZCA8IDAgPyBudWxsIDogcGx1Z2luLm1hbmFnZXIudG9vbHRpcFZpZXdzW2ZvdW5kXTtcbn1cbi8qKlxuUmV0dXJucyB0cnVlIGlmIGFueSBob3ZlciB0b29sdGlwcyBhcmUgY3VycmVudGx5IGFjdGl2ZS5cbiovXG5mdW5jdGlvbiBoYXNIb3ZlclRvb2x0aXBzKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZhY2V0KHNob3dIb3ZlclRvb2x0aXApLnNvbWUoeCA9PiB4KTtcbn1cbmNvbnN0IGNsb3NlSG92ZXJUb29sdGlwRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuLyoqXG5UcmFuc2FjdGlvbiBlZmZlY3QgdGhhdCBjbG9zZXMgYWxsIGhvdmVyIHRvb2x0aXBzLlxuKi9cbmNvbnN0IGNsb3NlSG92ZXJUb29sdGlwcyA9IC8qQF9fUFVSRV9fKi9jbG9zZUhvdmVyVG9vbHRpcEVmZmVjdC5vZihudWxsKTtcbi8qKlxuVGVsbCB0aGUgdG9vbHRpcCBleHRlbnNpb24gdG8gcmVjb21wdXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgYWN0aXZlXG50b29sdGlwcy4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gc29tZXRoaW5nIGhhcHBlbnMgKHN1Y2ggYXMgYVxucmUtcG9zaXRpb25pbmcgb3IgQ1NTIGNoYW5nZSBhZmZlY3RpbmcgdGhlIGVkaXRvcikgdGhhdCBjb3VsZFxuaW52YWxpZGF0ZSB0aGUgZXhpc3RpbmcgdG9vbHRpcCBwb3NpdGlvbnMuXG4qL1xuZnVuY3Rpb24gcmVwb3NpdGlvblRvb2x0aXBzKHZpZXcpIHtcbiAgICBsZXQgcGx1Z2luID0gdmlldy5wbHVnaW4odG9vbHRpcFBsdWdpbik7XG4gICAgaWYgKHBsdWdpbilcbiAgICAgICAgcGx1Z2luLm1heWJlTWVhc3VyZSgpO1xufVxuXG5jb25zdCBwYW5lbENvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICBsZXQgdG9wQ29udGFpbmVyLCBib3R0b21Db250YWluZXI7XG4gICAgICAgIGZvciAobGV0IGMgb2YgY29uZmlncykge1xuICAgICAgICAgICAgdG9wQ29udGFpbmVyID0gdG9wQ29udGFpbmVyIHx8IGMudG9wQ29udGFpbmVyO1xuICAgICAgICAgICAgYm90dG9tQ29udGFpbmVyID0gYm90dG9tQ29udGFpbmVyIHx8IGMuYm90dG9tQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHRvcENvbnRhaW5lciwgYm90dG9tQ29udGFpbmVyIH07XG4gICAgfVxufSk7XG4vKipcbkNvbmZpZ3VyZXMgdGhlIHBhbmVsLW1hbmFnaW5nIGV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBwYW5lbHMoY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbmZpZyA/IFtwYW5lbENvbmZpZy5vZihjb25maWcpXSA6IFtdO1xufVxuLyoqXG5HZXQgdGhlIGFjdGl2ZSBwYW5lbCBjcmVhdGVkIGJ5IHRoZSBnaXZlbiBjb25zdHJ1Y3RvciwgaWYgYW55LlxuVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91IG5lZWQgYWNjZXNzIHRvIHlvdXIgcGFuZWxzJyBET01cbnN0cnVjdHVyZS5cbiovXG5mdW5jdGlvbiBnZXRQYW5lbCh2aWV3LCBwYW5lbCkge1xuICAgIGxldCBwbHVnaW4gPSB2aWV3LnBsdWdpbihwYW5lbFBsdWdpbik7XG4gICAgbGV0IGluZGV4ID0gcGx1Z2luID8gcGx1Z2luLnNwZWNzLmluZGV4T2YocGFuZWwpIDogLTE7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyBwbHVnaW4ucGFuZWxzW2luZGV4XSA6IG51bGw7XG59XG5jb25zdCBwYW5lbFBsdWdpbiA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmlucHV0ID0gdmlldy5zdGF0ZS5mYWNldChzaG93UGFuZWwpO1xuICAgICAgICB0aGlzLnNwZWNzID0gdGhpcy5pbnB1dC5maWx0ZXIocyA9PiBzKTtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSB0aGlzLnNwZWNzLm1hcChzcGVjID0+IHNwZWModmlldykpO1xuICAgICAgICBsZXQgY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQocGFuZWxDb25maWcpO1xuICAgICAgICB0aGlzLnRvcCA9IG5ldyBQYW5lbEdyb3VwKHZpZXcsIHRydWUsIGNvbmYudG9wQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5ib3R0b20gPSBuZXcgUGFuZWxHcm91cCh2aWV3LCBmYWxzZSwgY29uZi5ib3R0b21Db250YWluZXIpO1xuICAgICAgICB0aGlzLnRvcC5zeW5jKHRoaXMucGFuZWxzLmZpbHRlcihwID0+IHAudG9wKSk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmModGhpcy5wYW5lbHMuZmlsdGVyKHAgPT4gIXAudG9wKSk7XG4gICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpIHtcbiAgICAgICAgICAgIHAuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1wYW5lbFwiKTtcbiAgICAgICAgICAgIGlmIChwLm1vdW50KVxuICAgICAgICAgICAgICAgIHAubW91bnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBjb25mID0gdXBkYXRlLnN0YXRlLmZhY2V0KHBhbmVsQ29uZmlnKTtcbiAgICAgICAgaWYgKHRoaXMudG9wLmNvbnRhaW5lciAhPSBjb25mLnRvcENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy50b3Auc3luYyhbXSk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCB0cnVlLCBjb25mLnRvcENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYm90dG9tLmNvbnRhaW5lciAhPSBjb25mLmJvdHRvbUNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5ib3R0b20uc3luYyhbXSk7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbSA9IG5ldyBQYW5lbEdyb3VwKHVwZGF0ZS52aWV3LCBmYWxzZSwgY29uZi5ib3R0b21Db250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9wLnN5bmNDbGFzc2VzKCk7XG4gICAgICAgIHRoaXMuYm90dG9tLnN5bmNDbGFzc2VzKCk7XG4gICAgICAgIGxldCBpbnB1dCA9IHVwZGF0ZS5zdGF0ZS5mYWNldChzaG93UGFuZWwpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgbGV0IHNwZWNzID0gaW5wdXQuZmlsdGVyKHggPT4geCk7XG4gICAgICAgICAgICBsZXQgcGFuZWxzID0gW10sIHRvcCA9IFtdLCBib3R0b20gPSBbXSwgbW91bnQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgICAgICBsZXQga25vd24gPSB0aGlzLnNwZWNzLmluZGV4T2Yoc3BlYyksIHBhbmVsO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZWwgPSBzcGVjKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgbW91bnQucHVzaChwYW5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYW5lbCA9IHRoaXMucGFuZWxzW2tub3duXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhbmVsLnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYW5lbHMucHVzaChwYW5lbCk7XG4gICAgICAgICAgICAgICAgKHBhbmVsLnRvcCA/IHRvcCA6IGJvdHRvbSkucHVzaChwYW5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3M7XG4gICAgICAgICAgICB0aGlzLnBhbmVscyA9IHBhbmVscztcbiAgICAgICAgICAgIHRoaXMudG9wLnN5bmModG9wKTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tLnN5bmMoYm90dG9tKTtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgbW91bnQpIHtcbiAgICAgICAgICAgICAgICBwLmRvbS5jbGFzc0xpc3QuYWRkKFwiY20tcGFuZWxcIik7XG4gICAgICAgICAgICAgICAgaWYgKHAubW91bnQpXG4gICAgICAgICAgICAgICAgICAgIHAubW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wYW5lbHMpXG4gICAgICAgICAgICAgICAgaWYgKHAudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICBwLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudG9wLnN5bmMoW10pO1xuICAgICAgICB0aGlzLmJvdHRvbS5zeW5jKFtdKTtcbiAgICB9XG59LCB7XG4gICAgcHJvdmlkZTogcGx1Z2luID0+IEVkaXRvclZpZXcuc2Nyb2xsTWFyZ2lucy5vZih2aWV3ID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gdmlldy5wbHVnaW4ocGx1Z2luKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHsgdG9wOiB2YWx1ZS50b3Auc2Nyb2xsTWFyZ2luKCksIGJvdHRvbTogdmFsdWUuYm90dG9tLnNjcm9sbE1hcmdpbigpIH07XG4gICAgfSlcbn0pO1xuY2xhc3MgUGFuZWxHcm91cCB7XG4gICAgY29uc3RydWN0b3IodmlldywgdG9wLCBjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGFzc2VzID0gXCJcIjtcbiAgICAgICAgdGhpcy5wYW5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5zeW5jQ2xhc3NlcygpO1xuICAgIH1cbiAgICBzeW5jKHBhbmVscykge1xuICAgICAgICBmb3IgKGxldCBwIG9mIHRoaXMucGFuZWxzKVxuICAgICAgICAgICAgaWYgKHAuZGVzdHJveSAmJiBwYW5lbHMuaW5kZXhPZihwKSA8IDApXG4gICAgICAgICAgICAgICAgcC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMucGFuZWxzID0gcGFuZWxzO1xuICAgICAgICB0aGlzLnN5bmNET00oKTtcbiAgICB9XG4gICAgc3luY0RPTSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFuZWxzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSB0aGlzLnRvcCA/IFwiY20tcGFuZWxzIGNtLXBhbmVscy10b3BcIiA6IFwiY20tcGFuZWxzIGNtLXBhbmVscy1ib3R0b21cIjtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlW3RoaXMudG9wID8gXCJ0b3BcIiA6IFwiYm90dG9tXCJdID0gXCIwXCI7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5jb250YWluZXIgfHwgdGhpcy52aWV3LmRvbTtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy5kb20sIHRoaXMudG9wID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VyRE9NID0gdGhpcy5kb20uZmlyc3RDaGlsZDtcbiAgICAgICAgZm9yIChsZXQgcGFuZWwgb2YgdGhpcy5wYW5lbHMpIHtcbiAgICAgICAgICAgIGlmIChwYW5lbC5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJET00gIT0gcGFuZWwuZG9tKVxuICAgICAgICAgICAgICAgICAgICBjdXJET00gPSBybShjdXJET00pO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IGN1ckRPTS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShwYW5lbC5kb20sIGN1ckRPTSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGN1ckRPTSlcbiAgICAgICAgICAgIGN1ckRPTSA9IHJtKGN1ckRPTSk7XG4gICAgfVxuICAgIHNjcm9sbE1hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRvbSB8fCB0aGlzLmNvbnRhaW5lciA/IDBcbiAgICAgICAgICAgIDogTWF0aC5tYXgoMCwgdGhpcy50b3AgP1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAtIE1hdGgubWF4KDAsIHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSA6XG4gICAgICAgICAgICAgICAgTWF0aC5taW4oaW5uZXJIZWlnaHQsIHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tKSAtIHRoaXMuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCk7XG4gICAgfVxuICAgIHN5bmNDbGFzc2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyIHx8IHRoaXMuY2xhc3NlcyA9PSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2YgdGhpcy5jbGFzc2VzLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgICBmb3IgKGxldCBjbHMgb2YgKHRoaXMuY2xhc3NlcyA9IHRoaXMudmlldy50aGVtZUNsYXNzZXMpLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChjbHMpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJtKG5vZGUpIHtcbiAgICBsZXQgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8qKlxuT3BlbmluZyBhIHBhbmVsIGlzIGRvbmUgYnkgcHJvdmlkaW5nIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yXG50aGUgcGFuZWwgdGhyb3VnaCB0aGlzIGZhY2V0LiAoVGhlIHBhbmVsIGlzIGNsb3NlZCBhZ2FpbiB3aGVuIGl0c1xuY29uc3RydWN0b3IgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLikgVmFsdWVzIG9mIGBudWxsYCBhcmUgaWdub3JlZC5cbiovXG5jb25zdCBzaG93UGFuZWwgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBlbmFibGVzOiBwYW5lbFBsdWdpblxufSk7XG5cbi8qKlxuQSBndXR0ZXIgbWFya2VyIHJlcHJlc2VudHMgYSBiaXQgb2YgaW5mb3JtYXRpb24gYXR0YWNoZWQgdG8gYSBsaW5lXG5pbiBhIHNwZWNpZmljIGd1dHRlci4gWW91ciBvd24gY3VzdG9tIG1hcmtlcnMgaGF2ZSB0byBleHRlbmQgdGhpc1xuY2xhc3MuXG4qL1xuY2xhc3MgR3V0dGVyTWFya2VyIGV4dGVuZHMgUmFuZ2VWYWx1ZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBtYXJrZXIgdG8gYW5vdGhlciBtYXJrZXIgb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIENhbGxlZCBpZiB0aGUgbWFya2VyIGhhcyBhIGB0b0RPTWAgbWV0aG9kIGFuZCBpdHMgcmVwcmVzZW50YXRpb25cbiAgICB3YXMgcmVtb3ZlZCBmcm9tIGEgZ3V0dGVyLlxuICAgICovXG4gICAgZGVzdHJveShkb20pIHsgfVxufVxuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5lbGVtZW50Q2xhc3MgPSBcIlwiO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS50b0RPTSA9IHVuZGVmaW5lZDtcbkd1dHRlck1hcmtlci5wcm90b3R5cGUubWFwTW9kZSA9IE1hcE1vZGUuVHJhY2tCZWZvcmU7XG5HdXR0ZXJNYXJrZXIucHJvdG90eXBlLnN0YXJ0U2lkZSA9IEd1dHRlck1hcmtlci5wcm90b3R5cGUuZW5kU2lkZSA9IC0xO1xuR3V0dGVyTWFya2VyLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG4vKipcbkZhY2V0IHVzZWQgdG8gYWRkIGEgY2xhc3MgdG8gYWxsIGd1dHRlciBlbGVtZW50cyBmb3IgYSBnaXZlbiBsaW5lLlxuTWFya2VycyBnaXZlbiB0byB0aGlzIGZhY2V0IHNob3VsZCBfb25seV8gZGVmaW5lIGFuXG5bYGVsZW1lbnRjbGFzc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5HdXR0ZXJNYXJrZXIuZWxlbWVudENsYXNzKSwgbm90IGFcbltgdG9ET01gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuR3V0dGVyTWFya2VyLnRvRE9NKSAob3IgdGhlIG1hcmtlciB3aWxsIGFwcGVhclxuaW4gYWxsIGd1dHRlcnMgZm9yIHRoZSBsaW5lKS5cbiovXG5jb25zdCBndXR0ZXJMaW5lQ2xhc3MgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkZhY2V0IHVzZWQgdG8gYWRkIGEgY2xhc3MgdG8gYWxsIGd1dHRlciBlbGVtZW50cyBuZXh0IHRvIGEgd2lkZ2V0LlxuU2hvdWxkIG5vdCBwcm92aWRlIHdpZGdldHMgd2l0aCBhIGB0b0RPTWAgbWV0aG9kLlxuKi9cbmNvbnN0IGd1dHRlcldpZGdldENsYXNzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgY2xhc3M6IFwiXCIsXG4gICAgcmVuZGVyRW1wdHlFbGVtZW50czogZmFsc2UsXG4gICAgZWxlbWVudFN0eWxlOiBcIlwiLFxuICAgIG1hcmtlcnM6ICgpID0+IFJhbmdlU2V0LmVtcHR5LFxuICAgIGxpbmVNYXJrZXI6ICgpID0+IG51bGwsXG4gICAgd2lkZ2V0TWFya2VyOiAoKSA9PiBudWxsLFxuICAgIGxpbmVNYXJrZXJDaGFuZ2U6IG51bGwsXG4gICAgaW5pdGlhbFNwYWNlcjogbnVsbCxcbiAgICB1cGRhdGVTcGFjZXI6IG51bGwsXG4gICAgZG9tRXZlbnRIYW5kbGVyczoge31cbn07XG5jb25zdCBhY3RpdmVHdXR0ZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5EZWZpbmUgYW4gZWRpdG9yIGd1dHRlci4gVGhlIG9yZGVyIGluIHdoaWNoIHRoZSBndXR0ZXJzIGFwcGVhciBpc1xuZGV0ZXJtaW5lZCBieSB0aGVpciBleHRlbnNpb24gcHJpb3JpdHkuXG4qL1xuZnVuY3Rpb24gZ3V0dGVyKGNvbmZpZykge1xuICAgIHJldHVybiBbZ3V0dGVycygpLCBhY3RpdmVHdXR0ZXJzLm9mKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMpLCBjb25maWcpKV07XG59XG5jb25zdCB1bmZpeEd1dHRlcnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUoeCA9PiB4KVxufSk7XG4vKipcblRoZSBndXR0ZXItZHJhd2luZyBwbHVnaW4gaXMgYXV0b21hdGljYWxseSBlbmFibGVkIHdoZW4geW91IGFkZCBhXG5ndXR0ZXIsIGJ1dCB5b3UgY2FuIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGV4cGxpY2l0bHkgY29uZmlndXJlIGl0LlxuXG5Vbmxlc3MgYGZpeGVkYCBpcyBleHBsaWNpdGx5IHNldCB0byBgZmFsc2VgLCB0aGUgZ3V0dGVycyBhcmVcbmZpeGVkLCBtZWFuaW5nIHRoZXkgZG9uJ3Qgc2Nyb2xsIGFsb25nIHdpdGggdGhlIGNvbnRlbnRcbmhvcml6b250YWxseSAoZXhjZXB0IG9uIEludGVybmV0IEV4cGxvcmVyLCB3aGljaCBkb2Vzbid0IHN1cHBvcnRcbkNTUyBbYHBvc2l0aW9uOlxuc3RpY2t5YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3Bvc2l0aW9uI3N0aWNreSkpLlxuKi9cbmZ1bmN0aW9uIGd1dHRlcnMoY29uZmlnKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtcbiAgICAgICAgZ3V0dGVyVmlldyxcbiAgICBdO1xuICAgIGlmIChjb25maWcgJiYgY29uZmlnLmZpeGVkID09PSBmYWxzZSlcbiAgICAgICAgcmVzdWx0LnB1c2godW5maXhHdXR0ZXJzLm9mKHRydWUpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgZ3V0dGVyVmlldyA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnByZXZWaWV3cG9ydCA9IHZpZXcudmlld3BvcnQ7XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJzXCI7XG4gICAgICAgIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gKHRoaXMudmlldy5jb250ZW50SGVpZ2h0IC8gdGhpcy52aWV3LnNjYWxlWSkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZ3V0dGVycyA9IHZpZXcuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycykubWFwKGNvbmYgPT4gbmV3IFNpbmdsZUd1dHRlclZpZXcodmlldywgY29uZikpO1xuICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZ3V0dGVyLmRvbSk7XG4gICAgICAgIHRoaXMuZml4ZWQgPSAhdmlldy5zdGF0ZS5mYWNldCh1bmZpeEd1dHRlcnMpO1xuICAgICAgICBpZiAodGhpcy5maXhlZCkge1xuICAgICAgICAgICAgLy8gRklYTUUgSUUxMSBmYWxsYmFjaywgd2hpY2ggZG9lc24ndCBzdXBwb3J0IHBvc2l0aW9uOiBzdGlja3ksXG4gICAgICAgICAgICAvLyBieSB1c2luZyBwb3NpdGlvbjogcmVsYXRpdmUgKyBldmVudCBoYW5kbGVycyB0aGF0IHJlYWxpZ24gdGhlXG4gICAgICAgICAgICAvLyBndXR0ZXIgKG9yIGp1c3QgZm9yY2UgZml4ZWQ9ZmFsc2Ugb24gSUUxMT8pXG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5wb3NpdGlvbiA9IFwic3RpY2t5XCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zeW5jR3V0dGVycyhmYWxzZSk7XG4gICAgICAgIHZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdmlldy5jb250ZW50RE9NKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVHdXR0ZXJzKHVwZGF0ZSkpIHtcbiAgICAgICAgICAgIC8vIERldGFjaCBkdXJpbmcgc3luYyB3aGVuIHRoZSB2aWV3cG9ydCBjaGFuZ2VkIHNpZ25pZmljYW50bHlcbiAgICAgICAgICAgIC8vIChzdWNoIGFzIGR1cmluZyBzY3JvbGxpbmcpLCBzaW5jZSBmb3IgbGFyZ2UgdXBkYXRlcyB0aGF0IGlzXG4gICAgICAgICAgICAvLyBmYXN0ZXIuXG4gICAgICAgICAgICBsZXQgdnBBID0gdGhpcy5wcmV2Vmlld3BvcnQsIHZwQiA9IHVwZGF0ZS52aWV3LnZpZXdwb3J0O1xuICAgICAgICAgICAgbGV0IHZwT3ZlcmxhcCA9IE1hdGgubWluKHZwQS50bywgdnBCLnRvKSAtIE1hdGgubWF4KHZwQS5mcm9tLCB2cEIuZnJvbSk7XG4gICAgICAgICAgICB0aGlzLnN5bmNHdXR0ZXJzKHZwT3ZlcmxhcCA8ICh2cEIudG8gLSB2cEIuZnJvbSkgKiAwLjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGUuZ2VvbWV0cnlDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5zdHlsZS5taW5IZWlnaHQgPSAodGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgLyB0aGlzLnZpZXcuc2NhbGVZKSArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlLmZhY2V0KHVuZml4R3V0dGVycykgIT0gIXRoaXMuZml4ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZml4ZWQgPSAhdGhpcy5maXhlZDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5maXhlZCA/IFwic3RpY2t5XCIgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldlZpZXdwb3J0ID0gdXBkYXRlLnZpZXcudmlld3BvcnQ7XG4gICAgfVxuICAgIHN5bmNHdXR0ZXJzKGRldGFjaCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmRvbS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgICAgICBsZXQgbGluZUNsYXNzZXMgPSBSYW5nZVNldC5pdGVyKHRoaXMudmlldy5zdGF0ZS5mYWNldChndXR0ZXJMaW5lQ2xhc3MpLCB0aGlzLnZpZXcudmlld3BvcnQuZnJvbSk7XG4gICAgICAgIGxldCBjbGFzc1NldCA9IFtdO1xuICAgICAgICBsZXQgY29udGV4dHMgPSB0aGlzLmd1dHRlcnMubWFwKGd1dHRlciA9PiBuZXcgVXBkYXRlQ29udGV4dChndXR0ZXIsIHRoaXMudmlldy52aWV3cG9ydCwgLXRoaXMudmlldy5kb2N1bWVudFBhZGRpbmcudG9wKSk7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy52aWV3LnZpZXdwb3J0TGluZUJsb2Nrcykge1xuICAgICAgICAgICAgaWYgKGNsYXNzU2V0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBjbGFzc1NldCA9IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGluZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYiBvZiBsaW5lLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCAmJiBmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZUN1cnNvcihsaW5lQ2xhc3NlcywgY2xhc3NTZXQsIGIuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC5saW5lKHRoaXMudmlldywgYiwgY2xhc3NTZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiLndpZGdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gud2lkZ2V0KHRoaXMudmlldywgYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaW5lLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlQ3Vyc29yKGxpbmVDbGFzc2VzLCBjbGFzc1NldCwgbGluZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjeCBvZiBjb250ZXh0cylcbiAgICAgICAgICAgICAgICAgICAgY3gubGluZSh0aGlzLnZpZXcsIGxpbmUsIGNsYXNzU2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUud2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY3ggb2YgY29udGV4dHMpXG4gICAgICAgICAgICAgICAgICAgIGN4LndpZGdldCh0aGlzLnZpZXcsIGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGN4IG9mIGNvbnRleHRzKVxuICAgICAgICAgICAgY3guZmluaXNoKCk7XG4gICAgICAgIGlmIChkZXRhY2gpXG4gICAgICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgYWZ0ZXIpO1xuICAgIH1cbiAgICB1cGRhdGVHdXR0ZXJzKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldiA9IHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGFjdGl2ZUd1dHRlcnMpLCBjdXIgPSB1cGRhdGUuc3RhdGUuZmFjZXQoYWN0aXZlR3V0dGVycyk7XG4gICAgICAgIGxldCBjaGFuZ2UgPSB1cGRhdGUuZG9jQ2hhbmdlZCB8fCB1cGRhdGUuaGVpZ2h0Q2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAhUmFuZ2VTZXQuZXEodXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoZ3V0dGVyTGluZUNsYXNzKSwgdXBkYXRlLnN0YXRlLmZhY2V0KGd1dHRlckxpbmVDbGFzcyksIHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20sIHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgaWYgKHByZXYgPT0gY3VyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBndXR0ZXIgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgICAgICAgICAgIGlmIChndXR0ZXIudXBkYXRlKHVwZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGd1dHRlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbmYgb2YgY3VyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtub3duID0gcHJldi5pbmRleE9mKGNvbmYpO1xuICAgICAgICAgICAgICAgIGlmIChrbm93biA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKG5ldyBTaW5nbGVHdXR0ZXJWaWV3KHRoaXMudmlldywgY29uZikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ndXR0ZXJzW2tub3duXS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZ3V0dGVycy5wdXNoKHRoaXMuZ3V0dGVyc1trbm93bl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGcgb2YgdGhpcy5ndXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgZy5kb20ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGd1dHRlcnMuaW5kZXhPZihnKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGcuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgZyBvZiBndXR0ZXJzKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGcuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ3V0dGVycyA9IGd1dHRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgdmlldyBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgfVxufSwge1xuICAgIHByb3ZpZGU6IHBsdWdpbiA9PiBFZGl0b3JWaWV3LnNjcm9sbE1hcmdpbnMub2YodmlldyA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHZpZXcucGx1Z2luKHBsdWdpbik7XG4gICAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUuZ3V0dGVycy5sZW5ndGggPT0gMCB8fCAhdmFsdWUuZml4ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSXG4gICAgICAgICAgICA/IHsgbGVmdDogdmFsdWUuZG9tLm9mZnNldFdpZHRoICogdmlldy5zY2FsZVggfVxuICAgICAgICAgICAgOiB7IHJpZ2h0OiB2YWx1ZS5kb20ub2Zmc2V0V2lkdGggKiB2aWV3LnNjYWxlWCB9O1xuICAgIH0pXG59KTtcbmZ1bmN0aW9uIGFzQXJyYXkodmFsKSB7IHJldHVybiAoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0pOyB9XG5mdW5jdGlvbiBhZHZhbmNlQ3Vyc29yKGN1cnNvciwgY29sbGVjdCwgcG9zKSB7XG4gICAgd2hpbGUgKGN1cnNvci52YWx1ZSAmJiBjdXJzb3IuZnJvbSA8PSBwb3MpIHtcbiAgICAgICAgaWYgKGN1cnNvci5mcm9tID09IHBvcylcbiAgICAgICAgICAgIGNvbGxlY3QucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgIH1cbn1cbmNsYXNzIFVwZGF0ZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGd1dHRlciwgdmlld3BvcnQsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmd1dHRlciA9IGd1dHRlcjtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gUmFuZ2VTZXQuaXRlcihndXR0ZXIubWFya2Vycywgdmlld3BvcnQuZnJvbSk7XG4gICAgfVxuICAgIGFkZEVsZW1lbnQodmlldywgYmxvY2ssIG1hcmtlcnMpIHtcbiAgICAgICAgbGV0IHsgZ3V0dGVyIH0gPSB0aGlzLCBhYm92ZSA9IChibG9jay50b3AgLSB0aGlzLmhlaWdodCkgLyB2aWV3LnNjYWxlWSwgaGVpZ2h0ID0gYmxvY2suaGVpZ2h0IC8gdmlldy5zY2FsZVk7XG4gICAgICAgIGlmICh0aGlzLmkgPT0gZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG5ld0VsdCA9IG5ldyBHdXR0ZXJFbGVtZW50KHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgICAgICAgICAgZ3V0dGVyLmVsZW1lbnRzLnB1c2gobmV3RWx0KTtcbiAgICAgICAgICAgIGd1dHRlci5kb20uYXBwZW5kQ2hpbGQobmV3RWx0LmRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBndXR0ZXIuZWxlbWVudHNbdGhpcy5pXS51cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBibG9jay5ib3R0b207XG4gICAgICAgIHRoaXMuaSsrO1xuICAgIH1cbiAgICBsaW5lKHZpZXcsIGxpbmUsIGV4dHJhTWFya2Vycykge1xuICAgICAgICBsZXQgbG9jYWxNYXJrZXJzID0gW107XG4gICAgICAgIGFkdmFuY2VDdXJzb3IodGhpcy5jdXJzb3IsIGxvY2FsTWFya2VycywgbGluZS5mcm9tKTtcbiAgICAgICAgaWYgKGV4dHJhTWFya2Vycy5sZW5ndGgpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMgPSBsb2NhbE1hcmtlcnMuY29uY2F0KGV4dHJhTWFya2Vycyk7XG4gICAgICAgIGxldCBmb3JMaW5lID0gdGhpcy5ndXR0ZXIuY29uZmlnLmxpbmVNYXJrZXIodmlldywgbGluZSwgbG9jYWxNYXJrZXJzKTtcbiAgICAgICAgaWYgKGZvckxpbmUpXG4gICAgICAgICAgICBsb2NhbE1hcmtlcnMudW5zaGlmdChmb3JMaW5lKTtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICBpZiAobG9jYWxNYXJrZXJzLmxlbmd0aCA9PSAwICYmICFndXR0ZXIuY29uZmlnLnJlbmRlckVtcHR5RWxlbWVudHMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudCh2aWV3LCBsaW5lLCBsb2NhbE1hcmtlcnMpO1xuICAgIH1cbiAgICB3aWRnZXQodmlldywgYmxvY2spIHtcbiAgICAgICAgbGV0IG1hcmtlciA9IHRoaXMuZ3V0dGVyLmNvbmZpZy53aWRnZXRNYXJrZXIodmlldywgYmxvY2sud2lkZ2V0LCBibG9jayksIG1hcmtlcnMgPSBtYXJrZXIgPyBbbWFya2VyXSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNscyBvZiB2aWV3LnN0YXRlLmZhY2V0KGd1dHRlcldpZGdldENsYXNzKSkge1xuICAgICAgICAgICAgbGV0IG1hcmtlciA9IGNscyh2aWV3LCBibG9jay53aWRnZXQsIGJsb2NrKTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIpXG4gICAgICAgICAgICAgICAgKG1hcmtlcnMgfHwgKG1hcmtlcnMgPSBbXSkpLnB1c2gobWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VycylcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudCh2aWV3LCBibG9jaywgbWFya2Vycyk7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgbGV0IGd1dHRlciA9IHRoaXMuZ3V0dGVyO1xuICAgICAgICB3aGlsZSAoZ3V0dGVyLmVsZW1lbnRzLmxlbmd0aCA+IHRoaXMuaSkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBndXR0ZXIuZWxlbWVudHMucG9wKCk7XG4gICAgICAgICAgICBndXR0ZXIuZG9tLnJlbW92ZUNoaWxkKGxhc3QuZG9tKTtcbiAgICAgICAgICAgIGxhc3QuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2luZ2xlR3V0dGVyVmlldyB7XG4gICAgY29uc3RydWN0b3IodmlldywgY29uZmlnKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuc3BhY2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWd1dHRlclwiICsgKHRoaXMuY29uZmlnLmNsYXNzID8gXCIgXCIgKyB0aGlzLmNvbmZpZy5jbGFzcyA6IFwiXCIpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIGNvbmZpZy5kb21FdmVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKHByb3AsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQsIHk7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPSB0aGlzLmRvbSAmJiB0aGlzLmRvbS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0YXJnZXQucGFyZW50Tm9kZSAhPSB0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSB2aWV3LmxpbmVCbG9ja0F0SGVpZ2h0KHkgLSB2aWV3LmRvY3VtZW50VG9wKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmRvbUV2ZW50SGFuZGxlcnNbcHJvcF0odmlldywgbGluZSwgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheShjb25maWcubWFya2Vycyh2aWV3KSk7XG4gICAgICAgIGlmIChjb25maWcuaW5pdGlhbFNwYWNlcikge1xuICAgICAgICAgICAgdGhpcy5zcGFjZXIgPSBuZXcgR3V0dGVyRWxlbWVudCh2aWV3LCAwLCAwLCBbY29uZmlnLmluaXRpYWxTcGFjZXIodmlldyldKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuc3BhY2VyLmRvbSk7XG4gICAgICAgICAgICB0aGlzLnNwYWNlci5kb20uc3R5bGUuY3NzVGV4dCArPSBcInZpc2liaWxpdHk6IGhpZGRlbjsgcG9pbnRlci1ldmVudHM6IG5vbmVcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBwcmV2TWFya2VycyA9IHRoaXMubWFya2VycztcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gYXNBcnJheSh0aGlzLmNvbmZpZy5tYXJrZXJzKHVwZGF0ZS52aWV3KSk7XG4gICAgICAgIGlmICh0aGlzLnNwYWNlciAmJiB0aGlzLmNvbmZpZy51cGRhdGVTcGFjZXIpIHtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkID0gdGhpcy5jb25maWcudXBkYXRlU3BhY2VyKHRoaXMuc3BhY2VyLm1hcmtlcnNbMF0sIHVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodXBkYXRlZCAhPSB0aGlzLnNwYWNlci5tYXJrZXJzWzBdKVxuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VyLnVwZGF0ZSh1cGRhdGUudmlldywgMCwgMCwgW3VwZGF0ZWRdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdnAgPSB1cGRhdGUudmlldy52aWV3cG9ydDtcbiAgICAgICAgcmV0dXJuICFSYW5nZVNldC5lcSh0aGlzLm1hcmtlcnMsIHByZXZNYXJrZXJzLCB2cC5mcm9tLCB2cC50bykgfHxcbiAgICAgICAgICAgICh0aGlzLmNvbmZpZy5saW5lTWFya2VyQ2hhbmdlID8gdGhpcy5jb25maWcubGluZU1hcmtlckNoYW5nZSh1cGRhdGUpIDogZmFsc2UpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBlbHQgb2YgdGhpcy5lbGVtZW50cylcbiAgICAgICAgICAgIGVsdC5kZXN0cm95KCk7XG4gICAgfVxufVxuY2xhc3MgR3V0dGVyRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICB0aGlzLmhlaWdodCA9IC0xO1xuICAgICAgICB0aGlzLmFib3ZlID0gMDtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJFbGVtZW50XCI7XG4gICAgICAgIHRoaXMudXBkYXRlKHZpZXcsIGhlaWdodCwgYWJvdmUsIG1hcmtlcnMpO1xuICAgIH1cbiAgICB1cGRhdGUodmlldywgaGVpZ2h0LCBhYm92ZSwgbWFya2Vycykge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hYm92ZSAhPSBhYm92ZSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnN0eWxlLm1hcmdpblRvcCA9ICh0aGlzLmFib3ZlID0gYWJvdmUpID8gYWJvdmUgKyBcInB4XCIgOiBcIlwiO1xuICAgICAgICBpZiAoIXNhbWVNYXJrZXJzKHRoaXMubWFya2VycywgbWFya2VycykpXG4gICAgICAgICAgICB0aGlzLnNldE1hcmtlcnModmlldywgbWFya2Vycyk7XG4gICAgfVxuICAgIHNldE1hcmtlcnModmlldywgbWFya2Vycykge1xuICAgICAgICBsZXQgY2xzID0gXCJjbS1ndXR0ZXJFbGVtZW50XCIsIGRvbVBvcyA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZvciAobGV0IGlOZXcgPSAwLCBpT2xkID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgc2tpcFRvID0gaU9sZCwgbWFya2VyID0gaU5ldyA8IG1hcmtlcnMubGVuZ3RoID8gbWFya2Vyc1tpTmV3KytdIDogbnVsbCwgbWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICAgICAgICAgIGxldCBjID0gbWFya2VyLmVsZW1lbnRDbGFzcztcbiAgICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICAgICAgY2xzICs9IFwiIFwiICsgYztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaU9sZDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWFya2Vyc1tpXS5jb21wYXJlKG1hcmtlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBUbyA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBza2lwVG8gPSB0aGlzLm1hcmtlcnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGlPbGQgPCBza2lwVG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMubWFya2Vyc1tpT2xkKytdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LnRvRE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQuZGVzdHJveShkb21Qb3MpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWZ0ZXIgPSBkb21Qb3MubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcy5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZG9tUG9zID0gYWZ0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXJrZXIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobWFya2VyLnRvRE9NKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWQpXG4gICAgICAgICAgICAgICAgICAgIGRvbVBvcyA9IGRvbVBvcy5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShtYXJrZXIudG9ET00odmlldyksIGRvbVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hlZClcbiAgICAgICAgICAgICAgICBpT2xkKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb20uY2xhc3NOYW1lID0gY2xzO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBtYXJrZXJzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldE1hcmtlcnMobnVsbCwgW10pOyAvLyBGaXJzdCBhcmd1bWVudCBub3QgdXNlZCB1bmxlc3MgY3JlYXRpbmcgbWFya2Vyc1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhbWVNYXJrZXJzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICghYVtpXS5jb21wYXJlKGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG5GYWNldCB1c2VkIHRvIHByb3ZpZGUgbWFya2VycyB0byB0aGUgbGluZSBudW1iZXIgZ3V0dGVyLlxuKi9cbmNvbnN0IGxpbmVOdW1iZXJNYXJrZXJzID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5GYWNldCB1c2VkIHRvIGNyZWF0ZSBtYXJrZXJzIGluIHRoZSBsaW5lIG51bWJlciBndXR0ZXIgbmV4dCB0byB3aWRnZXRzLlxuKi9cbmNvbnN0IGxpbmVOdW1iZXJXaWRnZXRNYXJrZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBsaW5lTnVtYmVyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcodmFsdWVzLCB7IGZvcm1hdE51bWJlcjogU3RyaW5nLCBkb21FdmVudEhhbmRsZXJzOiB7fSB9LCB7XG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzKGEsIGIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgYSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZXZlbnQgaW4gYikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gcmVzdWx0W2V2ZW50XSwgYWRkID0gYltldmVudF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtldmVudF0gPSBleGlzdHMgPyAodmlldywgbGluZSwgZXZlbnQpID0+IGV4aXN0cyh2aWV3LCBsaW5lLCBldmVudCkgfHwgYWRkKHZpZXcsIGxpbmUsIGV2ZW50KSA6IGFkZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jbGFzcyBOdW1iZXJNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKG51bWJlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMubnVtYmVyID09IG90aGVyLm51bWJlcjsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5udW1iZXIpOyB9XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIodmlldywgbnVtYmVyKSB7XG4gICAgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZykuZm9ybWF0TnVtYmVyKG51bWJlciwgdmlldy5zdGF0ZSk7XG59XG5jb25zdCBsaW5lTnVtYmVyR3V0dGVyID0gLypAX19QVVJFX18qL2FjdGl2ZUd1dHRlcnMuY29tcHV0ZShbbGluZU51bWJlckNvbmZpZ10sIHN0YXRlID0+ICh7XG4gICAgY2xhc3M6IFwiY20tbGluZU51bWJlcnNcIixcbiAgICByZW5kZXJFbXB0eUVsZW1lbnRzOiBmYWxzZSxcbiAgICBtYXJrZXJzKHZpZXcpIHsgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQobGluZU51bWJlck1hcmtlcnMpOyB9LFxuICAgIGxpbmVNYXJrZXIodmlldywgbGluZSwgb3RoZXJzKSB7XG4gICAgICAgIGlmIChvdGhlcnMuc29tZShtID0+IG0udG9ET00pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTWFya2VyKGZvcm1hdE51bWJlcih2aWV3LCB2aWV3LnN0YXRlLmRvYy5saW5lQXQobGluZS5mcm9tKS5udW1iZXIpKTtcbiAgICB9LFxuICAgIHdpZGdldE1hcmtlcjogKHZpZXcsIHdpZGdldCwgYmxvY2spID0+IHtcbiAgICAgICAgZm9yIChsZXQgbSBvZiB2aWV3LnN0YXRlLmZhY2V0KGxpbmVOdW1iZXJXaWRnZXRNYXJrZXIpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbSh2aWV3LCB3aWRnZXQsIGJsb2NrKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGxpbmVNYXJrZXJDaGFuZ2U6IHVwZGF0ZSA9PiB1cGRhdGUuc3RhcnRTdGF0ZS5mYWNldChsaW5lTnVtYmVyQ29uZmlnKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQobGluZU51bWJlckNvbmZpZyksXG4gICAgaW5pdGlhbFNwYWNlcih2aWV3KSB7XG4gICAgICAgIHJldHVybiBuZXcgTnVtYmVyTWFya2VyKGZvcm1hdE51bWJlcih2aWV3LCBtYXhMaW5lTnVtYmVyKHZpZXcuc3RhdGUuZG9jLmxpbmVzKSkpO1xuICAgIH0sXG4gICAgdXBkYXRlU3BhY2VyKHNwYWNlciwgdXBkYXRlKSB7XG4gICAgICAgIGxldCBtYXggPSBmb3JtYXROdW1iZXIodXBkYXRlLnZpZXcsIG1heExpbmVOdW1iZXIodXBkYXRlLnZpZXcuc3RhdGUuZG9jLmxpbmVzKSk7XG4gICAgICAgIHJldHVybiBtYXggPT0gc3BhY2VyLm51bWJlciA/IHNwYWNlciA6IG5ldyBOdW1iZXJNYXJrZXIobWF4KTtcbiAgICB9LFxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHN0YXRlLmZhY2V0KGxpbmVOdW1iZXJDb25maWcpLmRvbUV2ZW50SGFuZGxlcnNcbn0pKTtcbi8qKlxuQ3JlYXRlIGEgbGluZSBudW1iZXIgZ3V0dGVyIGV4dGVuc2lvbi5cbiovXG5mdW5jdGlvbiBsaW5lTnVtYmVycyhjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGxpbmVOdW1iZXJDb25maWcub2YoY29uZmlnKSxcbiAgICAgICAgZ3V0dGVycygpLFxuICAgICAgICBsaW5lTnVtYmVyR3V0dGVyXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG1heExpbmVOdW1iZXIobGluZXMpIHtcbiAgICBsZXQgbGFzdCA9IDk7XG4gICAgd2hpbGUgKGxhc3QgPCBsaW5lcylcbiAgICAgICAgbGFzdCA9IGxhc3QgKiAxMCArIDk7XG4gICAgcmV0dXJuIGxhc3Q7XG59XG5jb25zdCBhY3RpdmVMaW5lR3V0dGVyTWFya2VyID0gLypAX19QVVJFX18qL25ldyBjbGFzcyBleHRlbmRzIEd1dHRlck1hcmtlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZWxlbWVudENsYXNzID0gXCJjbS1hY3RpdmVMaW5lR3V0dGVyXCI7XG4gICAgfVxufTtcbmNvbnN0IGFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9ndXR0ZXJMaW5lQ2xhc3MuY29tcHV0ZShbXCJzZWxlY3Rpb25cIl0sIHN0YXRlID0+IHtcbiAgICBsZXQgbWFya3MgPSBbXSwgbGFzdCA9IC0xO1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgbGV0IGxpbmVQb3MgPSBzdGF0ZS5kb2MubGluZUF0KHJhbmdlLmhlYWQpLmZyb207XG4gICAgICAgIGlmIChsaW5lUG9zID4gbGFzdCkge1xuICAgICAgICAgICAgbGFzdCA9IGxpbmVQb3M7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKGFjdGl2ZUxpbmVHdXR0ZXJNYXJrZXIucmFuZ2UobGluZVBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSYW5nZVNldC5vZihtYXJrcyk7XG59KTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBhZGRzIGEgYGNtLWFjdGl2ZUxpbmVHdXR0ZXJgIGNsYXNzIHRvXG5hbGwgZ3V0dGVyIGVsZW1lbnRzIG9uIHRoZSBbYWN0aXZlXG5saW5lXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuaGlnaGxpZ2h0QWN0aXZlTGluZSkuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlcigpIHtcbiAgICByZXR1cm4gYWN0aXZlTGluZUd1dHRlckhpZ2hsaWdodGVyO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyKGRlY29yYXRvcikge1xuICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+ICh7XG4gICAgICAgIGRlY29yYXRpb25zOiBkZWNvcmF0b3IuY3JlYXRlRGVjbyh2aWV3KSxcbiAgICAgICAgdXBkYXRlKHUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBkZWNvcmF0b3IudXBkYXRlRGVjbyh1LCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgfSxcbiAgICB9KSwge1xuICAgICAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG4gICAgfSk7XG59XG5jb25zdCB0YWJEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWhpZ2hsaWdodFRhYlwiIH0pO1xuY29uc3Qgc3BhY2VEZWNvID0gLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWhpZ2hsaWdodFNwYWNlXCIgfSk7XG5jb25zdCB3aGl0ZXNwYWNlSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovbWF0Y2hlcigvKkBfX1BVUkVfXyovbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICByZWdleHA6IC9cXHR8IC9nLFxuICAgIGRlY29yYXRpb246IG1hdGNoID0+IG1hdGNoWzBdID09IFwiXFx0XCIgPyB0YWJEZWNvIDogc3BhY2VEZWNvLFxuICAgIGJvdW5kYXJ5OiAvXFxTLyxcbn0pKTtcbi8qKlxuUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBoaWdobGlnaHRzIHdoaXRlc3BhY2UsIGFkZGluZyBhXG5gY20taGlnaGxpZ2h0U3BhY2VgIGNsYXNzIHRvIHN0cmV0Y2hlcyBvZiBzcGFjZXMsIGFuZCBhXG5gY20taGlnaGxpZ2h0VGFiYCBjbGFzcyB0byBpbmRpdmlkdWFsIHRhYiBjaGFyYWN0ZXJzLiBCeSBkZWZhdWx0LFxudGhlIGZvcm1lciBhcmUgc2hvd24gYXMgZmFpbnQgZG90cywgYW5kIHRoZSBsYXR0ZXIgYXMgYXJyb3dzLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFdoaXRlc3BhY2UoKSB7XG4gICAgcmV0dXJuIHdoaXRlc3BhY2VIaWdobGlnaHRlcjtcbn1cbmNvbnN0IHRyYWlsaW5nSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovbWF0Y2hlcigvKkBfX1BVUkVfXyovbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICByZWdleHA6IC9cXHMrJC9nLFxuICAgIGRlY29yYXRpb246IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS10cmFpbGluZ1NwYWNlXCIgfSksXG4gICAgYm91bmRhcnk6IC9cXFMvLFxufSkpO1xuLyoqXG5SZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgYSBgY20tdHJhaWxpbmdTcGFjZWAgY2xhc3MgdG8gYWxsXG50cmFpbGluZyB3aGl0ZXNwYWNlLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFRyYWlsaW5nV2hpdGVzcGFjZSgpIHtcbiAgICByZXR1cm4gdHJhaWxpbmdIaWdobGlnaHRlcjtcbn1cblxuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3Rlc3QgPSB7IEhlaWdodE1hcCwgSGVpZ2h0T3JhY2xlLCBNZWFzdXJlZEhlaWdodHMsIFF1ZXJ5VHlwZSwgQ2hhbmdlZFJhbmdlLCBjb21wdXRlT3JkZXIsXG4gICAgbW92ZVZpc3VhbGx5LCBjbGVhckhlaWdodENoYW5nZUZsYWcsIGdldEhlaWdodENoYW5nZUZsYWc6ICgpID0+IGhlaWdodENoYW5nZUZsYWcgfTtcblxuZXhwb3J0IHsgQmlkaVNwYW4sIEJsb2NrSW5mbywgQmxvY2tUeXBlLCBEZWNvcmF0aW9uLCBEaXJlY3Rpb24sIEVkaXRvclZpZXcsIEd1dHRlck1hcmtlciwgTWF0Y2hEZWNvcmF0b3IsIFJlY3RhbmdsZU1hcmtlciwgVmlld1BsdWdpbiwgVmlld1VwZGF0ZSwgV2lkZ2V0VHlwZSwgX190ZXN0LCBjbG9zZUhvdmVyVG9vbHRpcHMsIGNyb3NzaGFpckN1cnNvciwgZHJhd1NlbGVjdGlvbiwgZHJvcEN1cnNvciwgZ2V0RHJhd1NlbGVjdGlvbkNvbmZpZywgZ2V0UGFuZWwsIGdldFRvb2x0aXAsIGd1dHRlciwgZ3V0dGVyTGluZUNsYXNzLCBndXR0ZXJXaWRnZXRDbGFzcywgZ3V0dGVycywgaGFzSG92ZXJUb29sdGlwcywgaGlnaGxpZ2h0QWN0aXZlTGluZSwgaGlnaGxpZ2h0QWN0aXZlTGluZUd1dHRlciwgaGlnaGxpZ2h0U3BlY2lhbENoYXJzLCBoaWdobGlnaHRUcmFpbGluZ1doaXRlc3BhY2UsIGhpZ2hsaWdodFdoaXRlc3BhY2UsIGhvdmVyVG9vbHRpcCwga2V5bWFwLCBsYXllciwgbGluZU51bWJlck1hcmtlcnMsIGxpbmVOdW1iZXJXaWRnZXRNYXJrZXIsIGxpbmVOdW1iZXJzLCBsb2dFeGNlcHRpb24sIHBhbmVscywgcGxhY2Vob2xkZXIsIHJlY3Rhbmd1bGFyU2VsZWN0aW9uLCByZXBvc2l0aW9uVG9vbHRpcHMsIHJ1blNjb3BlSGFuZGxlcnMsIHNjcm9sbFBhc3RFbmQsIHNob3dQYW5lbCwgc2hvd1Rvb2x0aXAsIHRvb2x0aXBzIH07XG4iXSwibmFtZXMiOlsiVGV4dCIsIlJhbmdlU2V0IiwiTWFwTW9kZSIsIlJhbmdlVmFsdWUiLCJmaW5kQ2x1c3RlckJyZWFrIiwiRWRpdG9yU2VsZWN0aW9uIiwiRmFjZXQiLCJTdGF0ZUVmZmVjdCIsIkNoYW5nZVNldCIsImZpbmRDb2x1bW4iLCJDaGFyQ2F0ZWdvcnkiLCJFZGl0b3JTdGF0ZSIsIkFubm90YXRpb24iLCJUcmFuc2FjdGlvbiIsIlByZWMiLCJjb2RlUG9pbnRBdCIsImNvZGVQb2ludFNpemUiLCJjb21iaW5lQ29uZmlnIiwiU3RhdGVGaWVsZCIsIlJhbmdlU2V0QnVpbGRlciIsImNvdW50Q29sdW1uIiwiU3R5bGVNb2R1bGUiLCJrZXlOYW1lIiwiYmFzZSIsInNoaWZ0IiwiZ2V0U2VsZWN0aW9uIiwicm9vdCIsInRhcmdldCIsIm5vZGVUeXBlIiwib3duZXJEb2N1bWVudCIsImNvbnRhaW5zIiwiZG9tIiwibm9kZSIsInBhcmVudE5vZGUiLCJoYXNTZWxlY3Rpb24iLCJzZWxlY3Rpb24iLCJhbmNob3JOb2RlIiwiXyIsImNsaWVudFJlY3RzRm9yIiwidGV4dFJhbmdlIiwibm9kZVZhbHVlIiwibGVuZ3RoIiwiZ2V0Q2xpZW50UmVjdHMiLCJpc0VxdWl2YWxlbnRQb3NpdGlvbiIsIm9mZiIsInRhcmdldE5vZGUiLCJ0YXJnZXRPZmYiLCJzY2FuRm9yIiwiZG9tSW5kZXgiLCJpbmRleCIsInByZXZpb3VzU2libGluZyIsImlzQmxvY2tFbGVtZW50IiwidGVzdCIsIm5vZGVOYW1lIiwiZGlyIiwibWF4T2Zmc2V0IiwicGFyZW50IiwiY2hpbGROb2RlcyIsImNvbnRlbnRFZGl0YWJsZSIsImZsYXR0ZW5SZWN0IiwicmVjdCIsImxlZnQiLCJ4IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJ3aW5kb3dSZWN0Iiwid2luIiwidnAiLCJ2aXN1YWxWaWV3cG9ydCIsIndpZHRoIiwiaGVpZ2h0IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiZ2V0U2NhbGUiLCJlbHQiLCJzY2FsZVgiLCJvZmZzZXRXaWR0aCIsInNjYWxlWSIsIm9mZnNldEhlaWdodCIsImlzRmluaXRlIiwiTWF0aCIsImFicyIsInNjcm9sbFJlY3RJbnRvVmlldyIsInNpZGUiLCJ5IiwieE1hcmdpbiIsInlNYXJnaW4iLCJsdHIiLCJkb2MiLCJkZWZhdWx0VmlldyIsIndpbmRvdyIsImN1ciIsInN0b3AiLCJib3VuZGluZyIsImJvZHkiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJzY3JvbGxIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwiYXNzaWduZWRTbG90IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibW92ZVgiLCJtb3ZlWSIsInJlY3RIZWlnaHQiLCJib3VuZGluZ0hlaWdodCIsInRhcmdldFRvcCIsInRhcmdldExlZnQiLCJzY3JvbGxCeSIsIm1vdmVkWCIsIm1vdmVkWSIsInN0YXJ0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsIm1heCIsIm1pbiIsImhvc3QiLCJzY3JvbGxhYmxlUGFyZW50cyIsIkRPTVNlbGVjdGlvblN0YXRlIiwiY29uc3RydWN0b3IiLCJhbmNob3JPZmZzZXQiLCJmb2N1c05vZGUiLCJmb2N1c09mZnNldCIsImVxIiwiZG9tU2VsIiwic2V0UmFuZ2UiLCJyYW5nZSIsInNldCIsInByZXZlbnRTY3JvbGxTdXBwb3J0ZWQiLCJmb2N1c1ByZXZlbnRTY3JvbGwiLCJzZXRBY3RpdmUiLCJmb2N1cyIsInN0YWNrIiwicHVzaCIsInByZXZlbnRTY3JvbGwiLCJ1bmRlZmluZWQiLCJpIiwic2NyYXRjaFJhbmdlIiwiZnJvbSIsInRvIiwiZG9jdW1lbnQiLCJjcmVhdGVSYW5nZSIsInNldEVuZCIsInNldFN0YXJ0IiwiZGlzcGF0Y2hLZXkiLCJuYW1lIiwiY29kZSIsIm1vZHMiLCJvcHRpb25zIiwia2V5Iiwia2V5Q29kZSIsIndoaWNoIiwiY2FuY2VsYWJsZSIsImFsdEtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsIm1ldGFLZXkiLCJkb3duIiwiS2V5Ym9hcmRFdmVudCIsInN5bnRoZXRpYyIsImRpc3BhdGNoRXZlbnQiLCJ1cCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJnZXRSb290IiwiY2xlYXJBdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsInJlbW92ZUF0dHJpYnV0ZU5vZGUiLCJhdEVsZW1lbnRTdGFydCIsIm9mZnNldCIsInByZXYiLCJpc1Njcm9sbGVkVG9Cb3R0b20iLCJ0ZXh0Tm9kZUJlZm9yZSIsInN0YXJ0Tm9kZSIsInN0YXJ0T2Zmc2V0IiwidGV4dE5vZGVBZnRlciIsIkRPTVBvcyIsInByZWNpc2UiLCJiZWZvcmUiLCJhZnRlciIsIm5vQ2hpbGRyZW4iLCJDb250ZW50VmlldyIsImZsYWdzIiwib3ZlcnJpZGVET01UZXh0IiwicG9zQXRTdGFydCIsInBvc0JlZm9yZSIsInBvc0F0RW5kIiwidmlldyIsInBvcyIsImNoaWxkIiwiY2hpbGRyZW4iLCJicmVha0FmdGVyIiwiUmFuZ2VFcnJvciIsInBvc0FmdGVyIiwic3luYyIsInRyYWNrIiwibmV4dCIsIm5leHRTaWJsaW5nIiwiZmlyc3RDaGlsZCIsImNvbnRlbnRWaWV3IiwiZ2V0IiwiY2FuUmV1c2VET00iLCJyZXVzZURPTSIsIndyaXR0ZW4iLCJybSQxIiwiaW5zZXJ0QmVmb3JlIiwiX2RvbSIsImxvY2FsUG9zRnJvbURPTSIsImJpYXMiLCJsYXN0Q2hpbGQiLCJkb21Cb3VuZHNBcm91bmQiLCJmcm9tSSIsImZyb21TdGFydCIsInRvSSIsInRvRW5kIiwicHJldkVuZCIsImVuZCIsInN0YXJ0RE9NIiwiZW5kRE9NIiwibWFya0RpcnR5IiwiYW5kUGFyZW50IiwibWFya1BhcmVudHNEaXJ0eSIsImNoaWxkTGlzdCIsInNldFBhcmVudCIsInNldERPTSIsImNtVmlldyIsInJvb3RWaWV3IiwidiIsInJlcGxhY2VDaGlsZHJlbiIsImluZGV4T2YiLCJkZXN0cm95Iiwic3BsaWNlIiwiY29uY2F0Iiwic2xpY2UiLCJpZ25vcmVNdXRhdGlvbiIsIl9yZWMiLCJpZ25vcmVFdmVudCIsIl9ldmVudCIsImNoaWxkQ3Vyc29yIiwiQ2hpbGRDdXJzb3IiLCJjaGlsZFBvcyIsImZpbmRQb3MiLCJ0b1N0cmluZyIsInJlcGxhY2UiLCJqb2luIiwidGV4dCIsImlzRWRpdGFibGUiLCJpc1dpZGdldCIsImlzSGlkZGVuIiwibWVyZ2UiLCJzb3VyY2UiLCJoYXNTdGFydCIsIm9wZW5TdGFydCIsIm9wZW5FbmQiLCJiZWNvbWUiLCJvdGhlciIsImdldFNpZGUiLCJwcm90b3R5cGUiLCJyZW1vdmVDaGlsZCIsInJlcGxhY2VSYW5nZSIsImZyb21PZmYiLCJ0b09mZiIsImluc2VydCIsImJyZWFrQXRTdGFydCIsImxhc3QiLCJicmVha0F0RW5kIiwic3BsaXQiLCJwb3AiLCJtZXJnZUNoaWxkcmVuSW50byIsImRMZW4iLCJuYXYiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ2ZW5kb3IiLCJwbGF0Zm9ybSIsImRvY3VtZW50RWxlbWVudCIsInN0eWxlIiwiaWVfZWRnZSIsImV4ZWMiLCJpZV91cHRvMTAiLCJpZV8xMXVwIiwiaWUiLCJnZWNrbyIsImNocm9tZSIsIndlYmtpdCIsInNhZmFyaSIsImlvcyIsIm1heFRvdWNoUG9pbnRzIiwiYnJvd3NlciIsIm1hYyIsIndpbmRvd3MiLCJsaW51eCIsImllX3ZlcnNpb24iLCJkb2N1bWVudE1vZGUiLCJnZWNrb192ZXJzaW9uIiwiY2hyb21lX3ZlcnNpb24iLCJhbmRyb2lkIiwid2Via2l0X3ZlcnNpb24iLCJ0YWJTaXplIiwiTWF4Sm9pbkxlbiIsIlRleHRWaWV3IiwiY3JlYXRlRE9NIiwidGV4dERPTSIsImNyZWF0ZVRleHROb2RlIiwicmVzdWx0IiwiZG9tQXRQb3MiLCJfZnJvbSIsIl90byIsImNvb3Jkc0F0IiwidGV4dENvb3JkcyIsIk1hcmtWaWV3IiwibWFyayIsImNoIiwic2V0QXR0cnMiLCJjbGFzcyIsImNsYXNzTmFtZSIsImF0dHJzIiwic2V0QXR0cmlidXRlIiwidGFnTmFtZSIsInRvVXBwZXJDYXNlIiwiY3JlYXRlRWxlbWVudCIsIl9oYXNTdGFydCIsImRldGFjaEZyb20iLCJpbmxpbmVET01BdFBvcyIsImNvb3Jkc0luQ2hpbGRyZW4iLCJmbGF0dGVuIiwicmVjdHMiLCJBcnJheSIsImZpbmQiLCJjYWxsIiwiciIsIldpZGdldFZpZXciLCJjcmVhdGUiLCJ3aWRnZXQiLCJwcmV2V2lkZ2V0IiwidXBkYXRlRE9NIiwidG9ET00iLCJlZGl0YWJsZSIsImNvbXBhcmUiLCJldmVudCIsImVtcHR5Iiwic3RhdGUiLCJjdXN0b20iLCJmcm9tQmFjayIsIldpZGdldEJ1ZmZlclZpZXciLCJqIiwiam9pbklubGluZUludG8iLCJvcGVuIiwiYmVmb3JlUG9zIiwiYWZ0ZXJQb3MiLCJzY2FuIiwiZmFsbGJhY2tSZWN0IiwiY29tYmluZUF0dHJzIiwibm9BdHRycyIsIk9iamVjdCIsImF0dHJzRXEiLCJhIiwiYiIsImlnbm9yZSIsImtleXNBIiwia2V5cyIsImtleXNCIiwidXBkYXRlQXR0cnMiLCJjaGFuZ2VkIiwiY3NzVGV4dCIsInJlbW92ZUF0dHJpYnV0ZSIsImdldEF0dHJzIiwiYXR0ciIsInZhbHVlIiwiV2lkZ2V0VHlwZSIsImVzdGltYXRlZEhlaWdodCIsImxpbmVCcmVha3MiLCJCbG9ja1R5cGUiLCJEZWNvcmF0aW9uIiwic3RhcnRTaWRlIiwiZW5kU2lkZSIsInNwZWMiLCJoZWlnaHRSZWxldmFudCIsIk1hcmtEZWNvcmF0aW9uIiwiYmxvY2siLCJpbmxpbmVPcmRlciIsIlBvaW50RGVjb3JhdGlvbiIsImlzQmxvY2tHYXAiLCJnZXRJbmNsdXNpdmUiLCJsaW5lIiwiTGluZURlY29yYXRpb24iLCJvZiIsInNvcnQiLCJoYXNIZWlnaHQiLCJub25lIiwiX2EiLCJfYiIsInBvaW50IiwibWFwTW9kZSIsIlRyYWNrQmVmb3JlIiwiaXNSZXBsYWNlIiwiVHJhY2tEZWwiLCJUcmFja0FmdGVyIiwidHlwZSIsIldpZGdldFJhbmdlIiwiV2lkZ2V0QmVmb3JlIiwiV2lkZ2V0QWZ0ZXIiLCJ3aWRnZXRzRXEiLCJpbmNsdXNpdmVTdGFydCIsImluY2x1c2l2ZUVuZCIsImluY2x1c2l2ZSIsImFkZFJhbmdlIiwicmFuZ2VzIiwibWFyZ2luIiwiTGluZVZpZXciLCJhcmd1bWVudHMiLCJwcmV2QXR0cnMiLCJ0cmFuc2ZlckRPTSIsInNldERlY28iLCJhdCIsImFwcGVuZCIsImFkZExpbmVEZWNvIiwiZGVjbyIsImNscyIsImNsYXNzTGlzdCIsImFkZCIsInNvbWUiLCJoYWNrIiwiY21JZ25vcmUiLCJhcHBlbmRDaGlsZCIsIm1lYXN1cmVUZXh0U2l6ZSIsInRvdGFsV2lkdGgiLCJ0ZXh0SGVpZ2h0IiwibGluZUhlaWdodCIsImNoYXJXaWR0aCIsImhlaWdodE9yYWNsZSIsInZpZXdTdGF0ZSIsImRpc3QiLCJjb3ZlcnMiLCJkb2NWaWV3IiwiQmxvY2tXaWRnZXRWaWV3IiwiX3Rha2VEZWNvIiwibGVuIiwiQmxvY2tHYXBXaWRnZXQiLCJDb250ZW50QnVpbGRlciIsImRpc2FsbG93QmxvY2tFZmZlY3RzRm9yIiwiY29udGVudCIsImN1ckxpbmUiLCJwZW5kaW5nQnVmZmVyIiwiYnVmZmVyTWFya3MiLCJhdEN1cnNvclBvcyIsInRleHRPZmYiLCJjdXJzb3IiLCJpdGVyIiwic2tpcCIsInBvc0NvdmVyZWQiLCJsaW5lQXQiLCJnZXRMaW5lIiwiZmx1c2hCdWZmZXIiLCJhY3RpdmUiLCJ3cmFwTWFya3MiLCJhZGRCbG9ja1dpZGdldCIsImZpbmlzaCIsImJ1aWxkVGV4dCIsImxpbmVCcmVhayIsImRvbmUiLCJFcnJvciIsInRha2UiLCJzcGFuIiwiTnVsbFdpZGdldCIsImlubGluZSIsImN1cnNvckJlZm9yZSIsImN1cnNvckFmdGVyIiwiYnVpbGQiLCJkZWNvcmF0aW9ucyIsImR5bmFtaWNEZWNvcmF0aW9uTWFwIiwiYnVpbGRlciIsInNwYW5zIiwidGFnIiwidG9Mb3dlckNhc2UiLCJEaXJlY3Rpb24iLCJMVFIiLCJSVEwiLCJkZWMiLCJzdHIiLCJMb3dUeXBlcyIsIkFyYWJpY1R5cGVzIiwiQnJhY2tldHMiLCJCcmFja2V0U3RhY2siLCJwIiwibCIsImNoYXJDb2RlQXQiLCJjaGFyVHlwZSIsIkJpZGlSRSIsIkJpZGlTcGFuIiwibGV2ZWwiLCJmb3J3YXJkIiwib3JkZXIiLCJhc3NvYyIsIm1heWJlIiwiaXNvbGF0ZXNFcSIsImlBIiwiaUIiLCJkaXJlY3Rpb24iLCJpbm5lciIsInR5cGVzIiwiY29tcHV0ZUNoYXJUeXBlcyIsInJGcm9tIiwiclRvIiwiaXNvbGF0ZXMiLCJvdXRlclR5cGUiLCJpSSIsInByZXZUeXBlIiwicHJldlN0cm9uZyIsInByb2Nlc3NCcmFja2V0UGFpcnMiLCJvcHBvc2l0ZVR5cGUiLCJzSSIsImNvbnRleHQiLCJiciIsInNKIiwiZW1iZWQiLCJwcm9jZXNzTmV1dHJhbHMiLCJiZWZvcmVMIiwiYWZ0ZXJMIiwiakkiLCJmcm9tSiIsImVtaXRTcGFucyIsImJhc2VMZXZlbCIsIm91clR5cGUiLCJpQ2giLCJzYW1lRGlyIiwiaXNOdW0iLCJyZWN1cnNlIiwibG9jYWxMZXZlbCIsImlTY2FuIiwicnVuIiwiaXNvIiwidXB0byIsImRpclN3YXAiLCJjb21wdXRlU2VjdGlvbk9yZGVyIiwiY29tcHV0ZU9yZGVyIiwidHJpdmlhbE9yZGVyIiwibW92ZWRPdmVyIiwibW92ZVZpc3VhbGx5Iiwic3RhcnRJbmRleCIsImhlYWQiLCJzcGFuSSIsImJpZGlMZXZlbCIsInNwYW5FbmQiLCJuZXh0SSIsIm5leHRJbmRleCIsIm5leHRTcGFuIiwiYXV0b0RpcmVjdGlvbiIsImNsaWNrQWRkc1NlbGVjdGlvblJhbmdlIiwiZGVmaW5lIiwiZHJhZ01vdmVzU2VsZWN0aW9uJDEiLCJtb3VzZVNlbGVjdGlvblN0eWxlIiwiZXhjZXB0aW9uU2luayIsInVwZGF0ZUxpc3RlbmVyIiwiaW5wdXRIYW5kbGVyIiwiZm9jdXNDaGFuZ2VFZmZlY3QiLCJjbGlwYm9hcmRJbnB1dEZpbHRlciIsImNsaXBib2FyZE91dHB1dEZpbHRlciIsInBlckxpbmVUZXh0RGlyZWN0aW9uIiwiY29tYmluZSIsInZhbHVlcyIsIm5hdGl2ZVNlbGVjdGlvbkhpZGRlbiIsInNjcm9sbEhhbmRsZXIiLCJTY3JvbGxUYXJnZXQiLCJpc1NuYXBzaG90IiwibWFwIiwiY2hhbmdlcyIsImNsaXAiLCJzY3JvbGxJbnRvVmlldyIsInQiLCJzZXRFZGl0Q29udGV4dEZvcm1hdHRpbmciLCJsb2dFeGNlcHRpb24iLCJleGNlcHRpb24iLCJoYW5kbGVyIiwiZmFjZXQiLCJvbmVycm9yIiwiU3RyaW5nIiwiY29uc29sZSIsImVycm9yIiwibmV4dFBsdWdpbklEIiwidmlld1BsdWdpbiIsIlZpZXdQbHVnaW4iLCJpZCIsImRvbUV2ZW50SGFuZGxlcnMiLCJkb21FdmVudE9ic2VydmVycyIsImJ1aWxkRXh0ZW5zaW9ucyIsImV4dGVuc2lvbiIsImV2ZW50SGFuZGxlcnMiLCJldmVudE9ic2VydmVycyIsInByb3ZpZGUiLCJwbHVnaW4iLCJleHQiLCJwbHVnaW5JbnN0IiwiZnJvbUNsYXNzIiwiUGx1Z2luSW5zdGFuY2UiLCJtdXN0VXBkYXRlIiwidXBkYXRlIiwiZSIsImRlYWN0aXZhdGUiLCJlZGl0b3JBdHRyaWJ1dGVzIiwiY29udGVudEF0dHJpYnV0ZXMiLCJvdXRlckRlY29yYXRpb25zIiwiYXRvbWljUmFuZ2VzIiwiYmlkaUlzb2xhdGVkUmFuZ2VzIiwiZ2V0SXNvbGF0ZWRSYW5nZXMiLCJzZXRzIiwiRnVuY3Rpb24iLCJmcm9tRG9jIiwidG9Eb2MiLCJiaWRpSXNvbGF0ZSIsInNjcm9sbE1hcmdpbnMiLCJnZXRTY3JvbGxNYXJnaW5zIiwibSIsInN0eWxlTW9kdWxlIiwiQ2hhbmdlZFJhbmdlIiwiZnJvbUEiLCJ0b0EiLCJmcm9tQiIsInRvQiIsImFkZFRvU2V0IiwibWUiLCJleHRlbmRXaXRoUmFuZ2VzIiwiZGlmZiIsImRJIiwickkiLCJwb3NBIiwicG9zQiIsIlZpZXdVcGRhdGUiLCJ0cmFuc2FjdGlvbnMiLCJzdGFydFN0YXRlIiwidHIiLCJjb21wb3NlIiwiY2hhbmdlZFJhbmdlcyIsIml0ZXJDaGFuZ2VkUmFuZ2VzIiwidmlld3BvcnRDaGFuZ2VkIiwidmlld3BvcnRNb3ZlZCIsImhlaWdodENoYW5nZWQiLCJnZW9tZXRyeUNoYW5nZWQiLCJkb2NDaGFuZ2VkIiwiZm9jdXNDaGFuZ2VkIiwic2VsZWN0aW9uU2V0IiwiRG9jVmlldyIsImRvbUNoYW5nZWQiLCJoYXNDb21wb3NpdGlvbiIsIm1hcmtlZEZvckNvbXBvc2l0aW9uIiwiU2V0IiwiZWRpdENvbnRleHRGb3JtYXR0aW5nIiwibGFzdENvbXBvc2l0aW9uQWZ0ZXJDdXJzb3IiLCJtaW5XaWR0aCIsIm1pbldpZHRoRnJvbSIsIm1pbldpZHRoVG8iLCJpbXByZWNpc2VBbmNob3IiLCJpbXByZWNpc2VIZWFkIiwiZm9yY2VTZWxlY3Rpb24iLCJsYXN0VXBkYXRlIiwiRGF0ZSIsIm5vdyIsImNvbnRlbnRET00iLCJ1cGRhdGVEZWNvIiwidXBkYXRlSW5uZXIiLCJldmVyeSIsIm1hcFBvcyIsInVwZGF0ZUVkaXRDb250ZXh0Rm9ybWF0dGluZyIsInJlYWRDb21wb3NpdGlvbkF0IiwiaW5wdXRTdGF0ZSIsImNvbXBvc2luZyIsIm9ic2VydmVyIiwiZWRpdENvbnRleHQiLCJuZXdTZWwiLCJ0b3VjaGVzQ29tcG9zaXRpb24iLCJtYWluIiwiY29tcG9zaXRpb24iLCJmaW5kQ29tcG9zaXRpb25SYW5nZSIsImNsZWFyIiwibGluZXMiLCJwcmV2RGVjbyIsImRlY29EaWZmIiwiZmluZENoYW5nZWREZWNvIiwib2xkTGVuZ3RoIiwibXVzdE1lYXN1cmVDb250ZW50IiwidXBkYXRlQ2hpbGRyZW4iLCJjb250ZW50SGVpZ2h0IiwiZmxleEJhc2lzIiwic2VsZWN0aW9uUmFuZ2UiLCJmb3JFYWNoIiwiY1ZpZXciLCJnYXBzIiwidmlld3BvcnQiLCJ1cGRhdGVHYXBzIiwiY29tcExpbmUiLCJjb21wb3NpdGlvblZpZXciLCJmaXhDb21wb3NpdGlvbkRPTSIsImVmZmVjdCIsImVmZmVjdHMiLCJpcyIsIm1hcmtzIiwiZml4IiwiYyIsInVwZGF0ZVNlbGVjdGlvbiIsIm11c3RSZWFkIiwiZnJvbVBvaW50ZXIiLCJyZWFkU2VsZWN0aW9uUmFuZ2UiLCJhY3RpdmVFbHQiLCJhY3RpdmVFbGVtZW50IiwiZm9jdXNlZCIsInNlbGVjdGlvbk5vdEZvY3VzIiwidGFiSW5kZXgiLCJmb3JjZSIsImFuY2hvciIsIm1vdmVUb0xpbmUiLCJiZXR3ZWVuVW5lZGl0YWJsZSIsImR1bW15Iiwic3VwcHJlc3NXaWRnZXRDdXJzb3JDaGFuZ2UiLCJpblVuZWRpdGFibGUiLCJibHVyIiwicmF3U2VsIiwibmV4dFRvIiwibmV4dFRvVW5lZGl0YWJsZSIsImNvbGxhcHNlIiwiY2FyZXRCaWRpTGV2ZWwiLCJleHRlbmQiLCJyZW1vdmVBbGxSYW5nZXMiLCJzZXRTZWxlY3Rpb25SYW5nZSIsInNlbCIsInBvc0Zyb21ET00iLCJlbmZvcmNlQ3Vyc29yQXNzb2MiLCJtb2RpZnkiLCJsaW5lU3RhcnQiLCJuZXdSYW5nZSIsIm5ld1BvcyIsIm5lYXJlc3QiLCJkb21WaWV3IiwiYmVzdCIsImJlc3RQb3MiLCJjb29yZHNGb3JDaGFyIiwiY2hpbGRPZmYiLCJtZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzIiwiY29udGVudFdpZHRoIiwiaXNXaWRlciIsInNjcm9sbERPTSIsIndpZGVzdCIsInRleHREaXJlY3Rpb24iLCJjaGlsZFJlY3QiLCJ0ZXh0RGlyZWN0aW9uQXQiLCJtZWFzdXJlIiwidGV4dENvbnRlbnQiLCJyZW1vdmUiLCJjb21wdXRlQmxvY2tHYXBEZWNvIiwidnMiLCJ2aWV3cG9ydHMiLCJsaW5lQmxvY2tBdCIsImFsbERlY28iLCJkIiwiZHluYW1pYyIsImR5bmFtaWNPdXRlciIsIm91dGVyRGVjbyIsImxpbmVHYXBEZWNvIiwicmVmIiwibWFyZ2lucyIsInRhcmdldFJlY3QiLCJmaW5kQ29tcG9zaXRpb25Ob2RlIiwiaGVhZFBvcyIsInRleHRCZWZvcmUiLCJ0ZXh0QWZ0ZXIiLCJ0ZXh0Tm9kZSIsImRlc2NBZnRlciIsImRlc2NCZWZvcmUiLCJmb3VuZCIsInNsaWNlU3RyaW5nIiwiaW52IiwiaW52ZXJ0ZWREZXNjIiwicGFyZW50VmlldyIsIkRlY29yYXRpb25Db21wYXJhdG9yJDEiLCJEZWNvcmF0aW9uQ29tcGFyYXRvciIsImNvbXBhcmVSYW5nZSIsImNvbXBhcmVQb2ludCIsImJvdW5kQ2hhbmdlIiwiY29tcCIsImluc2lkZSIsInRvdWNoZWQiLCJncm91cEF0IiwiY2F0ZWdvcml6ZSIsImNoYXJDYXRlZ29yaXplciIsImxpbmVQb3MiLCJjYXQiLCJnZXRkeCIsImdldGR5IiwieU92ZXJsYXAiLCJ1cFRvcCIsInVwQm90IiwiZG9tUG9zQXRDb29yZHMiLCJjbG9zZXN0IiwiY2xvc2VzdFJlY3QiLCJjbG9zZXN0WCIsImNsb3Nlc3RZIiwiY2xvc2VzdE92ZXJsYXAiLCJhYm92ZSIsImJlbG93IiwiYWJvdmVSZWN0IiwiYmVsb3dSZWN0IiwiZHgiLCJkeSIsImRvbVBvc0luVGV4dCIsImNsaXBYIiwiY2xvc2VzdE9mZnNldCIsImNsb3Nlc3REWSIsImdlbmVyYWxTaWRlIiwicmVjdEJlZm9yZSIsInBvc0F0Q29vcmRzIiwiY29vcmRzIiwiZG9jVG9wIiwicGFkZGluZ1RvcCIsImRvY0hlaWdodCIsInlPZmZzZXQiLCJoYWxmTGluZSIsImJvdW5jZWQiLCJlbGVtZW50QXRIZWlnaHQiLCJwb3NBdENvb3Jkc0ltcHJlY2lzZSIsImVsZW1lbnRGcm9tUG9pbnQiLCJlbGVtZW50IiwiY2FyZXRQb3NpdGlvbkZyb21Qb2ludCIsIm9mZnNldE5vZGUiLCJjYXJldFJhbmdlRnJvbVBvaW50Iiwic3RhcnRDb250YWluZXIiLCJpc1N1c3BpY2lvdXNTYWZhcmlDYXJldFJlc3VsdCIsImlzU3VzcGljaW91c0Nocm9tZUNhcmV0UmVzdWx0IiwiY29udGVudFJlY3QiLCJpbnRvIiwicm91bmQiLCJkZWZhdWx0Q2hhcmFjdGVyV2lkdGgiLCJsaW5lV3JhcHBpbmciLCJkZWZhdWx0TGluZUhlaWdodCIsImZsb29yIiwibGluZUxlbmd0aCIsInNsaWNlRG9jIiwiYmxvY2tBdCIsImlzQXJyYXkiLCJtb3ZlVG9MaW5lQm91bmRhcnkiLCJpbmNsdWRlV3JhcCIsIndpZGdldExpbmVCcmVha3MiLCJjb29yZHNBdFBvcyIsImVkaXRvclJlY3QiLCJtb3ZlQnlDaGFyIiwiYnkiLCJiaWRpU3BhbnMiLCJjaGVjayIsImNoYXIiLCJudW1iZXIiLCJ2aXN1YWxMaW5lU2lkZSIsImJ5R3JvdXAiLCJuZXh0Q2F0IiwiU3BhY2UiLCJtb3ZlVmVydGljYWxseSIsImRpc3RhbmNlIiwic3RhcnRQb3MiLCJnb2FsIiwiZ29hbENvbHVtbiIsInN0YXJ0WSIsInN0YXJ0Q29vcmRzIiwiZG9jdW1lbnRUb3AiLCJyZXNvbHZlZEdvYWwiLCJleHRyYSIsImN1clkiLCJjaGFyUmVjdCIsInNraXBBdG9taWNSYW5nZXMiLCJhdG9tcyIsIm1vdmVkIiwiYmV0d2VlbiIsInNraXBBdG9tcyIsIm9sZFBvcyIsImYiLCJMaW5lQnJlYWtQbGFjZWhvbGRlciIsIkRPTVJlYWRlciIsInBvaW50cyIsImxpbmVTZXBhcmF0b3IiLCJyZWFkUmFuZ2UiLCJmaW5kUG9pbnRCZWZvcmUiLCJvbGRMZW4iLCJyZWFkTm9kZSIsIm5leHRWaWV3IiwicmVhZFRleHROb2RlIiwicmUiLCJuZXh0QnJlYWsiLCJicmVha1NpemUiLCJmcm9tVmlldyIsImZpbmRQb2ludEluc2lkZSIsImlzQXRFbmQiLCJET01Qb2ludCIsIkRPTUNoYW5nZSIsInR5cGVPdmVyIiwiYm91bmRzIiwiaUhlYWQiLCJpQW5jaG9yIiwicmVhZE9ubHkiLCJzZWxQb2ludHMiLCJzZWxlY3Rpb25Qb2ludHMiLCJyZWFkZXIiLCJzZWxlY3Rpb25Gcm9tUG9pbnRzIiwib2ZmRnJvbSIsIm9mZlRvIiwic2luZ2xlIiwiYXBwbHlET01DaGFuZ2UiLCJkb21DaGFuZ2UiLCJjaGFuZ2UiLCJsYXN0S2V5IiwibGFzdEtleVRpbWUiLCJsYXN0S2V5Q29kZSIsInByZWZlcnJlZFBvcyIsInByZWZlcnJlZFNpZGUiLCJmaW5kRGlmZiIsImhhc0ZvY3VzIiwiZ2V0QXR0cmlidXRlIiwiYXBwbHlET01DaGFuZ2VJbm5lciIsInVzZXJFdmVudCIsImxhc3RTZWxlY3Rpb25UaW1lIiwibGFzdFNlbGVjdGlvbk9yaWdpbiIsImRpc3BhdGNoIiwiZmx1c2hJT1NLZXkiLCJkZWZhdWx0VHIiLCJkZWZhdWx0SW5zZXJ0IiwiYXBwbHlEZWZhdWx0SW5zZXJ0IiwiaCIsInJlcGxhY2VTZWxlY3Rpb24iLCJ0b1RleHQiLCJtYWluU2VsIiwibmV3TGVuZ3RoIiwicmVwbGFjZWQiLCJjb21wb3NpdGlvblJhbmdlIiwic2l6ZSIsImNoYW5nZUJ5UmFuZ2UiLCJyYW5nZUNoYW5nZXMiLCJzZWxPZmYiLCJjb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UiLCJjb21wb3NpdGlvbkVuZGVkQXQiLCJjb21wb3NpdGlvbkZpcnN0Q2hhbmdlIiwibWluTGVuIiwiYWRqdXN0IiwibW92ZSIsIklucHV0U3RhdGUiLCJzZXRTZWxlY3Rpb25PcmlnaW4iLCJvcmlnaW4iLCJsYXN0VG91Y2hUaW1lIiwibGFzdEZvY3VzVGltZSIsImxhc3RTY3JvbGxUb3AiLCJsYXN0U2Nyb2xsTGVmdCIsInBlbmRpbmdJT1NLZXkiLCJ0YWJGb2N1c01vZGUiLCJsYXN0Q29udGV4dE1lbnUiLCJzY3JvbGxIYW5kbGVycyIsImhhbmRsZXJzIiwiY29tcG9zaXRpb25QZW5kaW5nS2V5IiwibW91c2VTZWxlY3Rpb24iLCJkcmFnZ2VkQ29udGVudCIsImhhbmRsZUV2ZW50IiwiYmluZCIsIm5vdGlmaWVkRm9jdXNlZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJmaXJlZm94Q29weUN1dEhhY2siLCJldmVudEJlbG9uZ3NUb0VkaXRvciIsImlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uIiwia2V5ZG93biIsInVwZGF0ZVN0YXRlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwicnVuSGFuZGxlcnMiLCJvYnNlcnZlcnMiLCJwcmV2ZW50RGVmYXVsdCIsImVuc3VyZUhhbmRsZXJzIiwicGx1Z2lucyIsImNvbXB1dGVIYW5kbGVycyIsInBhc3NpdmUiLCJleGlzdHMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibW9kaWZpZXJDb2RlcyIsImRlbGF5QW5kcm9pZEtleSIsInBlbmRpbmciLCJQZW5kaW5nS2V5cyIsIkVtYWNzeVBlbmRpbmdLZXlzIiwic2V0VGltZW91dCIsImZvcmNlRmx1c2giLCJzdGFydE1vdXNlU2VsZWN0aW9uIiwiYmluZEhhbmRsZXIiLCJyZWNvcmQiLCJpbnB1dFR5cGUiLCJkcmFnU2Nyb2xsTWFyZ2luIiwiZHJhZ1Njcm9sbFNwZWVkIiwiY2xpZW50WCIsImNsaWVudFkiLCJNb3VzZVNlbGVjdGlvbiIsInN0YXJ0RXZlbnQiLCJtdXN0U2VsZWN0Iiwic2Nyb2xsU3BlZWQiLCJzY3JvbGxpbmciLCJsYXN0RXZlbnQiLCJzY3JvbGxQYXJlbnRzIiwibXVsdGlwbGUiLCJhbGxvd011bHRpcGxlU2VsZWN0aW9ucyIsImFkZHNTZWxlY3Rpb25SYW5nZSIsImRyYWdnaW5nIiwiaXNJblByaW1hcnlTZWxlY3Rpb24iLCJnZXRDbGlja1R5cGUiLCJzZWxlY3QiLCJidXR0b25zIiwic3giLCJzeSIsInNldFNjcm9sbFNwZWVkIiwic2V0SW50ZXJ2YWwiLCJzY3JvbGwiLCJjbGVhckludGVydmFsIiwidXBkYXRlZCIsIm1haW5JbmRleCIsImlzVXNlckV2ZW50IiwiZHJhZ01vdmVzU2VsZWN0aW9uIiwicmFuZ2VDb3VudCIsImdldFJhbmdlQXQiLCJidWJibGVzIiwiYnJva2VuQ2xpcGJvYXJkQVBJIiwiY2FwdHVyZVBhc3RlIiwiZG9QYXN0ZSIsInRleHRGaWx0ZXIiLCJmaWx0ZXIiLCJpbnB1dCIsImJ5TGluZSIsImxpbmV3aXNlIiwibGFzdExpbmV3aXNlQ29weSIsImxhc3RMaW5lIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsIm1vdXNlZG93biIsImZsdXNoIiwibWFrZVN0eWxlIiwiYnV0dG9uIiwiYmFzaWNNb3VzZVNlbGVjdGlvbiIsIm11c3RGb2N1cyIsIm1vdXNlU2VsIiwicmFuZ2VGb3JDbGljayIsInZpc3VhbCIsImZpbmRQb3NpdGlvblNpZGUiLCJxdWVyeVBvcyIsIkJhZE1vdXNlRGV0YWlsIiwibGFzdE1vdXNlRG93biIsImxhc3RNb3VzZURvd25Db3VudCIsImxhc3RNb3VzZURvd25UaW1lIiwiZGV0YWlsIiwibGFzdFRpbWUiLCJzdGFydFNlbCIsInJlbW92ZWQiLCJzdGFydFJhbmdlIiwicmVtb3ZlUmFuZ2VBcm91bmQiLCJkcmFnc3RhcnQiLCJkcmFnZ2FibGUiLCJkYXRhVHJhbnNmZXIiLCJzZXREYXRhIiwiZWZmZWN0QWxsb3dlZCIsImRyYWdlbmQiLCJkcm9wVGV4dCIsImRpcmVjdCIsImRyb3BQb3MiLCJkZWwiLCJpbnMiLCJkcm9wIiwiZmlsZXMiLCJyZWFkIiwiZmluaXNoRmlsZSIsInMiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwicmVhZEFzVGV4dCIsImdldERhdGEiLCJwYXN0ZSIsImRhdGEiLCJjbGlwYm9hcmREYXRhIiwiY2FwdHVyZUNvcHkiLCJzZWxlY3Rpb25FbmQiLCJzZWxlY3Rpb25TdGFydCIsImNvcGllZFJhbmdlIiwiY29weSIsImN1dCIsImNsZWFyRGF0YSIsImlzRm9jdXNDaGFuZ2UiLCJmb2N1c0NoYW5nZVRyYW5zYWN0aW9uIiwiZ2V0RWZmZWN0IiwiYW5ub3RhdGlvbnMiLCJ1cGRhdGVGb3JGb2N1c0NoYW5nZSIsImNsZWFyU2VsZWN0aW9uUmFuZ2UiLCJjb21wb3NpdGlvbnN0YXJ0IiwiY29tcG9zaXRpb251cGRhdGUiLCJjb21wb3NpdGlvbmVuZCIsInBlbmRpbmdSZWNvcmRzIiwiZmx1c2hTb29uIiwiY29udGV4dG1lbnUiLCJiZWZvcmVpbnB1dCIsImdldFRhcmdldFJhbmdlcyIsInBvc0F0RE9NIiwiZW5kQ29udGFpbmVyIiwiZW5kT2Zmc2V0Iiwic3RhcnRWaWV3SGVpZ2h0IiwiYXBwbGllZEZpcmVmb3hIYWNrIiwiaGFzIiwid3JhcHBpbmdXaGl0ZVNwYWNlIiwiaGVpZ2h0Q2hhbmdlRmxhZyIsImNsZWFySGVpZ2h0Q2hhbmdlRmxhZyIsIkhlaWdodE9yYWNsZSIsImhlaWdodFNhbXBsZXMiLCJoZWlnaHRGb3JHYXAiLCJjZWlsIiwiaGVpZ2h0Rm9yTGluZSIsInNldERvYyIsIm11c3RSZWZyZXNoRm9yV3JhcHBpbmciLCJ3aGl0ZVNwYWNlIiwibXVzdFJlZnJlc2hGb3JIZWlnaHRzIiwibGluZUhlaWdodHMiLCJuZXdIZWlnaHQiLCJyZWZyZXNoIiwia25vd25IZWlnaHRzIiwiTWVhc3VyZWRIZWlnaHRzIiwiaGVpZ2h0cyIsIm1vcmUiLCJCbG9ja0luZm8iLCJfY29udGVudCIsIlF1ZXJ5VHlwZSIsIkVwc2lsb24iLCJIZWlnaHRNYXAiLCJvdXRkYXRlZCIsInNldEhlaWdodCIsIm5vZGVzIiwiZGVjb21wb3NlTGVmdCIsImRlY29tcG9zZVJpZ2h0IiwiYXBwbHlDaGFuZ2VzIiwib2xkRG9jIiwib3JhY2xlIiwiQnlQb3NOb0hlaWdodCIsIk5vZGVCdWlsZGVyIiwidXBkYXRlSGVpZ2h0IiwiSGVpZ2h0TWFwVGV4dCIsImJyZWFrIiwiYnJrIiwiSGVpZ2h0TWFwQnJhbmNoIiwib2xkIiwidmFsIiwiSGVpZ2h0TWFwQmxvY2siLCJfaGVpZ2h0IiwiX29yYWNsZSIsIl92YWx1ZSIsIl90eXBlIiwiZm9yRWFjaExpbmUiLCJfZm9yY2UiLCJtZWFzdXJlZCIsImNvbGxhcHNlZCIsIndpZGdldEhlaWdodCIsImJyZWFrcyIsIkhlaWdodE1hcEdhcCIsImhlaWdodE1ldHJpY3MiLCJmaXJzdExpbmUiLCJwZXJMaW5lIiwicGVyQ2hhciIsInRvdGFsUGVyTGluZSIsImd1ZXNzIiwibGluZVRvcCIsIkJ5SGVpZ2h0IiwibGluZXNBYm92ZSIsImZpcnN0IiwidW5zaGlmdCIsInNpbmdsZUhlaWdodCIsIm1pZCIsInJpZ2h0VG9wIiwicmlnaHRPZmZzZXQiLCJzdWJRdWVyeSIsIkJ5UG9zIiwicmlnaHRTdGFydCIsImJhbGFuY2VkIiwibWVyZ2VHYXBzIiwicmViYWxhbmNlIiwiYXJvdW5kIiwicmVsZXZhbnRXaWRnZXRIZWlnaHQiLCJsaW5lRW5kIiwiY292ZXJpbmciLCJ3cml0dGVuVG8iLCJpc0NvdmVyZWQiLCJhZGRCbG9jayIsImVudGVyTGluZSIsImJsYW5rQ29udGVudCIsImdhcCIsImVuc3VyZUxpbmUiLCJoZWlnaHRSZWxldmFudERlY29DaGFuZ2VzIiwidmlzaWJsZVBpeGVsUmFuZ2UiLCJvdmVyZmxvdyIsInBhcmVudFJlY3QiLCJvZmZzZXRQYXJlbnQiLCJpbldpbmRvdyIsImZ1bGxQaXhlbFJhbmdlIiwiTGluZUdhcCIsImRpc3BsYXlTaXplIiwic2FtZSIsImdBIiwiZ0IiLCJkcmF3Iiwid3JhcHBpbmciLCJMaW5lR2FwV2lkZ2V0IiwidmVydGljYWwiLCJkaXNwbGF5IiwiVmlld1N0YXRlIiwicGl4ZWxWaWV3cG9ydCIsImluVmlldyIsInBhZGRpbmdCb3R0b20iLCJjb250ZW50RE9NV2lkdGgiLCJjb250ZW50RE9NSGVpZ2h0IiwiZWRpdG9ySGVpZ2h0IiwiZWRpdG9yV2lkdGgiLCJzY3JvbGxlZFRvQm90dG9tIiwic2Nyb2xsQW5jaG9yUG9zIiwic2Nyb2xsQW5jaG9ySGVpZ2h0Iiwic2NhbGVyIiwiSWRTY2FsZXIiLCJzY3JvbGxUYXJnZXQiLCJwcmludGluZyIsImRlZmF1bHRUZXh0RGlyZWN0aW9uIiwidmlzaWJsZVJhbmdlcyIsIm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MiLCJndWVzc1dyYXBwaW5nIiwic3RhdGVEZWNvIiwiaGVpZ2h0TWFwIiwiZ2V0Vmlld3BvcnQiLCJ1cGRhdGVGb3JWaWV3cG9ydCIsInVwZGF0ZVZpZXdwb3J0TGluZXMiLCJsaW5lR2FwcyIsImVuc3VyZUxpbmVHYXBzIiwiY29tcHV0ZVZpc2libGVSYW5nZXMiLCJWaWV3cG9ydCIsInVwZGF0ZVNjYWxlciIsIkJpZ1NjYWxlciIsInZpZXdwb3J0TGluZXMiLCJzY2FsZUJsb2NrIiwiY29udGVudENoYW5nZXMiLCJoZWlnaHRDaGFuZ2VzIiwicHJldkhlaWdodCIsInNjcm9sbEFuY2hvciIsInNjcm9sbEFuY2hvckF0IiwibWFwVmlld3BvcnQiLCJ2aWV3cG9ydElzQXBwcm9wcmlhdGUiLCJ2aWV3cG9ydENoYW5nZSIsInVwZGF0ZUxpbmVHYXBzIiwibWFwTGluZUdhcHMiLCJkb21SZWN0IiwibWVhc3VyZUNvbnRlbnQiLCJwYXJzZUludCIsImRUb3AiLCJkQm90dG9tIiwidmlzaWJsZVRvcCIsImZyb21ET00iLCJ2aXNpYmxlQm90dG9tIiwibWFyZ2luVG9wIiwidmlld0hlaWdodCIsInRvcFBvcyIsIm1hcHBlZCIsInRvdWNoZXNSYW5nZSIsImN1cnJlbnQiLCJtYXlNZWFzdXJlIiwiaGFsZk1hcmdpbiIsImRvdWJsZU1hcmdpbiIsImFkZEdhcCIsInN0cnVjdHVyZSIsImF2b2lkIiwiZ2FwU2l6ZSIsImNoZWNrTGluZSIsImxpbmVTdHJ1Y3R1cmUiLCJ0b3RhbCIsInZpZXdGcm9tIiwidmlld1RvIiwibWFyZ2luSGVpZ2h0IiwiYm90IiwidGFyZ2V0RnJhYyIsImZpbmRGcmFjdGlvbiIsInNwYWNlRnJhYyIsImZpbmRQb3NpdGlvbiIsIm1hcmdpbldpZHRoIiwiaG9yaXpPZmZzZXQiLCJweExlZnQiLCJweFJpZ2h0IiwiZnJhY3Rpb24iLCJudyIsImxpbmVCbG9ja0F0SGVpZ2h0IiwicmF0aW8iLCJjb3VudGVkIiwiYXJyYXkiLCJuIiwic2NhbGUiLCJ2cEhlaWdodCIsImRvbUJhc2UiLCJkb21Ub3AiLCJkb21Cb3R0b20iLCJvYmoiLCJiVG9wIiwiYkJvdHRvbSIsInRoZW1lIiwic3RycyIsImRhcmtUaGVtZSIsImJhc2VUaGVtZUlEIiwibmV3TmFtZSIsImJhc2VMaWdodElEIiwiYmFzZURhcmtJRCIsImxpZ2h0RGFya0lEcyIsImJ1aWxkVGhlbWUiLCJzY29wZXMiLCJiYXNlVGhlbWUkMSIsImJveFNpemluZyIsIm91dGxpbmUiLCJmbGV4RGlyZWN0aW9uIiwiYWxpZ25JdGVtcyIsImZvbnRGYW1pbHkiLCJvdmVyZmxvd1giLCJ6SW5kZXgiLCJvdmVyZmxvd0FuY2hvciIsImZsZXhHcm93IiwiZmxleFNocmluayIsIndvcmRXcmFwIiwibWluSGVpZ2h0IiwicGFkZGluZyIsIldlYmtpdFVzZXJNb2RpZnkiLCJ3aGl0ZVNwYWNlX2ZhbGxiYWNrIiwid29yZEJyZWFrIiwib3ZlcmZsb3dXcmFwIiwiY2FyZXRDb2xvciIsImNvbnRhaW4iLCJiYWNrZ3JvdW5kIiwicG9pbnRlckV2ZW50cyIsImFuaW1hdGlvbiIsIm9wYWNpdHkiLCJib3JkZXJMZWZ0IiwibWFyZ2luTGVmdCIsImJvcmRlckxlZnRDb2xvciIsInVuaWNvZGVCaWRpIiwiYmFja2dyb3VuZENvbG9yIiwiY29sb3IiLCJpbnNldElubGluZVN0YXJ0IiwiYm9yZGVyUmlnaHQiLCJ0ZXh0QWxpZ24iLCJib3JkZXJCb3R0b20iLCJib3JkZXJUb3AiLCJ2ZXJ0aWNhbEFsaWduIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFNpemUiLCJiYWNrZ3JvdW5kUmVwZWF0IiwiZm9udFNpemUiLCJib3JkZXJSYWRpdXMiLCJib3JkZXIiLCJvYnNlcnZlT3B0aW9ucyIsImNoYXJhY3RlckRhdGEiLCJzdWJ0cmVlIiwiY2hhcmFjdGVyRGF0YU9sZFZhbHVlIiwidXNlQ2hhckRhdGEiLCJET01PYnNlcnZlciIsInNlbGVjdGlvbkNoYW5nZWQiLCJkZWxheWVkRmx1c2giLCJyZXNpemVUaW1lb3V0IiwicXVldWUiLCJkZWxheWVkQW5kcm9pZEtleSIsImZsdXNoaW5nQW5kcm9pZEtleSIsImxhc3RDaGFuZ2UiLCJzY3JvbGxUYXJnZXRzIiwiaW50ZXJzZWN0aW9uIiwicmVzaXplU2Nyb2xsIiwiaW50ZXJzZWN0aW5nIiwiZ2FwSW50ZXJzZWN0aW9uIiwicHJpbnRRdWVyeSIsInBhcmVudENoZWNrIiwiTXV0YXRpb25PYnNlcnZlciIsIm11dGF0aW9ucyIsIm11dCIsInJlbW92ZWROb2RlcyIsIm9sZFZhbHVlIiwiRWRpdENvbnRleHQiLCJFRElUX0NPTlRFWFQiLCJFZGl0Q29udGV4dE1hbmFnZXIiLCJvbkNoYXJEYXRhIiwicHJldlZhbHVlIiwib25TZWxlY3Rpb25DaGFuZ2UiLCJvblJlc2l6ZSIsIm9uUHJpbnQiLCJvblNjcm9sbCIsIm1hdGNoTWVkaWEiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJhZGRXaW5kb3dMaXN0ZW5lcnMiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsImVudHJpZXMiLCJsaXN0ZW5Gb3JTY3JvbGwiLCJpbnRlcnNlY3Rpb25SYXRpbyIsIm9uU2Nyb2xsQ2hhbmdlZCIsImNyZWF0ZUV2ZW50IiwidGhyZXNob2xkIiwicmVxdWVzdE1lYXN1cmUiLCJtZWFzdXJlUmVxIiwibWF0Y2hlcyIsImciLCJkaXNjb25uZWN0Iiwid2FzQ2hhbmdlZCIsInNhZmFyaVNlbGVjdGlvblJhbmdlSGFjayIsImxvY2FsIiwicHJvY2Vzc1JlY29yZHMiLCJjbGVhckRlbGF5ZWRBbmRyb2lkS2V5IiwiZmx1c2hlZCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwidGFrZVJlY29yZHMiLCJyZWNvcmRzIiwicmVhZE11dGF0aW9uIiwicmVhZENoYW5nZSIsInJlYWRTZWxlY3Rpb24iLCJoYW5kbGVkIiwicmVjIiwiY2hpbGRCZWZvcmUiLCJmaW5kQ2hpbGQiLCJjaGlsZEFmdGVyIiwic2V0V2luZG93IiwicmVtb3ZlV2luZG93TGlzdGVuZXJzIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIl9jIiwiY2xlYXJUaW1lb3V0IiwiY3VyVmlldyIsImJ1aWxkU2VsZWN0aW9uUmFuZ2VGcm9tUmFuZ2UiLCJjdXJBbmNob3IiLCJnZXRDb21wb3NlZFJhbmdlcyIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsImV4ZWNDb21tYW5kIiwicGVuZGluZ0NvbnRleHRDaGFuZ2UiLCJyZXNldFJhbmdlIiwidG9Db250ZXh0UG9zIiwidGV4dHVwZGF0ZSIsInRvRWRpdG9yUG9zIiwidXBkYXRlUmFuZ2VTdGFydCIsInVwZGF0ZVJhbmdlRW5kIiwiY29udGV4dEJhc2UiLCJlZGl0b3JCYXNlIiwiZHJpZnRlZCIsIm5ld0xlbiIsInJldmVydFBlbmRpbmciLCJzZXRTZWxlY3Rpb24iLCJjaGFyYWN0ZXJib3VuZHN1cGRhdGUiLCJyYW5nZVN0YXJ0IiwicmFuZ2VFbmQiLCJET01SZWN0IiwidXBkYXRlQ2hhcmFjdGVyQm91bmRzIiwidGV4dGZvcm1hdHVwZGF0ZSIsImZvcm1hdCIsImdldFRleHRGb3JtYXRzIiwibGluZVN0eWxlIiwidW5kZXJsaW5lU3R5bGUiLCJ0aGlja25lc3MiLCJ1bmRlcmxpbmVUaGlja25lc3MiLCJyZXNldCIsInVwZGF0ZUNvbnRyb2xCb3VuZHMiLCJ1cGRhdGVTZWxlY3Rpb25Cb3VuZHMiLCJhcHBseUVkaXRzIiwiYWJvcnQiLCJpdGVyQ2hhbmdlcyIsIl9mcm9tQiIsIl90b0IiLCJ1cGRhdGVUZXh0IiwicmV2ZXJ0ZWQiLCJyYW5nZUlzVmFsaWQiLCJjb250ZXh0UG9zIiwiY2xpcExlbiIsImVkaXRvclBvcyIsIkVkaXRvclZpZXciLCJjb21wb3NpdGlvblN0YXJ0ZWQiLCJfcm9vdCIsImNvbmZpZyIsInBsdWdpbk1hcCIsIk1hcCIsImVkaXRvckF0dHJzIiwiY29udGVudEF0dHJzIiwiYmlkaUNhY2hlIiwiZGVzdHJveWVkIiwibWVhc3VyZVNjaGVkdWxlZCIsIm1lYXN1cmVSZXF1ZXN0cyIsImFubm91bmNlRE9NIiwiZGlzcGF0Y2hUcmFuc2FjdGlvbnMiLCJ0cnMiLCJzY3JvbGxUbyIsIm1vdW50U3R5bGVzIiwiZm9udHMiLCJyZWFkeSIsInJlZHJhd24iLCJhdHRyc0NoYW5nZWQiLCJmb2N1c0ZsYWciLCJkaXNwYXRjaEZvY3VzIiwiYW5ub3RhdGlvbiIsInBlbmRpbmdLZXkiLCJwaHJhc2VzIiwic2V0U3RhdGUiLCJDYWNoZWRPcmRlciIsInVwZGF0ZVBsdWdpbnMiLCJzdHlsZU1vZHVsZXMiLCJzaG93QW5ub3VuY2VtZW50cyIsImRvY1ZpZXdVcGRhdGUiLCJsaXN0ZW5lciIsIm5ld1N0YXRlIiwiaGFkRm9jdXMiLCJwcmV2U3BlY3MiLCJzcGVjcyIsIm5ld1BsdWdpbnMiLCJzRE9NIiwid2FybiIsIm1lYXN1cmluZyIsIkJhZE1lYXN1cmUiLCJ3cml0ZSIsIm5ld0FuY2hvckhlaWdodCIsInRoZW1lQ2xhc3NlcyIsImF0dHJzRnJvbUZhY2V0Iiwic3BlbGxjaGVjayIsImF1dG9jb3JyZWN0IiwiYXV0b2NhcGl0YWxpemUiLCJ3cml0aW5nc3VnZ2VzdGlvbnMiLCJ0cmFuc2xhdGUiLCJjb250ZW50ZWRpdGFibGUiLCJyb2xlIiwiY2hhbmdlZENvbnRlbnQiLCJjaGFuZ2VkRWRpdG9yIiwiYW5ub3VuY2UiLCJkaXYiLCJub25jZSIsImNzcE5vbmNlIiwibW91bnQiLCJyZXZlcnNlIiwicmVhZE1lYXN1cmVkIiwicmVxdWVzdCIsImtub3duIiwiZG9jdW1lbnRQYWRkaW5nIiwidmlld3BvcnRMaW5lQmxvY2tzIiwibW92ZUJ5R3JvdXAiLCJpbml0aWFsIiwiTWF4QmlkaUxpbmUiLCJlbnRyeSIsImZyZXNoIiwic2V0Um9vdCIsInNjcm9sbFNuYXBzaG90Iiwic2V0VGFiRm9jdXNNb2RlIiwicHJlZml4IiwiZGFyayIsImJhc2VUaGVtZSIsImxvd2VzdCIsImZpbmRGcm9tRE9NIiwicXVlcnlTZWxlY3RvciIsImNhY2hlIiwibGFzdERpciIsInNvdXJjZXMiLCJjdXJyZW50UGxhdGZvcm0iLCJub3JtYWxpemVLZXlOYW1lIiwicGFydHMiLCJhbHQiLCJjdHJsIiwibWV0YSIsIm1vZCIsIm1vZGlmaWVycyIsImhhbmRsZUtleUV2ZW50cyIsImRlZmF1bHQiLCJnZXRLZXltYXAiLCJrZXltYXAiLCJlbmFibGVzIiwiS2V5bWFwcyIsIldlYWtNYXAiLCJiaW5kaW5ncyIsImJ1aWxkS2V5bWFwIiwicmVkdWNlIiwicnVuU2NvcGVIYW5kbGVycyIsInNjb3BlIiwic3RvcmVkUHJlZml4IiwiUHJlZml4VGltZW91dCIsImJvdW5kIiwiaXNQcmVmaXgiLCJjaGVja1ByZWZpeCIsImNvbW1hbmQiLCJzdG9wUHJvcGFnYXRpb24iLCJzY29wZU9iaiIsImsiLCJvdXJPYmoiLCJmdWxsIiwiYmluZGluZyIsIl9hbnkiLCJhbnkiLCJjdXJyZW50S2V5RXZlbnQiLCJjaGFyQ29kZSIsImlzQ2hhciIsInByZXZlbnRlZCIsInJhbiIsInJ1bkZvciIsImNtZCIsImJhc2VOYW1lIiwic2hpZnROYW1lIiwiUmVjdGFuZ2xlTWFya2VyIiwiZm9yUmFuZ2UiLCJnZXRCYXNlIiwicmVjdGFuZ2xlc0ZvclJhbmdlIiwid3JhcHBlZExpbmUiLCJsaW5lRWx0IiwibGVmdFNpZGUiLCJwYWRkaW5nTGVmdCIsInRleHRJbmRlbnQiLCJyaWdodFNpZGUiLCJwYWRkaW5nUmlnaHQiLCJzdGFydEJsb2NrIiwiZW5kQmxvY2siLCJ2aXN1YWxTdGFydCIsInZpc3VhbEVuZCIsInBpZWNlcyIsImRyYXdGb3JMaW5lIiwiZHJhd0ZvcldpZGdldCIsInBpZWNlIiwiaG9yaXpvbnRhbCIsImFkZFNwYW4iLCJmcm9tT3BlbiIsInRvT3BlbiIsImZyb21Db29yZHMiLCJ0b0Nvb3JkcyIsImVuZFBvcyIsImRvY0xpbmUiLCJzcGFuRnJvbSIsInNwYW5UbyIsInNhbWVNYXJrZXIiLCJMYXllclZpZXciLCJsYXllciIsImRyYXduIiwic2V0T3JkZXIiLCJsYXllck9yZGVyIiwidXBkYXRlT25Eb2NWaWV3VXBkYXRlIiwibWFya2VycyIsInRyYW5zZm9ybSIsIm9sZEkiLCJtYXJrZXIiLCJDYW5IaWRlUHJpbWFyeSIsInNlbGVjdGlvbkNvbmZpZyIsImNvbmZpZ3MiLCJjdXJzb3JCbGlua1JhdGUiLCJkcmF3UmFuZ2VDdXJzb3IiLCJkcmF3U2VsZWN0aW9uIiwiY3Vyc29yTGF5ZXIiLCJzZWxlY3Rpb25MYXllciIsImhpZGVOYXRpdmVTZWxlY3Rpb24iLCJnZXREcmF3U2VsZWN0aW9uQ29uZmlnIiwiY29uZmlnQ2hhbmdlZCIsImNvbmYiLCJjdXJzb3JzIiwicHJpbSIsImFuaW1hdGlvbk5hbWUiLCJjb25mQ2hhbmdlIiwic2V0QmxpbmtSYXRlIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJ0aGVtZVNwZWMiLCJoaWdoZXN0Iiwic2V0RHJvcEN1cnNvclBvcyIsIm1hcHBpbmciLCJkcm9wQ3Vyc29yUG9zIiwiZHJhd0Ryb3BDdXJzb3IiLCJyZWFkUG9zIiwiZHJhd0N1cnNvciIsImN1cnNvclBvcyIsImZpZWxkIiwib3V0ZXIiLCJzZXREcm9wUG9zIiwiZHJhZ292ZXIiLCJkcmFnbGVhdmUiLCJyZWxhdGVkVGFyZ2V0IiwiZHJvcEN1cnNvciIsIml0ZXJNYXRjaGVzIiwibGFzdEluZGV4IiwiaXRlclJhbmdlIiwibWF0Y2hSYW5nZXMiLCJtYXhMZW5ndGgiLCJ2aXNpYmxlIiwiTWF0Y2hEZWNvcmF0b3IiLCJyZWdleHAiLCJkZWNvcmF0aW9uIiwiZGVjb3JhdGUiLCJib3VuZGFyeSIsImdsb2JhbCIsImFkZE1hdGNoIiwibWF0Y2giLCJfdmlldyIsImNyZWF0ZURlY28iLCJjaGFuZ2VGcm9tIiwiY2hhbmdlVG8iLCJfZiIsIl90IiwidXBkYXRlUmFuZ2UiLCJ1cGRhdGVGcm9tIiwidXBkYXRlVG8iLCJmcm9tTGluZSIsInRvTGluZSIsImZpbHRlckZyb20iLCJmaWx0ZXJUbyIsIlVuaWNvZGVSZWdleHBTdXBwb3J0IiwidW5pY29kZSIsIlNwZWNpYWxzIiwiUmVnRXhwIiwiTmFtZXMiLCJfc3VwcG9ydHNUYWJTaXplIiwic3VwcG9ydHNUYWJTaXplIiwic3R5bGVzIiwiTW96VGFiU2l6ZSIsInNwZWNpYWxDaGFyQ29uZmlnIiwicmVuZGVyIiwic3BlY2lhbENoYXJzIiwiYWRkU3BlY2lhbENoYXJzIiwicmVwbGFjZVRhYnMiLCJoaWdobGlnaHRTcGVjaWFsQ2hhcnMiLCJzcGVjaWFsQ2hhclBsdWdpbiIsIl9wbHVnaW4iLCJkZWNvcmF0aW9uQ2FjaGUiLCJkZWNvcmF0b3IiLCJtYWtlRGVjb3JhdG9yIiwiY29sIiwiVGFiV2lkZ2V0IiwiU3BlY2lhbENoYXJXaWRnZXQiLCJEZWZhdWx0UGxhY2Vob2xkZXIiLCJwbGFjZWhvbGRlciQxIiwiZnJvbUNoYXJDb2RlIiwicGgiLCJkZXNjIiwicGhyYXNlIiwidGl0bGUiLCJzY3JvbGxQYXN0RW5kIiwiaGlnaGxpZ2h0QWN0aXZlTGluZSIsImFjdGl2ZUxpbmVIaWdobGlnaHRlciIsImxpbmVEZWNvIiwiZ2V0RGVjbyIsImxhc3RMaW5lU3RhcnQiLCJQbGFjZWhvbGRlciIsIndyYXAiLCJjbG9uZU5vZGUiLCJwbGFjZWhvbGRlciIsIk1heE9mZiIsInJlY3RhbmdsZUZvciIsInN0YXJ0TGluZSIsImVuZExpbmUiLCJzdGFydE9mZiIsImVuZE9mZiIsInN0YXJ0Q29sIiwiZW5kQ29sIiwiYWJzb2x1dGVDb2x1bW4iLCJnZXRQb3MiLCJyZWN0YW5nbGVTZWxlY3Rpb25TdHlsZSIsIm5ld1N0YXJ0IiwibmV3TGluZSIsIl9leHRlbmQiLCJyZWN0YW5ndWxhclNlbGVjdGlvbiIsImV2ZW50RmlsdGVyIiwiQWx0IiwiQ29udHJvbCIsIlNoaWZ0IiwiTWV0YSIsInNob3dDcm9zc2hhaXIiLCJjcm9zc2hhaXJDdXJzb3IiLCJnZXR0ZXIiLCJpc0Rvd24iLCJrZXl1cCIsIm1vdXNlbW92ZSIsIk91dHNpZGUiLCJUb29sdGlwVmlld01hbmFnZXIiLCJjcmVhdGVUb29sdGlwVmlldyIsInJlbW92ZVRvb2x0aXBWaWV3IiwidG9vbHRpcHMiLCJ0b29sdGlwVmlld3MiLCJuZXdBYm92ZSIsInRpcCIsInRvb2x0aXBWaWV3IiwidG9vbHRpcENvbmZpZyIsIndpbmRvd1NwYWNlIiwiZG9jRWx0IiwidG9vbHRpcFNwYWNlIiwia25vd25IZWlnaHQiLCJ0b29sdGlwUGx1Z2luIiwibWFkZUFic29sdXRlIiwibGFzdFRyYW5zYWN0aW9uIiwibWVhc3VyZVRpbWVvdXQiLCJjbGFzc2VzIiwiY3JlYXRlQ29udGFpbmVyIiwicmVhZE1lYXN1cmUiLCJ3cml0ZU1lYXN1cmUiLCJyZXNpemVPYnNlcnZlciIsIm1lYXN1cmVTb29uIiwibWFuYWdlciIsInNob3dUb29sdGlwIiwiY3JlYXRlVG9vbHRpcCIsInVub2JzZXJ2ZSIsImludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZUludGVyc2VjdGlvbiIsIm1heWJlTWVhc3VyZSIsImNvbnRhaW5lciIsInRvb2x0aXAiLCJzaG91bGRNZWFzdXJlIiwibmV3Q29uZmlnIiwiYXJyb3ciLCJtYWtlQWJzb2x1dGUiLCJ0diIsImdldENvb3JkcyIsInNwYWNlIiwib3RoZXJzIiwidFZpZXciLCJhcnJvd0hlaWdodCIsIm5vT2Zmc2V0Iiwic3RyaWN0U2lkZSIsInNwYWNlVmVydCIsInJlc2l6ZSIsIm92ZXJsYXAiLCJzZXRMZWZ0U3R5bGUiLCJhcnJvd0xlZnQiLCJ0b2dnbGUiLCJwb3NpdGlvbmVkIiwiaXNOYU4iLCJib3JkZXJUb3BDb2xvciIsImJvcmRlckJvdHRvbUNvbG9yIiwic2hvd0hvdmVyVG9vbHRpcCIsImlucHV0cyIsIkhvdmVyVG9vbHRpcEhvc3QiLCJtb3VudGVkIiwiY3JlYXRlSG9zdGVkVmlldyIsImhvc3RlZFZpZXciLCJwYXNzUHJvcCIsImdpdmVuIiwic2hvd0hvdmVyVG9vbHRpcEhvc3QiLCJjb21wdXRlIiwiSG92ZXJQbHVnaW4iLCJzZXRIb3ZlciIsImhvdmVyVGltZSIsImhvdmVyVGltZW91dCIsInJlc3RhcnRUaW1lb3V0IiwibGFzdE1vdmUiLCJ0aW1lIiwiY2hlY2tIb3ZlciIsIm1vdXNlbGVhdmUiLCJzdGFydEhvdmVyIiwiaG92ZXJlZCIsInBvc0Nvb3JkcyIsImJpZGkiLCJydGwiLCJmaW5kSW5kZXgiLCJpc0luVG9vbHRpcCIsImlzT3ZlclJhbmdlIiwiaW5Ub29sdGlwIiwid2F0Y2hUb29sdGlwTGVhdmUiLCJ3YXRjaCIsInRvb2x0aXBNYXJnaW4iLCJhcnJvd1JlY3QiLCJkb2NCb3R0b20iLCJob3ZlclRvb2x0aXAiLCJob3ZlclN0YXRlIiwiaGlkZU9uQ2hhbmdlIiwiaGlkZU9uIiwiYXNzaWduIiwiY2xvc2VIb3ZlclRvb2x0aXBFZmZlY3QiLCJnZXRUb29sdGlwIiwiaGFzSG92ZXJUb29sdGlwcyIsImNsb3NlSG92ZXJUb29sdGlwcyIsInJlcG9zaXRpb25Ub29sdGlwcyIsInBhbmVsQ29uZmlnIiwidG9wQ29udGFpbmVyIiwiYm90dG9tQ29udGFpbmVyIiwicGFuZWxzIiwiZ2V0UGFuZWwiLCJwYW5lbCIsInBhbmVsUGx1Z2luIiwic2hvd1BhbmVsIiwiUGFuZWxHcm91cCIsInN5bmNDbGFzc2VzIiwic2Nyb2xsTWFyZ2luIiwic3luY0RPTSIsImN1ckRPTSIsInJtIiwiR3V0dGVyTWFya2VyIiwiZWxlbWVudENsYXNzIiwiZ3V0dGVyTGluZUNsYXNzIiwiZ3V0dGVyV2lkZ2V0Q2xhc3MiLCJkZWZhdWx0cyIsInJlbmRlckVtcHR5RWxlbWVudHMiLCJlbGVtZW50U3R5bGUiLCJsaW5lTWFya2VyIiwid2lkZ2V0TWFya2VyIiwibGluZU1hcmtlckNoYW5nZSIsImluaXRpYWxTcGFjZXIiLCJ1cGRhdGVTcGFjZXIiLCJhY3RpdmVHdXR0ZXJzIiwiZ3V0dGVyIiwiZ3V0dGVycyIsInVuZml4R3V0dGVycyIsImd1dHRlclZpZXciLCJmaXhlZCIsInByZXZWaWV3cG9ydCIsIlNpbmdsZUd1dHRlclZpZXciLCJzeW5jR3V0dGVycyIsInVwZGF0ZUd1dHRlcnMiLCJ2cEEiLCJ2cEIiLCJ2cE92ZXJsYXAiLCJkZXRhY2giLCJsaW5lQ2xhc3NlcyIsImNsYXNzU2V0IiwiY29udGV4dHMiLCJVcGRhdGVDb250ZXh0IiwiYWR2YW5jZUN1cnNvciIsImN4IiwiYXNBcnJheSIsImNvbGxlY3QiLCJhZGRFbGVtZW50IiwiZWxlbWVudHMiLCJuZXdFbHQiLCJHdXR0ZXJFbGVtZW50IiwiZXh0cmFNYXJrZXJzIiwibG9jYWxNYXJrZXJzIiwiZm9yTGluZSIsInNwYWNlciIsInByb3AiLCJwcmV2TWFya2VycyIsInNhbWVNYXJrZXJzIiwic2V0TWFya2VycyIsImRvbVBvcyIsImlOZXciLCJpT2xkIiwic2tpcFRvIiwibWF0Y2hlZCIsImxpbmVOdW1iZXJNYXJrZXJzIiwibGluZU51bWJlcldpZGdldE1hcmtlciIsImxpbmVOdW1iZXJDb25maWciLCJmb3JtYXROdW1iZXIiLCJOdW1iZXJNYXJrZXIiLCJsaW5lTnVtYmVyR3V0dGVyIiwibWF4TGluZU51bWJlciIsImxpbmVOdW1iZXJzIiwiYWN0aXZlTGluZUd1dHRlck1hcmtlciIsImFjdGl2ZUxpbmVHdXR0ZXJIaWdobGlnaHRlciIsImhpZ2hsaWdodEFjdGl2ZUxpbmVHdXR0ZXIiLCJtYXRjaGVyIiwidSIsInRhYkRlY28iLCJzcGFjZURlY28iLCJ3aGl0ZXNwYWNlSGlnaGxpZ2h0ZXIiLCJoaWdobGlnaHRXaGl0ZXNwYWNlIiwidHJhaWxpbmdIaWdobGlnaHRlciIsImhpZ2hsaWdodFRyYWlsaW5nV2hpdGVzcGFjZSIsIl9fdGVzdCIsImdldEhlaWdodENoYW5nZUZsYWciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@codemirror/view/dist/index.js\n");

/***/ })

};
;